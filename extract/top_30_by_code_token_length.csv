seq_id,entry_point,code,code_token_length
38901396701,next_closest_palindrome,"from functools import reduce

def next_closest_palindrome(n: str) -> str:
    length = len(n)
    mid = length // 2
    if n == n[::-1]:
        if re.match('^10*1$', n):
            return str(int(n) - 2)
        if re.match('^9+$', n):
            return str(int(n) + 2)
        if length & 1:
            s1 = str(int(n[:mid+1]) + 1)
            s2 = str(int(n[:mid+1]) - 1)
            si1 = int(s1[:-1] + s1[::-1])
            si2 = int(s2[:-1] + s2[::-1])
        else:
            s1 = str(int(n[:mid]) + 1)
            s2 = str(int(n[:mid]) - 1)
            si1 = int(s1 + s1[::-1])
            si2 = int(s2 + s2[::-1])
        return str([si2, si1][abs(si1 - int(n)) < abs(si2 - int(n))])
    else:
        ret = [int(e) for e in n]
        if length & 1:
            i, j = mid - 1, mid + 1
        else:
            i, j = mid - 1, mid
        dis = abs(ret[i] - ret[j])
        if length & 1:
            if dis <= 5:
                ret[j] = ret[i]
            else:
                if ret[j] > ret[i]:
                    ret[mid] += 1
                    if ret[mid] == 10:
                        ret[mid] = 0
                        ret[i] += 1
                else:
                    ret[mid] -= 1
                    if ret[mid] == -1:
                        ret[mid] = 9
                        ret[i] -= 1
                ret[j] = ret[i]
            for k in range(1, mid):
                x, y = i - k, j + k
                if ret[x] != ret[y]: ret[y] = ret[x]
        else:
            ret2 = ret[:]
            if ret[j] > ret[i]:
                ret[i] += 1
            else:
                ret[i] = (ret[i] - 1 + 10) % 10
            ret[j], ret2[j] = ret[i], ret2[i]
            for k in range(1, mid):
                x, y = i - k, j + k
                if ret[x] != ret[y]: ret[y] = ret[x]
                if ret2[x] != ret2[y]: ret2[y] = ret2[x]
            f = lambda x, y: x * 10 + y
            r1, r2 = reduce(f, ret), reduce(f, ret2)
            if abs(r1 - int(n)) == abs(r2 - int(n)):
                ret = ret2 if r2 < r1 else ret
            else:
                ret = [ret, ret2][abs(r1 - int(n)) > abs(r2 - int(n))]
        return ''.join([str(e) for e in ret])",681
30074294089,transform_words,"from collections import defaultdict

def transform_words(beginWord, endWord, wordList):
    def buildConnectionMapping(beginWord, wordList):
        wordList.sort()
        mapping = defaultdict(lambda: [])
        for i in range(len(wordList)):
            for j in range(i + 1, len(wordList)):
                for k in range(len(beginWord)):
                    if wordList[i][k] != wordList[j][k]:
                        break
                if wordList[i][k+1:] == wordList[j][k+1:]:
                    mapping[wordList[i]].append(wordList[j])
                    mapping[wordList[j]].append(wordList[i])
        for w in wordList:
            for k in range(len(beginWord)):
                if w[k] != beginWord[k]:
                    break
            if w[k+1:] == beginWord[k+1:]:
                mapping[beginWord].append(w)
        return mapping

    def findShortestPath(beginWord, endWord, wordList):
        current_layer = [beginWord]
        next_layer = []
        visited = set()
        not_find_end_word = True
        count = 1
        while current_layer and not_find_end_word:
            count += 1
            for word in current_layer:
                for next_word in mapping[word]:
                    if next_word == endWord:
                        not_find_end_word = False
                    if next_word not in visited:
                        visited.add(next_word)
                        next_layer.append(next_word)
            current_layer = next_layer
            next_layer = []
        return count

    def deeper(path, candidates):
        if path[-1] == endWord:
            result.append(path)
            return
        if len(path) < shortest_path_length:
            for i in range(len(candidates)):
                for j in range(len(beginWord)):
                    if path[-1][j] != candidates[i][j]:
                        break
                if path[-1][j+1:] == candidates[i][j+1:]:
                    deeper(path + [candidates[i]], candidates[:i] + candidates[i+1:])

    mapping = buildConnectionMapping(beginWord, wordList)
    shortest_path_length = findShortestPath(beginWord, endWord, wordList)
    result = []
    deeper([beginWord], wordList)
    return result

class Solution:
    def findLadders(self, beginWord, endWord, wordList):
        return transform_words(beginWord, endWord, wordList)",504
14120506416,ideal_arrays,"from collections import Counter
from functools import lru_cache
from math import floor

MOD = int(1e9 + 7)

@lru_cache(None)
def getPrimeFactors(n: int) -> Counter[int]:
    """"""返回 n 的质因子分解""""""
    res = Counter()
    upper = floor(n**0.5) + 1
    for i in range(2, upper):
        while n % i == 0:
            res[i] += 1
            n //= i

    if n > 1:
        res[n] += 1
    return res

@lru_cache(None)
def fac(n: int) -> int:
    """"""n的阶乘""""""
    if n == 0:
        return 1
    return n * fac(n - 1) % MOD

@lru_cache(None)
def ifac(n: int) -> int:
    """"""n的阶乘的逆元""""""
    return pow(fac(n), MOD - 2, MOD)

def C(n: int, k: int) -> int:
    if n < 0 or k < 0 or n < k:
        return 0
    return ((fac(n) * ifac(k)) % MOD * ifac(n - k)) % MOD

def CWithReplacement(n: int, k: int) -> int:
    """"""可重复选取的组合数 itertools.combinations_with_replacement 的个数""""""
    return C(n + k - 1, k)

def put(n: int, k: int) -> int:
    """"""
    n个物品放入k个槽(槽可空)的方案数
    """"""
    return C(n + k - 1, k - 1)

class Solution:
    def ideal_arrays(self, n: int, end: int) -> int:
        res = 0
        cur = 1
        counter = getPrimeFactors(end)
        for _, k in counter.items():
            cur *= put(n - 1, k + 1)
            cur %= MOD
        res += cur
        res %= MOD
        return res

def ideal_arrays(n: int, maxValue: int) -> int:
    res = 0
    for end in range(1, maxValue + 1):
        res += Solution().ideal_arrays(n, end)
        res %= MOD
    return res",496
1185920464,is_perfect_rectangle,"from typing import List

class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:

        tris = {}

        def add(x, y, tris):
            if x in tris:
                if y in tris[x]:
                    tris[x][y] += 1
                else:
                    tris[x][y] = 1
            else:
                tris[x] = {y: 1}

        area = 0
        minx = 10000000000
        miny = 10000000000
        maxa = -10000000000
        maxb = -10000000000

        for x, y, a, b in rectangles:
            add(x, y, tris)
            add(a, y, tris)
            add(a, b, tris)
            add(x, b, tris)

            area += (b - y) * (a - x)
            minx = min(minx, x)
            miny = min(miny, y)
            maxa = max(maxa, a)
            maxb = max(maxb, b)

        if (
            area != (maxa - minx) * (maxb - miny)
            or (miny in tris[minx] and tris[minx][miny] != 1)
            or (maxb in tris[minx] and tris[minx][maxb] != 1)
            or (miny in tris[maxa] and tris[maxa][miny] != 1)
            or (maxb in tris[maxa] and tris[maxa][maxb] != 1)
        ):
            return False

        cou = 0
        for k, v in tris.items():
            for k2, v2 in v.items():
                if v2 == 2 or v2 == 4:
                    pass
                elif v2 == 1:
                    cou += 1
                else:
                    return False

        return cou == 4


def is_perfect_rectangle(rectangles):
    solution = Solution()
    return solution.isRectangleCover(rectangles)",487
7804968646,is_valid_number,"def is_valid_number(s):
    s = s.strip()
    # dfa status
    err = -1 #error
    srt = 0  #start
    sgd = 1  #integer part sign
    did = 2  #integer part number
    ddp = 3  #xx. (there some number before '.')
    dnp = 4  #.
    dii = 5  # decimal part number
    exe = 6  # e
    sge = 7  # exp part sign
    die = 8  # exp part number
    end = 9  # end
    
    # construct a dfa
    dfa = [[err] * 128 for i in range(9)]
    dfa[srt][ord('+')] = dfa[srt][ord('-')] = sgd
    dfa[srt][ord('.')] = dfa[sgd][ord('.')] = dnp
    dfa[did][ord('.')] = ddp
    dfa[did][ord('e')] = dfa[ddp][ord('e')] = dfa[dii][ord('e')] = exe
    dfa[exe][ord('+')] = dfa[exe][ord('-')] = sge
    dfa[dii][0] = dfa[ddp][0] = dfa[did][0] = dfa[die][0] = end
    for i in range(10):
        t = ord('0') + i
        dfa[srt][t] = dfa[sgd][t] = dfa[did][t] = did
        dfa[ddp][t] = dfa[dnp][t] = dfa[dii][t] = dii
        dfa[exe][t] = dfa[sge][t] = dfa[die][t] = die
    
    # run dfa with s
    s = s.strip()
    status = srt
    for c in s:
        status = dfa[status][ord(c)]
        if status == err:
            return False
    return True if dfa[status][0] == end else False",479
17638916816,is_cyclic,"from collections import defaultdict

# Graph class represents a directed graph
class Graph:

    def __init__(self, vertices):
        self.graph = defaultdict(list) # dictionary containing adjacency List
        self.V = vertices # No. of vertices

    # function to add an edge to graph
    def addEdge(self, u, v):
        self.graph[u].append(v)

    # A recursive function used by isCyclic
    def isCyclicUtil(self, v, visited, recStack):

        # Mark current node as visited and
        # adds to recursion stack
        visited[v] = True
        recStack[v] = True

        # Recur for all neighbours
        # if any neighbour is visited and in recStack then graph is cyclic
        for neighbour in self.graph[v]:
            if visited[neighbour] == False:
                if self.isCyclicUtil(neighbour, visited, recStack) == True:
                    return True
            elif recStack[neighbour] == True:
                return True

        # The node needs to be popped from
        # recursion stack before function ends
        recStack[v] = False
        return False

    # Returns true if graph is cyclic else false
    def isCyclic(self):
        visited = [False] * self.V
        recStack = [False] * self.V
        for node in range(self.V):
            if visited[node] == False:
                if self.isCyclicUtil(node, visited, recStack) == True:
                    return True
        return False

# Function to check if the graph is cyclic
def is_cyclic(vertices, edges):
    g = Graph(vertices)
    for edge in edges:
        g.addEdge(edge[0], edge[1])
    return g.isCyclic()

# Test cases
assert is_cyclic(4, [[0, 1], [0, 2], [1, 2], [2, 0], [2, 3], [3, 3]]) == True
assert is_cyclic(4, [[0, 1], [0, 2], [1, 3], [2, 3]]) == False
assert is_cyclic(3, [[0, 1], [1, 2]]) == False",476
71003293221,find_quadruplets,"def find_quadruplets(nums, target):
    nums.sort()
    result = []
    length = len(nums)
    for i in range(length - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        for j in range(i + 1, length - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue
            left, right = j + 1, length - 1
            while left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                if total == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif total < target:
                    left += 1
                else:
                    right -= 1
    return result

assert find_quadruplets([-3, -2, -1, 0, 0, 1, 2, 3], 0) == [[-3, -2, 2, 3], [-3, -1, 1, 3], [-3, 0, 0, 3], [-3, 0, 1, 2], [-2, -1, 0, 3], [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]
assert find_quadruplets([1, 0, -1, 0, -2, 2], 0) == [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]
assert find_quadruplets([2, 2, 2, 2, 2], 8) == [[2, 2, 2, 2]]",466
2225669181,convex_hull,"import math

def polar_angle(p0, p1):
    return math.atan2(p1[1]-p0[1], p1[0]-p0[0])

def distance(p, anchor):
    return (p[1]-anchor[1])**2 + (p[0]-anchor[0])**2

def sort_points(points, anchor):
    if len(points) <= 1:
        return points
    s, e, l = [], [], []
    pivot_angle = polar_angle(anchor, points[randint(0, len(points) - 1)])
    for pt in points:
        if pt == anchor:
            continue
        angle = polar_angle(anchor, pt)
        if angle < pivot_angle:
            s.append(pt)
        elif angle == pivot_angle:
            e.append(pt)
        else:
            l.append(pt)
    return sort_points(s, anchor) + sorted(e, key=lambda p: distance(p, anchor)) + sort_points(l, anchor)

def reverse_tail(points, anchor):
    if polar_angle(anchor, points[0]) != polar_angle(anchor, points[-1]):
        tail = [points.pop()]
        while polar_angle(anchor, points[-1]) == polar_angle(anchor, tail[0]):
            tail.append(points.pop())
        points.extend(reversed(tail))
    return points

def determinant(p1, p2, p3):
    return (p2[0]-p1[0]) * (p3[1]-p1[1]) - (p2[1]-p1[1])*(p3[0]-p1[0])

def convex_hull(trees):
    if len(trees) < 4:
        return trees

    p = []
    anchor = min(trees, key=lambda x: (x[1], x[0]))
    p.append(anchor)
    trees = sort_points(trees, anchor)
    trees = reverse_tail(trees, anchor)
    p.append(trees[0])
    for t in trees[1:]:
        while len(p) >= 2 and determinant(p[-2], p[-1], t) < 0:
            del p[-1]
        p.append(t)
    return p",455
14865859737,has_valid_path,"from collections import deque

def has_valid_path(grid):
    paths = {1: [[0, 1], [0, -1]], 2: [[1, 0], [-1, 0]], 3: [[0, -1], [1, 0]], 4: [[1, 0], [0, 1]], 5: [[0, -1], [-1, 0]], 6: [[0, 1], [-1, 0]]}
    pairs = {(0, 1): [1, 3, 5], (0, -1): [1, 4, 6], (1, 0): [2, 5, 6], (-1, 0): [2, 3, 4]}
    tx, ty = len(grid) - 1, len(grid[0]) - 1
    queue = deque()
    queue.append([0, 0])
    visited = [[False] * len(grid[0]) for _ in range(len(grid))]
    start = [0, 0]

    while queue:
        x, y = queue.popleft()
        if x == tx and y == ty:
            return True
        num = grid[x][y]
        visited[x][y] = True
        for dx, dy in paths[num]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):
                nxt = pairs[(dx, dy)]
                if grid[nx][ny] in nxt and not visited[nx][ny]:
                    queue.append([nx, ny])

    return False

assert has_valid_path([[2,4,3],[6,5,2]]) == True
assert has_valid_path([[1,2,1],[1,2,1]]) == False
assert has_valid_path([[1,1,2]]) == False
assert has_valid_path([[1,1,1,1,1,1,3]]) == True
assert has_valid_path([[2],[2],[2],[2],[2],[2],[6]]) == True",454
20602737783,word_break,"def word_break(wordDict, s):
    n = len(s)
    dp = [False] * (n + 1)
    dp[0] = True
    for i in range(1, n + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break
    return dp[n]

wordDict = [""dog"", ""cat"", ""code"", ""sand"", ""dogcar""]
s = ""dogcarcode""
print(word_break(wordDict, s))
wordDict = [""hello"", ""world""]
s = ""helloworld""
print(word_break(wordDict, s))
wordDict = [""apple"", ""pen""]
s = ""applepenapple""
print(word_break(wordDict, s))
wordDict = [""hello"", ""world""]
s = ""helloplanet""
print(word_break(wordDict, s))
wordDict = [""cat"", ""cats"", ""dog"", ""dogs""]
s = ""catdog""
print(word_break(wordDict, s))
wordDict = [""cat"", ""cats"", ""dog"", ""dogs""]
s = ""catcats""
print(word_break(wordDict, s))
wordDict = [""cat"", ""cats"", ""dog"", ""dogs""]
s = ""catcatsdog""
print(word_break(wordDict, s))
wordDict = [""cat"", ""cats"", ""dog"", ""dogs""]
s = ""catdogdog""
print(word_break(wordDict, s))
wordDict = [""cat"", ""cats"", ""dog"", ""dogs""]
s = ""dogcatsdog""
print(word_break(wordDict, s))
wordDict = [""cat"", ""cats"", ""dog"", ""dogs""]
s = ""catsdogcats""
print(word_break(wordDict, s))
wordDict = [""cat"", ""cats"", ""dog"", ""dogs""]
s = ""dogdog""
print(word_break(wordDict, s))
wordDict = [""cat"", ""cats"", ""dog"", ""dogs""]
s = ""catcat""
print(word_break(wordDict, s))
wordDict = [""cat"", ""cats"", ""dog"", ""dogs""]
s = ""dog""
print(word_break(wordDict, s))",452
14121173536,maximum_heights,"from typing import List

def makeDp(seq: List[int], rev=True) -> List[int]:
    n = len(seq)
    minRange = getRange(seq)
    dp = [0] * (n + 1)
    for i in range(n):
        cur = seq[i]
        j = minRange[i][0]
        dp[i + 1] = dp[j] + (i - j + 1) * cur
    return dp

def getRange(seq: List[int]) -> List[List[int]]:
    n = len(seq)
    stack = []
    range_ = [[0, 0] for _ in range(n)]
    for i in range(n):
        while stack and seq[stack[-1]] >= seq[i]:
            stack.pop()
        if stack:
            range_[i][0] = stack[-1] + 1
        else:
            range_[i][0] = 0
        stack.append(i)
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and seq[stack[-1]] >= seq[i]:
            stack.pop()
        if stack:
            range_[i][1] = n - stack[-1] - 1
        else:
            range_[i][1] = n - i - 1
        stack.append(i)
    return range_

def maximum_heights(maxHeights: List[int]) -> int:
    n = len(maxHeights)
    pre, suf = makeDp(maxHeights[:], False), makeDp(maxHeights[::-1])[::-1]
    res = 0
    for i in range(n):  # 枚举分割点
        res = max(res, pre[i] + suf[i])
    return res

print(maximum_heights([5, 3, 4, 1, 1]))
print(maximum_heights([6, 5, 3, 9, 2, 7]))
print(maximum_heights([3, 2, 5, 5, 2, 3]))",440
25905839552,check_circle,"def check_circle(coordinates):
    if len(coordinates) <= 2:
        return False

    x0, y0 = coordinates[0]
    x1, y1 = coordinates[1]
    x2, y2 = coordinates[2]

    # Calculate the center of the circle using the coordinates
    A = x0 * (y2 - y1) - y0 * (x2 - x1) + x1 * y2 - y1 * x2
    B = (x0 ** 2 + y0 ** 2) * (y1 - y2) + (x1 ** 2 + y1 ** 2) * (y2 - y0) + (x2 ** 2 + y2 ** 2) * (y0 - y1)
    C = (x0 ** 2 + y0 ** 2) * (x2 - x1) + (x1 ** 2 + y1 ** 2) * (x0 - x2) + (x2 ** 2 + y2 ** 2) * (x1 - x0)
    D = (x0 ** 2 + y0 ** 2) * (x1 * y2 - x2 * y1) + (x1 ** 2 + y1 ** 2) * (x2 * y0 - x0 * y2) + (x2 ** 2 + y2 ** 2) * (x0 * y1 - x1 * y0)

    if A == 0 or B == 0 or C == 0:
        return False

    center_x = -B / (2 * A)
    center_y = -C / (2 * A)

    radius_squared = (x0 - center_x) ** 2 + (y0 - center_y) ** 2

    for x, y in coordinates[3:]:
        if (x - center_x) ** 2 + (y - center_y) ** 2 != radius_squared:
            return False

    return True",435
8993549875,shortest_path,"from collections import deque
from typing import List

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

def shortest_path(grid: List[List[int]], k: int) -> int:
    def is_valid_coord(x: int, y: int):
        return 0 <= x < len(grid) and 0 <= y < len(grid[0])

    bfs_history = [[[float('inf') for _ in range(k + 1)] for _ in range(len(grid[0]))] for _ in range(len(grid))]
    min_table = [[(float('inf'), float('inf')) for _ in range(len(grid[0]))] for _ in range(len(grid))]

    q = deque([(0, 0, 0)])

    bfs_history[0][0][0] = 0
    min_table[0][0] = (0, 0)
    while q:
        x, y, w = q.popleft()
        c = bfs_history[x][y][w]
        for d in range(4):
            nx, ny = x + dx[d], y + dy[d]
            if not is_valid_coord(nx, ny):
                continue
            nw = w + grid[nx][ny]
            if nw > k or c + 1 >= bfs_history[nx][ny][nw]:
                continue
            if c >= min_table[nx][ny][0] and nw >= min_table[nx][ny][1]:
                continue
            bfs_history[nx][ny][nw] = c + 1
            if min_table[nx][ny][0] > c + 1:
                min_table[nx][ny] = (c + 1, nw)
            q.append((nx, ny, nw))

    return min_table[len(grid) - 1][len(grid[0]) - 1][0] if min_table[len(grid) - 1][len(grid[0]) - 1][0] != float('inf') else -1",432
74966726078,largest_bst_subtree,"class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def largest_bst_subtree(root):
    inf = float('inf')

    def largestBST(node):
        if not node:
            return [0, inf, -inf]
        n1, l1, l2 = largestBST(node.left)
        n2, r1, r2 = largestBST(node.right)
        if node.val > l2 and node.val < r1:
            return [1 + n1 + n2, min(node.val, l1), max(node.val, r2)]
        else:
            return [max(n1, n2), -inf, inf]
    return largestBST(root)[0]

# Helper function to create tree from list
def create_tree(arr):
    if not arr:
        return None
    root = TreeNode(arr[0])
    queue = [root]
    front = 0
    index = 1
    while index < len(arr):
        node = queue[front]
        front = front + 1

        item = arr[index]
        index = index + 1
        if item is not None:
            left_number = item
            node.left = TreeNode(left_number)
            queue.append(node.left)

        if index >= len(arr):
            break

        item = arr[index]
        index = index + 1
        if item is not None:
            right_number = item
            node.right = TreeNode(right_number)
            queue.append(node.right)
    return root

# Test cases
root1 = create_tree([10,5,15,1,8,None,7])
assert largest_bst_subtree(root1) == 3

root2 = create_tree([5,4,6,None,1,None,7])
assert largest_bst_subtree(root2) == 2

root3 = create_tree([1,1,1,1,1,1,1])
assert largest_bst_subtree(root3) == 1",429
16053655124,linked_list_to_list,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeNthFromEnd(head: ListNode, n: int) -> ListNode:
    slow = fast = head
    
    for _ in range(n):
        fast = fast.next
    
    if not fast:
        return head.next
    
    while fast.next:
        slow = slow.next
        fast = fast.next
    
    slow.next = slow.next.next
    return head

# Function to convert a list to a linked list
def list_to_linked_list(lst):
    head = ListNode(lst[0]) if lst else None
    current = head
    for value in lst[1:]:
        current.next = ListNode(value)
        current = current.next
    return head

# Function to convert a linked list to a list
def linked_list_to_list(linked_list):
    lst = []
    current = linked_list
    while current:
        lst.append(current.val)
        current = current.next
    return lst

# Test cases
head = list_to_linked_list([1,2,3,4,5])
n = 2
output = removeNthFromEnd(head, n)
assert linked_list_to_list(output) == [1,2,3,5], f""Test case 1 failed. Expected [1,2,3,5], got {linked_list_to_list(output)}""

head = list_to_linked_list([1])
n = 1
output = removeNthFromEnd(head, n)
assert linked_list_to_list(output) == [], f""Test case 2 failed. Expected [], got {linked_list_to_list(output)}""

head = list_to_linked_list([1,2,3,4,5])
n = 5
output = removeNthFromEnd(head, n)
assert linked_list_to_list(output) == [2,3,4,5], f""Test case 3 failed. Expected [2,3,4,5], got {linked_list_to_list(output)}""",427
8610918592,patternMatch,"def patternMatch(pattern: str, value: str)->bool:
    count_a = count_b = 0
    for ch in pattern:
        if ch == 'a':
            count_a += 1
        else:
            count_b += 1
    if count_a < count_b:
        count_a, count_b = count_b, count_a
        pattern = ''.join('a' if ch == 'b' else 'b' for ch in pattern)

    if len(pattern) == 0:
        return value == """"
    if count_b == 0:
        return len(value)%count_a == 0 and all(value[i:i+len(value)//count_a] == value[:len(value)//count_a] for i in range(0, len(value), len(value)//count_a))
    if len(value) == 0:
        return count_b == 0
    for i in range(len(value)//count_a + 1):
        if (len(value) - count_a*i)%count_b == 0:
            a_pattern_len = i
            b_pattern_len = (len(value)-count_a*i)//count_b
            pos_pattern = 0
            pos_value = 0
            a_pattern = b_pattern = """"
            isMatch = True
            while pos_value < len(value) and pos_pattern < len(pattern):
                if pattern[pos_pattern] == 'a':
                    if a_pattern == """":
                        a_pattern = value[pos_value:pos_value+a_pattern_len]
                    elif value[pos_value:pos_value+a_pattern_len] != a_pattern:
                        isMatch = False
                        break
                    pos_value += a_pattern_len
                else:
                    if b_pattern == """":
                        b_pattern = value[pos_value:pos_value+b_pattern_len]
                    elif value[pos_value:pos_value+b_pattern_len] != b_pattern:
                        isMatch = False
                        break
                    pos_value += b_pattern_len
                pos_pattern += 1
            if isMatch and pos_pattern == len(pattern):
                return True
    return False",423
74960168958,find_max_sum_divisible_by_three,"def find_max_sum_divisible_by_three(arr):
    arr.sort()
    sum_arr = sum(arr)
    if sum_arr % 3 == 0:
        return sum_arr
    else:
        mod_one = []
        mod_two = []
        for num in arr:
            if num % 3 == 1:
                mod_one.append(num)
            elif num % 3 == 2:
                mod_two.append(num)
        if len(mod_one) == 0 and len(mod_two) == 0:
            return 0
        elif len(mod_one) == 0 and len(mod_two) >= 2:
            return sum_arr - min(mod_two[0], mod_two[1])
        elif len(mod_two) == 0 and len(mod_one) >= 2:
            return sum_arr - min(mod_one[0], mod_one[1])
        elif len(mod_one) >= 1 and len(mod_two) >= 1:
            if (sum_arr - mod_one[0]) % 3 == 0:
                return sum_arr - mod_one[0]
            elif (sum_arr - mod_two[0]) % 3 == 0:
                return sum_arr - mod_two[0]
            else:
                return sum_arr - min(mod_one[0], mod_two[0], mod_two[1])
        elif len(mod_one) >= 2 and len(mod_two) >= 2:
            if (sum_arr - mod_one[0] - mod_one[1]) % 3 == 0:
                return sum_arr - mod_one[0] - mod_one[1]
            elif (sum_arr - mod_two[0] - mod_two[1]) % 3 == 0:
                return sum_arr - mod_two[0] - mod_two[1]
            else:
                return sum_arr - min(mod_one[0] + mod_one[1], mod_two[0] + mod_two[1])
        else:
            return 0",413
19319983338,rabin_karp,"def rabin_karp(text, pattern):
    if not pattern or not text:
        return []

    d = 256  # number of characters in the input alphabet
    q = 101  # a prime number

    n = len(text)
    m = len(pattern)
    h = 1

    i = 0
    j = 0
    p = 0  # hash value for pattern
    t = 0  # hash value for text
    result = []

    # The value of h would be ""pow(d, m-1)%q""
    for i in range(m-1):
        h = (h*d) % q

    # Calculate the hash value of pattern and first window of text
    for i in range(m):
        p = (d*p + ord(pattern[i])) % q
        t = (d*t + ord(text[i])) % q

    # Slide the pattern over text one by one
    for i in range(n-m+1):
        # Check the hash values of current window of text and pattern
        # If the hash values match then only check for characters one by one
        if p == t:
            # Check for characters one by one
            for j in range(m):
                if text[i+j] != pattern[j]:
                    break
            j += 1
            # if p == t and pattern[0...m-1] = text[i, i+1, ...i+m-1]
            if j == m:
                result.append(i)

        # Calculate hash value for next window of text: Remove leading digit,
        # add trailing digit
        if i < n-m:
            t = (d*(t-ord(text[i])*h) + ord(text[i+m])) % q

            # We might get negative value of t, converting it to positive
            if t < 0:
                t = t+q

    return result",409
72617789185,maxProfit,"def maxProfit(k, prices):
    def max_profit_without_limit() -> int:
        max_profit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                max_profit += prices[i] - prices[i - 1]
        return max_profit

    if len(prices) == 0:
        return 0
    elif k > len(prices) // 2:
        return max_profit_without_limit()

    stage_num = 2 * k + 1
    profit = [[-float('inf') for _ in range(stage_num)] for _ in range(len(prices) + 1)]
    profit[0][0] = 0

    for i in range(1, len(prices) + 1):
        for j in range(0, stage_num, 2):
            profit[i][j] = profit[i - 1][j]
            if j > 0 and i >= 2 and not float('inf') == profit[i - 1][j - 1]:
                curr_profit = prices[i - 1] - prices[i - 2]
                profit[i][j] = max(profit[i][j], profit[i - 1][j - 1] + curr_profit)

        for j in range(1, stage_num, 2):
            profit[i][j] = profit[i - 1][j - 1]
            if i >= 2 and not float('inf') == profit[i - 1][j]:
                curr_profit = prices[i - 1] - prices[i - 2]
                profit[i][j] = max(profit[i][j], profit[i - 1][j] + curr_profit)

    max_profit = 0
    for i in range(0, stage_num, 2):
        max_profit = max(max_profit, profit[-1][i])
    return max_profit",407
5548193231,countGoodSubstrings,"def countGoodSubstrings(s, k):
        
	#To keep track of count of good substrings
    count = 0
        
	#Dictionary to keep the count of each character in a substring
    dict = {}
		
	#This variable keeps track of how many unique characters are there in current substring
    uniques = 0
        
    i,j = 0,0
    n = len(s)

    while(j < n):
            
        c = s[j]
		#If jth character is not in dictionary, that means not only we can add it, but that also means it is currently a unique character in substring
        if not c in dict:
            dict[c] = 1
            uniques += 1
        else:
            dict[c] += 1
            
		#If window length is not yet k, increment j
        if(j - i + 1 < k): j += 1
		#If window size is k that means we found a substring of length k
        else:
			#To check if it is a good substring, just check if number of unique characters is k or not
            if(uniques == k): count += 1
                
			#Now, just before sliding the window to right, reduce the count of ith character from map
            dict[s[i]] -= 1
				
			#If count becomes 0, that means we also need to reduce count of uniques and remove this key from dictionary
            if(dict[s[i]] == 0): 
                dict.pop(s[i])
                uniques -= 1
                
			# Slide the window
            i += 1
            j += 1
                
    return count

s = ""aababcabc""
k = 3
count = countGoodSubstrings(s, k)

print(""Number of Substrings of size"", k, ""with Distinct Characters are ->"", count)",401
33086575613,shortest_distance,"from collections import deque

def shortest_distance(grid):
    if not grid or not grid[0]:
        return -1
    m, n = len(grid), len(grid[0])
    buildings = sum(1 if grid[i][j] == 1 else 0 for i in range(m) for j in range(n))
    
    distance = [[0] * n for _ in range(m)]
    reach = [[0] * n for _ in range(m)]
    
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                bfs(grid, i, j, distance, reach)
    
    min_distance = float('inf')
    for i in range(m):
        for j in range(n):
            if reach[i][j] == buildings and distance[i][j] < min_distance:
                min_distance = distance[i][j]
    return min_distance if min_distance != float('inf') else -1

def bfs(grid, i, j, distance, reach):
    m, n = len(grid), len(grid[0])
    visited = [[False] * n for _ in range(m)]
    queue = deque([(i, j, 0)])
    while queue:
        x, y, d = queue.popleft()
        if not visited[x][y]:
            visited[x][y] = True
            if grid[x][y] == 0:
                reach[x][y] += 1
                distance[x][y] += d
            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                if (0 <= x + dx < m) and (0 <= y + dy < n) and grid[x + dx][y + dy] == 0:
                    queue.append((x + dx, y + dy, d + 1))",398
36333296431,is_valid_number,"def is_valid_number(s):
    """"""
    :type s: str
    :rtype: bool
    """"""
    # remove leading and trailing spaces
    s = s.strip()
    
    # check for empty string
    if not s:
        return False
    
    # check for plus or minus sign
    if s[0] in ['+', '-']:
        s = s[1:]
    
    # check for decimal point
    dot_count = s.count('.')
    if dot_count > 1:
        return False
    
    # check for scientific notation
    e_count = s.count('e') + s.count('E')
    if e_count > 1:
        return False
    if 'e' in s or 'E' in s:
        parts = s.split('e') if 'e' in s else s.split('E')
        if len(parts) != 2:
            return False
        base, exponent = parts
        if not base or not exponent:
            return False
        if base[-1] == '.':
            return False
        if not base[-1].isdigit() and base[-1] != '.':
            return False
        if not exponent[0].isdigit() and exponent[0] != '+' and exponent[0] != '-':
            return False
        if not exponent[-1].isdigit():
            return False
        base = base.replace('.', '')
        if not base.isdigit():
            return False
        return True
    
    # check for valid decimal or integer
    if dot_count == 0:
        return s.isdigit()
    else:
        parts = s.split('.')
        if len(parts) != 2:
            return False
        left, right = parts
        if not left and not right:
            return False
        if not left.isdigit() and left:
            return False
        if not right.isdigit():
            return False
        return True",393
32230330759,heap_sort,"def sift(li, low, high):
    """"""
    :param li: list
    :param low: the position of root in the heap
    :param high: the position of the last element in the heap
    """"""
    i = low # index, as pointer1, point to root node
    j = 2 * i + 1 # the left node of i
    tmp = li[low] # store root value
    
    while j <= high:
        # if the right node exist, and greater than the left one
        if (j + 1 <= high) and (li[j + 1] > li[j]):
             j = j + 1 # then j point to the right node
        # if not, j still point to the left ndoe
        
        # compare a son node to its father node(root)
        if li[j] > tmp: # the son node greater than the fathter node
            li[i] = li[j] # move the son node to the father node
            i = j # dive into the next level
            j = 2 * i + 1
        else: # the father node greater than the son node
            li[i] = tmp # put the father node to the i position
            break
    else: # j > high
        li[i] = tmp # put tmp to the left node

def heap_sort(li):
    """"""
    :param li: list
    """"""
    n = len(li)
    for i in range(n // 2 - 1, -1, -1):
        sift(li, i, n - 1)
    
    for i in range(n - 1, -1, -1):
        li[i], li[0] = li[0], li[i]
        sift(li, 0, i - 1)
    return li",391
37180736650,count_inversions,"def merge_sort(arr, temp_arr, left, right):
    inv_count = 0
    if left < right:
        mid = (left + right) // 2
        inv_count = merge_sort(arr, temp_arr, left, mid)
        inv_count += merge_sort(arr, temp_arr, mid + 1, right)
        inv_count += merge(arr, temp_arr, left, mid + 1, right)
    return inv_count

def merge(arr, temp_arr, left, mid, right):
    i = left
    j = mid
    k = left
    inv_count = 0

    while (i <= mid - 1) and (j <= right):
        if arr[i] <= arr[j]:
            temp_arr[k] = arr[i]
            k += 1
            i += 1
        else:
            temp_arr[k] = arr[j]
            inv_count += (mid - i)
            k += 1
            j += 1

    while i <= mid - 1:
        temp_arr[k] = arr[i]
        k += 1
        i += 1

    while j <= right:
        temp_arr[k] = arr[j]
        k += 1
        j += 1

    for loop_var in range(left, right + 1):
        arr[loop_var] = temp_arr[loop_var]

    return inv_count

def count_inversions(arr):
    temp_arr = [0] * len(arr)
    return merge_sort(arr, temp_arr, 0, len(arr) - 1)

print(count_inversions([1, 3, 5, 2, 4, 6]))
print(count_inversions([1, 20, 6, 4, 5]))
print(count_inversions([10, 20, 30]))",390
28109870787,count_inversions,"def merge_sort(arr, temp_arr, left, right):
    inv_count = 0
    if left < right:
        mid = (left + right) // 2
        inv_count += merge_sort(arr, temp_arr, left, mid)
        inv_count += merge_sort(arr, temp_arr, mid + 1, right)
        inv_count += merge(arr, temp_arr, left, mid, right)
    return inv_count

def merge(arr, temp_arr, left, mid, right):
    i = left
    j = mid + 1
    k = left
    inv_count = 0

    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp_arr[k] = arr[i]
            k += 1
            i += 1
        else:
            temp_arr[k] = arr[j]
            inv_count += (mid - i + 1)
            k += 1
            j += 1

    while i <= mid:
        temp_arr[k] = arr[i]
        k += 1
        i += 1

    while j <= right:
        temp_arr[k] = arr[j]
        k += 1
        j += 1

    for i in range(left, right + 1):
        arr[i] = temp_arr[i]

    return inv_count

def count_inversions(arr):
    n = len(arr)
    temp_arr = [0] * n
    return merge_sort(arr, temp_arr, 0, n - 1)

# Test cases
assert count_inversions([1, 3, 5, 2, 4, 6]) == 3
assert count_inversions([1, 2, 3]) == 0
assert count_inversions([4, 3, 2, 1]) == 6",390
20644857012,convert_to_words,"def convert_to_words(n):
    ones = ["""", ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""]
    teens = [""Ten"", ""Eleven"", ""Twelve"", ""Thirteen"", ""Fourteen"", ""Fifteen"", ""Sixteen"", ""Seventeen"", ""Eighteen"", ""Nineteen""]
    tens = ["""", """", ""Twenty"", ""Thirty"", ""Forty"", ""Fifty"", ""Sixty"", ""Seventy"", ""Eighty"", ""Ninety""]
    thousands = ["""", ""Thousand"", ""Million"", ""Billion""]

    def helper(num):
        if num < 10:
            return ones[num]
        elif num < 20:
            return teens[num - 10]
        elif num < 100:
            return tens[num // 10] + ("" "" + ones[num % 10] if num % 10 != 0 else """")
        else:
            return ones[num // 100] + "" Hundred "" + helper(num % 100)

    if n == 0:
        return ""Zero""
    result = """"
    i = 0
    while n > 0:
        if n % 1000 != 0:
            result = helper(n % 1000) + "" "" + thousands[i] + "" "" + result
        n //= 1000
        i += 1
    return result.strip()

print(convert_to_words(123))  # One Hundred Twenty Three
print(convert_to_words(12))  # Twelve
print(convert_to_words(101))  # One Hundred One
print(convert_to_words(1009))  # One Thousand Nine",385
28723096718,Longest_Palindrome_Manacher,"def Longest_Palindrome_Manacher(s):
    s1 , l = ""|"", len(s)
    l1 = l*2 + 1
    palinRadii = [0]*l1
    for i in range(l):
        s1 = s1 + s[i] + ""|""

    center , radius = 0, 0
    while center < l1:
        while center - (radius + 1) >= 0 and center + (radius + 1) < l1 and s1[center - (radius + 1)] == s1[center + (radius + 1)]:
            radius += 1

        centerOld , radiusOld , palinRadii[center] = center , radius , radius
        center , radius = center + 1 , 0

        while center <= centerOld + radiusOld:
            mirrorCenter, maxMirrorRadius = centerOld + centerOld - center,  centerOld + radiusOld - center
            
            if palinRadii[mirrorCenter] < maxMirrorRadius :
                palinRadii[center] = palinRadii[mirrorCenter]
                center += 1
            elif palinRadii[mirrorCenter] > maxMirrorRadius:
                palinRadii[center] = maxMirrorRadius
                center += 1
            else:
                radius = maxMirrorRadius
                break

    maxi , pos = 0 , 0
    for i in range(l1):
        if palinRadii[i] > maxi:
            maxi = palinRadii[i]
            pos = i

    i , j , ans = pos - maxi , pos + maxi, """"
    while i < j:
        if s1[i] != ""|"":
            ans += s1[i]
        i+=1

    return ans",382
41413418510,justify_text,"def justify_text(words, maxWidth):
    LineS = []
    line = []
    Text = []
    length = maxWidth
    wordnum = 0
    for word in words:
        if length >= (wordnum + len(word)):
            line.append(word)
            wordnum += 1
            length -= len(word)
        else:
            line.append(length)
            LineS.append(line)
            length = maxWidth
            wordnum = 1
            line = [word]
            length -= len(word)
    if len(line):
        line.append(length)
        LineS.append(line)

    for i in range( 0, len(LineS) - 1):
        line = LineS[i]
        numspace = line[len(line) - 1]
        wordnum = len(line) - 1
        string = ''
        if wordnum == 1:
            string = line[0] + ' ' * numspace
            Text.append(string)
        else:
            averagespace = numspace // (wordnum-1)
            leftspace = numspace % (wordnum-1)
            for i in range(0, wordnum - 1):
                if i < leftspace:
                    string += line[i] + ' '*(averagespace + 1)
                else:
                    string += line[i] + ' '*averagespace
            string += line[wordnum - 1]
            Text.append(string)
    string = ''
    for i in range(0, len(LineS[len(LineS) - 1]) - 1):
        string = string + LineS[len(LineS) - 1][i] + ' '
    string = string[:-1]
    string += ' ' * (maxWidth - len(string))
    Text.append(string)
    return Text",372
31579887216,find_modes,"from collections import defaultdict

class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def insert(node, data):
    if node is None:
        return Node(data)
    else:
        if data <= node.data:
            node.left = insert(node.left, data)
        else:
            node.right = insert(node.right, data)
    return node

def find_modes(root):
    if root is None:
        return []

    count = defaultdict(int)
    max_count = 0
    stack = []
    node = root

    while node or stack:
        while node:
            stack.append(node)
            node = node.left

        node = stack.pop()
        count[node.data] += 1
        max_count = max(max_count, count[node.data])
        node = node.right

    modes = [key for key, value in count.items() if value == max_count]

    return modes

# Test case 1
root = None
root = insert(root, 2)
root = insert(root, 2)
root = insert(root, 3)
root = insert(root, 3)
assert find_modes(root) == [2, 3]

# Test case 2
root1 = None
root1 = insert(root1, 5)
root1 = insert(root1, 4)
root1 = insert(root1, 5)
assert find_modes(root1) == [5]

# Test case 3
root2 = None
root2 = insert(root2, 4)
root2 = insert(root2, 4)
root2 = insert(root2, 5)
root2 = insert(root2, 5)
assert find_modes(root2) == [4, 5]",371
20636006683,median_of_two_sorted_arrays,"def findMedianSortedArrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2
    else:
        return nums[length // 2]

def median_of_two_sorted_arrays(arr1, arr2):
    m, n = len(arr1), len(arr2)
    if m > n:
        arr1, arr2, m, n = arr2, arr1, n, m
    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and arr2[j-1] > arr1[i]:
            imin = i + 1
        elif i > 0 and arr1[i-1] > arr2[j]:
            imax = i - 1
        else:
            if i == 0: max_of_left = arr2[j-1]
            elif j == 0: max_of_left = arr1[i-1]
            else: max_of_left = max(arr1[i-1], arr2[j-1])
            if (m + n) % 2 == 1:
                return max_of_left
            if i == m: min_of_right = arr2[j]
            elif j == n: min_of_right = arr1[i]
            else: min_of_right = min(arr1[i], arr2[j])
            return (max_of_left + min_of_right) / 2.0",369
24149066672,max_points,"class Solution:
    def gcd(self,a,b):
        if a<b:
            return self.gcd(b,a)
        while b!=0:
            tmp = a%b
            a=b
            b = tmp
        return a

    def calK(self,x1,y1,x2,y2):
        if x1 == x2:
            return x1, float('inf')
        if y1 == y2:
            return float('inf'), y1

        delta_x = (x2-x1)
        delta_y = (y2-y1)
        neg = delta_x*delta_y<0

        delta_x = abs(delta_x)
        delta_y = abs(delta_y)

        gcd = self.gcd(delta_x,delta_y)

        delta_x/=gcd
        delta_y/=gcd

        if neg:
            delta_x = -delta_x
        return delta_x, delta_y

    def maxPoints(self, points) -> int:
        if len(points) == 1:
            return 1

        ans = 0
        for i in range(len(points)):
            x1,y1 = points[i]
            dic = {}
            for j in range(i+1,len(points)):
                x2,y2 = points[j]

                delta_x, delta_y = self.calK(x1,y1,x2,y2)

                if delta_x not in dic:
                    dic[delta_x] = {}
                if delta_y not in dic[delta_x]:
                    dic[delta_x][delta_y] = 0
                dic[delta_x][delta_y]+=1
                ans = max(ans,dic[delta_x][delta_y])
        return ans+1
obj = Solution()
def max_points(points):
    return obj.maxPoints(points)",366
19863482278,isLinkedListPalindrome,"class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

def isLinkedListPalindrome(head):
    """"""
    :type head: ListNode
    :rtype: bool
    """"""
    
    def reverse(curr):
        if not curr.next:
            return curr
        head = reverse(curr.next)
        curr.next.next = curr
        curr.next = None
        return head
    
    if not head: return True
    pre, slow, fast = head, head, head
    while fast and fast.next:
        pre = slow
        slow = slow.next
        fast = fast.next.next
    
    front_half = head
    back_half = reverse(slow)
    back_half_head = back_half
    pre.next = None
    
    while front_half and back_half:
        if front_half.val != back_half.val:
            pre.next = reverse(back_half_head)
            return False
        front_half = front_half.next
        back_half = back_half.next
        
    pre.next = reverse(back_half_head)
    return True


def print_list(head):
    if not head: return
    print(head.val)
    print_list(head.next)

def make_list(vec):
    if not vec: return None
    curr = ListNode(vec[0])
    curr.next = make_list(vec[1:])
    return curr

head = make_list([1, 2, 3, 2, 1])
print(isLinkedListPalindrome(head))
head2 = make_list([1, 2, 3, 4, 3, 2, 1])
print(isLinkedListPalindrome(head2))
head3 = make_list([1, 2, 3, 4, 5])
print(isLinkedListPalindrome(head3))",365
73396494235,min_substring_window,"from collections import Counter

def min_substring_window(s, t):
    """"""
    Finds the minimum window in string s that contains all characters of string t.
    Returns the substring if such a window exists, otherwise returns an empty string.
    """"""
    need, missing = Counter(t), len(t)
    left = w_l = w_r = 0
    for right, ch in enumerate(s, 1):
        missing -= need[ch] > 0
        need[ch] -= 1
        if not missing:
            while left < right and need[s[left]] < 0:
                need[s[left]] += 1
                left += 1
            if not w_r or right - left < w_r - w_l:
                w_l, w_r = left, right
    return s[w_l:w_r]

# Testing the function
print(min_substring_window(""ZXCCVZXCCV"", ""ZXC""))  # Expected: ""ZXC""
print(min_substring_window(""ABBBBEEODEBAC"", ""ABC""))  # Expected: ""BAC""
print(min_substring_window(""ABBBBEEODEBAC"", ""ABB""))  # Expected: ""ABB""
print(min_substring_window(""AAAABEEODEBAC"", ""ABB""))  # Expected: ""ABEEODEB""
print(min_substring_window(""AA"", ""AA""))  # Expected: ""AA""
print(min_substring_window(""ABBBBEEODEBAC"", ""ABCZ""))  # Expected: """"
print(min_substring_window("""", ""ABCZ""))  # Expected: """"
print(min_substring_window(""ABBBBEEODEBAC"", """"))  # Expected: """"",354
21786141207,oranges_rotting,"from typing import List
from collections import deque

def oranges_rotting(grid: List[List[int]]) -> int:
    if not grid: return -1
    m, n = len(grid), len(grid[0])
    q = deque()
    res, count = 0, 0
    judge = lambda x, y: 0 <= x < m and 0 <= y < n
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                count += 1
            elif grid[i][j] == 2:
                q.append([i, j])
    direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while count and q:
        queue_len = len(q)
        for i in range(queue_len):
            tmp_x, tmp_y = q.popleft()
            for (dx, dy) in direction:
                if judge(tmp_x + dx, tmp_y + dy):
                    if grid[tmp_x + dx][tmp_y + dy] == 1:
                        count -= 1
                        grid[tmp_x + dx][tmp_y + dy] = 2
                        q.append((tmp_x + dx, tmp_y + dy))
        res += 1

    if count: return -1
    else: return res

assert oranges_rotting([[2,1,1],[1,1,0],[0,1,1]]) == 4
assert oranges_rotting([[2,1,1],[0,1,1],[1,0,1]]) == -1
assert oranges_rotting([[0,2]]) == 0",354
8157516886,evaluate_expression,"def evaluate_expression(expression: str) -> int:
    def calculate(operands, operators):
        right = operands.pop()
        left = operands.pop()
        op = operators.pop()
        if op == '+':
            operands.append(left + right)
        elif op == '-':
            operands.append(left - right)
        elif op == '*':
            operands.append(left * right)
        elif op == '/':
            operands.append(int(left / right))
    
    def greater_precedence(op1, op2):
        precedence = {'+': 1, '-': 1, '*': 2, '/': 2}
        return precedence[op1] > precedence[op2]
    
    def evaluate(expr):
        operands = []
        operators = []
        i = 0
        while i < len(expr):
            if expr[i] == ' ':
                i += 1
            elif expr[i].isdigit():
                num = ''
                while i < len(expr) and expr[i].isdigit():
                    num += expr[i]
                    i += 1
                operands.append(int(num))
            elif expr[i] in ""+-*/"":
                while (operators and operators[-1] != '(' and
                       greater_precedence(operators[-1], expr[i])):
                    calculate(operands, operators)
                operators.append(expr[i])
                i += 1
            elif expr[i] == '(':
                operators.append(expr[i])
                i += 1
            elif expr[i] == ')':
                while operators[-1] != '(':
                    calculate(operands, operators)
                operators.pop()
                i += 1
        while operators:
            calculate(operands, operators)
        return operands[0]
    
    return evaluate(expression)",353
2511967888,create_largest_palindrome,"def create_largest_palindrome(s: str) -> str:
    def longest_palindromic_substring(s: str) -> str:
        if len(s) == 0:
            return """"
        start = 0
        end = 0
        for i in range(len(s)):
            len1 = expand_around_center(s, i, i)
            len2 = expand_around_center(s, i, i + 1)
            max_len = max(len1, len2)
            if max_len > end - start:
                start = i - (max_len - 1) // 2
                end = i + max_len // 2
        return s[start:end + 1]

    def expand_around_center(s: str, left: int, right: int) -> int:
        L = left
        R = right
        while L >= 0 and R < len(s) and s[L] == s[R]:
            L -= 1
            R += 1
        return R - L - 1

    def remove_chars(s: str, p: str) -> str:
        left = 0
        right = len(p) - 1
        result = """"
        for i in range(len(s)):
            if left <= right:
                if s[i] == p[left]:
                    result += s[i]
                    left += 1
                elif s[i] == p[right]:
                    result += s[i]
                    right -= 1
            else:
                result += s[i:]
                break
        return result

    palindrome = longest_palindromic_substring(s)
    result = remove_chars(s, palindrome)
    return result",351
3535220424,find_day_of_week,"def find_day_of_week(a, b):

    # 요일 배열 (1월 1일이 금요일이라서 금요일이 첫번째 인덱스)
    dayArray = ['FRI','SAT', 'SUN','MON','TUE','WED','THU']

    # 31, 30일인 월을 정리
    threeOne = [1,3,5,7,8,10,12]
    threeZero = [4,6,9,11]

    # 월에 해당하는 누적일을 가질 배열 설정
    array = [0]*13
    array[1] = 31
    # 윤년이라 2월은 29일로 설정 (2021년은 윤년이 아니지만, 2월의 일수를 결정하는 것은 함수의 목적이 아니므로 제외)
    array[2] = array[1]+28

    # 3월~12월까지 월에 해당하는 누적 일을 넣음
    for i in range(3, len(array)):
        
        if i in threeOne:
            array[i] = array[i-1]+31
        elif i in threeZero:
            array[i] = array[i-1]+30


    if a ==1:
        totalDay = b
    else:
        totalDay = array[a-1]+b
    
    if totalDay%7 ==0:
        idx = 6
    else:
        idx = (totalDay%7)-1    

    return dayArray[idx]",348
25859230986,find_connected_components,"def find_connected_components(edges):
    class UnionFind:
        def __init__(self, capacity):
            self.parent = [0] * capacity
            self.rank = [0] * capacity
            self.circles = 0
            for i in range(capacity):
                self.parent[i] = i
                self.rank[i] = 1
                self.circles += 1

        def find(self, p):
            if p < 0 or p >= len(self.parent):
                raise Exception(""p 超出了范围"")
            while p != self.parent[p]:
                self.parent[p] = self.parent[self.parent[p]]
                p = self.parent[p]
            return p

        def is_connected(self, p, q):
            return self.find(p) == self.find(q)

        def union_element(self, p, q):
            p_root, q_root = self.find(p), self.find(q)
            if p_root == q_root:
                return
            if self.rank[p_root] < self.rank[q_root]:
                self.parent[p_root] = q_root
            elif self.rank[p_root] > self.rank[q_root]:
                self.parent[q_root] = p_root
            else:
                self.parent[q_root] = p_root
                self.rank[p_root] += 1
            self.circles -= 1

        def get_circles(self):
            return self.circles

    nodes = set()
    for edge in edges:
        nodes.add(edge[0])
        nodes.add(edge[1])

    uf = UnionFind(len(nodes))
    for edge in edges:
        uf.union_element(edge[0], edge[1])

    return uf.get_circles()",348
15004338983,dijkstra,"import heapq

def dijkstra(graph, start, end):
    # Create a dictionary to store the shortest distance from the start node to each node
    shortest_distances = {node: float('inf') for node in graph}
    shortest_distances[start] = 0

    # Create a priority queue to store the nodes to visit next
    queue = [(0, start)]

    # Keep track of the previous node in the shortest path
    previous_nodes = {node: None for node in graph}

    while queue:
        # Pop the node with the smallest distance from the start node
        current_distance, current_node = heapq.heappop(queue)

        # If we've reached the end node, we can stop
        if current_node == end:
            break

        # Iterate over the neighbors of the current node
        for neighbor, distance in graph[current_node].items():
            # Calculate the distance from the start node to the neighbor through the current node
            distance_from_start = current_distance + distance

            # If this is the shortest distance we've found to the neighbor, update the shortest distances and previous nodes
            if distance_from_start < shortest_distances[neighbor]:
                shortest_distances[neighbor] = distance_from_start
                previous_nodes[neighbor] = current_node
                heapq.heappush(queue, (distance_from_start, neighbor))

    # Reconstruct the shortest path from the start node to the end node
    path = []
    current_node = end
    while current_node is not None:
        path.append(current_node)
        current_node = previous_nodes[current_node]
    path.reverse()

    # Return the shortest distance and the shortest path
    return shortest_distances[end]",348
3238549146,alien_dictionary,"from collections import defaultdict
from typing import List

def alien_dictionary(words: List[str]):
    NUM_ALPHABET = 26

    def dfs(dp, idx, visited, res):
        if not dp[idx][idx]:
            return True

        visited[idx] = True
        for i in range(NUM_ALPHABET):
            if i == idx or not dp[idx][i]:
                continue
            if visited[i]:
                return False
            if not dfs(dp, i, visited, res):
                return False
        
        visited[idx] = False
        dp[idx][idx] = False
        res.append(chr(ord('a') + idx))
        return True

    dp = [[False for _ in range(NUM_ALPHABET)] for _ in range(NUM_ALPHABET)]
    visited = defaultdict(lambda: False)
    res = []

    for word in words:
        for c in word:
            i = ord(c) - ord('a')
            dp[i][i] = True
    
    for i in range(1, len(words)):
        j = 0
        while words[i][j] == words[i-1][j]:
            j += 1
        c1, c2 = ord(words[i][j]) - ord('a'),  ord(words[i-1][j]) - ord('a')
        if dp[c2][c1]:
            return """"
        dp[c1][c2] = True

    for i in range(NUM_ALPHABET):
        if not dfs(dp, i, [False for _ in range(NUM_ALPHABET)], res):
            return """"   
    return """".join(res)",346
19604842105,findOrder,"def findOrder(numCourses, prerequisites):
    if len(prerequisites) == 0:
        return [i for i in range(numCourses)]

    graph = {}
    root = []

    for i in prerequisites:

        if i[0] in graph.keys():
            sub = graph[i[0]]
        else:
            sub = course_nodes(i[0])
            graph[i[0]] = sub

        if i[1] in graph.keys():
            pre = graph[i[1]]
        else:
            pre = course_nodes(i[1])
            graph[i[1]] = pre

        if sub in pre.pre:
            return []

        sub.pre.append(pre)
        pre.sub.append(sub)

        if len(root) == 0 or sub not in root:
            root.append(pre)
        else:
            root[root.index(sub)] = pre

    course_order = []
    waiting_list = root

    while len(course_order) < numCourses and len(waiting_list) != 0:
        current_node = waiting_list.pop(0)

        if current_node.node in course_order or not set([i.node for i in current_node.pre]).issubset(set(course_order)):
            continue

        course_order.append(current_node.node)
        waiting_list += current_node.sub

    if len(course_order) < numCourses:
        all_course = [i for i in range(numCourses)]
        course_order += list(set(all_course) - set(graph.keys()))

        if len(course_order) < numCourses:
            return []

    return course_order


class course_nodes:

    def __init__(self, value):
        self.node = value
        self.pre = []
        self.sub = []",345
36088179920,quick_select,"from random import randint

def quick_select(arr, k):
    def partition(left, right, pivot_index):
        pivot = arr[pivot_index]
        arr[pivot_index], arr[right] = arr[right], arr[pivot_index]
        store_index = left
        for i in range(left, right):
            if arr[i] < pivot:
                arr[i], arr[store_index] = arr[store_index], arr[i]
                store_index += 1
        arr[right], arr[store_index] = arr[store_index], arr[right]
        return store_index

    def select(left, right, k_smallest):
        if left == right:
            return arr[left]
        pivot_index = randint(left, right)
        pivot_index = partition(left, right, pivot_index)
        if k_smallest == pivot_index:
            return arr[k_smallest]
        elif k_smallest < pivot_index:
            return select(left, pivot_index - 1, k_smallest)
        else:
            return select(pivot_index + 1, right, k_smallest)

    return select(0, len(arr) - 1, k - 1)

# Test cases
assert quick_select([3, 2, 1, 5, 4], 3) == 3
assert quick_select([7, 6, 5, 4, 3, 2, 1], 1) == 1
assert quick_select([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 10) == 10",341
41963868434,find_max_xor,"class MaxXOR:
    def __init__(self):
        self.root = {}

    def add(self, n):
        node = self.root
        for i in reversed(range(32)):
            bit = (n >> i) & 1
            if bit not in node:
                node[bit] = {}
            node = node[bit]

    def query(self, n):
        node = self.root
        xor_sum = 0
        for i in reversed(range(32)):
            bit = (n >> i) & 1
            if 1 - bit in node:
                xor_sum |= (1 << i)
                node = node[1 - bit]
            else:
                node = node[bit]
        return xor_sum

def find_max_xor(nums):
    max_xor_tree = MaxXOR()
    max_xor = 0
    for num in nums:
        max_xor_tree.add(num)
        max_xor = max(max_xor, max_xor_tree.query(num))
    return max_xor

nums1 = [3, 10, 5, 25, 2, 8]
nums2 = [14, 70, 53, 83, 49, 91, 36, 80, 92, 51, 66, 70]
nums3 = [1, 2, 3, 9, 8]
assert find_max_xor(nums1) == 28
assert find_max_xor(nums2) == 127
assert find_max_xor(nums3) == 11",339
17925324544,max_depth,"# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def max_depth(root):
    if not root:
        return 0
    left_depth = max_depth(root.left)
    right_depth = max_depth(root.right)
    return max(left_depth, right_depth) + 1

# Function to create a binary tree from a list representation
def create_binary_tree(values):
    if not values:
        return None
    root = TreeNode(values[0])
    queue = [root]
    front = 0
    index = 1
    while index < len(values):
        node = queue[front]
        front = front + 1
        item = values[index]
        index = index + 1
        if item is not None:
            left_number = item
            node.left = TreeNode(left_number)
            queue.append(node.left)
        if index >= len(values):
            break
        item = values[index]
        index = index + 1
        if item is not None:
            right_number = item
            node.right = TreeNode(right_number)
            queue.append(node.right)
    return root

# Test cases
assert max_depth(create_binary_tree([3,9,20,None,None,15,7])) == 3
assert max_depth(create_binary_tree([1,2,3,4,5,6])) == 3
assert max_depth(create_binary_tree([1,2,3,4,None,None,5])) == 3",337
41232775590,shortest_path_dijkstra,"import heapq

def shortest_path_dijkstra(graph, start, end):
    # Initialize the distance dictionary with positive infinity for all vertices except the start vertex
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    # Initialize the path dictionary with None for all vertices
    path = {vertex: None for vertex in graph}
    
    # Create a priority queue and insert the start vertex with distance 0
    priority_queue = [(0, start)]
    
    while priority_queue:
        # Get the vertex with the smallest distance from the priority queue
        current_distance, current_vertex = heapq.heappop(priority_queue)
        
        # If we have reached the end vertex, we can stop
        if current_vertex == end:
            break
        
        # Iterate over the neighbors of the current vertex
        for neighbor, weight in graph[current_vertex].items():
            # Calculate the distance to the neighbor through the current vertex
            distance = current_distance + weight
            # If this distance is smaller than the previously stored distance, update the distance and the path
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                path[neighbor] = current_vertex
                # Insert the neighbor into the priority queue with the new distance
                heapq.heappush(priority_queue, (distance, neighbor))
    
    # Reconstruct the shortest path
    shortest_path = []
    current_vertex = end
    while current_vertex:
        shortest_path.append(current_vertex)
        current_vertex = path[current_vertex]
    shortest_path.reverse()
    
    return [distances[end], shortest_path]",335
11594989349,shortest_distance,"from collections import deque

def shortest_distance(mat):
    n = len(mat)
    m = len(mat[0])
    ans = [[-1 for _ in range(m)] for _ in range(n)]
    visited = [[0 for _ in range(m)] for _ in range(n)]
    directions = [[0,1],[1,0],[-1,0],[0,-1]]
    zeros = []

    for i in range(n):
        for j in range(m):
            if mat[i][j] == 0:
                zeros.append([i,j])
                visited[i][j] = 1
                ans[i][j] = 0

    queue = deque(zeros)
    dist = 0
    while queue:
        for _ in range(len(queue)):
            i, j = queue.popleft()
            for d in directions:
                if valid(i+d[0],j+d[1],n,m) and visited[i+d[0]][j+d[1]] == 0:
                    queue.append([i+d[0],j+d[1]])
                    visited[i+d[0]][j+d[1]] = 1
                    if mat[i+d[0]][j+d[1]] == 1 and ans[i+d[0]][j+d[1]] == -1:
                        ans[i+d[0]][j+d[1]] = dist + 1
        dist += 1

    return ans

def valid(x, y, n, m):
    if x >= 0 and x < n and y >= 0 and y < m:
        return True
    return False",334
43114128798,shortest_distance,"from collections import deque

def shortest_distance(grid):
    def bfs(i, j):
        visited = {(i, j)}
        buildings = set()
        q = deque([(i, j, 0)])
        total_step = 0

        while q:
            i, j, step = q.popleft()
            if grid[i][j] == 1 and (i, j) not in buildings:
                total_step += step
                buildings.add((i, j))
            if len(buildings) == num_buildings:
                return total_step
            if grid[i][j] == 0:
                for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):
                    if 0 <= x < m and 0 <= y < n and (x, y) not in visited and grid[x][y] != 2:
                        q.append((x, y, step + 1))
                        visited.add((x, y))
        return float('inf')

    m, n = len(grid), len(grid[0])
    num_buildings = sum(grid[i][j] == 1 for i in range(m) for j in range(n))
    min_step = float('inf')

    for i in range(m):
        for j in range(n):
            if grid[i][j] == 0:
                total_step = bfs(i, j)
                if min_step > total_step:
                    min_step = total_step

    return min_step if min_step != float('inf') else -1",331
17838176688,longest_line,"from typing import List

def longest_line(mat: List[List[int]]) -> int:
    n = len(mat)
    m = len(mat[0])
    dp = [[[0, 0, 0, 0] for _ in range(m)] for _ in range(n)]
    max_length = 0
    for i in range(n):
        for j in range(m):
            if mat[i][j] == 0:
                continue
            if i - 1 >= 0 and j - 1 >= 0:
                dp[i][j][3] = 1 + dp[i - 1][j - 1][3]
            else:
                dp[i][j][3] = 1
            if i - 1 >= 0:
                dp[i][j][0] = 1 + dp[i - 1][j][0]
            else:
                dp[i][j][0] = 1
            if j - 1 >= 0:
                dp[i][j][1] = 1 + dp[i][j - 1][1]
            else:
                dp[i][j][1] = 1
            if i - 1 >= 0 and j + 1 < m:
                dp[i][j][2] = 1 + dp[i - 1][j + 1][2]
            else:
                dp[i][j][2] = 1
            max_length1 = max(dp[i][j])
            max_length = max(max_length, max_length1)
    return max_length",329
8374830554,count_inversions,"def count_inversions(arr):
	arr_temp = [0]*len(arr)
	return mergeSort(arr, arr_temp, 0, len(arr)-1)

def mergeSort(arr, arr_temp, arr_left, arr_right):
	count = 0 
	if arr_left < arr_right:
		mid = (arr_left + arr_right)//2
		count += mergeSort(arr, arr_temp, arr_left, mid)
		count += mergeSort(arr, arr_temp, mid + 1, arr_right)
		count += merge(arr, arr_temp, arr_left, mid, arr_right)
	return count

def merge(arr, arr_temp, arr_left, mid, arr_right):
	l = arr_left	 
	m = mid + 1 
	k = arr_left	 
	count = 0
	while l <= mid and m <= arr_right:
		if arr[l] <= arr[m]:
			arr_temp[k] = arr[l]
			k = k+ 1
			l = l+ 1
		else:
			arr_temp[k] = arr[m]
			count += (mid-l + 1)
			k = k+ 1
			m = m+ 1
	while l <= mid:
		arr_temp[k] = arr[l]
		k = k+ 1
		l = l+ 1
	while m <= arr_right:
		arr_temp[k] = arr[m]
		k = k+ 1
		m = m+ 1
	for i in range(arr_left, arr_right + 1):
		arr[i] = arr_temp[i]
		
	return count",328
74290846332,kth_smallest,"def partition(arr, left, right, pivot_index):
    pivot = arr[pivot_index]
    arr[pivot_index], arr[right] = arr[right], arr[pivot_index]
    store_index = left
    for i in range(left,right):
        if arr[i] < pivot:
            arr[i],arr[store_index] = arr[store_index],arr[i]
            store_index += 1
    arr[right], arr[store_index] = arr[store_index], arr[right]
    return store_index

def _quickselect(arr, left, right, k):
    if left == right: 
        return arr[left]
    pivot_index = left
    pivot_index = partition(arr, left, right, pivot_index)
    if k == pivot_index:
        return arr[k]
    elif k < pivot_index:
        return _quickselect(arr, left, pivot_index-1, k)
    else:
        return _quickselect(arr, pivot_index+1, right, k)

def kth_smallest(arr, k):
    if not 1 <= k <= len(arr):
        raise ValueError('k is out of bounds')
    return _quickselect(arr, 0, len(arr)-1, k-1)

print(kth_smallest([7,10,4,3,20,15], 3))
print(kth_smallest([7,10,4,3,20,15], 4))
print(kth_smallest([12, 3, 5, 7, 19], 2))",327
38122595020,count_inversions,"def merge_sort(arr, temp_arr, left, right):
    inv_count = 0
    if left < right:
        mid = (left + right) // 2
        inv_count = merge_sort(arr, temp_arr, left, mid)
        inv_count += merge_sort(arr, temp_arr, mid + 1, right)
        inv_count += merge(arr, temp_arr, left, mid, right)
    return inv_count

def merge(arr, temp_arr, left, mid, right):
    i = left
    j = mid + 1
    k = left
    inv_count = 0

    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp_arr[k] = arr[i]
            k += 1
            i += 1
        else:
            temp_arr[k] = arr[j]
            inv_count += (mid - i + 1)
            k += 1
            j += 1

    while i <= mid:
        temp_arr[k] = arr[i]
        k += 1
        i += 1

    while j <= right:
        temp_arr[k] = arr[j]
        k += 1
        j += 1

    for loop_var in range(left, right + 1):
        arr[loop_var] = temp_arr[loop_var]

    return inv_count

def count_inversions(arr):
    temp_arr = [0] * len(arr)
    return merge_sort(arr, temp_arr, 0, len(arr) - 1)",326
70084950291,count_inversions,"def merge_count_split_inv(arr, temp_arr, left, mid, right):
    i = left
    j = mid + 1
    k = left
    inv_count = 0

    while i <= mid and j <= right:

        if arr[i] <= arr[j]:
            temp_arr[k] = arr[i]
            k += 1
            i += 1
        else:
            temp_arr[k] = arr[j]
            inv_count += (mid - i + 1)
            k += 1
            j += 1

    while i <= mid:
        temp_arr[k] = arr[i]
        k += 1
        i += 1

    while j <= right:
        temp_arr[k] = arr[j]
        k += 1
        j += 1

    for i in range(left, right+1):
        arr[i] = temp_arr[i]
    return inv_count

def mergeSort(arr, temp_arr, left, right):
    inv_count = 0
    if left < right:
        mid = (left + right) // 2
        inv_count += mergeSort(arr, temp_arr, left, mid)
        inv_count += mergeSort(arr, temp_arr, mid + 1, right)

        inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right)
    return inv_count

def count_inversions(arr):
    temp_arr = [0]*len(arr)
    return mergeSort(arr, temp_arr, 0, len(arr) - 1)",325
71883340824,longest_word,"def longest_word(words):
    dic = {}
    words.sort()
    start = ''
    res = ''
    for i in range(len(words)):
        if res == '':
            if len(words[i]) == 1:
                start = words[i]
                res = words[i]
                dic[start] = res
            continue
        if len(res) + 1 == len(words[i]):
            if words[i].startswith(res):
                res = words[i]
                dic[start] = res
        else:
            if len(words[i]) == 1:
                start = words[i]
                res = words[i]
                dic[start] = res
            elif len(words[i]) == 2:
                if words[i][0] in dic:
                    start = words[i][0]
                    res = words[i]
                    dic[start] = res
    res = ''
    for value in dic.values():
        if len(res) < len(value):
            res = value
        elif len(res) == len(value):
            res = min(res, value)
    return res


if __name__ == '__main__':
    words1 = [""w"", ""wo"", ""wor"", ""worl"", ""world""]
    words2 = [""a"", ""at"", ""ate"", ""ater"", ""atee""]
    words3 = [""c"", ""ca"", ""cat"", ""catz"", ""catze"", ""catzea""]
    s = Solution()
    print(s.longest_word(words1))
    print(s.longest_word(words2))
    print(s.longest_word(words3))",324
12638508679,is_symmetric,"from typing import Optional
from collections import deque

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_symmetric(root: Optional[TreeNode]) -> bool:
    if not root:
        return True

    def check(left, right):
        if not left and not right:
            return True
        if not left or not right:
            return False
        return left.val == right.val and check(left.left, right.right) and check(left.right, right.left)

    return check(root.left, root.right)

def construct(arr):
    if not arr:
        return None
    root = TreeNode(arr.pop(0))
    queue = deque([root])
    while arr:
        node = queue.popleft()
        if arr:
            val = arr.pop(0)
            left = TreeNode(val) if val is not None else None
            node.left = left
            if left:
                queue.append(left)
        if arr:
            val = arr.pop(0)
            right = TreeNode(val) if val is not None else None
            node.right = right
            if right:
                queue.append(right)
    return root

assert is_symmetric(construct([1,2,2,3,4,4,3]))==True
assert is_symmetric(construct([1,2,2,None,3,None,3]))==False
assert is_symmetric(construct([1]))==True",324
17490512693,max_path_sum,"class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None

def max_path_sum(root):
    # Initialize the result variable to store the maximum path sum
    result = float('-inf')

    # Define a helper function to recursively find the maximum path sum
    def helper(node):
        nonlocal result
        if not node:
            return 0

        # Recursively find the maximum path sum for the left and right subtrees
        left_sum = max(helper(node.left), 0)
        right_sum = max(helper(node.right), 0)

        # Update the result variable if the sum of the current node, left subtree sum, and right subtree sum is greater than the current maximum path sum
        result = max(result, node.val + left_sum + right_sum)

        # Return the maximum sum of the current node and either the left subtree sum or the right subtree sum
        return node.val + max(left_sum, right_sum)

    helper(root)
    return result

# Test cases
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
assert max_path_sum(root) == 6

root = TreeNode(-10)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)
assert max_path_sum(root) == 42

root = TreeNode(2)
root.left = TreeNode(-1)
assert max_path_sum(root) == 2",324
10787038555,shortest_path,"from collections import deque

def shortest_path(grid, start, end):
    """"""
    :type grid: List[List[int]]
    :type start: List[int]
    :type end: List[int]
    :rtype: int
    """"""
    # Define the four possible directions: up, down, left, right
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    # Create a queue for Breadth-First Search (BFS)
    queue = deque([(start[0], start[1], 0)])
    # Create a set to store visited cells
    visited = set((start[0], start[1]))
    
    while queue:
        x, y, distance = queue.popleft()
        # Check if the current cell is the end point
        if (x, y) == (end[0], end[1]):
            return distance
        # Explore all four directions from the current cell
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            # Check if the new cell is within the grid and is not an obstacle
            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 0 and (nx, ny) not in visited:
                queue.append((nx, ny, distance + 1))
                visited.add((nx, ny))
    # If no path is found, return -1
    return -1",323
28247670047,connected_components,"from typing import List

def find_root(uf_set: List[int], x: int) -> int:
    while uf_set[x] != x:
        uf_set[x] = uf_set[uf_set[x]]
        x = uf_set[x]
    return x

def union_uf_set(uf_set: List[int], a: int, b: int) -> None:
    root_a = find_root(uf_set, a)
    root_b = find_root(uf_set, b)
    if root_a != root_b:
        uf_set[root_b] = root_a

def connected_components(n: int, edges: List[List[int]]) -> int:
    uf_set = list(range(n))
    for edge in edges:
        union_uf_set(uf_set, edge[0], edge[1])
    
    roots = set()
    for i in range(n):
        roots.add(find_root(uf_set, i))
    return len(roots)

# Test cases
assert connected_components(10, [[0, 1], [1, 2], [3, 4], [5, 6], [6, 7], [7, 8], [8, 9]]) == 3
assert connected_components(6, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]) == 1
assert connected_components(5, [[0, 1], [2, 3], [3, 4]]) == 2",321
21008933269,shortest_alternating_paths,"from collections import defaultdict

def shortest_alternating_paths(n, red_edges, blue_edges):
    """"""
    :type n: int
    :type red_edges: List[List[int]]
    :type blue_edges: List[List[int]]
    :rtype: List[int]
    """"""
    if n <= 0: return []
    red_map = defaultdict(list)
    blue_map = defaultdict(list)
    for u, v in red_edges:
        red_map[u].append(v)
    for u, v in blue_edges:
        blue_map[u].append(v)
    res = [-1] * n
    res[0] = 0
    queue = [(0, True, 0), (0, False, 0)]
    visited = set()
    while queue:
        u, is_red, level = queue.pop(0)
        if (u, is_red) in visited: continue
        visited.add((u, is_red))
        if is_red and u in red_map:
            for v in red_map[u]:
                if res[v] == -1 or res[v] > level + 1:
                    res[v] = level + 1
                    queue.append((v, not is_red, level + 1))
        if not is_red and u in blue_map:
            for v in blue_map[u]:
                if res[v] == -1 or res[v] > level + 1:
                    res[v] = level + 1
                    queue.append((v, not is_red, level + 1))
    return res",320
21270086021,is_balanced_tree,"class Node:
    def __init__(self, val, l=None, r=None):
        self.val = val
        self.l = l
        self.r = r

def get():
    n4 = Node(4)
    n5 = Node(5)

    n2 = Node(2)
    n3 = Node(3, n4, n5)

    n1 = Node(1, n2, n3)
    return n1

def get2():
    n6 = Node(6)
    n7 = Node(7)

    n4 = Node(4, n6, n7)
    n5 = Node(5)

    n2 = Node(2, n4, n5)
    n3 = Node(3)

    n1 = Node(1, n2, n3)
    return n1

def is_balanced_tree(node):
    if node is None:
        return True

    left_height = get_height(node.l)
    right_height = get_height(node.r)

    if abs(left_height - right_height) > 1:
        return False

    return is_balanced_tree(node.l) and is_balanced_tree(node.r)

def get_height(node):
    if node is None:
        return 0
    return 1 + max(get_height(node.l), get_height(node.r))

if __name__ == ""__main__"":
    node = get()
    assert is_balanced_tree(node) == True

    node = get2()
    assert is_balanced_tree(node) == False",320
15402720575,can_type_word,"def can_type_word(word, valid):
    keyboard = {'q': 'qwertyuiop', 'w': 'qwertyuiop', 'e': 'qwertyuiop', 'r': 'qwertyuiop', 't': 'qwertyuiop',
                'y': 'qwertyuiop', 'u': 'qwertyuiop', 'i': 'qwertyuiop', 'o': 'qwertyuiop', 'p': 'qwertyuiop',
                'a': 'asdfghjkl', 's': 'asdfghjkl', 'd': 'asdfghjkl', 'f': 'asdfghjkl', 'g': 'asdfghjkl',
                'h': 'asdfghjkl', 'j': 'asdfghjkl', 'k': 'asdfghjkl', 'l': 'asdfghjkl',
                'z': 'zxcvbnm', 'x': 'zxcvbnm', 'c': 'zxcvbnm', 'v': 'zxcvbnm', 'b': 'zxcvbnm',
                'n': 'zxcvbnm', 'm': 'zxcvbnm'}

    prev_key = None
    for char in word:
        if char not in valid:
            return False
        for key, chars in keyboard.items():
            if char in chars:
                if key == prev_key:
                    return False
                prev_key = key
                break
    return True",318
27356418674,linked_list_to_list,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode()
    current = dummy

    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next

    if l1:
        current.next = l1
    elif l2:
        current.next = l2

    return dummy.next

# Helper function to create a linked list from a list
def create_linked_list(lst):
    if not lst:
        return None
    dummy = ListNode()
    current = dummy
    for val in lst:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

# Helper function to convert a linked list to a list
def linked_list_to_list(head):
    lst = []
    current = head
    while current:
        lst.append(current.val)
        current = current.next
    return lst

# Test case
list1 = [1, 3, 5]
list2 = [2, 4, 6]
merged_list = merge_sorted_lists(create_linked_list(list1), create_linked_list(list2))
assert linked_list_to_list(merged_list) == [1, 2, 3, 4, 5, 6]",318
21530654044,count_inversions,"def count_inversions(arr):
    def merge_sort(arr, temp_arr, left, right):
        inv_count = 0
        if left < right:
            mid = (left + right) // 2
            inv_count += merge_sort(arr, temp_arr, left, mid)
            inv_count += merge_sort(arr, temp_arr, mid + 1, right)
            inv_count += merge(arr, temp_arr, left, mid, right)
        return inv_count

    def merge(arr, temp_arr, left, mid, right):
        i = left
        j = mid + 1
        k = left
        inv_count = 0

        while i <= mid and j <= right:
            if arr[i] <= arr[j]:
                temp_arr[k] = arr[i]
                i += 1
            else:
                temp_arr[k] = arr[j]
                inv_count += (mid - i + 1)
                j += 1
            k += 1

        while i <= mid:
            temp_arr[k] = arr[i]
            i += 1
            k += 1

        while j <= right:
            temp_arr[k] = arr[j]
            j += 1
            k += 1

        for i in range(left, right + 1):
            arr[i] = temp_arr[i]

        return inv_count

    temp_arr = [0] * len(arr)
    return merge_sort(arr, temp_arr, 0, len(arr) - 1)",317
18401123764,isSymmetric,"from typing import Optional

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isSymmetric(root: Optional[TreeNode]) -> bool:
    if not root:
        return True

    def dfs(left, right):
        if left is None and right is None:
            return True
        if not left or not right:
            return False
        if left.val != right.val:
            return False
        isSame = dfs(left.left, right.right)
        isSame = isSame and dfs(left.right, right.left)
        return isSame

    return dfs(root.left, root.right)

# Test cases
node1 = TreeNode(1, None, None)
node2 = TreeNode(2, None, None)
root = TreeNode(0, node1, node2)
print(isSymmetric(root))  # True

node3 = TreeNode(3, None, None)
node4 = TreeNode(4, None, None)
root = TreeNode(1, TreeNode(2, node3, node4), TreeNode(2, node4, node3))
print(isSymmetric(root))  # True

node3 = TreeNode(3, None, None)
node4 = TreeNode(4, None, None)
root = TreeNode(1, TreeNode(2, node3), TreeNode(2, None, node3))
print(isSymmetric(root))  # False",316
31370546481,unique_sorted,"def unique_sorted(numbers):
    def merge_sort(arr):
        if len(arr) <= 1:
            return arr
        mid = len(arr) // 2
        left_half = merge_sort(arr[:mid])
        right_half = merge_sort(arr[mid:])
        return merge(left_half, right_half)

    def merge(left, right):
        result = []
        left_index = right_index = 0
        while left_index < len(left) and right_index < len(right):
            if left[left_index] < right[right_index]:
                if len(result) == 0 or result[-1] != left[left_index]:
                    result.append(left[left_index])
                left_index += 1
            elif left[left_index] > right[right_index]:
                if len(result) == 0 or result[-1] != right[right_index]:
                    result.append(right[right_index])
                right_index += 1
            else:
                if len(result) == 0 or result[-1] != left[left_index]:
                    result.append(left[left_index])
                left_index += 1
                right_index += 1

        while left_index < len(left):
            if len(result) == 0 or result[-1] != left[left_index]:
                result.append(left[left_index])
            left_index += 1

        while right_index < len(right):
            if len(result) == 0 or result[-1] != right[right_index]:
                result.append(right[right_index])
            right_index += 1

        return result

    return merge_sort(numbers)",316
14838762052,findMedianSortedArrays,"from typing import List

def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:
    n, m = len(nums1), len(nums2)
    if n > m:
        nums1, nums2, n, m = nums2, nums1, m, n

    imin, imax, half_len = 0, n, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < n and nums2[j-1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i-1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = nums2[j-1]
            elif j == 0:
                max_of_left = nums1[i-1]
            else:
                max_of_left = max(nums1[i-1], nums2[j-1])

            if (m + n) % 2 == 1:
                return max_of_left

            if i == n:
                min_of_right = nums2[j]
            elif j == m:
                min_of_right = nums1[i]
            else:
                min_of_right = min(nums1[i], nums2[j])

            return (max_of_left + min_of_right) / 2",315
5493783126,isBST,"# A binary tree node
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

# This function should return tree if it is a BST, and false otherwise
def isBST(root): 
    return (isBSTUtil(root, float('-inf'), float('inf')))

# Returns true if the given tree is a binary search tree (efficient version)
def isBSTUtil(root, mini, maxi): 
    # An empty tree is BST
    if root is None:
        return True
  
    # False if this node violates the min/max constraint 
    if root.key < mini or root.key > maxi:
        return False
  
    # Otherwise check the subtrees recursively, 
    # tightening the min or max constraint 
    return (isBSTUtil(root.left, mini, root.key -1) and
          isBSTUtil(root.right, root.key+1, maxi))
  
# Let's create this tree:
#     4
#    / \
#   2   5
#  / \
# 1   3
root = Node(4)
root.left = Node(2)
root.right = Node(5)
root.left.left = Node(1)
root.left.right = Node(3)

# Check function
def check():
    assert isBST(root) == True
    root.left.right.key = 2  # This makes it not a BST
    assert isBST(root) == False

check()",315
33112073646,maximum_gap,"import math

def maximum_gap(nums):
    n = len(nums)
    if not nums or len(nums) < 2:
        return 0
    _min, _max = min(nums), max(nums)
    gap = int(math.ceil(float(_max-_min)/(n-1)))
    min_bucket = [float('inf')] * (n-1)
    max_bucket = [float('-inf')] * (n-1)
    for num in nums:
        if num == _max:
            continue
        i = (num-_min)//gap
        min_bucket[i] = min(min_bucket[i], num)
        max_bucket[i] = max(max_bucket[i], num)
    prev, max_gap = _min, 0
    for i in range(n-1):
        if min_bucket[i] == float('inf') and max_bucket[i] == float('-inf'):
            continue
        curr_gap = min_bucket[i] - prev
        max_gap = max(max_gap, curr_gap)
        prev = max_bucket[i]
    return max(max_gap, _max-prev)

print(maximum_gap([3, 6, 9, 1])) # 3
print(maximum_gap([10, 20, 30, 40])) # 10
print(maximum_gap([1, 2, 3, 4, 5])) # 1
print(maximum_gap([1])) # 0
print(maximum_gap([])) # 0",314
15520487689,solve,"def solve(n):
    board = [['.'] * n for _ in range(n)]
    res = []
    dfs(0, board, res)
    return res


def dfs(i, board, res):
    if i == len(board):
        res.append(convert_res(board))
        return
    for j in range(len(board[i])):
        if is_valid(i, j, board):
            board[i][j] = 'Q'
            dfs(i+1, board, res)
            board[i][j] = '.'


def is_valid(cur_i, cur_j, board):
    n_col = len(board)
    for i in range(cur_i):
        if board[i][cur_j] == 'Q':
            return False
    d = max(cur_i - cur_j, cur_j - cur_i)

    for i in range(cur_i):
        j = i - (cur_i - cur_j)
        if j >= 0 and j < n_col and board[i][j] == 'Q':
            return False
        j = cur_i + cur_j - i
        if j >= 0 and j < n_col and board[i][j] == 'Q':
            return False

    return True


def convert_res(board):
    res = []
    for row in board:
        sub_res = []
        for e in row:
            if e == '#':
                sub_res.append('.')
            else:
                sub_res.append(e)
        res.append(''.join(sub_res))
    return res",308
19864092908,lengthOfLongestSubstringKDistinct,"import collections

def lengthOfLongestSubstringKDistinct(s, k):
    """"""
    :type s: str
    :type k: int
    :rtype: int
    """"""
    # Datastructures #
    # table maps   char -> num occurrences
    # rightidx, leftidx are inclusive of current string
    # uniqcounter is number of unique characters in current string
    # ret is max length seen so far.
    table = collections.defaultdict(int)
    rightidx = 0                     
    leftidx = 0
    uniqcounter = 0
    ret = float('-inf')
    if not s or not k: return 0
    
    while rightidx < len(s):
        # Check to see if we have encounted a new character
        if table[s[rightidx]] == 0:
            uniqcounter += 1
        table[s[rightidx]] += 1
        
        while leftidx < rightidx and uniqcounter > k:
            table[s[leftidx]] -= 1
            # Check to see if we have lost a unique character
            if table[s[leftidx]] == 0:
                uniqcounter -= 1
            # BE CAREFUL WHERE THIS PLACED
            leftidx += 1

        # At this point uniqcounter <= k
        ret = max(ret, rightidx - leftidx + 1)
        # BE CAREFUL WHERE THIS PLACED
        rightidx += 1
        
    return ret",306
24657008435,find_Max_XOR,"from collections import deque

class TrieNode:
    def __init__(self):
        self.children = {}

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, val):
        node = self.root
        for shift in range(31, -1, -1):
            bit = (val >> shift) & 1
            if bit not in node.children:
                node.children[bit] = TrieNode()
            node = node.children[bit]

    def getMaxXor(self, val):
        node = self.root
        max_xor = 0
        for shift in range(31, -1, -1):
            bit = (val >> shift) & 1
            toggle_bit = 1 - bit
            if toggle_bit in node.children:
                max_xor |= (1 << shift)
                node = node.children[toggle_bit]
            else:
                node = node.children[bit]
        return max_xor

def find_Max_XOR(nums):
    trie = Trie()
    max_xor = float('-inf')
    for num in nums:
        trie.insert(num)
        max_xor = max(max_xor, trie.getMaxXor(num))
    return max_xor

find_Max_XOR([8,1,2,12,7,6])
find_Max_XOR([4,8,2,10])
find_Max_XOR([3,10,5,25,2,8])",305
3643961056,find_median_sorted_arrays,"def find_median_sorted_arrays(nums1, nums2):
    m, n = len(nums1), len(nums2)
    if m > n:
        nums1, nums2, m, n = nums2, nums1, n, m

    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and nums2[j-1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i-1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = nums2[j-1]
            elif j == 0:
                max_of_left = nums1[i-1]
            else:
                max_of_left = max(nums1[i-1], nums2[j-1])

            if (m + n) % 2 == 1:
                return max_of_left

            if i == m:
                min_of_right = nums2[j]
            elif j == n:
                min_of_right = nums1[i]
            else:
                min_of_right = min(nums1[i], nums2[j])

            return (max_of_left + min_of_right) / 2.0",303
25543566408,findMedianSortedArrays,"def findMedianSortedArrays(nums1, nums2):
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1

    m, n = len(nums1), len(nums2)
    imin, imax, half_len = 0, m, (m + n + 1) // 2

    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and nums2[j-1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i-1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = nums2[j-1]
            elif j == 0:
                max_of_left = nums1[i-1]
            else:
                max_of_left = max(nums1[i-1], nums2[j-1])

            if (m + n) % 2 == 1:
                return max_of_left

            if i == m:
                min_of_right = nums2[j]
            elif j == n:
                min_of_right = nums1[i]
            else:
                min_of_right = min(nums1[i], nums2[j])

            return (max_of_left + min_of_right) / 2.0",300
5309982247,median,"def median(arr1, arr2):
    m, n = len(arr1), len(arr2)
    if m > n:
        arr1, arr2, m, n = arr2, arr1, n, m

    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and arr2[j-1] > arr1[i]:
            imin = i + 1
        elif i > 0 and arr1[i-1] > arr2[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = arr2[j-1]
            elif j == 0:
                max_of_left = arr1[i-1]
            else:
                max_of_left = max(arr1[i-1], arr2[j-1])

            if (m + n) % 2 == 1:
                return max_of_left

            if i == m:
                min_of_right = arr2[j]
            elif j == n:
                min_of_right = arr1[i]
            else:
                min_of_right = min(arr1[i], arr2[j])

            return (max_of_left + min_of_right) / 2.0",300
33531155998,search_in_rotated_sorted_array,"def search_in_rotated_sorted_array(nums, target):
    def find_rotation_index(left, right):
        if nums[left] < nums[right]:
            return 0

        while left <= right:
            pivot = (left + right) // 2
            if nums[pivot] > nums[pivot + 1]:
                return pivot + 1
            else:
                if nums[pivot] < nums[left]:
                    right = pivot - 1
                else:
                    left = pivot + 1

    def binary_search(left, right):
        while left <= right:
            pivot = (left + right) // 2
            if nums[pivot] == target:
                return pivot
            else:
                if target < nums[pivot]:
                    right = pivot - 1
                else:
                    left = pivot + 1
        return -1

    n = len(nums)

    if n == 0:
        return -1
    if n == 1:
        return 0 if nums[0] == target else -1

    rotate_index = find_rotation_index(0, n - 1)

    if nums[rotate_index] == target:
        return rotate_index
    if rotate_index == 0:
        return binary_search(0, n - 1)
    if target < nums[0]:
        return binary_search(rotate_index, n - 1)
    return binary_search(0, rotate_index)",300
33760280988,max_requests,"from itertools import combinations
from collections import defaultdict, Counter

def max_requests(n, req):
    res = 0
    In, Out = defaultdict(Counter), defaultdict(Counter)
    for L, R in req:
        if L != R:
            Out[L][R] += 1
            In[R][L] += 1
        else:
            res += 1

    remove = [i for i in range(n) if not In[i] or not Out[i]]
    for i in remove:
        for L in In[i]:
            Out[L][i] -= 1
            if not Out[L][i]: Out[L].pop(i)
            if not Out[L]: remove.append(L)
        for R in Out[i]:
            In[R][i] -= 1
            if not In[R][i]: In[R].pop(i)
            if not In[R]: remove.append(R)
        In.pop(i)
        Out.pop(i)
    req = sum(([(L, R)] * Out[L][R] for L in Out for R in Out[L]), [])
    for k in range(len(req), 0, -1):
        for c in combinations(req, k):
            degree = [0] * n
            for L, R in c:
                degree[L] -= 1
                degree[R] += 1
            if not any(degree):
                return k + res
    return res",299
74654317904,game_of_life,"def game_of_life(board):
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]
    rows, cols = len(board), len(board[0])
    
    def count_live_neighbors(row, col):
        live_neighbors = 0
        for dr, dc in directions:
            r, c = row + dr, col + dc
            if (r < rows and r >= 0) and (c < cols and c >= 0) and abs(board[r][c]) == 1:
                live_neighbors += 1
        return live_neighbors
    
    for row in range(rows):
        for col in range(cols):
            live_neighbors = count_live_neighbors(row, col)
            if board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                board[row][col] = -1
            elif board[row][col] == 0 and live_neighbors == 3:
                board[row][col] = 2
    
    for row in range(rows):
        for col in range(cols):
            if board[row][col] == -1:
                board[row][col] = 0
            elif board[row][col] == 2:
                board[row][col] = 1
    
    return board",299
70676496137,quickSelect,"def quickSelect(arr, k):
    def partition(left, right, pivot_index):
        pivot = arr[pivot_index]
        arr[pivot_index], arr[right] = arr[right], arr[pivot_index]  
        store_index = left
        for i in range(left, right):
            if arr[i] < pivot:
                arr[i], arr[store_index] = arr[store_index], arr[i]
                store_index += 1
        arr[right], arr[store_index] = arr[store_index], arr[right]  
        return store_index

    def select(left, right, k_smallest):
        if left == right:  
            return arr[left]
        pivot_index = (left + right) // 2
        pivot_index = partition(left, right, pivot_index)
        if k_smallest == pivot_index:
            return arr[k_smallest]
        elif k_smallest < pivot_index:
            return select(left, pivot_index - 1, k_smallest)
        else:
            return select(pivot_index + 1, right, k_smallest)

    return select(0, len(arr) - 1, k - 1)

print(quickSelect([3,2,1], 2))
print(quickSelect([0,1,2,1], 1))
print(quickSelect([7, 10, 4, 3, 20, 15], 3))",299
12003837985,count_construct,"def isWordInTarget(word, target):
    if len(word) > len(target):
        return False
    subTarget = target[:len(word)]
    return subTarget == word

# O(n*m * m) Time | O(m^2) Space where m is length of target and n is length of wordBank
def count_construct(target, wordBank, memo={}):
    if target in memo:
        return memo[target]
    if len(target) == 0:
        return 1
    count = 0
    for word in wordBank:
        if isWordInTarget(word, target):
            newTarget = target[len(word):]
            numberOfWays = count_construct(newTarget, wordBank, memo)
            count += numberOfWays
    memo[target] = count
    return count

if __name__ == '__main__':
    # print(count_construct(""abcdef"", [""ab"", ""abc"", ""cd"", ""def"", ""abcd"", ""ef""]))
    # print(count_construct(""skateboard"", [""bo"", ""rd"", ""ate"", ""t"", ""ska"", ""sk"", ""boar""]))
    # print(count_construct(""enterapotentpot"", [""a"", ""p"", ""ent"", ""enter"", ""ot"", ""o"", ""t""]))
    print(count_construct(""eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef"", [""e"", ""ee"", ""eee"", ""eeee"", ""eeeee""]))",298
28733210316,word_ladder_ii,"from typing import List
import collections

def word_ladder_ii(beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
    if endWord not in wordList: return []
    m, conn = len(beginWord), collections.defaultdict(list)

    def genKeys(word):
        for i in range(m):
            yield word[:i] + '*' + word[i+1:]
    for w in wordList:
        for key in genKeys(w):
            conn[key].append(w)

    que, prev = collections.deque([beginWord]), collections.defaultdict(list)
    dis, shortest, res = {beginWord: 1}, float(""inf""), []
    while que:
        word = que.popleft()
        if word == endWord:
            shortest = dis[word]
            break
        if dis[word] >= shortest: continue
        for key in genKeys(word):
            for nxt in conn[key]:
                if nxt not in dis:
                    dis[nxt] = dis[word] + 1
                    que.append(nxt)
                if dis[word] + 1 == dis[nxt]:
                    prev[nxt].append(word)

    def backtrace(path):
        if len(path) == shortest:
            res.append(path[::-1])
        for w in prev[path[-1]]:
            path.append(w)
            backtrace(path)
            path.pop()
    backtrace([endWord])
    return res",298
1279926886,divide,"def divide(dividend, divisor):
    """"""
    Implement the division algorithm using bitwise operators.

    ...

    Parameters
    ----------
    dividend : int
        The integer used to divide into.
    divisor  : int
        The integer used to divide with.

    Returns
    -------
    quotient : int
        The quotient without fractions.
    """"""
    MIN_INT = pow(-2, 31)
    MAX_INT = pow(2, 31) - 1

    # Determine if the result should be negative
    negative = (dividend > 0) != (divisor > 0)

    # Work with positive values
    dividend, divisor = abs(dividend), abs(divisor)

    # Handle edge cases
    if dividend < divisor:
        return 0
    elif dividend == divisor:
        return -1 if negative else 1

    # Handle Min/Max 32bit cases
    if divisor == 1:
        return -dividend if MIN_INT < -dividend else MIN_INT if negative else dividend if MAX_INT > dividend else MAX_INT

    # Divide using bitwise operations
    quotient = 0
    while dividend >= divisor:
        temp, i = divisor, 1
        while dividend >= (temp << 1):
            temp <<= 1
            i <<= 1
        dividend -= temp
        quotient += i

    return quotient if not negative else -quotient",297
4496304611,find_substring_indices,"import collections

def find_substring_indices(s, words):
    if not s or not words or not words[0]:
        return []

    word_len = len(words[0])
    str_len = len(s)
    num_words = len(words)
    word_set = set(words)
    starting_points = []
    window = None
    counter = None

    def _check_word_fill_window(start):
        word = s[start:start + word_len]
        if word in word_set:
            counter[word] -= 1
            window.append(word)
        else:
            window.append(None)

    def _check_solution(start):
        (_, count) = counter.most_common(1)[0]
        if count == 0:
            starting_points.append(start)

    def _remove_word():
        word = window.popleft()
        if word:
            counter[word] += 1

    for i in range(word_len):
        window = collections.deque()
        counter = collections.Counter(words)

        for j in range(i, i + num_words * word_len, word_len):
            _check_word_fill_window(j)

        _check_solution(i)

        for k in range(i + word_len, (str_len + 1) - (word_len * num_words), word_len):
            _remove_word()
            _check_word_fill_window(k + word_len * (num_words - 1))
            _check_solution(k)

    return starting_points",294
41383987418,closest_points,"import math

def distance(p1, p2):
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def closest_points(points):
    min_distance = float('inf')
    closest_pair = None
    for i in range(len(points)):
        for j in range(i+1, len(points)):
            dist = distance(points[i], points[j])
            if dist < min_distance:
                min_distance = dist
                closest_pair = (points[i], points[j])
    return min_distance

assert closest_points([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]) == 1.4142135623730951
assert closest_points([(0, 0), (10, 10), (0, 10), (10, 0), (5, 5)]) == 7.0710678118654755
assert closest_points([(0, 0), (10, 10), (20, 20), (30, 30), (40, 40)]) == 14.142135623730951",294
41777358596,count_distinct_islands,"from typing import List, Tuple

def normalize_path(path: List[Tuple[int, int]]) -> Tuple[Tuple[int, int], ...]:
    min_x, min_y = min(p[0] for p in path), min(p[1] for p in path)
    return tuple((p[0] - min_x, p[1] - min_y) for p in path)

def dfs(x: int, y: int, grid: List[List[int]], paths: List[List[Tuple[int, int]]]) -> None:
    if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1:
        grid[x][y] = 0
        paths[-1].append((x, y))
        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            dfs(x + dx, y + dy, grid, paths)

def count_distinct_islands(grid: List[List[int]]) -> int:
    paths = []
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                paths.append([])
                dfs(i, j, grid, paths)

    normalized_paths = [normalize_path(path) for path in paths]
    return len(set(normalized_paths))",292
71725234706,findMedianSortedArrays,"def findMedianSortedArrays(nums1, nums2):
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1

    x, y = len(nums1), len(nums2)
    low = 0
    high = x

    while low <= high:
        partitionX = (low + high) // 2
        partitionY = (x + y + 1) // 2 - partitionX

        maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]
        minRightX = float('inf') if partitionX == x else nums1[partitionX]

        maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]
        minRightY = float('inf') if partitionY == y else nums2[partitionY]

        if maxLeftX <= minRightY and maxLeftY <= minRightX:
            if (x + y) % 2 == 0:
                return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2
            else:
                return max(maxLeftX, maxLeftY)
        elif maxLeftX > minRightY:
            high = partitionX - 1
        else:
            low = partitionX + 1",291
12234333640,is_non_degenerate_square,"from typing import List

def is_non_degenerate_square(p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
    def distance2(point1, point2):
        x1, y1 = point1
        x2, y2 = point2
        return (x1 - x2) ** 2 + (y1 - y2) ** 2

    points = [p1, p2, p3, p4]
    dis2 = []
    for i in range(len(points) - 1):
        for j in range(i + 1, len(points)):
            dis2.append(distance2(points[i], points[j]))
    dis2.sort()
    a, b, c, d, ac, bd = dis2
    return a != 0 and a == b == c == d and ac == bd and a + a == ac

# Test cases
print(is_non_degenerate_square([0, 0], [1, 1], [1, 0], [0, 1]))
print(is_non_degenerate_square([0, 0], [1, 1], [1, 0], [0, 2]))
print(is_non_degenerate_square([1, -1], [1, 1], [-1, 1], [-1, -1]))",290
74310319891,median_sorted_arrays,"def median_sorted_arrays(A,B):
    m, n = len(A), len(B)
    if m > n:
        A, B, m, n = B, A, n, m
    i, j = 0, 0
    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and B[j-1] > A[i]:
            imin = i + 1
        elif i > 0 and A[i-1] > B[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = B[j-1]
            elif j == 0:
                max_of_left = A[i-1]
            else:
                max_of_left = max(A[i-1], B[j-1])
            if (m + n) % 2 == 1:
                return max_of_left
            if i == m:
                min_of_right = B[j]
            elif j == n:
                min_of_right = A[i]
            else:
                min_of_right = min(A[i], B[j])
            return (max_of_left + min_of_right) / 2",290
1186506884,inorder_traversal,"from typing import List

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def create_bst(nums: List[int]) -> TreeNode:
    if not nums:
        return None

    root = TreeNode(nums[0])
    for num in nums[1:]:
        insert_into_bst(root, num)
    return root

def insert_into_bst(node: TreeNode, val: int):
    if val < node.val:
        if node.left is None:
            node.left = TreeNode(val)
        else:
            insert_into_bst(node.left, val)
    else:
        if node.right is None:
            node.right = TreeNode(val)
        else:
            insert_into_bst(node.right, val)

def inorder_traversal(node: TreeNode) -> List[int]:
    result = []
    if node:
        result = inorder_traversal(node.left)
        result.append(node.val)
        result = result + inorder_traversal(node.right)
    return result

# Test case
nums = [10, 5, 15, 3, 7, 12, 18]
root = create_bst(nums)
assert inorder_traversal(root) == [3, 5, 7, 10, 12, 15, 18]",290
12916891433,countWays,"def countWays(n):
    if n < 0:
        return 0
    elif n == 0:
        return 1
    else:
        return countWays(n - 1) + countWays(n - 2) + countWays(n - 3)

def countWays_memo(n):
    array = [0] * (n + 1)

    def _countWays(n):
        if n < 0:
            return 0
        elif n == 0:
            return 1
        if not array[n]:
            array[n] = _countWays(n - 1) + _countWays(n - 2) + _countWays(n - 3)
        return array[n]

    res = _countWays(n)
    return res

def countWays_bottom_up_dp(n):
    array = [0] * (n + 1)
    array[0] = 1
    array[1] = 1
    array[2] = 2
    for i in range(3, n + 1):
        array[i] = array[i - 1] + array[i - 2] + array[i - 3]
    return array[n]

print(countWays(3))
print(countWays_memo(3))
print(countWays_bottom_up_dp(3))",290
1711803247,median_sorted_arrays,"def median_sorted_arrays(arr1, arr2):
    if len(arr1) > len(arr2):
        arr1, arr2 = arr2, arr1

    x, y = len(arr1), len(arr2)
    start, end = 0, x

    while start <= end:
        partition_x = (start + end) // 2
        partition_y = (x + y + 1) // 2 - partition_x

        max_left_x = float('-inf') if partition_x == 0 else arr1[partition_x - 1]
        min_right_x = float('inf') if partition_x == x else arr1[partition_x]

        max_left_y = float('-inf') if partition_y == 0 else arr2[partition_y - 1]
        min_right_y = float('inf') if partition_y == y else arr2[partition_y]

        if max_left_x <= min_right_y and max_left_y <= min_right_x:
            if (x + y) % 2 == 0:
                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2
            else:
                return max(max_left_x, max_left_y)
        elif max_left_x > min_right_y:
            end = partition_x - 1
        else:
            start = partition_x + 1",289
32143187129,median,"def median(nums1, nums2):
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1

    x, y = len(nums1), len(nums2)
    low = 0
    high = x

    while low <= high:
        partitionX = (low + high) // 2
        partitionY = (x + y + 1) // 2 - partitionX

        maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]
        minRightX = float('inf') if partitionX == x else nums1[partitionX]

        maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]
        minRightY = float('inf') if partitionY == y else nums2[partitionY]

        if maxLeftX <= minRightY and maxLeftY <= minRightX:
            if (x + y) % 2 == 0:
                return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2
            else:
                return max(maxLeftX, maxLeftY)
        elif maxLeftX > minRightY:
            high = partitionX - 1
        else:
            low = partitionX + 1",288
8637071735,get_minimum_window,"def get_minimum_window(original: str, check: str) -> str:
    window, need = {}, {}
    l, r, valid = 0, 0, 0
    start, length = 0, len(original) + 1
    res = len(original) + 2
    ans = None
    for c in check:
        need[c] = need.get(c, 0) + 1
    while r < len(original):
        rChar = original[r]
        if rChar in need:
            window[rChar] = window.get(rChar, 0) + 1
            if window[rChar] == need[rChar]:
                valid += 1
            while valid == len(need):
                if length > r - l + 1:
                    ans = original[l:r + 1]
                    length = r - l + 1
                elif length == r - l + 1 and ans > original[l:r + 1]:
                    ans = original[l:r + 1]
                    length = r - l + 1
                lChar = original[l]
                if lChar in need:
                    if window[lChar] == need[lChar]:
                        valid -= 1
                    window[lChar] -= 1
                l += 1
        r += 1
    return """" if not ans else ans",285
33322457443,schedule_tasks,"import heapq

def schedule_tasks(tasks):
    """"""
    Schedules tasks based on their duration and deadline to maximize the number of completed tasks.
    
    :param tasks: List of [duration, deadline] for each task
    :return: Maximum number of tasks that can be completed
    """"""
    tasks.sort(key=lambda x: x[1])  # Sort tasks by deadline
    total_time = 0  # Total time spent on tasks
    completed_tasks = []  # Priority queue for completed tasks

    for duration, deadline in tasks:
        if total_time + duration <= deadline:
            heapq.heappush(completed_tasks, -duration)
            total_time += duration
        elif completed_tasks and -completed_tasks[0] > duration:
            total_time += duration + heapq.heappop(completed_tasks)
            heapq.heappush(completed_tasks, -duration)

    return len(completed_tasks)

# Test cases
print(schedule_tasks([[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]))  # Expected output: 3
print(schedule_tasks([[1,2]]))  # Expected output: 1
print(schedule_tasks([[3,2],[4,3]]))  # Expected output: 0",285
23951534972,is_bst,"from typing import Optional

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_bst(root: Optional[TreeNode]) -> bool:
    def helper(node, lower = float('-inf'), upper = float('inf')):
        if not node:
            return True

        if node.val <= lower or node.val >= upper:
            return False

        if not helper(node.right, node.val, upper):
            return False
        if not helper(node.left, lower, node.val):
            return False
        return True

    return helper(root)

# Test cases
tree1 = TreeNode(2)
tree1.left = TreeNode(1)
tree1.right = TreeNode(3)

tree2 = TreeNode(2)
tree2.left = TreeNode(3)
tree2.right = TreeNode(1)

tree3 = TreeNode(4)
tree3.left = TreeNode(2)
tree3.left.left = TreeNode(1)
tree3.left.right = TreeNode(3)
tree3.right = TreeNode(6)
tree3.right.left = TreeNode(5)
tree3.right.right = TreeNode(7)

assert is_bst(tree1) == True
assert is_bst(tree2) == False
assert is_bst(tree3) == True",285
35791569878,find_target_index,"def find_target_index(nums, target):
    pivot = find_pivot(nums)
    if nums[pivot] == target:
        return pivot
    if pivot == 0:
        return binary_search(nums, target, 0, len(nums) - 1)
    if target >= nums[0]:
        return binary_search(nums, target, 0, pivot - 1)
    return binary_search(nums, target, pivot, len(nums) - 1)

def find_pivot(arr):
    start = 0
    end = len(arr) - 1
    while start <= end:
        mid = start + (end - start) // 2
        if mid < end and arr[mid] > arr[mid + 1]:
            return mid
        if mid > start and arr[mid] < arr[mid - 1]:
            return mid - 1
        if arr[start] >= arr[mid]:
            end = mid - 1
        else:
            start = mid + 1
    return 0

def binary_search(arr, target, start, end):
    while start <= end:
        mid = start + (end - start) // 2
        if target == arr[mid]:
            return mid
        if target < arr[mid]:
            end = mid - 1
        else:
            start = mid + 1
    return -1",285
29866734992,is_bst,"class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def is_bst(node, min_val=float('-inf'), max_val=float('inf')):
    if node is None:
        return True
    if node.value < min_val or node.value > max_val:
        return False
    return is_bst(node.left, min_val, node.value) and is_bst(node.right, node.value, max_val)

# Test cases
tree1 = TreeNode(4)
tree1.left = TreeNode(2)
tree1.right = TreeNode(6)
tree1.left.left = TreeNode(1)
tree1.left.right = TreeNode(3)
tree1.right.left = TreeNode(5)
tree1.right.right = TreeNode(7)

tree2 = TreeNode(4)
tree2.left = TreeNode(2)
tree2.right = TreeNode(6)
tree2.left.left = TreeNode(1)
tree2.left.right = TreeNode(5)
tree2.right.left = TreeNode(3)
tree2.right.right = TreeNode(7)

tree3 = TreeNode(6)
tree3.left = TreeNode(4)
tree3.right = TreeNode(8)
tree3.left.left = TreeNode(2)
tree3.left.right = TreeNode(5)
tree3.right.left = TreeNode(7)
tree3.right.right = TreeNode(9)",284
73605337938,median,"def median(A, B):
    m, n = len(A), len(B)
    if m > n:
        A, B, m, n = B, A, n, m
    i, j = 0, m
    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while i <= j:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and B[j-1] > A[i]:
            imin = i + 1
        elif i > 0 and A[i-1] > B[j]:
            imax = i - 1
        else:
            if i == 0: max_of_left = B[j-1]
            elif j == 0: max_of_left = A[i-1]
            else: max_of_left = max(A[i-1], B[j-1])
            if (m + n) % 2 == 1:
                return max_of_left
            if i == m: min_of_right = B[j]
            elif j == n: min_of_right = A[i]
            else: min_of_right = min(A[i], B[j])
            return (max_of_left + min_of_right) / 2.0",282
42384341083,find_lcs,"def find_lcs(X , Y): 
    m = len(X) 
    n = len(Y) 
  
    L = [[None]*(n+1) for i in range(m+1)] 
  
    for i in range(m+1): 
        for j in range(n+1): 
            if i == 0 or j == 0 : 
                L[i][j] = 0
            elif X[i-1] == Y[j-1]: 
                L[i][j] = L[i-1][j-1]+1
            else: 
                L[i][j] = max(L[i-1][j] , L[i][j-1]) 

    index = L[m][n] 
    lcs = [""""] * (index+1) 
    lcs[index] = """" 

    i = m 
    j = n 
    while i > 0 and j > 0: 

        if X[i-1] == Y[j-1]: 
            lcs[index-1] = X[i-1] 
            i-=1
            j-=1
            index-=1

        elif L[i-1][j] > L[i][j-1]: 
            i-=1
        else: 
            j-=1

    return """".join(lcs)",280
20047987492,shortestPathBinaryMatrix,"from collections import deque

def shortestPathBinaryMatrix(grid):
    moves = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    n = len(grid)
    
    if grid[0][0] != 0 or grid[n-1][n-1] != 0: return -1 # no such path
    grid[0][0] = 1
    frontier = deque([(0, 0)]) # start from top-left
    count = 1 # at least 1 length
    if n == 1: return count # edge case
    while frontier:
        for _ in range(len(frontier)):
            x, y = frontier.popleft()
            for ix, iy in moves:
                i = x + ix
                j = y + iy
                if 0 <= j < n and 0 <= i < n and grid[i][j] == 0:
                    if i == j == n - 1: return count + 1 # reach the destination
                    grid[i][j] = 1 # visited
                    frontier.append((i, j))
        count += 1 # switch to next layer
    return -1",280
786682188,generate_random,"import random

def generate_random(n, blacklist):
    if len(blacklist) < n / 5:
        while True:
            x = random.randint(0, n - 1)
            if x not in blacklist:
                return x
    if not blacklist:
        return random.randint(0, n - 1)
    sorted_bl = sorted(blacklist)
    possibilities = []
    weights = []
    if sorted_bl[0] != 0:
        possibilities.append([0, sorted_bl[0] - 1])
        weights.append(sorted_bl[0] - 1 + 1)
    if sorted_bl[-1] != n - 1:
        possibilities.append([sorted_bl[-1] + 1, n - 1])
        weights.append(n - (sorted_bl[-1] + 1))
    for i in range(len(sorted_bl) - 1):
        if sorted_bl[i] + 1 != sorted_bl[i + 1]:
            possibilities.append([sorted_bl[i] + 1, sorted_bl[i + 1] - 1])
            weights.append(sorted_bl[i + 1] - 1 - (sorted_bl[i] + 1) + 1)
    range1 = random.choices(possibilities, weights)[0]
    return random.randint(range1[0], range1[1])",280
31096734144,sum_of_node_tilts,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def sum_of_node_tilts(root):
    """"""
    Calculate the sum of every tree node's tilt in a binary tree.
    The tilt of a tree node is the absolute difference between the sum of all left subtree node values
    and all right subtree node values.
    """"""
    tilt_sum = 0

    def postorder(node):
        nonlocal tilt_sum
        if node is None:
            return 0

        left_sum = postorder(node.left)
        right_sum = postorder(node.right)
        tilt_sum += abs(left_sum - right_sum)

        return node.val + left_sum + right_sum

    postorder(root)
    return tilt_sum


# Test cases
root1 = TreeNode(1)
root1.left = TreeNode(2)
root1.right = TreeNode(3)
assert sum_of_node_tilts(root1) == 1

root2 = TreeNode(4)
root2.left = TreeNode(2)
root2.right = TreeNode(9)
root2.left.left = TreeNode(3)
root2.left.right = TreeNode(5)
root2.right.right = TreeNode(7)
assert sum_of_node_tilts(root2) == 15",280
39817312703,find_lcs,"def find_lcs(str1, str2):
    m = len(str1)
    n = len(str2)
    dp = [[0 for x in range(n+1)] for x in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                dp[i][j] = 0
            elif str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    index = dp[m][n]
    lcs = [''] * (index+1)
    lcs[index] = ''
    i = m
    j = n
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            lcs[index-1] = str1[i-1]
            i -= 1
            j -= 1
            index -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1
    return ''.join(lcs)",280
73477953801,median,"def median(A, B):
    m, n = len(A), len(B)
    if m > n:
        A, B, m, n = B, A, n, m
    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and B[j-1] > A[i]:
            imin = i + 1
        elif i > 0 and A[i-1] > B[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = B[j-1]
            elif j == 0:
                max_of_left = A[i-1]
            else:
                max_of_left = max(A[i-1], B[j-1])
            if (m + n) % 2 == 1:
                return max_of_left
            if i == m:
                min_of_right = B[j]
            elif j == n:
                min_of_right = A[i]
            else:
                min_of_right = min(A[i], B[j])
            return (max_of_left + min_of_right) / 2.0",280
70313100670,find_longest_common_subsequence,"def find_longest_common_subsequence(lst):
    def lcs(a, b):
        lengths = [[0 for j in range(len(b)+1)] for i in range(len(a)+1)]
        for i, x in enumerate(a):
            for j, y in enumerate(b):
                if x == y:
                    lengths[i+1][j+1] = lengths[i][j] + 1
                else:
                    lengths[i+1][j+1] = max(lengths[i+1][j], lengths[i][j+1])
        result = """"
        x, y = len(a), len(b)
        while x != 0 and y != 0:
            if lengths[x][y] == lengths[x-1][y]:
                x -= 1
            elif lengths[x][y] == lengths[x][y-1]:
                y -= 1
            else:
                assert a[x-1] == b[y-1]
                result = a[x-1] + result
                x -= 1
                y -= 1
        return result
    
    if not lst:
        return """"
    common_subsequence = lst[0]
    for s in lst[1:]:
        common_subsequence = lcs(common_subsequence, s)
        if common_subsequence == """":
            break
    return common_subsequence",279
20704096917,is_wildcard_match,"def is_wildcard_match(s, p):
    M = {}

    if len(s) and not len(p):
        return False

    if not len(s):
        return not any([c for c in p if c != '*'])

    if p[0] == '*' or p[0] == '?' or p[0] == s[0]:
        M[(0, -1)] = 0
    else:
        return False

    for y in range(0, len(p)):
        for x in range(0, len(s)):
            if p[y] == '?' or p[y] == s[x]:
                if M.get((x, y - 1), -1) == 0 or M.get((x - 1, y - 1), -1) == 1:
                    M[(x, y)] = 1

            if p[y] == '*':
                if M.get((x, y - 1), -1) >= 0:
                    M[(x, y)] = M[(x, y - 1)]

                if M.get((x - 1, y), -1) >= 0:
                    M[(x, y)] = 0

    return M.get((len(s) - 1, len(p) - 1), -1) >= 0",279
41029156278,lcs,"def lcs(str1, str2):
    m = len(str1)
    n = len(str2)
    dp = [[0] * (n+1) for _ in range(m+1)]
    
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                dp[i][j] = 0
            elif str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    index = dp[m][n]
    lcs = [''] * (index+1)
    lcs[index] = ''

    i = m
    j = n
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            lcs[index-1] = str1[i-1]
            i -= 1
            j -= 1
            index -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1

    return ''.join(lcs)",279
14442412442,sum_left_leaves,"class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def array_to_tree(self, arr):
        if not arr:
            return None
        root = TreeNode(arr[0])
        queue = [root]
        i = 1
        while queue and i < len(arr):
            node = queue.pop(0)
            if arr[i] is not None:
                node.left = TreeNode(arr[i])
                queue.append(node.left)
            i += 1
            if i < len(arr) and arr[i] is not None:
                node.right = TreeNode(arr[i])
                queue.append(node.right)
            i += 1
        return root

    def sumOfLeftLeaves(self, root):
        stack = []
        stack.append(root)
        leftsum = 0
        while stack:
            node = stack.pop()
            if not node: continue
            if node.left:
                if not node.left.left and not node.left.right:
                    leftsum += node.left.val
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        return leftsum

def sum_left_leaves(arr):
    sol = Solution()
    root = sol.array_to_tree(arr)
    return sol.sumOfLeftLeaves(root)",278
7433988406,lowest_common_ancestor,"from collections import deque

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def lowestCommonAncestor(self, root, p, q):
        if root.val > p.val and root.val > q.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif root.val < p.val and root.val < q.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root

    def coverttoTree(self, ls):
        temp = TreeNode(ls.popleft())
        res = deque()
        res.append(temp)
        while ls:
            left = ls.popleft()
            right = ls.popleft()
            node = res.popleft()
            if left != None:
                node.left = TreeNode(left)
                res.append(node.left)
            if right != None:
                node.right = TreeNode(right)
                res.append(node.right)
        return temp

solution = Solution()
def lowest_common_ancestor(test_list, p, q):
    root = solution.coverttoTree(deque(test_list))
    res = solution.lowestCommonAncestor(root, TreeNode(p), TreeNode(q)).val
    return res",278
23777179243,move_evens_to_front,"def move_evens_to_front(nums):
    """"""
    This function takes a list of integers and returns a new list where all the even numbers
    are moved to the front, preserving their relative order, and all the odd numbers are moved
    to the back, also preserving their relative order.

    :param nums: List of integers.
    :return: A list of integers with even numbers at the front and odd numbers at the back.
    """"""
    evens = [x for x in nums if x % 2 == 0]
    odds = [x for x in nums if x % 2 != 0]
    return evens + odds

if __name__ == '__main__':
    print(move_evens_to_front([1, 2, 3, 4, 5, 6]))  # [2, 4, 6, 1, 3, 5]
    print(move_evens_to_front([10, 15, 20, 25, 30]))  # [10, 20, 30, 15, 25]
    print(move_evens_to_front([1, 3, 5, 7, 9]))  # [1, 3, 5, 7, 9]",277
70093781229,minCostConnectPoints,"import heapq

def minCostConnectPoints(points):
    def manhattan_distance(p1, p2):
        return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])
    
    N = len(points)
    edges = []
    for i in range(N):
        for j in range(i+1, N):
            edges.append((manhattan_distance(points[i], points[j]), i, j))
    edges.sort()

    parent = list(range(N))
    rank = [0]*N

    def find_parent(x):
        if parent[x] != x:
            parent[x] = find_parent(parent[x])
        return parent[x]

    def union(x, y):
        rootX = find_parent(x)
        rootY = find_parent(y)
        if rootX != rootY:
            if rank[rootX] > rank[rootY]:
                parent[rootY] = rootX
            elif rank[rootX] < rank[rootY]:
                parent[rootX] = rootY
            else:
                parent[rootY] = rootX
                rank[rootX] += 1

    min_cost = 0
    for cost, x, y in edges:
        if find_parent(x) != find_parent(y):
            union(x, y)
            min_cost += cost

    return min_cost",276
12480479184,lcs,"def lcs(str1, str2):
    m = len(str1)
    n = len(str2)
    L = [[None]*(n+1) for i in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif str1[i-1] == str2[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])
    index = L[m][n]
    lcs = [""""] * (index+1)
    lcs[index] = """"
    i = m
    j = n
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            lcs[index-1] = str1[i-1]
            i -= 1
            j -= 1
            index -= 1
        elif L[i-1][j] > L[i][j-1]:
            i -= 1
        else:
            j -= 1
    return """".join(lcs)",276
20046719371,median,"def median(A, B):
    m, n = len(A), len(B)
    if m > n:
        A, B, m, n = B, A, n, m
    i_min, i_max, half_len = 0, m, (m + n + 1) // 2
    while i_min <= i_max:
        i = (i_min + i_max) // 2
        j = half_len - i
        if i < m and B[j-1] > A[i]:
            i_min = i + 1
        elif i > 0 and A[i-1] > B[j]:
            i_max = i - 1
        else:
            if i == 0: max_of_left = B[j-1]
            elif j == 0: max_of_left = A[i-1]
            else: max_of_left = max(A[i-1], B[j-1])

            if (m + n) % 2 == 1:
                return max_of_left

            if i == m: min_of_right = B[j]
            elif j == n: min_of_right = A[i]
            else: min_of_right = min(A[i], B[j])

            return (max_of_left + min_of_right) / 2.0",275
19805916387,longest_increasing_subsequence,"def ci(A, l, r, k):
    while r-l > 1:
        mid = (l + r) // 2
        if A[mid] >= k:
            r = mid
        else:
            l = mid
    return r

def longest_increasing_subsequence(a):
    n = len(a)
    t = [0 for _ in range(n + 1)]
    t[0] = a[0]
    l = 1
    for i in range(1, n):
        if a[i] < t[0]:
            t[0] = a[i]
        elif a[i] > t[l - 1]:
            t[l] = a[i]
            l += 1
        else:
            x = ci(t, -1, l - 1, a[i])
            t[x] = a[i]
    return l

print(longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]))
print(longest_increasing_subsequence([0, 1, 0, 3, 2, 3]))
print(longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]))",274
22488401597,count_distinct_islands,"def dfs(grid, i, j, seen, shape):
    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1 and (i, j) not in seen:
        seen.add((i, j))
        shape.append((i, j))
        dfs(grid, i-1, j, seen, shape)
        dfs(grid, i+1, j, seen, shape)
        dfs(grid, i, j-1, seen, shape)
        dfs(grid, i, j+1, seen, shape)

def normalize_shape(shape):
    min_x, min_y = min(x for x, _ in shape), min(y for _, y in shape)
    normalized = []
    for x, y in shape:
        normalized.append((x-min_x, y-min_y))
    return normalized

def count_distinct_islands(grid):
    seen = set()
    shapes = set()
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1 and (i, j) not in seen:
                shape = []
                dfs(grid, i, j, seen, shape)
                normalized = normalize_shape(shape)
                shapes.add(tuple(normalized))
    return len(shapes)",273
29663763251,find_Kth_smallest,"import heapq

def find_Kth_smallest(nums, k):
    return sorted(nums)[k-1]

def find_Kth_smallest_heap(nums, k):
    heapq.heapify(nums)
    for _ in range(k-1):
        heapq.heappop(nums)
    return heapq.heappop(nums)

assert find_Kth_smallest([7, 10, 4, 3, 20, 15], 3) == 7
assert find_Kth_smallest([7, 10, 4, 3, 20, 15], 4) == 10
assert find_Kth_smallest([7, 10, 4, 3, 20, 15], 6) == 20

assert find_Kth_smallest_heap([7, 10, 4, 3, 20, 15], 3) == 7
assert find_Kth_smallest_heap([7, 10, 4, 3, 20, 15], 4) == 10
assert find_Kth_smallest_heap([7, 10, 4, 3, 20, 15], 6) == 20",273
73903724788,next_smaller,"def next_smaller(n):
    # Convert the number to a list of digits
    digits = list(str(n))
    length = len(digits)

    # Start from the rightmost non-zero digit
    for i in range(length - 2, -1, -1):
        if digits[i] > digits[i + 1]:
            break
    else:
        # If no such digit is found, return -1
        return -1

    # Find the largest digit to the right of digits[i] that is smaller than digits[i]
    for j in range(length - 1, i, -1):
        if digits[j] < digits[i]:
            # Swap digits[i] and digits[j]
            digits[i], digits[j] = digits[j], digits[i]
            break
    else:
        # If no such digit is found, return -1
        return -1

    # Sort the digits to the right of the swapped position in descending order
    digits[i + 1:] = sorted(digits[i + 1:], reverse=True)

    # Convert the list of digits back to a number
    result = int(''.join(digits))

    # If the result has a leading zero, return -1
    return result if result >= 10 ** (length - 1) else -1",273
32084480095,is_valid_shuffle,"def is_valid_shuffle(string1, string2, shuffle):
    if len(string1) + len(string2) != len(shuffle):
        return False
    if string1 == """" and string2 == """":
        return shuffle == """"
    
    dp = [[False for _ in range(len(string2) + 1)] for _ in range(len(string1) + 1)]
    dp[0][0] = True
    for i in range(1, len(string1) + 1):
        dp[i][0] = dp[i-1][0] and string1[i-1] == shuffle[i-1]
    for j in range(1, len(string2) + 1):
        dp[0][j] = dp[0][j-1] and string2[j-1] == shuffle[j-1]
    
    for i in range(1, len(string1) + 1):
        for j in range(1, len(string2) + 1):
            dp[i][j] = (dp[i-1][j] and string1[i-1] == shuffle[i+j-1]) or (dp[i][j-1] and string2[j-1] == shuffle[i+j-1])
    
    return dp[len(string1)][len(string2)]",273
22961844672,longest_palindromic_subsequence,"def longest_palindromic_subsequence(s: str) -> int:
    # Size of the string
    n = len(s)
    # Initialize a memoization matrix to store the length of the longest palindromic subsequence (LPS)
    memo = [[0 for _ in range(n)] for _ in range(n)]

    # Loop over the string in reverse to fill the matrix
    for i in range(n - 1, -1, -1):
        # The longest palindromic subsequence of a single character is the character itself
        memo[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                # If the characters at positions i and j are the same,
                # the LPS is the current characters plus the LPS of the characters in between
                memo[i][j] = 2 + memo[i + 1][j - 1]
            else:
                # If the characters at positions i and j are not the same,
                # the LPS is the maximum of the LPS excluding either character
                memo[i][j] = max(memo[i + 1][j], memo[i][j - 1])

    return memo[0][n - 1]",272
41343561066,longest_zigzag_subsequence,"def longest_zigzag_subsequence(nums):
    if len(nums) < 2:
        return len(nums)
    
    up = [1] * len(nums)
    down = [1] * len(nums)
    
    for i in range(1, len(nums)):
        if nums[i] > nums[i-1]:
            up[i] = down[i-1] + 1
            down[i] = down[i-1]
        elif nums[i] < nums[i-1]:
            down[i] = up[i-1] + 1
            up[i] = up[i-1]
        else:
            up[i] = up[i-1]
            down[i] = down[i-1]
    
    return max(max(up), max(down))

assert longest_zigzag_subsequence([1, 7, 4, 9, 2, 5]) == 6
assert longest_zigzag_subsequence([1, 17, 5, 10, 13, 15, 10, 5, 16, 8]) == 7
assert longest_zigzag_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 2",272
37809091374,has_cycle,"from collections import defaultdict

def has_cycle(graph):
    """"""
    Detects if a directed graph contains a cycle.
    :param graph: List of lists where graph[i] contains all nodes that node i has edges to.
    :return: True if the graph contains a cycle, False otherwise.
    """"""
    edges = defaultdict(list)
    for node, neighbors in enumerate(graph):
        edges[node] = neighbors
    
    valid = True
    flag_nodes = [0] * len(graph)

    def dfs(v):
        nonlocal valid
        if valid:
            if flag_nodes[v] == 0:
                flag_nodes[v] = 1
                for u in edges[v]:
                    dfs(u)
            elif flag_nodes[v] == 1:
                valid = False
                return
            else:
                return
            flag_nodes[v] = 2
        else:
            return

    for i in range(len(graph)):
        if flag_nodes[i] == 0:
            dfs(i)
    return not valid

# Test cases
assert has_cycle([[1], [2], [3], [0]]) == True
assert has_cycle([[1], [2], [], [0]]) == False
assert has_cycle([[1], [2], [], [4,5], [3], [4]]) == True",271
86451559410,longest_common_subseq,"def longest_common_subseq(X, Y):
    m = len(X)
    n = len(Y)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    index = dp[m][n]
    lcs = [""""] * (index + 1)
    lcs[index] = """"
    i, j = m, n
    while i > 0 and j > 0:
        if X[i - 1] == Y[j - 1]:
            lcs[index - 1] = X[i - 1]
            i -= 1
            j -= 1
            index -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1
    return """".join(lcs)",271
36222822006,maximum_xor,"class TrieNode:
    def __init__(self):
        self.children = {}
        self.max_xor = 0

def build_trie(nums):
    root = TrieNode()
    for num in nums:
        node = root
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            if bit not in node.children:
                node.children[bit] = TrieNode()
            node = node.children[bit]
        node.max_xor = num
    return root

def query_trie(root, num):
    node = root
    xor_sum = 0
    for i in range(31, -1, -1):
        bit = (num >> i) & 1
        xor_bit = 1 - bit
        if xor_bit in node.children:
            node = node.children[xor_bit]
        else:
            node = node.children[bit]
        xor_sum = xor_sum * 2 + (1 - bit) * bit
    return xor_sum + (node.max_xor ^ num)

def maximum_xor(nums):
    root = build_trie(nums)
    max_xor = 0
    for num in nums:
        max_xor = max(max_xor, query_trie(root, num))
    return max_xor",270
36159331257,find_fibonacci,"def multiply(F, M):
    x = F[0][0]*M[0][0] + F[0][1]*M[1][0]
    y = F[0][0]*M[0][1] + F[0][1]*M[1][1]
    z = F[1][0]*M[0][0] + F[1][1]*M[1][0]
    w = F[1][0]*M[0][1] + F[1][1]*M[1][1]

    F[0][0] = x
    F[0][1] = y
    F[1][0] = z
    F[1][1] = w

def power(F, n):
    M = [[1, 1],
         [1, 0]]

    # n - 1 times multiply the matrix to {{1,0},{0,1}}
    for _ in range(2, n+1):
        multiply(F, M)

def find_fibonacci(n):
    F = [[1, 1],
         [1, 0]]
    if n == 0:
        return 0
    power(F, n - 1)
    return F[0][0]",270
3800904894,match_pattern,"def match_pattern(s, p):
    len_s = len(s)
    len_p = len(p)
    dp = [[False for _ in range(len_s + 1)] for _ in range(len_p + 1)]
    dp[0][0] = True
    for i in range(1, len_p + 1):
        if p[i - 1] == '*' or p[i - 1] == '.':
            dp[i][0] = dp[i - 2][0] if p[i - 1] == '*' else dp[i - 1][0]
        else:
            break
    for i in range(1, len_p + 1):
        for j in range(1, len_s + 1):
            if p[i - 1] == s[j - 1] or p[i - 1] == '.':
                dp[i][j] = dp[i - 1][j - 1]
            elif p[i - 1] == '*':
                dp[i][j] = dp[i - 2][j] or (dp[i][j - 1] if p[i - 2] == s[j - 1] or p[i - 2] == '.' else False)
    return dp[-1][-1]",270
74021880278,closest_pair,"import math
from itertools import combinations

def euclidean_distance(p1, p2):
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def closest_pair(points):
    min_distance = float('inf')
    closest_pair = None
    for p1, p2 in combinations(points, 2):
        distance = euclidean_distance(p1, p2)
        if distance < min_distance:
            min_distance = distance
            closest_pair = (p1, p2)
    return min_distance

print(closest_pair([(0, 0), (4, 0), (4, 3), (8, 4)]))  # Expected output: 3.0
print(closest_pair([(0, 0), (1, 1), (2, 2), (3, 3)]))  # Expected output: 1.4142135623730951
print(closest_pair([(1, 1), (2, 2), (3, 3), (4, 4)]))  # Expected output: 1.4142135623730951",270
42496731135,check_anagram,"def check_anagram(str1, str2):
    # First, remove any spaces from the strings and convert them to lower case
    str1 = str1.replace("" "", """").lower()
    str2 = str2.replace("" "", """").lower()
    
    # Check if the length of the strings is different, if yes, they can't be anagrams
    if len(str1) != len(str2):
        return False
    
    # Create a dictionary to store the frequency of each character in the first string
    char_count = {}
    
    # Iterate over the first string and update the character count in the dictionary
    for char in str1:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    
    # Iterate over the second string and decrement the character count in the dictionary
    # If at any point a character is not present in the dictionary or the count becomes negative, return False
    for char in str2:
        if char in char_count:
            char_count[char] -= 1
        else:
            return False
    
    # If all character counts are zero, the strings are anagrams
    for count in char_count.values():
        if count != 0:
            return False
    
    return True",269
38218047489,matrix_fibonacci,"def multiply(F, M): 
    x = F[0][0] * M[0][0] + F[0][1] * M[1][0] 
    y = F[0][0] * M[0][1] + F[0][1] * M[1][1] 
    z = F[1][0] * M[0][0] + F[1][1] * M[1][0] 
    w = F[1][0] * M[0][1] + F[1][1] * M[1][1] 
  
    F[0][0] = x 
    F[0][1] = y 
    F[1][0] = z 
    F[1][1] = w 
  
def power(F, n): 
    M = [[1, 1], [1, 0]] 
  
    for _ in range(2, n+1): 
        multiply(F, M) 
  
def matrix_fibonacci(n): 
    F = [[1, 1], [1, 0]] 
    if n == 0: 
        return 0
    power(F, n - 1) 
    return F[0][0]",269
27215992458,min_swaps_couples,"class UF:
    def __init__(self, count):
        self.count = count
        self.parent = [i for i in range(count)]

    def find(self, x):
        while self.parent[x] != x:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP == rootQ:
            return
        self.parent[rootQ] = rootP
        self.count -= 1


def min_swaps_couples(row):
    n = len(row)
    uf = UF(n)

    for i in range(0, n, 2):
        uf.parent[i + 1] = i
        uf.count -= 1

    for i in range(0, n, 2):
        if (row[i] % 2 == 0 and row[i + 1] == row[i] + 1) or (row[i + 1] % 2 == 0 and row[i] == row[i + 1] + 1):
            pass
        else:
            uf.union(row[i], row[i + 1])

    return n // 2 - uf.count",269
16556101062,remove_duplicate_letters,"from collections import deque

def remove_duplicate_letters(s):
    chars = deque(sorted(set(s)))
    duplicated_word = ''

    while chars: 
        if set(s) == set(s[s.index(chars[0]):]):
            s = s[s.index(chars[0]):].replace(chars[0],'')
            duplicated_word += chars[0]
            chars.popleft()
            chars = deque(sorted(set(s)))
            continue
        chars.popleft()
        
    new_word = """"
    for i in range(len(s)-1, -1, -1):
        if s[i] not in new_word:  
            new_word = s[i] + new_word 
        else:
            n = list(new_word)
            n.remove(s[i])
            n = """".join(n)
            n = s[i] + n
            new_word = min(new_word, n)
            
    new_word2 = """"
    for i in range(0, len(s)):
        if s[i] not in new_word2:
            new_word2 += s[i]
        else:
            n = list(new_word2)
            n.remove(s[i])
            n = """".join(n)
            n += s[i]
            new_word2 = min(new_word2, n)
            
    return duplicated_word + min(new_word, new_word2)",269
7833996520,fibonacci_matrix,"def multiply(F, M): 
    
    x = F[0][0] * M[0][0] + F[0][1] * M[1][0] 
    y = F[0][0] * M[0][1] + F[0][1] * M[1][1] 
    z = F[1][0] * M[0][0] + F[1][1] * M[1][0] 
    w = F[1][0] * M[0][1] + F[1][1] * M[1][1] 
  
    F[0][0] = x 
    F[0][1] = y 
    F[1][0] = z 
    F[1][1] = w 
  
def power(F, n): 
  
    M = [[1, 1], [1, 0]] 
  
    for _ in range(2, n+1): 
        multiply(F, M) 
  
def fibonacci_matrix(n): 
  
    F = [[1, 1], [1, 0]] 
    if (n == 0): 
        return 0
    power(F, n - 1) 
  
    return F[0][0]",268
2880917277,fibonacci_matrix,"def multiply(F, M): 
  x = F[0][0] * M[0][0] + F[0][1] * M[1][0] 
  y = F[0][0] * M[0][1] + F[0][1] * M[1][1] 
  z = F[1][0] * M[0][0] + F[1][1] * M[1][0] 
  w = F[1][0] * M[0][1] + F[1][1] * M[1][1] 
  F[0][0] = x 
  F[0][1] = y 
  F[1][0] = z 
  F[1][1] = w 
  
def power(F, n): 
  M = [[1, 1], [1, 0]] 
  for _ in range(2, n+1): 
    multiply(F, M) 
    
def fibonacci_matrix(n): 
  F = [[1, 1], [1, 0]] 
  if n == 0: 
    return 0
  power(F, n - 1) 
  return F[0][0]",267
26006106912,is_BST,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_BST(root):
    def validate(node, low=-float('inf'), high=float('inf')):
        if not node:
            return True
        if not (low < node.val < high):
            return False
        return (validate(node.left, low, node.val) and
                validate(node.right, node.val, high))

    return validate(root)

# Check function with provided data points
def check_BST():
    root1 = TreeNode(2, TreeNode(1), TreeNode(3))
    assert is_BST(root1) == True, ""Test case 1 failed""

    root2 = TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))
    assert is_BST(root2) == False, ""Test case 2 failed""

    root3 = TreeNode(10, TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(7)), TreeNode(15))
    assert is_BST(root3) == True, ""Test case 3 failed""

    print(""All test cases passed!"")

check_BST()",266
10784937155,numOfArrays,"def numOfArrays(n, m, k):
    MOD = 10**9 + 7
    dp = [[[0]*(k+1) for _ in range(m+1)] for _ in range(2)]
    prefix_dp = [[[0]*(k+1) for _ in range(m+1)] for _ in range(2)]
    for i in range(1, m+1):
        dp[1][i][1] = 1
        prefix_dp[1][i][1] = (prefix_dp[1][i-1][1] + dp[1][i][1])%MOD
    for l in range(2, n+1):
        for i in range(1, m+1):
            for j in range(1, k+1):
                dp[l%2][i][j] = (i*dp[(l-1)%2][i][j]%MOD + prefix_dp[(l-1)%2][i-1][j-1])%MOD
                prefix_dp[l%2][i][j] = (prefix_dp[l%2][i-1][j] + dp[l%2][i][j])%MOD
    return prefix_dp[n%2][m][k]",266
73295373829,LCS,"def LCS(X, Y):
    m = len(X)
    n = len(Y)
    L = [[None]*(n+1) for i in range(m+1)]
 
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif X[i-1] == Y[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])
 
    index = L[m][n]
 
    lcs = [""""] * (index+1)
    lcs[index] = """"
 
    i = m
    j = n
    while i > 0 and j > 0:
        if X[i-1] == Y[j-1]:
            lcs[index-1] = X[i-1]
            i-=1
            j-=1
            index-=1
        elif L[i-1][j] > L[i][j-1]:
            i-=1
        else:
            j-=1
 
    return """".join(lcs)",265
8250431840,find_LCS,"def find_LCS(s1, s2):
    m = len(s1)
    n = len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 or j == 0:
                dp[i][j] = 0
            elif s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    i = m
    j = n
    lcs = []
    while i > 0 and j > 0:
        if s1[i - 1] == s2[j - 1]:
            lcs.append(s1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1
    return ''.join(lcs[::-1])",264
19365498054,findSubstring,"from collections import Counter

def findSubstring(s, words):
    if not words:
        return []
    counter = Counter(words)
    unit = len(words[0])
    ans = []
    window = unit * len(words)

    for margin in range(unit):
        sub_counter = Counter()
        score = 0
        for cur in range(margin, margin+window, unit):
            word = s[cur:cur+unit]
            if word in counter:
                sub_counter[word] += 1
                if sub_counter[word] <= counter[word]:
                    score += 1

        if score == len(words):
            ans.append(margin)

        for start in range(margin, len(s), unit):
            removed_word = s[start:start+unit]
            if removed_word in counter:
                sub_counter[removed_word] -= 1
                if sub_counter[removed_word] < counter[removed_word]:
                    score -= 1

            added_word = s[start+window: start+window+unit]
            if added_word in counter:
                sub_counter[added_word] += 1
                if sub_counter[added_word] <= counter[added_word]:
                    score += 1
            if score == len(words):
                ans.append(start+unit)
    return ans",264
23725502919,shortest_transformation_sequence,"import collections
def shortest_transformation_sequence(beginWord, endWord, wordList):
    if endWord not in wordList:
        return 0
    if not beginWord or not endWord:
        return 0

    wordList = set(wordList)
    wordList.add(beginWord)

    visited = set()
    queue = collections.deque([beginWord])
    visited.add(beginWord)

    distance = 0
    while queue:
        distance += 1
        for i in range(len(queue)):
            cur_word = queue.popleft()
            if cur_word == endWord:
                return distance
            # get next word
            next_words = get_next_words(cur_word, wordList)
            for next_word in next_words:
                if next_word not in visited:
                    queue.append(next_word)
                    visited.add(next_word)
    return 0

def get_next_words(cur_word, wordList):
    next_words = []
    for i in range(len(cur_word)):
        left = cur_word[:i]
        right = cur_word[i + 1:]
        for c in ""abcdefghijklmnopqrstuvwxyz"":
            if c != cur_word[i]:
                new_word = left + c + right
                if new_word in wordList:
                    next_words.append(new_word)
    return next_words",264
17253370067,max_full_groups,"def max_full_groups(n, reservedSeats):
    reservedSeats.sort(key=lambda x: x[0])
    reservedSeats.append([0, 0])
    M = len(reservedSeats)
    free = [True] * 11
    free[reservedSeats[0][1]] = False
    i = 1
    count = 0
    while i < M:
        if reservedSeats[i][0] == reservedSeats[i - 1][0]:
            free[reservedSeats[i][1]] = False
        else:
            mid_seats = True
            if free[2] and free[3] and free[4] and free[5]:
                mid_seats = False
                count += 1
            if free[6] and free[7] and free[8] and free[9]:
                mid_seats = False
                count += 1
            if mid_seats and free[4] and free[5] and free[6] and free[7]:
                count += 1
            n -= 1
            free = [True] * 11
            free[reservedSeats[i][1]] = False
        i += 1

    return count + n * 2",263
9820478829,max_stock_profit,"from typing import List

def max_stock_profit(k: int, prices: List[int]) -> int:
    def profitHelper(prices,i,k,buy,n,dp):
        if i == n or k == 0:
            return 0
        if dp[i][buy][k] != -1:
            return dp[i][buy][k]
        
        if buy == 1:
            pick = -prices[i] + profitHelper(prices,i+1,k,0,n,dp)
            unpick = profitHelper(prices,i+1,k,1,n,dp)
            dp[i][buy][k] = max(pick,unpick)
            return dp[i][buy][k]
        else:
            sell = prices[i] + profitHelper(prices,i+1,k-1,1,n,dp)
            unsell = profitHelper(prices,i+1,k,0,n,dp)
            dp[i][buy][k] = max(sell,unsell)
            return dp[i][buy][k]
    
    n = len(prices)
    dp = [[[-1]*(k+1) for j in range(2)] for i in range(n)]
    return profitHelper(prices,0,k,1,n,dp)",262
1199705165,zigzag_traversal,"from collections import deque
from typing import List

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def zigzag_traversal(root: TreeNode) -> List[List[int]]:
    if not root:
        return []

    result = []
    queue = deque([root])
    level = 0

    while queue:
        level_size = len(queue)
        current_level = deque()

        for _ in range(level_size):
            node = queue.popleft()

            if level % 2 == 0:
                current_level.append(node.val)
            else:
                current_level.appendleft(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(list(current_level))
        level += 1

    return result

# Test cases
root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)

assert zigzag_traversal(root) == [[3], [20, 9], [15, 7]]
print(zigzag_traversal(root))",261
74982463186,max_sum_after_deletion,"def max_sum_after_deletion(arr):
    if all(x <= 0 for x in arr):
        return max(arr)
    neg, l = 0, len(arr)
    ans = [[max(0, arr[0])] * l for i in range(2)]
    for i in range(1, l):
        ans[0][i] = max(0, ans[0][i - 1] + arr[i])
        if arr[i] >= 0:
            ans[1][i] = ans[1][i - 1] + arr[i]
        else:
            if neg == 0:
                ans[1][i], neg = ans[1][i - 1], arr[i]
            elif ans[0][i - 1] - ans[1][i - 1] >= arr[i]:
                ans[1][i], neg = ans[0][i - 1], arr[i]
            else:
                ans[1][i] = ans[1][i - 1] + arr[i]
            if ans[1][i] <= 0:
                ans[1][i] = neg = 0
    return max(max(ans[0]), max(ans[1]))",261
30872158765,num_geometric_triplets,"def num_geometric_triplets(arr, r):
    count = 0
    before = {}
    after = {}

    # Populate the after dictionary
    for num in arr:
        if num in after:
            after[num] += 1
        else:
            after[num] = 1

    for num in arr:
        after[num] -= 1  # Exclude the current number from the after dictionary

        if num % r == 0:
            left_num = num // r
            right_num = num * r
            if left_num in before and right_num in after:
                count += before[left_num] * after[right_num]

        # Move the current number to the before dictionary
        if num in before:
            before[num] += 1
        else:
            before[num] = 1

    return count


# Test cases
assert num_geometric_triplets([1, 3, 9, 9, 27, 81], 3) == 6
assert num_geometric_triplets([1, 1, 1, 1], 1) == 4
assert num_geometric_triplets([1, 2, 4, 8], 2) == 2",261
26067496258,max_xor,"def max_xor(nums, k):
    class TrieNode:
        def __init__(self):
            self.children = [None] * 2

    def insert(root, num):
        node = root
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            if node.children[bit] is None:
                node.children[bit] = TrieNode()
            node = node.children[bit]

    def query(root, num):
        node = root
        xor = 0
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            if node.children[1 - bit] is not None:
                xor = xor | (1 << i)
                node = node.children[1 - bit]
            else:
                node = node.children[bit]
        return xor

    root = TrieNode()
    nums.sort(reverse=True)
    max_xor = 0
    for i in range(k):
        insert(root, nums[i])
    for i in range(k, len(nums)):
        insert(root, nums[i])
        max_xor = max(max_xor, query(root, nums[i - k]))
    return max_xor",260
23754656926,is_bst,"class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def is_bst(root):
    def helper(node, lower=float('-inf'), upper=float('inf')):
        if not node:
            return True

        val = node.val
        if val <= lower or val >= upper:
            return False

        if not helper(node.right, val, upper):
            return False
        if not helper(node.left, lower, val):
            return False
        return True

    return helper(root)

# Test cases
root1 = TreeNode(4)
root1.left = TreeNode(2)
root1.right = TreeNode(6)
root1.left.left = TreeNode(1)
root1.left.right = TreeNode(3)
root1.right.left = TreeNode(5)
root1.right.right = TreeNode(7)
assert is_bst(root1) == True

root2 = TreeNode(4)
root2.left = TreeNode(2)
root2.right = TreeNode(6)
root2.left.left = TreeNode(1)
root2.left.right = TreeNode(5)
root2.right.left = TreeNode(3)
root2.right.right = TreeNode(7)
assert is_bst(root2) == False",260
18586786321,max_xor,"class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, num):
        node = self.root
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            if bit not in node.children:
                node.children[bit] = TrieNode()
            node = node.children[bit]

    def get_max_xor(self, num):
        node = self.root
        xor_num = 0
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            if (1 - bit) in node.children:
                xor_num |= (1 << i)
                node = node.children[1 - bit]
            else:
                node = node.children[bit]
        return xor_num

def max_xor(nums):
    trie = Trie()
    max_xor_value = float('-inf')
    for num in nums:
        trie.insert(num)
    for num in nums:
        max_xor_value = max(max_xor_value, trie.get_max_xor(num))
    return max_xor_value",260
20611904909,largest_square_fibonacci,"def largest_square_fibonacci(fib_list):
    def is_perfect_square(n):
        return int(n**0.5)**2 == n

    def is_fibonacci(n):
        a, b = 0, 1
        while b < n:
            a, b = b, a + b
        return b == n

    largest = -1
    for num in fib_list:
        if is_perfect_square(num) and is_fibonacci(num):
            largest = max(largest, num)
    return largest

assert largest_square_fibonacci([1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]) == 144
assert largest_square_fibonacci([1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233]) == 144
assert largest_square_fibonacci([2, 3, 5, 7, 11, 17, 19]) == -1",259
38222541336,sum_of_distances_in_tree,"from collections import defaultdict

def sum_of_distances_in_tree(N, edges, node):
    tree = defaultdict(list)

    # Build the tree
    for u, v in edges:
        tree[u].append(v)
        tree[v].append(u)

    # Helper function to compute the sum of distances
    def dfs(node, parent, distance):
        nonlocal total_distance

        # Increment the total distance by the current distance
        total_distance += distance

        # Recurse on the children
        for child in tree[node]:
            if child != parent:
                dfs(child, node, distance + 1)

    # Compute the sum of distances from the given node
    total_distance = 0
    dfs(node, -1, 0)
    return total_distance

print(sum_of_distances_in_tree(6, [[0,1],[0,2],[2,3],[2,4],[2,5]], 0))
print(sum_of_distances_in_tree(6, [[0,1],[0,2],[2,3],[2,4],[2,5]], 2))
print(sum_of_distances_in_tree(6, [[0,1],[0,2],[2,3],[2,4],[2,5]], 4))",259
11595639296,deepest_node,"from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def deepest_node(root: Optional[TreeNode]) -> int:
    deepest_val = 0
    deepest_node = None
    stack = [(root, 0)]
    
    while stack:
        node, depth = stack.pop()
        if node is not None:
            if depth > deepest_val:
                deepest_val = depth
                deepest_node = node.val
            stack.append((node.left, depth + 1))
            stack.append((node.right, depth + 1))
    return deepest_node

# Test cases
assert deepest_node(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) == 5
assert deepest_node(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(6), TreeNode(7)))) == 7
assert deepest_node(TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(8)), TreeNode(5, TreeNode(9))), TreeNode(3, TreeNode(6, TreeNode(10)), TreeNode(7, TreeNode(11))))) == 11",258
4134561240,longest_cycle,"from collections import defaultdict, deque

def longest_cycle(edges):
    indegree = defaultdict(int)

    # traverse the edges to calculate indegree
    for from_, to_ in enumerate(edges):
        if to_ != -1:
            indegree[to_] += 1
            
    queue = deque()
    for node in range(len(edges)):
        if indegree[node] == 0:
            queue.append(node)
        
    while queue:
        curr = queue.popleft()
        indegree[curr] = 0
            
        if edges[curr] == -1:
            continue

        if indegree[edges[curr]] == 1:
            queue.append(edges[curr])
        
        indegree[edges[curr]] -= 1

    # now we're left with nodes that are in cycles
    def findCycleLength(node):
        curr = node
        length = 0

        while indegree[curr]:
            indegree[curr] -= 1
            curr = edges[curr]
            length += 1
        
        return length
    
    longestCycle = 0

    for node in range(len(edges)):
        if indegree[node] > 0:
            longestCycle = max(longestCycle, findCycleLength(node))

    return longestCycle if longestCycle else -1",258
5271454146,longest_concatenated_word,"def longest_concatenated_word(words):
    def is_concatenated(word, word_set):
        for i in range(1, len(word)):
            prefix = word[:i]
            suffix = word[i:]
            if prefix in word_set and (suffix in word_set or is_concatenated(suffix, word_set)):
                return True
        return False

    words.sort(key=lambda x: -len(x))
    word_set = set(words)
    for word in words:
        if is_concatenated(word, word_set):
            return word
    return """"

# Test cases
print(longest_concatenated_word([""cat"", ""cats"", ""catsdogcats"", ""dog"", ""dogcatsdog"", ""hippopotamuses"", ""rat"", ""ratcatdogcat""]))
print(longest_concatenated_word([""cat"", ""dog"", ""catdog"", ""dogcat"", ""catdogcatdog""]))
print(longest_concatenated_word([""a"", ""aa"", ""aaa"", ""aaaa"", ""aaaaa""]))
print(longest_concatenated_word([""hello"", ""world"", ""helloworld"", ""hel"", ""wor""]))
print(longest_concatenated_word([""ab"", ""abc"", ""abcd"", ""abcde"", ""abcdex""]))",258
23794794790,nth_ugly_number,"def nth_ugly_number(n):
    ugly = [1]
    i2 = i3 = i5 = 0
    next_multiple_of_2 = 2
    next_multiple_of_3 = 3
    next_multiple_of_5 = 5

    for i in range(1, n):
        next_ugly = min(next_multiple_of_2, next_multiple_of_3, next_multiple_of_5)
        ugly.append(next_ugly)

        if next_ugly == next_multiple_of_2:
            i2 += 1
            next_multiple_of_2 = ugly[i2] * 2

        if next_ugly == next_multiple_of_3:
            i3 += 1
            next_multiple_of_3 = ugly[i3] * 3

        if next_ugly == next_multiple_of_5:
            i5 += 1
            next_multiple_of_5 = ugly[i5] * 5

    return ugly[-1]

# Test the function
assert nth_ugly_number(10) == 12
assert nth_ugly_number(1) == 1
assert nth_ugly_number(20) == 36",258
70132983379,min_substring,"def min_substring(s, t):
    if not s or not t:
        return """"
    dict_t = {}
    for c in t:
        if c not in dict_t:
            dict_t[c] = 0
        dict_t[c] += 1

    required = len(dict_t)
    formed = 0
    window_counts = {}
    l, r, min_length = 0, 0, float(""inf"")
    min_window = """"

    while r < len(s):
        character = s[r]
        if character in dict_t:
            window_counts[character] = window_counts.get(character, 0) + 1
            if window_counts[character] == dict_t[character]:
                formed += 1

        while l <= r and formed == required:
            character = s[l]
            if r - l + 1 < min_length:
                min_length = r - l + 1
                min_window = s[l : r + 1]

            if character in dict_t:
                window_counts[character] -= 1
                if window_counts[character] < dict_t[character]:
                    formed -= 1

            l += 1

        r += 1

    return min_window",258
22658987325,max_xor,"def max_xor(nums):
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.isEnd = False
    
    class Trie:
        def __init__(self):
            self.root = TrieNode()
    
        def insert(self, num):
            node = self.root
            for i in range(31, -1, -1):
                bit = (num >> i) & 1
                if bit not in node.children:
                    node.children[bit] = TrieNode()
                node = node.children[bit]
            node.isEnd = True
    
        def max_xor_helper(self, num):
            node = self.root
            xor = 0
            for i in range(31, -1, -1):
                bit = (num >> i) & 1
                toggle = 1 - bit
                if toggle in node.children:
                    xor |= (1 << i)
                    node = node.children[toggle]
                else:
                    node = node.children[bit]
            return xor

    trie = Trie()
    max_xor = 0
    for num in nums:
        trie.insert(num)
        max_xor = max(max_xor, trie.max_xor_helper(num))
    
    return max_xor",257
14911149728,count_connected_components,"class UnionFind(object):
    def __init__(self, n):
        self.uf = [-1 for i in range(n + 1)]
        self.sets_count = n

    def find(self, p):
        if self.uf[p] < 0:
            return p
        self.uf[p] = self.find(self.uf[p])
        return self.uf[p]

    def union(self, p, q):
        proot = self.find(p)
        qroot = self.find(q)
        if proot == qroot:
            return
        elif self.uf[proot] > self.uf[qroot]:
            self.uf[qroot] += self.uf[proot]
            self.uf[proot] = qroot
        else:
            self.uf[proot] += self.uf[qroot]
            self.uf[qroot] = proot
        self.sets_count -= 1

    def is_connected(self, p, q):
        return self.find(p) == self.find(q)

def count_connected_components(edges):
    max_node = max([max(edge) for edge in edges])
    uf = UnionFind(max_node)
    for edge in edges:
        uf.union(edge[0], edge[1])
    return uf.sets_count",257
30347409212,shortest_path,"from collections import deque

def shortest_path(grid, k):
    rows, cols = len(grid), len(grid[0])

    if k >= rows - 1 + cols -1:
        return rows + cols - 2
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    queue = deque([(0, 0, k, 0)])

    visited = set([(0, 0, k)])

    while queue:

        x, y, remaining_k, path = queue.popleft()

        if (x, y) == (rows-1, cols-1):
            return path 
        
        for direction in directions:
            new_x = x + direction[0]
            new_y = y + direction[1]

            if (0 <= new_x < rows) and (0 <= new_y < cols):
                new_k = remaining_k - grid[new_x][new_y]
                    
                if new_k >= 0 and (new_x, new_y, new_k) not in visited:
                    visited.add((new_x, new_y, new_k))
                    queue.append((new_x, new_y, new_k, path+1))
            
    return -1",257
20051686404,smallest_substring,"def smallest_substring(str1, pattern):
    window_start, matched = 0, 0
    min_length = len(str1) + 1
    sub_string_start = 0
    char_frequency = {}

    for chr in pattern:
        if chr not in char_frequency:
            char_frequency[chr] = 0
        char_frequency[chr] += 1

    for window_end in range(len(str1)):
        right_char = str1[window_end]
        if right_char in char_frequency:
            char_frequency[right_char] -= 1
            if char_frequency[right_char] >= 0:
                matched += 1

        while matched == len(pattern):
            if min_length > window_end - window_start + 1:
                min_length = window_end - window_start + 1
                sub_string_start = window_start

            left_char = str1[window_start]
            window_start += 1
            if left_char in char_frequency:
                if char_frequency[left_char] == 0:
                    matched -= 1
                char_frequency[left_char] += 1

    if min_length > len(str1):
        return """"
    return str1[sub_string_start:sub_string_start + min_length]",256
72070901287,min_window,"def min_window(s, t):
    if not s or not t:
        return """"
    t_count = {}
    for char in t:
        if char not in t_count:
            t_count[char] = 0
        t_count[char] += 1

    required = len(t_count)
    formed = 0
    window_counts = {}

    left = 0
    right = 0
    min_len = float(""inf"")
    min_window = """"

    while right < len(s):
        char = s[right]
        if char not in window_counts:
            window_counts[char] = 0
        window_counts[char] += 1

        if char in t_count and window_counts[char] == t_count[char]:
            formed += 1

        while left <= right and formed == required:
            char = s[left]

            if right - left + 1 < min_len:
                min_len = right - left + 1
                min_window = s[left:right + 1]

            window_counts[char] -= 1
            if char in t_count and window_counts[char] < t_count[char]:
                formed -= 1

            left += 1

        right += 1

    return min_window",256
1233790387,fib,"def fib(n):
    F = [[1, 1],
         [1, 0]]
    if n == 0:
        return 0
    power(F, n - 1)
    return F[0][0]

def multiply(F, M):
    x = F[0][0] * M[0][0] + F[0][1] * M[1][0]
    y = F[0][0] * M[0][1] + F[0][1] * M[1][1]
    z = F[1][0] * M[0][0] + F[1][1] * M[1][0]
    w = F[1][0] * M[0][1] + F[1][1] * M[1][1]
    F[0][0] = x
    F[0][1] = y
    F[1][0] = z
    F[1][1] = w

def power(F, n):
    M = [[1, 1],
         [1, 0]]
    for _ in range(2, n + 1):
        multiply(F, M)",256
74002511806,levenshtein_distance,"def levenshtein_distance(str1, str2):
    if str1 == str2:
        return 0
    len1 = len(str1)
    len2 = len(str2)
    
    if len1 == 0:
        return len2
    if len2 == 0:
        return len1
    
    matrix = [[0] * (len2 + 1) for _ in range(len1 + 1)]
    
    for i in range(len1 + 1):
        matrix[i][0] = i
    for j in range(len2 + 1):
        matrix[0][j] = j
        
    for i in range(1, len1 + 1):
        for j in range(1, len2 + 1):
            if str1[i-1] == str2[j-1]:
                cost = 0
            else:
                cost = 1
            matrix[i][j] = min(matrix[i-1][j] + 1,      # deletion
                               matrix[i][j-1] + 1,      # insertion
                               matrix[i-1][j-1] + cost) # substitution
    return matrix[len1][len2]",256
22039466625,min_window_substring,"def min_window_substring(s: str, t: str) -> str:
    from collections import Counter

    if not t or not s:
        return ''

    dict_t = Counter(t)
    required = len(dict_t)

    l, r = 0, 0
    formed = 0
    window_counts = {}

    ans = float(""inf""), None, None

    while r < len(s):
        character = s[r]
        window_counts[character] = window_counts.get(character, 0) + 1

        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1

        while l <= r and formed == required:
            character = s[l]

            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)

            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1

            l += 1    

        r += 1    

    return """" if ans[0] == float(""inf"") else s[ans[1] : ans[2] + 1]",255
7088274938,find_Max_XOR,"class TrieNode: 
    def __init__(self): 
        self.children = {} 
        self.end = False

class Trie: 
    def __init__(self): 
        self.root = TrieNode()

    def insert(self, val): 
        node = self.root 
        for i in reversed(range(32)): 
            bit = (val >> i) & 1 
            if bit not in node.children: 
                node.children[bit] = TrieNode() 
            node = node.children[bit]

    def find_max_xor(self, val): 
        node = self.root 
        xor_val = 0
        for i in reversed(range(32)): 
            bit = (val >> i) & 1 
            if 1 - bit in node.children: 
                xor_val |= (1 << i) 
                node = node.children[1 - bit]
            else: 
                node = node.children[bit]
        return xor_val

def find_Max_XOR(nums): 
    trie = Trie() 
    max_xor = 0

    for num in nums: 
        trie.insert(num) 
        max_xor = max(max_xor, trie.find_max_xor(num))

    return max_xor",255
22438084650,minSwaps,"def minSwaps(arr):
    n = len(arr)
    # Create two arrays and use as pairs where first array
    # is element and second array is position of first element
    arrpos = [*enumerate(arr)]
    
    # Sort the array by array element values to get right
    # position of every element as the elements of second
    # array.
    arrpos.sort(key=lambda it: it[1])
    
    # To keep track of visited elements. Initialize all
    # elements as not visited or false.
    vis = {k: False for k in range(n)}
    
    ans = 0
    for i in range(n):
        # already swapped or
        # already present at correct position
        if vis[i] or arrpos[i][0] == i:
            continue
 
        cycle_size = 0
        j = i
        while not vis[j]:
            # mark node as visited
            vis[j] = True
            # move to next node
            j = arrpos[j][0]
            cycle_size += 1
 
        # Update answer by adding current cycle
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",254
70608903386,subarray_sum,"def subarray_sum(l, t):
    sum_of_elements = sum(l)
    current_sum = 0
    start_index = 0

    # First check: l must contain 1 to 100 elements --> OK
    if not 1 <= len(l) <= 100:
        return [-1, -1]

    # Second check: l elements must be between 1 to 100 --> OK
    if max(l) > 100 or min(l) < 1:
        return [-1, -1]

    # Third check: t must be smaller or equal to 250 --> OK
    if not 1 <= t <= 250:
        return [-1, -1]

    # Forth check: check if the sum of all elements is smaller than t --> OK
    if sum_of_elements < t:
        return [-1, -1]

    for index, value in enumerate(l):
        current_sum += value
        while current_sum > t:
            current_sum -= l[start_index]
            start_index += 1
        if current_sum == t:
            return [start_index, index]
    return [-1, -1]",254
74397738695,closest_points,"from math import sqrt

def closest_points(points):
    points.sort()
    def closest_pair(points):
        n = len(points)
        if n <= 3:
            return min([sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2) for i in range(n) for j in range(i + 1, n)])
        mid = n // 2
        mid_point = points[mid]
        dl = closest_pair(points[:mid])
        dr = closest_pair(points[mid:])
        d = min(dl, dr)
        strip = [point for point in points if abs(point[0] - mid_point[0]) < d]
        strip.sort(key=lambda point: point[1])
        for i in range(len(strip)):
            for j in range(i + 1, len(strip)):
                if (strip[j][1] - strip[i][1]) ** 2 >= d ** 2:
                    break
                d = min(d, sqrt((strip[i][0] - strip[j][0]) ** 2 + (strip[i][1] - strip[j][1]) ** 2))
        return d
    return closest_pair(points)",254
23216631276,min_edit_distance,"def min_edit_distance(source, target):
    len_source, len_target = len(source), len(target)
    
    # Create a 2D array to store the minimum edit distance at each step
    dp = [[0 for _ in range(len_target + 1)] for _ in range(len_source + 1)]
    
    # Initialize the first row and column
    for i in range(len_source + 1):
        dp[i][0] = i
    for j in range(len_target + 1):
        dp[0][j] = j
    
    # Fill in the dp array
    for i in range(1, len_source + 1):
        for j in range(1, len_target + 1):
            if source[i - 1] == target[j - 1]:
                cost = 0
            else:
                cost = 1
            dp[i][j] = min(dp[i - 1][j] + 1,      # Deletion
                           dp[i][j - 1] + 1,      # Insertion
                           dp[i - 1][j - 1] + cost)  # Substitution
    
    return dp[len_source][len_target]",254
21944749992,fib_matrix,"def fib_matrix(n):
    F = [[1, 1], [1, 0]]
    if n == 0:
        return 0
    power(F, n - 1)
    return F[0][0]

def multiply(F, M):
    x = F[0][0] * M[0][0] + F[0][1] * M[1][0]
    y = F[0][0] * M[0][1] + F[0][1] * M[1][1]
    z = F[1][0] * M[0][0] + F[1][1] * M[1][0]
    w = F[1][0] * M[0][1] + F[1][1] * M[1][1]

    F[0][0] = x
    F[0][1] = y
    F[1][0] = z
    F[1][1] = w

def power(F, n):
    M = [[1, 1], [1, 0]]
    for _ in range(2, n+1):
        multiply(F, M)",254
26862758161,match_words,"def match_words(words, queries):
    answer = []
    words_dic = {}

    # Create a dictionary where keys are word lengths and values are lists of words with those lengths
    for word in words:
        w_l = len(word)
        if w_l in words_dic.keys():
            words_dic[w_l].append(word)
        else:
            words_dic[w_l] = [word]

    # For each query, find matching words
    for querie in queries:
        q_l = len(querie)
    
        t_l = 0
        t_lst = []

        # If the query's length exists in the dictionary, prepare a list of potential matches
        if q_l in  words_dic.keys():
            t_l = len(words_dic[q_l])
            t_lst = [1] * t_l

        # Check each word against the query
        for i in range(t_l):
            for j in range(q_l):
                if querie[j] != '?' and querie[j] != words_dic[q_l][i][j]:
                    t_lst[i] = 0
                    break

        # Append the sum of matches for this query to the answer
        answer.append(sum(t_lst))
    
    return answer",254
31940710540,smallest_number,"def smallest_number(arr):
    if not arr:
        return None
    smallest = arr[0]
    for num in arr[1:]:
        if num < smallest:
            smallest = num
    return smallest

def smallest_number_chip_conquer(arr):
    if not arr:
        return None
    if len(arr) == 1:
        return arr[0]
    else:
        return min(arr[0], smallest_number_chip_conquer(arr[1:]))

def smallest_number_divide_halves_non_recursive(arr):
    if not arr:
        return None
    while len(arr) > 1:
        mid = len(arr) // 2
        left, right = arr[:mid], arr[mid:]
        if min(left) < min(right):
            arr = left
        else:
            arr = right
    return arr[0]

def smallest_number_divide_halves_recursive(arr):
    if not arr:
        return None
    if len(arr) == 1:
        return arr[0]
    mid = len(arr) // 2
    left, right = arr[:mid], arr[mid:]
    return min(smallest_number_divide_halves_recursive(left), smallest_number_divide_halves_recursive(right))",253
42799959231,count_knight_moves,"def count_knight_moves(position):
    rows = [1, 2, 3, 4, 5, 6, 7, 8]
    columns = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

    row_point = int(position[1])
    column_point = position[0]

    input_column_index = columns.index(column_point)

    row_move = [-2, -2, 2, 2, -1, 1, -1, 1]
    column_move = [1, -1, 1, -1, 2, 2, -2, -2]
    move_types = [""UUR"", ""UUL"", ""DDR"", ""DDL"", ""RRU"", ""RRD"", ""LLU"", ""LLD""]

    count = 0

    for i in range(len(move_types)):
        new_row = row_point + row_move[i]
        new_column_index = input_column_index + column_move[i]
        if new_row > 0 and new_row <= 8 and new_column_index >= 0 and new_column_index < 8:
            count += 1

    return count",253
19807579080,shortest_substring,"def shortest_substring(str1, pattern):
    window_start, matched, substr_start = 0, 0, 0
    min_length = len(str1) + 1
    char_frequency = {}

    for chr in pattern:
        if chr not in char_frequency:
            char_frequency[chr] = 0
        char_frequency[chr] += 1

    for window_end in range(len(str1)):
        right_char = str1[window_end]

        if right_char in char_frequency:
            char_frequency[right_char] -= 1
            if char_frequency[right_char] >= 0:
                matched += 1

        while matched == len(pattern):
            if min_length > window_end - window_start + 1:
                min_length = window_end - window_start + 1
                substr_start = window_start

            left_char = str1[window_start]
            window_start += 1
            if left_char in char_frequency:
                if char_frequency[left_char] == 0:
                    matched -= 1
                char_frequency[left_char] += 1

    if min_length > len(str1):
        return """"
    return str1[substr_start:substr_start + min_length]",252
31907877092,smallest_substring,"def smallest_substring(str1, pattern):
    window_start, matched, substr_start = 0, 0, 0
    min_length = len(str1) + 1
    char_frequency = {}

    for chr in pattern:
        if chr not in char_frequency:
            char_frequency[chr] = 0
        char_frequency[chr] += 1

    for window_end in range(len(str1)):
        right_char = str1[window_end]
        if right_char in char_frequency:
            char_frequency[right_char] -= 1
            if char_frequency[right_char] >= 0:
                matched += 1

        while matched == len(pattern):
            if min_length > window_end - window_start + 1:
                min_length = window_end - window_start + 1
                substr_start = window_start

            left_char = str1[window_start]
            window_start += 1
            if left_char in char_frequency:
                if char_frequency[left_char] == 0:
                    matched -= 1
                char_frequency[left_char] += 1

    if min_length > len(str1):
        return """"
    return str1[substr_start:substr_start+min_length]",252
16938807109,shortestPathBinaryMatrix,"from collections import deque

def shortestPathBinaryMatrix(grid):
    if grid[0][0] == 1 or grid[-1][-1] == 1:
        return -1

    m, n = len(grid), len(grid[0])
    q = deque([(0, 0)])
    grid[0][0] = 1
    directions = [(0, 1), (1, 0), (1, 1), (-1, 0), (0, -1), (1, -1), (-1, 1), (-1, -1)]
    steps = 1

    while q:
        size = len(q)
        for _ in range(size):
            x, y = q.popleft()
            if x == m - 1 and y == n - 1:
                return steps
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0:
                    q.append((nx, ny))
                    grid[nx][ny] = 1
        steps += 1

    return -1",252
41154957696,findQuadruplets,"def findQuadruplets(nums, target):
    def findN(nums, target, N, result, results):
        if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:
            return
        if N == 2:
            left, right = 0, len(nums) - 1
            while left < right:
                s = nums[left] + nums[right]
                if s == target:
                    results.append(result + [nums[left], nums[right]])
                    left += 1
                    while left < right and nums[left] == nums[left - 1]:
                        left += 1
                elif s < target:
                    left += 1
                else:
                    right -= 1
        else:
            for i in range(len(nums) - N + 1):
                if i == 0 or (i > 0 and nums[i - 1] != nums[i]):
                    findN(nums[i + 1:], target - nums[i], N - 1, result + [nums[i]], results)
    nums.sort()
    results = []
    findN(nums, target, 4, [], results)
    return results",252
30340943702,max_flags,"def max_flags(A):
    A_len = len(A)
    next_peak = [-1] * A_len
    peaks_count = 0
    first_peak = -1
    
    for index in range(A_len - 2, 0, -1):
        if A[index] > A[index + 1] and A[index] > A[index - 1]:
            next_peak[index] = index
            peaks_count += 1
            first_peak = index
        else:
            next_peak[index] = next_peak[index + 1]
    if peaks_count < 2:
        return peaks_count
 
    max_flags = 1
    for min_distance in range(int(A_len ** 0.5), 1, -1):
        flags_used = 1
        flags_have = min_distance - 1
        pos = first_peak
        while flags_have > 0:
            if pos + min_distance >= A_len - 1:
                break
            pos = next_peak[pos + min_distance]
            if pos == -1:
                break
            flags_used += 1
            flags_have -= 1
        max_flags = max(max_flags, flags_used)
 
    return max_flags",252
1789880729,kmp_search,"def compute_kmp_table(pattern):
    table = [0] * len(pattern)
    prefix_index = 0

    for suffix_index in range(1, len(pattern)):
        while prefix_index > 0 and pattern[prefix_index] != pattern[suffix_index]:
            prefix_index = table[prefix_index - 1]

        if pattern[prefix_index] == pattern[suffix_index]:
            prefix_index += 1

        table[suffix_index] = prefix_index

    return table

def kmp_search(text, pattern):
    if len(pattern) == 0:
        return 0

    pattern_table = compute_kmp_table(pattern)
    text_index = 0
    pattern_index = 0

    while text_index < len(text):
        if text[text_index] == pattern[pattern_index]:
            text_index += 1
            pattern_index += 1

        if pattern_index == len(pattern):
            return text_index - pattern_index

        elif text_index < len(text) and pattern[pattern_index] != text[text_index]:
            if pattern_index != 0:
                pattern_index = pattern_table[pattern_index - 1]
            else:
                text_index += 1

    return -1",251
38901472021,isPossibleConsecutive,"from collections import defaultdict
import heapq

def isPossibleConsecutive(nums):
    """"""
    Determines if a list of integers can be partitioned into consecutive subsequences of length at least 3.
    
    :param nums: List of integers.
    :return: True if it's possible to partition into consecutive subsequences of length at least 3, False otherwise.
    """"""
    d1, d2 = defaultdict(int), defaultdict(int)
    for x in nums:
        d1[x] += 1
    for x in nums:
        if d1[x] > 0:
            if d2.get(x - 1, 0) > 0:
                d1[x] -= 1
                d2[x] += 1
                d2[x-1] -= 1
            else:
                if d1.get(x+1, 0) > 0 and d1.get(x+2, 0) > 0:
                    d1[x] -= 1
                    d1[x+1] -= 1
                    d1[x+2] -= 1
                    d2[x+2] += 1
                else:
                    return False
    return True",251
33310401595,spiral_matrix,"def spiral_matrix(n):
    """"""
    Generates a spiral matrix of size n x n, starting at the top left corner and moving clockwise.
    :param n: int, the size of the matrix.
    :return: List[List[int]], the spiral matrix.
    """"""
    matrix = [[0] * n for _ in range(n)]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
    x, y = 0, 0
    direction = 0
    for i in range(1, n * n + 1):
        matrix[x][y] = i
        next_x, next_y = x + directions[direction][0], y + directions[direction][1]
        if not (0 <= next_x < n and 0 <= next_y < n) or matrix[next_x][next_y] != 0:
            direction = (direction + 1) % 4
            next_x, next_y = x + directions[direction][0], y + directions[direction][1]
        x, y = next_x, next_y
    return matrix",251
35862072781,shortest_path,"from typing import List

def shortest_path(grid: List[List[int]]) -> int:
    if not grid:
        return 0

    rows, cols = len(grid), len(grid[0])
    dp = [[0] * cols for _ in range(rows)]
    dp[0][0] = grid[0][0]

    for i in range(1, rows):
        dp[i][0] = dp[i - 1][0] + grid[i][0]

    for j in range(1, cols):
        dp[0][j] = dp[0][j - 1] + grid[0][j]

    for i in range(1, rows):
        for j in range(1, cols):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]

    return dp[-1][-1]

print(shortest_path([[1,3,1],[1,5,1],[4,2,1]]), 7)
print(shortest_path([[1,2,3],[4,5,6]]), 12)
print(shortest_path([[1]]), 1)",251
25298945543,check_permutation_inclusion,"def check_permutation_inclusion(s, pattern):
    # 1. 在pattern中找到所有字符的数量
    pattern_map = {}
    for v in pattern:
        if v not in pattern_map:
            pattern_map[v] = 1
        else:
            pattern_map[v] += 1

    window_size = len(pattern)
    window_map = {}
    window_left = 0
    window_right = 0

    while window_right < len(s):

        if s[window_right] not in pattern_map:
            window_map = {}
            window_left = window_right + 1
            window_right = window_right + 1
            continue

        if s[window_right] not in window_map:
            window_map[s[window_right]] = 1
        else:
            window_map[s[window_right]] += 1

        window_right += 1

        if window_right - window_left > window_size:
            window_map[s[window_left]] -= 1
            if window_map[s[window_left]] == 0:
                window_map.pop(s[window_left])
            window_left += 1

        if window_map == pattern_map:
            return True

    return False",250
17716356629,count_occurrence,"def count_occurrence(A, x):
    first = find_first_occurrence(A, x)
    if first == -1:
        return 0
    last = find_last_occurrence(A, x)
    return last - first + 1

def find_first_occurrence(A, x):
    (left, right) = (0, len(A) - 1)
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if x == A[mid]:
            result = mid
            right = mid - 1
        elif x < A[mid]:
            right = mid - 1
        else:
            left = mid + 1
    return result

def find_last_occurrence(A, x):
    (left, right) = (0, len(A) - 1)
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if x == A[mid]:
            result = mid
            left = mid + 1
        elif x < A[mid]:
            right = mid - 1
        else:
            left = mid + 1
    return result",250
13538442764,longest_monotonic_subsequence,"def longest_monotonic_subsequence(arr):
    n = len(arr)
    inc, dec = [1] * n, [1] * n

    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j] and inc[i] < inc[j] + 1:
                inc[i] = inc[j] + 1
            if arr[i] < arr[j] and dec[i] < dec[j] + 1:
                dec[i] = dec[j] + 1

    return max(max(inc), max(dec))

assert longest_monotonic_subsequence([1, 11, 2, 10, 4, 5, 2, 1]) == 5
assert longest_monotonic_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6
assert longest_monotonic_subsequence([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 10",250
3788804045,largest_rectangle_of_ones,"def largest_rectangle_of_ones(matrix):
    if not matrix: return 0
    m, n = len(matrix), len(matrix[0])
    left = [0] * n
    right = [n] * n
    height = [0] * n
    maxArea = 0

    for i in range(m):
        curleft = 0
        curright = n
        for j in range(n):
            if matrix[i][j] == 1:
                height[j] += 1
            else:
                height[j] = 0
            if matrix[i][j] == 1:
                left[j] = max(left[j], curleft)
            else:
                left[j] = 0
                curleft = j + 1
        for j in range(n - 1, -1, -1):
            if matrix[i][j] == 1:
                right[j] = min(right[j], curright)
            else:
                right[j] = n
                curright = j
        for j in range(n):
            maxArea = max(maxArea, height[j] * (right[j] - left[j]))
    return maxArea",250
2279518876,containsNearbyAlmostDuplicate,"import bisect

def containsNearbyAlmostDuplicate(nums, k, t):
    if t < 0: return False
    n = len(nums)
    buckets = {}
    bucket_size = t + 1
    for i in range(n):
        bucket_num = nums[i] // bucket_size
        if bucket_num in buckets:
            return True
        if bucket_num - 1 in buckets and abs(nums[i] - buckets[bucket_num - 1]) < bucket_size:
            return True
        if bucket_num + 1 in buckets and abs(nums[i] - buckets[bucket_num + 1]) < bucket_size:
            return True
        buckets[bucket_num] = nums[i]
        if i >= k:
            del buckets[nums[i-k] // bucket_size]
    return False

# Test cases
print(containsNearbyAlmostDuplicate([1,2,3,1], 3, 0)) # True
print(containsNearbyAlmostDuplicate([1,0,1,1], 1, 2)) # True
print(containsNearbyAlmostDuplicate([1,5,9,1,5,9], 2, 3)) # False",250
33759708018,largest_min_distance,"import math

def largest_min_distance(points):
    def distance(p1, p2):
        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

    distances = []
    for i in range(len(points)):
        for j in range(i+1, len(points)):
            distances.append(distance(points[i], points[j]))

    return min(distances)

# Test cases
print(largest_min_distance([(1, 2), (3, 4), (5, 6)]))  # 2.8284271247461903
print(largest_min_distance([(1, 1), (2, 2), (3, 3), (4, 4)]))  # 1.4142135623730951
print(largest_min_distance([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]))  # 1.4142135623730951",249
25593087850,findWays,"def findWays(n):
    if n == 0:
        return 1
    elif n < 0:
        return 0
    else:
        return findWays(n-1) + findWays(n-3) + findWays(n-4)

# memoization solution
def findWaysMemo(n, memo):
    if n in memo:
        return memo[n]
    if n == 0:
        return 1
    elif n < 0:
        return 0
    else:
        memo[n] = findWaysMemo(n-1, memo) + findWaysMemo(n-3, memo) + findWaysMemo(n-4, memo)
        return memo[n]

# tabulation solution
def findWaysTabulation(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        dp[i] += dp[i-1]
        if i >= 3:
            dp[i] += dp[i-3]
        if i >= 4:
            dp[i] += dp[i-4]
    return dp[n]",249
25875447759,binary_search_count,"def binary_search_count(arr, target):
    left = find_leftmost(arr, target)
    if left == -1:
        return 0
    right = find_rightmost(arr, target)
    return right - left + 1

def find_leftmost(arr, target):
    low = 0
    high = len(arr) - 1
    result = -1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            result = mid
            high = mid - 1
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return result

def find_rightmost(arr, target):
    low = 0
    high = len(arr) - 1
    result = -1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            result = mid
            low = mid + 1
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return result",248
14556852282,diagonal_traverse,"def diagonal_traverse(matrix):
  if matrix is None:
    return
  m, n = len(matrix), len(matrix[0])
  dirs = ((-1, 1), (1, -1)) # there is only 2 directions
  col, row, d = 0, 0, 0 # the start point and direction
  res = []
  for i in range(m*n): # for all the elements
    res.append(matrix[row][col])
    row += dirs[d][0]
    col += dirs[d][1]
    # very time meet a boundary, need to change the direction
    if row >= m: # for the bottom boundary
      row -= 1
      col += 2
      d = 1-d
    if col >= n: # for the right boundary
      row += 2
      col -= 1
      d = 1-d
    if row < 0: # for the top boundary
      row = 0
      d = 1-d
    if col < 0: # for the left boundary
      col = 0
      d = 1-d
  return res",247
23100072540,kthSmallestElement,"def partition(nums, low, high):
    pivot = nums[high]
    i = low - 1
    for j in range(low, high):
        if nums[j] <= pivot:
            i += 1
            nums[i], nums[j] = nums[j], nums[i]
    nums[i + 1], nums[high] = nums[high], nums[i + 1]
    return i + 1

def quickSelect(nums, k, low, high):
    if low == high:
        return nums[low]
    pivot_index = partition(nums, low, high)
    if k == pivot_index:
        return nums[k]
    elif k < pivot_index:
        return quickSelect(nums, k, low, pivot_index - 1)
    else:
        return quickSelect(nums, k, pivot_index + 1, high)

def kthSmallestElement(nums, k):
    if not isinstance(nums, list) or not isinstance(k, int):
        return ""Invalid input!""
    if k < 1 or k > len(nums):
        return ""k is out of bounds!""
    return quickSelect(nums, k-1, 0, len(nums)-1)",247
32320805369,four_sum,"def four_sum(nums, target):
    """"""
    :type nums: List[int]
    :type target: int
    :rtype: List[List[int]]
    """"""
    nums.sort()
    n = len(nums)
    result = []
    for i in range(n):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        for j in range(i + 1, n):
            if j > i + 1 and nums[j] == nums[j-1]:
                continue
            k = j + 1
            l = n - 1
            while k < l:
                s = nums[i] + nums[j] + nums[k] + nums[l]
                if s == target:
                    result.append([nums[i], nums[j], nums[k], nums[l]])
                    k += 1
                    l -= 1
                    while k < l and nums[k] == nums[k-1]:
                        k += 1
                    while k < l and nums[l] == nums[l+1]:
                        l -= 1
                elif s < target:
                    k += 1
                else:
                    l -= 1
    return result",247
1464959154,min_window_substring,"def min_window_substring(s, t):
    from collections import Counter
    if not t or not s: return ''
    dict_t = Counter(t)
    required = len(dict_t)
    l, r = 0, 0
    formed = 0
    window_counts = {}
    ans = float(""inf""), None, None
    while r < len(s):
        character = s[r]
        window_counts[character] = window_counts.get(character, 0) + 1
        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1
        while l <= r and formed == required:
            character = s[l]
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)
            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1
            l += 1    
        r += 1    
    return """" if ans[0] == float(""inf"") else s[ans[1] : ans[2] + 1]",247
7861864784,is_Interleaving,"def is_Interleaving(str1, str2, interleaved_str):
    m = len(str1)
    n = len(str2)
    if len(interleaved_str) != m+n:
        return False
    dp = [[False]*(n+1) for _ in range(m+1)]
    dp[0][0] = True
    for i in range(1, m+1):
        dp[i][0] = (dp[i-1][0] and str1[i-1] == interleaved_str[i-1])
    for j in range(1, n+1):
        dp[0][j] = (dp[0][j-1] and str2[j-1] == interleaved_str[j-1])
    for i in range(1, m+1):
        for j in range(1, n+1):
            dp[i][j] = (dp[i-1][j] and str1[i-1] == interleaved_str[i+j-1]) or (dp[i][j-1] and str2[j-1] == interleaved_str[i+j-1])
    return dp[m][n]",246
73348312023,smallest_substring,"from collections import Counter
def smallest_substring(s, t):
    if not t or not s:
        return """"
    dict_t = Counter(t)
    required = len(dict_t)
    l, r = 0, 0
    formed = 0
    window_counts = {}
    ans = float(""inf""), None, None
    while r < len(s):
        character = s[r]
        window_counts[character] = window_counts.get(character, 0) + 1
        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1
        while l <= r and formed == required:
            character = s[l]
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)
            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1
            l += 1    
        r += 1    
    return """" if ans[0] == float(""inf"") else s[ans[1] : ans[2] + 1]",246
4180089218,min_window,"from collections import Counter

def min_window(s, t):
    if not t or not s:
        return """"
    dict_t = Counter(t)
    required = len(dict_t)
    
    l, r = 0, 0
    formed = 0
    window_counts = {}
    ans = float(""inf""), None, None
    while r < len(s):
        character = s[r]
        window_counts[character] = window_counts.get(character, 0) + 1
        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1
        while l <= r and formed == required:
            character = s[l]
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)
            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1
            l += 1
        r += 1
    return """" if ans[0] == float(""inf"") else s[ans[1] : ans[2] + 1]",246
33760482738,longest_common_substring,"def longest_common_substring(s1, s2):
    m = len(s1)
    n = len(s2)
    # Create a table to store lengths of longest common suffixes of substrings
    # The first row and first column are initialized to 0
    dp = [[0] * (n+1) for _ in range(m+1)]
    
    # Variable to store the length of the longest common substring
    length = 0
    
    # Variable to store the ending index of the longest common substring
    row = 0
    
    # Fill dp[][] in a bottom-up manner
    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > length:
                    length = dp[i][j]
                    row = i
            else:
                dp[i][j] = 0

    # The longest common substring is from s1[row-length:row]
    return s1[row-length:row]",246
10288795976,smallest_window,"from collections import Counter

def smallest_window(s, pattern):
    pattern_count = Counter(pattern)
    start, start_index, min_len = 0, -1, float('inf')
    count = 0
    current_count = {}

    for j in range(len(s)):
        current_count[s[j]] = current_count.get(s[j], 0) + 1
        if s[j] in pattern_count and current_count[s[j]] <= pattern_count[s[j]]:
            count += 1
        if count == len(pattern):
            while current_count[s[start]] > pattern_count.get(s[start], 0):
                current_count[s[start]] -= 1
                start += 1
            window_len = j - start + 1
            if min_len > window_len:
                min_len = window_len
                start_index = start

    return s[start_index:start_index + min_len] if start_index != -1 else """"

# Check function
print(smallest_window(""this is a test string"", ""tist"")) # t stri
print(smallest_window(""geeksforgeeks"", ""ork"")) # ksfor
print(smallest_window(""zoom"", ""o"")) # o",246
27438368381,smallest_window,"from collections import Counter

def smallest_window(s, t):
    if not t or not s:
        return """"
    dict_t = Counter(t)
    required = len(dict_t)
    l, r = 0, 0
    formed = 0
    window_counts = {}

    ans = float(""inf""), None, None
    while r < len(s):
        character = s[r]
        window_counts[character] = window_counts.get(character, 0) + 1

        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1

        while l <= r and formed == required:
            character = s[l]

            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)

            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1

            l += 1    

        r += 1    
    return """" if ans[0] == float(""inf"") else s[ans[1] : ans[2] + 1]",245
12800322812,smallest_substring,"def smallest_substring(str, pattern):
    window_start, matched, substr_start = 0, 0, 0
    min_length = len(str) + 1
    char_frequency = {}

    for chr in pattern:
        if chr not in char_frequency:
            char_frequency[chr] = 0
        char_frequency[chr] += 1

    for window_end in range(len(str)):
        right_char = str[window_end]

        if right_char in char_frequency:
            char_frequency[right_char] -= 1
            if char_frequency[right_char] >= 0:
                matched += 1

        while matched == len(pattern):
            if min_length > window_end - window_start + 1:
                min_length = window_end - window_start + 1
                substr_start = window_start

            left_char = str[window_start]
            window_start += 1

            if left_char in char_frequency:
                if char_frequency[left_char] == 0:
                    matched -= 1
                char_frequency[left_char] += 1

    if min_length > len(str):
        return ''
    return str[substr_start:substr_start+min_length]",245
34170775152,count_connected_components,"class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return
        if self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        elif self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1

def count_connected_components(edges):
    if not edges:
        return 0
    n = max(max(edge) for edge in edges) + 1
    uf = UnionFind(n)
    for edge in edges:
        uf.union(edge[0], edge[1])
    return sum(1 for i in range(n) if uf.find(i) == i)",245
7210286114,firstUniqChar,"def firstUniqChar(s: str) -> int:
    """"""
    Finds the first non-repeating character in a given string and returns its index.
    If it doesn't exist, return -1.

    Speed: O(N) because we iterate through the string once to create the count dictionary,
           and once more to find the first non-repeating character.
    Space: O(1) because the size of the dictionary is limited by the number of unique characters,
           which is at most 26 for lowercase and uppercase letters.

    Args:
        s (str): The input string.

    Returns:
        int: The index of the first non-repeating character, or -1 if all characters repeat.
    """"""

    # Populate count dictionary
    count = {}
    for char in s:
        if char in count:
            count[char] += 1
        else:
            count[char] = 1

    # Find the index of the first character that has a count of 1
    for i, char in enumerate(s):
        if count[char] == 1:
            return i

    # If no unique character was found, return -1
    return -1",245
29797872679,nextGreaterNumber,"def nextGreaterNumber(n: int) -> int:
    digits = list(str(n))
    length = len(digits)

    # From right to left, find the first digit that is smaller than the digit next to it
    for i in range(length - 2, -1, -1):
        if digits[i] < digits[i + 1]:
            break
    else:
        # If no such digit is found, the number is the largest permutation
        return -1

    # From right to left, find the smallest digit on the right side of (i-th digit) that is greater than digits[i]
    for j in range(length - 1, i, -1):
        if digits[j] > digits[i]:
            digits[i], digits[j] = digits[j], digits[i]
            break

    # Reverse the digits after the position i
    digits[i + 1:] = reversed(digits[i + 1:])

    # Convert the list of digits back to integer
    result = int("""".join(digits))

    # Check if the result is within the allowed range
    return result if result <= 2 ** 63 - 1 else -1",245
24484883952,min_window,"from collections import Counter

def min_window(s, t):
    if not t or not s:
        return """"
    dict_t = Counter(t)
    required = len(dict_t)
    l, r = 0, 0
    formed = 0
    window_counts = {}
    ans = float(""inf""), None, None
    while r < len(s):
        character = s[r]
        window_counts[character] = window_counts.get(character, 0) + 1
        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1
        while l <= r and formed == required:
            character = s[l]
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)
            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1
            l += 1    
        r += 1    
    return """" if ans[0] == float(""inf"") else s[ans[1] : ans[2] + 1]",245
40599793303,min_window,"from collections import Counter

def min_window(s, t):
    if not t or not s:
        return """"
    dict_t = Counter(t)
    required = len(dict_t)
    l, r = 0, 0
    formed = 0
    window_counts = {}
    ans = float(""inf""), None, None
    while r < len(s):
        character = s[r]
        window_counts[character] = window_counts.get(character, 0) + 1
        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1
        while l <= r and formed == required:
            character = s[l]
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)
            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1
            l += 1    
        r += 1    
    return """" if ans[0] == float(""inf"") else s[ans[1] : ans[2] + 1]",245
5890508357,min_knight_moves,"from collections import deque

def min_knight_moves(x: int, y: int) -> int:
    def get_neighbors(coord):
        res = []
        row, col = coord
        delta_row = [-2, -2, -1, 1, 2, 2, 1, -1]
        delta_col = [-1, 1, 2, 2, 1, -1, -2, -2]
        for i in range(len(delta_row)):
            r = row + delta_row[i]
            c = col + delta_col[i]
            res.append((r, c))
        return res
    
    def bfs(root):
        queue = deque([root])
        steps = 0
        visited = set()
        while queue:
            size = len(queue)
            for _ in range(size):
                node = queue.popleft()
                if node[0] == y and node[1] == x:
                    return steps
                for neighbor in get_neighbors(node):
                    if neighbor in visited:
                        continue
                    queue.append(neighbor)
                    visited.add(neighbor)
            steps += 1
    
    return bfs((0, 0))",244
24120340843,find_max_xor,"from collections import deque

class TrieNode:
    def __init__(self):
        self.children = {}
        self.isEnd = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, num):
        node = self.root
        for i in reversed(range(32)):
            bit = (num >> i) & 1
            if bit not in node.children:
                node.children[bit] = TrieNode()
            node = node.children[bit]

    def findMaxXOR(self, query):
        node = self.root
        xor = 0
        for i in reversed(range(32)):
            bit = (query >> i) & 1
            toggle = 1 - bit
            if toggle in node.children:
                xor |= (1 << i)
                node = node.children[toggle]
            else:
                node = node.children[bit]
        return xor

def find_max_xor(nums):
    trie = Trie()
    max_xor = 0
    for num in nums:
        trie.insert(num)
        max_xor = max(max_xor, trie.findMaxXOR(num))
    return max_xor",244
8291109409,max_distance,"def max_distance(grid):
    N, lands = len(grid), []
    for i in range(N):
        for j in range(N):
            if grid[i][j]: lands.append((i, j))
    if len(lands) == 0 or len(lands) == N * N: return -1

    cur_layer_queue, nxt_layer_queue = lands, []
    layer = 0

    while True:
        for cur_i, cur_j in cur_layer_queue:
            for tmp_i, tmp_j in [(cur_i + 1, cur_j), (cur_i - 1, cur_j), (cur_i, cur_j + 1), (cur_i, cur_j - 1)]:
                if tmp_i < 0 or tmp_i >= N or tmp_j < 0 or tmp_j >= N: continue
                if grid[tmp_i][tmp_j] == 0:
                    nxt_layer_queue.append((tmp_i, tmp_j))
                    grid[tmp_i][tmp_j] = layer + 1
        if nxt_layer_queue:
            layer += 1
            cur_layer_queue, nxt_layer_queue = nxt_layer_queue, []
        else: return layer",244
11607461487,smallestSubstring,"def smallestSubstring(str, pattern):
    dict_pat = {}
    for i in range(len(pattern)):
        dict_pat[pattern[i]] = dict_pat.get(pattern[i], 0) + 1

    start, start_index, min_len = 0, -1, float('inf')
    count = 0
    dict_str = {}
    for j in range(len(str)):
        dict_str[str[j]] = dict_str.get(str[j], 0) + 1
        if pattern.find(str[j]) != -1:
            if dict_str[str[j]] <= dict_pat[str[j]]:
                count += 1
        if count == len(pattern):
            while dict_str[str[start]] > dict_pat.get(str[start], 0) or dict_pat.get(str[start], 0) == 0:
                if dict_str[str[start]] > dict_pat.get(str[start], 0):
                    dict_str[str[start]] -= 1
                start += 1
            len_window = j - start + 1
            if min_len > len_window:
                min_len = len_window
                start_index = start
    return str[start_index: start_index + min_len]",244
9793399463,shortest_path,"from typing import List, Tuple, Optional
import queue

def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> Optional[Tuple[int, int]]:
    if grid[start[0]][start[1]] == 0 or grid[end[0]][end[1]] == 0:
        return None
    visited = set()
    waiting_q = queue.Queue()
    waiting_q.put(start)
    while not waiting_q.empty():
        x, y = waiting_q.get()
        if (x, y) == end:
            return (x, y)
        if (x, y) not in visited:
            visited.add((x, y))
            N = len(grid)
            M = len(grid[0])
            for dx, dy in [(0,1),(1,0),(-1,0),(0,-1)]:
                nx = x + dx
                ny = y + dy
                if 0<=nx<N and 0<=ny<M and grid[nx][ny] == 1 and (nx, ny) not in visited:
                    waiting_q.put((nx, ny))
    return None",243
71883317464,int_list_to_roman,"def int_list_to_roman(int_list):
    roman = {1: 'I', 5: 'V', 10: 'X', 50: 'L', 100: 'C', 500: 'D', 1000: 'M',
             4: 'IV', 9: 'IX', 40: 'XL', 90: 'XC', 400: 'CD', 900: 'CM'}
    keys = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    
    def convert(num):
        result = """"
        while num > 0:
            newKeys = [k for k in keys if k <= num]
            if len(newKeys) == 0:
                break
            num -= newKeys[0]
            result = result + roman[newKeys[0]]
        return result
    
    return [convert(num) for num in int_list]",243
71950615981,can_divide_into_consecutive_subsequences,"from typing import List
from collections import Counter

def can_divide_into_consecutive_subsequences(nums: List[int]) -> bool:
    """"""
    Checks if the given list can be divided into consecutive subsequences of length at least 3.
    
    Parameters:
    nums (List[int]): The input list of integers.
    
    Returns:
    bool: True if the list can be divided into consecutive subsequences of length at least 3, False otherwise.
    """"""
    count = Counter(nums)
    end_dict = Counter()
    
    for x in nums:
        if count[x] == 0:
            continue
        
        if end_dict[x - 1] > 0:
            count[x] -= 1
            end_dict[x - 1] -= 1
            end_dict[x] += 1
        elif count[x + 1] > 0 and count[x + 2] > 0:
            count[x] -= 1
            count[x + 1] -= 1
            count[x + 2] -= 1
            end_dict[x + 2] += 1
        else:
            return False
            
    return True",242
29878857430,shortest_substring,"from collections import Counter

def shortest_substring(text, target):
    if not text or not target:
        return """"
    
    target_count = Counter(target)
    required = len(target_count)
    formed = 0
    window_counts = Counter()
    
    l, r = 0, 0
    ans = float(""inf""), None, None
    while r < len(text):
        character = text[r]
        window_counts[character] += 1
        
        if character in target_count and window_counts[character] == target_count[character]:
            formed += 1
        
        while l <= r and formed == required:
            character = text[l]
            
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)
            
            window_counts[character] -= 1
            if character in target_count and window_counts[character] < target_count[character]:
                formed -= 1
            
            l += 1
        r += 1
    
    return """" if ans[0] == float(""inf"") else text[ans[1]:ans[2] + 1]",241
1085128469,floodFill,"from typing import List

def floodFill(image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
    tempColor = image[sr][sc]
        
    if tempColor == newColor:
        return image
        
    def changeColor(image, row, column, newColor, tempColor):
        if row < 0 or column < 0 or row >= len(image) or column >= len(image[0]) or image[row][column] != tempColor:
            return 
        image[row][column] = newColor
            
        if row > 0:
            changeColor(image, row-1, column, newColor, tempColor)
        if column > 0:
            changeColor(image, row, column-1, newColor, tempColor)
        if row < len(image):
            changeColor(image, row+1, column, newColor, tempColor)
        if column < len(image[0]):
            changeColor(image, row, column+1, newColor, tempColor)
        # return image
        
    changeColor(image, sr, sc, newColor, tempColor)
        
    return image",241
12474593875,rabin_karp_search,"def rabin_karp_search(haystack: str, needle: str) -> int:
    if not needle or needle not in haystack:
        return -1

    base = 256
    prime = 101
    n = len(haystack)
    m = len(needle)
    h = 1
    p = 0
    t = 0

    for i in range(m-1):
        h = (h * base) % prime

    for i in range(m):
        p = (base * p + ord(needle[i])) % prime
        t = (base * t + ord(haystack[i])) % prime

    for i in range(n-m+1):
        if p == t:
            for j in range(m):
                if haystack[i+j] != needle[j]:
                    break
            else:
                return i
        if i < n-m:
            t = (base * (t - ord(haystack[i]) * h) + ord(haystack[i+m])) % prime
            if t < 0:
                t = t + prime
    return -1",240
34596232731,minimum_deletion_cost,"def minimum_deletion_cost(s1: str, s2: str) -> int:
    m, n = len(s1), len(s2)
    dp = [[float('inf') for _ in range(n + 1)] for i in range(m + 1)]
    dp[0][0] = 0
    for i in range(m):
        dp[i + 1][0] = dp[i][0] + ord(s1[i])
    for i in range(n):
        dp[0][i + 1] = dp[0][i] + ord(s2[i])
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))
    return dp[-1][-1]",240
74994061899,shortest_substring,"from collections import Counter

def shortest_substring(str1, pattern):
    pattern_count = Counter(pattern)
    required = len(pattern_count)
    l, r = 0, 0
    formed = 0
    window_counts = {}
    ans = float(""inf""), None, None
    while r < len(str1):
        character = str1[r]
        window_counts[character] = window_counts.get(character, 0) + 1
        if character in pattern_count and window_counts[character] == pattern_count[character]:
            formed += 1
        while l <= r and formed == required:
            character = str1[l]
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)
            window_counts[character] -= 1
            if character in pattern_count and window_counts[character] < pattern_count[character]:
                formed -= 1
            l += 1    
        r += 1    
    return """" if ans[0] == float(""inf"") else str1[ans[1] : ans[2] + 1]",240
32255679546,window_substring,"from collections import Counter

def window_substring(string, pattern):
    str_len = len(string)
    pat_len = len(pattern)
    pat_count = Counter(pattern)
    start, start_index, min_len = 0, -1, float('inf')
    count = 0
    curr_count = {}
    for j in range(str_len):
        if string[j] in pat_count:
            curr_count[string[j]] = curr_count.get(string[j], 0) + 1
            if curr_count[string[j]] <= pat_count[string[j]]:
                count += 1
        if count == pat_len:
            while string[start] not in pat_count or curr_count[string[start]] > pat_count[string[start]]:
                if string[start] in curr_count and curr_count[string[start]] > pat_count[string[start]]:
                    curr_count[string[start]] -= 1
                start += 1
            curr_len = j - start + 1
            if curr_len < min_len:
                min_len = curr_len
                start_index = start
    return string[start_index: start_index + min_len] if start_index != -1 else ""No window found""",240
37542869743,smallest_substring,"from collections import Counter

def smallest_substring(string, pattern):
    pattern_count = Counter(pattern)
    required = len(pattern_count)
    formed = 0
    l, r = 0, 0
    min_length = float(""inf""), None, None
    window_counts = {}

    while r < len(string):
        character = string[r]
        window_counts[character] = window_counts.get(character, 0) + 1

        if character in pattern_count and window_counts[character] == pattern_count[character]:
            formed += 1

        while l <= r and formed == required:
            character = string[l]

            if r - l + 1 < min_length[0]:
                min_length = (r - l + 1, l, r)

            window_counts[character] -= 1
            if character in pattern_count and window_counts[character] < pattern_count[character]:
                formed -= 1

            l += 1    

        r += 1    
    return """" if min_length[0] == float(""inf"") else string[min_length[1] : min_length[2] + 1]",240
10080799518,count_ways_to_wear_hats,"from collections import defaultdict

def count_ways_to_wear_hats(hats):
    MOD = 10 ** 9 + 7
    n = len(hats)
    dp = [0] * (1 << n)
    dp[0] = 1
    hat_to_people = defaultdict(list)
    
    # Map each hat to the list of people who can wear it
    for i, person_hats in enumerate(hats):
        for hat in person_hats:
            hat_to_people[hat].append(i)
    
    # Iterate over all hats
    for hat in range(1, 41):
        cdp = dp[:]
        # For each person who can wear the hat, update the DP table
        for person in hat_to_people[hat]:
            for state in range(1 << n):
                if dp[state] > 0 and (state >> person) & 1 == 0:
                    cdp[state | (1 << person)] += dp[state]
                    cdp[state | (1 << person)] %= MOD
        dp = cdp
    
    return dp[(1 << n) - 1]",240
15529852640,max_points_on_line,"from collections import defaultdict

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def max_points_on_line(points):
    if not points:
        return 0
    ans = 1
    for i in range(len(points) - 1):
        start = Point(points[i][0], points[i][1])
        samepoint = 1
        dic = {'inf': 0}
        for j in range(i + 1, len(points)):
            end = Point(points[j][0], points[j][1])
            if start.x == end.x and start.y == end.y:
                samepoint += 1
            elif start.x == end.x:
                dic['inf'] += 1
            else:
                ydiff = start.y - end.y
                xdiff = start.x - end.x
                slope = float(ydiff) / xdiff
                if slope in dic:
                    dic[slope] += 1
                else:
                    dic[slope] = 1
        ans = max(ans, max(dic.values()) + samepoint)
    return ans",239
42832891276,check,"def check(arr,n): 
    sum = 0
    for i in range(0,n): 
        sum += arr[i] 
    if (sum % 2 != 0): 
        return False
    return subsetSum(arr, n, sum//2) 
def subsetSum(arr, n, sum): 
    subset = [ [ False for i in range(sum + 1) ] for i in range(n + 1) ] 
    for i in range(n + 1): 
        subset[i][0] = True
    for i in range(1, sum + 1): 
        subset[0][i] = False
    for i in range(1, n + 1): 
        for j in range(1, sum + 1): 
            if j<arr[i-1]: 
                subset[i][j] = subset[i-1][j] 
            if j>= arr[i-1]: 
                subset[i][j] = (subset[i-1][j] or subset[i - 1][j-arr[i-1]]) 
    return subset[n][sum]",239
7824848014,max_depth,"def max_depth(tree):
    depth = 0
    i = 0
    while i < len(tree):
        depth += 1
        i = 2 * i + 1
    return depth

def max_depth_solution(tree):
    depth = 0
    i = 0
    while i < len(tree):
        if 2 * i + 1 < len(tree) and tree[2 * i + 1] is not None:
            i = 2 * i + 1
        elif 2 * i + 2 < len(tree) and tree[2 * i + 2] is not None:
            i = 2 * i + 2
        else:
            i += 1
        depth = max(depth, int(math.log2(i + 1)))
    return depth

print(max_depth([3, 9, 20, None, None, 15, 7])) # should print 3
print(max_depth([1, 2, 3, 4, 5])) # should print 3
print(max_depth([1])) # should print 1",239
70631673490,get_Longest_Palindrome_Subsequence,"def get_Longest_Palindrome_Subsequence(s: str) -> str:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    start, max_len = 0, 1

    for i in range(n):
        dp[i][i] = 1

    for cl in range(2, n + 1):
        for i in range(n - cl + 1):
            end = i + cl
            if s[i] == s[end - 1] and cl == 2:
                dp[i][end - 1] = 2
            elif s[i] == s[end - 1]:
                dp[i][end - 1] = dp[i + 1][end - 2] + 2
            else:
                dp[i][end - 1] = max(dp[i][end - 2], dp[i + 1][end - 1])

            if dp[i][end - 1] > max_len:
                start = i
                max_len = dp[i][end - 1]

    return s[start:start + max_len]",238
29548566487,longest_palindrome_subsequence,"def longest_palindrome_subsequence(s):
    """"""
    :type s: str
    :rtype: int
    """"""
    n = len(s)

    # Create a table to store results of subproblems
    dp = [[0 for _ in range(n)] for _ in range(n)]

    # All substrings of length 1 are palindromes
    for i in range(n):
        dp[i][i] = 1

    # Build the table. The outer loop is for the length of the substring
    for cl in range(2, n + 1):
        for i in range(n - cl + 1):
            j = i + cl - 1
            if s[i] == s[j] and cl == 2:
                dp[i][j] = 2
            elif s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])

    return dp[0][n - 1]",238
72807780745,compute_max_length,"from bisect import bisect_left

def compute_max_length(arr):
    n = len(arr)
    increasing = [arr[0]]
    decreasing = [arr[-1]]
    for i in range(1, n):
        bisect_incr = bisect_left(increasing, arr[i])
        if bisect_incr == len(increasing):
            increasing.append(arr[i])
        else:
            increasing[bisect_incr] = arr[i]

        bisect_decr = bisect_left(decreasing, arr[-1-i])
        if bisect_decr == len(decreasing):
            decreasing.append(arr[-1-i])
        else:
            decreasing[bisect_decr] = arr[-1-i]

    return max(len(increasing), len(decreasing))

print(compute_max_length([1, 2, 3, 4, 5, 4, 3, 2, 1]))
print(compute_max_length([4, 2, 1, 5, 7, 8, 6, 3]))
print(compute_max_length([1, 2, 3, 2, 1]))",238
17391928218,min_distance,"def min_distance(word1, word2):
    T = [[0] * (len(word2) + 1) for i in range(len(word1) + 1)]
    for i in range(1, len(word1) + 1):
        T[i][0] = i
    for j in range(1, len(word2) + 1):
        T[0][j] = j
    for i in range(1, len(word1) + 1):
        for j in range(1, len(word2) + 1):
            if word1[i - 1] == word2[j - 1]:
                T[i][j] = min(T[i - 1][j - 1], T[i - 1][j] + 1, T[i][j - 1] + 1)
            else:
                T[i][j] = min(T[i - 1][j] + 1, T[i][j - 1] + 1, T[i - 1][j - 1] + 1)
    return T[-1][-1]",238
205150410,count_distinct_islands,"def count_distinct_islands(grid):
    def dfs(x, y, position, shape):
        if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != 1:
            return
        grid[x][y] = 0
        shape.add(position)
        dfs(x + 1, y, (position[0] + 1, position[1]), shape)
        dfs(x - 1, y, (position[0] - 1, position[1]), shape)
        dfs(x, y + 1, (position[0], position[1] + 1), shape)
        dfs(x, y - 1, (position[0], position[1] - 1), shape)
    
    shapes = set()
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                shape = set()
                dfs(i, j, (0, 0), shape)
                shapes.add(frozenset(shape))
    return len(shapes)",237
4319798516,level_order_traversal,"from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def level_order_traversal(root):
    if not root:
        return []
    result = []
    queue = deque([root])
    while queue:
        level_size = len(queue)
        current_level = []
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(current_level)
    return result

# Create a binary search tree for testing
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.left = TreeNode(6)
root.right.right = TreeNode(7)

# Test the level order traversal function
assert level_order_traversal(root) == [[1], [2, 3], [4, 5, 6, 7]]",237
37675083719,maxEqualRowsAfterFlips,"from typing import List

def maxEqualRowsAfterFlips(matrix: List[List[int]]) -> int:
    """"""
    Returns the maximum number of rows that can be made equal after flipping any number of columns in a binary matrix.
    
    :param matrix: List[List[int]] - A binary matrix of 0s and 1s.
    :return: int - The maximum number of equal rows that can be obtained.
    """"""
    groups = {}
    for row in matrix:
        if row[0] == 0:
            key = tuple(row)
        else:
            key = tuple(1 - x for x in row)
        groups[key] = groups.setdefault(key, 0) + 1
    return max(groups.values())

# Test cases
print(maxEqualRowsAfterFlips([[0,1],[1,1]])) # Expected output: 1
print(maxEqualRowsAfterFlips([[0,1],[1,0]])) # Expected output: 2
print(maxEqualRowsAfterFlips([[0,0,0],[0,0,1],[1,1,0]])) # Expected output: 2",237
5310060257,countWays,"def countWaysUtil(i, j, maze, dp):
    if i == 0 and j == 0:
        return 1
    if i < 0 or j < 0 or maze[i][j] == -1:
        return 0
    if dp[i][j] != -1:
        return dp[i][j]
    up = countWaysUtil(i - 1, j, maze, dp)
    left = countWaysUtil(i, j - 1, maze, dp)
    dp[i][j] = up + left
    return dp[i][j]

def countWays(m, n, maze):
    dp = [[-1 for j in range(n)] for i in range(m)]
    return countWaysUtil(m - 1, n - 1, maze, dp)

def main():
    maze = [[0,0,0], [0,-1,0], [0,0,0]]
    m = 3
    n = 3
    print(countWays(m, n, maze))

if __name__ == '__main__':
    main()",237
4359007719,transform_steps,"from collections import deque

def transform_steps(begin, target, words):
    if target not in words:
        return 0

    characters = set()
    for word in words:
        characters.update(list(word))
    characters = list(characters)
    queue = deque([(begin, 0, words)])

    answer = 100
    while queue:
        current, depth, now_words = queue.popleft()
        if current == target:
            answer = min(answer, depth)

        for i in range(len(current)):
            for j in range(len(characters)):
                if current[i] == characters[j]:
                    continue
                temp_word = current[:i] + characters[j] + current[i + 1:]
                for k in range(len(now_words)):
                    if now_words[k] == temp_word:
                        now_words[k] = False
                        queue.append((temp_word, depth + 1, now_words))

    if answer == 100:
        return 0
    return answer

print(transform_steps(""hit"", ""cog"", [""hot"", ""dot"", ""dog"", ""lot"", ""log"", ""cog""]))",237
25201140177,word_in_matrix,"from typing import List

def word_in_matrix(board: List[List[str]], word: str) -> bool:
    M, N = len(board), len(board[0])
    def dfs(x: int, y: int, index: int, visited: set) -> bool:
        if (x,y) in visited:
            return False
        visited.add((x,y))
        if board[x][y] == word[index]:
            if index == len(word) - 1:
                return True
            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                x_, y_ = x+dx, y+dy
                if 0 <= x_ < M and 0<= y_ < N:
                    if dfs(x_ , y_ , index + 1, visited):
                        return True
        visited.remove((x,y))
        return False

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0, set()):
                return True
    return False",236
41636330394,max_circular_subarray_sum,"def max_circular_subarray_sum(numbers: list[int]) -> int:
    def max_sub_array(numbers: list[int]) -> int:
        max_current = max_global = numbers[0]
        for i in range(1, len(numbers)):
            max_current = max(numbers[i], max_current + numbers[i])
            if max_current > max_global:
                max_global = max_current
        return max_global

    def min_sub_array(numbers: list[int]) -> int:
        min_current = min_global = numbers[0]
        for i in range(1, len(numbers)):
            min_current = min(numbers[i], min_current + numbers[i])
            if min_current < min_global:
                min_global = min_current
        return min_global

    max_kadane = max_sub_array(numbers)
    max_wrap = sum(numbers) - min_sub_array(numbers)

    # If all numbers are negative, max_wrap will be 0,
    # So in this case the result will be the maximum element in the array.
    if max_wrap == 0:
        return max_kadane

    return max(max_kadane, max_wrap)",235
12140831887,next_smaller,"def next_smaller(n):
    digits = list(str(n))
    length = len(digits)
    
    # From right to left, find the first digit that is smaller than the digit next to it
    for i in range(length - 2, -1, -1):
        if digits[i] > digits[i + 1]:
            # Find the largest digit on the right side of (i-th digit) that is smaller than digits[i]
            for j in range(length - 1, i, -1):
                if digits[j] < digits[i]:
                    # Swap the found digit with digits[i]
                    digits[i], digits[j] = digits[j], digits[i]
                    # Sort the digits after the (i+1)-th position in descending order and append to digits
                    digits = digits[:i + 1] + sorted(digits[i + 1:], reverse=True)
                    # Convert the digits list back to an integer
                    result = int(''.join(digits))
                    # Check if the result is smaller than the original number
                    return result if result < n else -1
            break
    return -1",234
25458513693,longest_zero_sum_subarray,"def longest_zero_sum_subarray(nums):
    """"""
    Algorithm:
    1. Initialize a dictionary to store the cumulative sum and its index. Set the initial sum to -1 to handle the case of zero sum at the beginning.
    2. Iterate through the array and calculate the cumulative sum.
    3. If the cumulative sum is already in the dictionary, it means that there is a subarray with a sum of zero from the index after the last occurrence of the sum to the current index. Update the maximum length if necessary.
    4. If the cumulative sum is not in the dictionary, add it with its index.
    5. Return the maximum length of subarray found.

    Time Complexity: O(n)
    Space Complexity: O(n)
    """"""
    sum_index = {0: -1}
    max_length = 0
    sum = 0
    for i in range(len(nums)):
        sum += nums[i]
        if sum in sum_index:
            max_length = max(max_length, i - sum_index[sum])
        else:
            sum_index[sum] = i
    return max_length",234
70818393802,heap_sort,"def heap_sort(nums):
    length = len(nums)
    
    # Build max heap
    for i in range(length // 2 - 1, -1, -1):
        heapify(nums, length, i)
    
    # Extract elements from heap one by one
    for i in range(length - 1, 0, -1):
        nums[i], nums[0] = nums[0], nums[i]  # swap
        heapify(nums, i, 0)
    
    return nums

def heapify(nums, heap_size, root_index):
    largest = root_index
    left_child = (2 * root_index) + 1
    right_child = (2 * root_index) + 2
    
    if left_child < heap_size and nums[left_child] > nums[largest]:
        largest = left_child
    
    if right_child < heap_size and nums[right_child] > nums[largest]:
        largest = right_child
    
    if largest != root_index:
        nums[root_index], nums[largest] = nums[largest], nums[root_index]
        heapify(nums, heap_size, largest)",234
21986917760,findQuadruplets,"def findQuadruplets(nums, target):
    nums.sort()
    res = []
    for i in range(len(nums) - 3):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        for j in range(i + 1, len(nums) - 2):
            if j > i + 1 and nums[j] == nums[j-1]:
                continue
            l, r = j + 1, len(nums) - 1
            while l < r:
                total_sum = nums[i] + nums[j] + nums[l] + nums[r]
                if total_sum < target:
                    l += 1
                elif total_sum > target:
                    r -= 1
                else:
                    res.append([nums[i], nums[j], nums[l], nums[r]])
                    while l < r and nums[l] == nums[l + 1]:
                        l += 1
                    while l < r and nums[r] == nums[r - 1]:
                        r -= 1
                    l += 1
                    r -= 1
    return res",233
31097282904,longest_palindromic_subsequence,"def longest_palindromic_subsequence(s):
    """"""
    :type s: str
    :rtype: int
    """"""
    # Initialize a 2D array to store the lengths of palindromic subsequences
    dp = [[0 for _ in range(len(s))] for _ in range(len(s))]

    # Any single character is a palindrome of length 1
    for i in range(len(s)):
        dp[i][i] = 1

    # Fill the dp array
    for i in range(len(s) - 1, -1, -1):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    # The length of the longest palindromic subsequence is in dp[0][len(s) - 1]
    return dp[0][len(s) - 1]",233
20274183141,find_max_xor,"class TrieNode:
    def __init__(self):
        self.children = {}

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, num):
        root = self.root
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            if bit not in root.children:
                root.children[bit] = TrieNode()
            root = root.children[bit]

    def query(self, num):
        root = self.root
        xor = 0
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            if 1 - bit in root.children:
                xor |= (1 << i)
                root = root.children[1 - bit]
            else:
                root = root.children[bit]
        return xor

def find_max_xor(nums):
    trie = Trie()
    max_xor = 0
    for num in nums:
        trie.insert(num)
        max_xor = max(max_xor, trie.query(num))
    return max_xor",233
27126127614,longest_common_substring,"def longest_common_substring(string1, string2): 
    m = len(string1) 
    n = len(string2) 
  
    # matrix to store lengths of longest 
    # common suffixes of substrings 
    L = [[0 for x in range(n+1)] for x in range(m+1)] 
  
    result = 0  # To store length of result 
  
    # To get the index of maximum value 
    index = 0
    for i in range(m+1): 
        for j in range(n+1): 
            if (i == 0 or j == 0) : 
                L[i][j] = 0
            elif (string1[i-1] == string2[j-1]): 
                L[i][j] = L[i-1][j-1] + 1
                if (result < L[i][j]): 
                    result = L[i][j] 
                    index = max(i, index) 
  
    # To get the longest common substring 
    # from string1 
    return string1[index - result : index]",233
15065818660,occurrence_in_list,"def binary_search(nums, target):
    if len(nums) == 0:
        return -1
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
    
def count_occurrence(nums, target):
    first_index = binary_search(nums, target)
    if first_index == -1:
        return 0
    count = 1
    left = first_index - 1
    while left >= 0 and nums[left] == target:
        count += 1
        left -= 1
    right = first_index + 1
    while right < len(nums) and nums[right] == target:
        count += 1
        right += 1
    return count

def occurrence_in_list(nums: list[int], target: int) -> int:
    return count_occurrence(nums, target)",233
3270704779,check_cycle,"def check_cycle(n: int, edges: list) -> bool:
    """"""
    Check if a graph contains a cycle using Depth-First Search (DFS).

    Time: O(N + M) for N vertices and M edges
    Space: O(N) for the recursive call stack

    :param n: an int, the number of vertices
    :param edges: a list of len 2 lists, the edges
    :return: a boolean
    """"""
    adj = {i: [] for i in range(n)}
    for edge in edges:
        adj[edge[0]].append(edge[1])

    visited = [False] * n
    rec_stack = [False] * n

    def dfs(v):
        visited[v] = True
        rec_stack[v] = True
        for neighbour in adj[v]:
            if not visited[neighbour] and dfs(neighbour) or rec_stack[neighbour]:
                return True
        rec_stack[v] = False
        return False

    for v in range(n):
        if not visited[v] and dfs(v):
            return True
    return False",233
41914146469,word_search,"def word_search(board, word):
    for i in range(len(board)):
        for j in range(len(board[0])):
            if _dfs(board, i, j, word):
                return True
    return False

def _dfs(board, i, j, word, depth=0):
    if i == len(board) or \
            j == len(board[0]) or \
            i == -1 or j == -1 or \
            board[i][j] != word[depth]:
        return False
    if depth == len(word) - 1:
        return True
    c = board[i][j]
    board[i][j] = ''
    sol = _dfs(board, i + 1, j, word, depth + 1) or \
        _dfs(board, i - 1, j, word, depth + 1) or \
        _dfs(board, i, j + 1, word, depth + 1) or \
        _dfs(board, i, j - 1, word, depth + 1)
    board[i][j] = c
    return sol",233
71118417260,calculate_parking_fees,"import math

def calculate_parking_fees(fees, records):
    answer = []
    td={}
    for r in records:
        rl=r.split()
        if rl[1] in td:
            td[rl[1]] += [rl[0]]
        else:
            td[rl[1]] = [rl[0]]

    for n in sorted(td.keys()):
        if len(td[n])%2!=0:
            td[n].append(""23:59"")
        tot=0
        for k in range(0,len(td[n]),2):
            time1=td[n][k].split("":"")
            time2=td[n][k+1].split("":"")
            tot+=((int(time2[0])*60+int(time2[1]))-(int(time1[0])*60+int(time1[1])))
        m=fees[0]-tot
        if m>0:
            answer.append(fees[1])
        else:
            answer.append(math.ceil(abs(m)/fees[2])*fees[-1]+fees[1])

    return answer",233
19758806793,findQuadruplets,"def findQuadruplets(nums):
    nums.sort()
    res = []
    for i in range(len(nums) - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        for j in range(i + 1, len(nums) - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue
            left = j + 1
            right = len(nums) - 1
            while left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                if total < 0:
                    left += 1
                elif total > 0:
                    right -= 1
                else:
                    res.append([nums[i], nums[j], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
    return res",233
21980997042,findKthLargest,"import heapq

def findKthLargest(nums, k):
    """"""
    Find the k-th largest element in an unsorted list using a min-heap.
    
    :param nums: List of integers.
    :param k: The k-th position to find.
    :return: The k-th largest element.
    """"""
    # Initialize a min heap with the first k elements of nums.
    heap = nums[:k]
    heapq.heapify(heap)
    
    # Iterate through the remaining elements.
    for num in nums[k:]:
        if num > heap[0]:
            heapq.heappop(heap)
            heapq.heappush(heap, num)
    
    # The root of the heap is the k-th largest element.
    return heap[0]

# Test cases
assert findKthLargest([3,2,1,5,6,4], 2) == 5
assert findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4
assert findKthLargest([1], 1) == 1",232
28531640920,findQuadruplets,"from typing import List

def findQuadruplets(arr: List[int]) -> List[List[int]]:
    arr.sort()
    results = []
    n = len(arr)
    for i in range(n):
        if i > 0 and arr[i] == arr[i-1]:
            continue
        for j in range(i+1, n):
            if j > i+1 and arr[j] == arr[j-1]:
                continue
            left = j+1
            right = n-1
            while left < right:
                total = arr[i] + arr[j] + arr[left] + arr[right]
                if total == 0:
                    results.append([arr[i], arr[j], arr[left], arr[right]])
                    left += 1
                    right -= 1
                    while left < right and arr[left] == arr[left-1]:
                        left += 1
                    while left < right and arr[right] == arr[right+1]:
                        right -= 1
                elif total < 0:
                    left += 1
                else:
                    right -= 1
    return results",232
20683965317,find_k_closest_points,"from typing import List

def calculate_dis(point: List[int]) -> int:
    """"""Calculate the Euclidean distance of a point from the origin.""""""
    return point[0] ** 2 + point[1] ** 2

def find_k_closest_points(points: List[List[int]], K: int) -> List[List[int]]:
    """"""Find the K closest points to the origin.""""""
    # Sort points based on their Euclidean distance from the origin
    points.sort(key=calculate_dis)
    # Return the first K points from the sorted list
    return points[:K]

# Test cases
assert find_k_closest_points([[1,3],[-2,2]], 1) == [[-2,2]]
assert find_k_closest_points([[3,3],[5,-1],[-2,4]], 2) in ([[3,3],[-2,4]], [[-2,4],[3,3]])
assert find_k_closest_points([[1,1],[2,2],[3,3]], 2) in ([[1,1],[2,2]], [[2,2],[1,1]])",232
14472101633,letter_combinations,"from collections import deque

def letter_combinations(digits):
    if not digits:
        return []
    alpha = {
        '2' : ['a', 'b', 'c'],
        '3' : ['d', 'e', 'f'],
        '4' : ['g', 'h', 'i'],
        '5' : ['j', 'k', 'l'],
        '6' : ['m', 'n', 'o'],
        '7' : ['p', 'q', 'r', 's'],
        '8' : ['t', 'u', 'v'],
        '9' : ['w', 'x', 'y', 'z']
    }
    fringe = deque([(a, 0) for a in alpha[digits[0]]])
    target = len(digits)-1
    combinations = []
    
    while fringe:
        curr, idx = fringe.popleft()
        if idx == target:
            combinations.append(curr)
            continue
        idx += 1
        
        for nxt in alpha[digits[idx]]:
            fringe.append((curr + nxt, idx))
                
    return combinations",232
15854299468,smallest_substring,"from collections import Counter

def smallest_substring(s, pattern):
    pattern_count = Counter(pattern)
    required = len(pattern_count)
    formed = 0
    window_counts = Counter()

    left, right = 0, 0
    min_length = float(""inf""), None, None

    while right < len(s):
        character = s[right]
        window_counts[character] += 1

        if character in pattern_count and window_counts[character] == pattern_count[character]:
            formed += 1

        while left <= right and formed == required:
            character = s[left]

            if right - left + 1 < min_length[0]:
                min_length = (right - left + 1, left, right)

            window_counts[character] -= 1
            if character in pattern_count and window_counts[character] < pattern_count[character]:
                formed -= 1

            left += 1    

        right += 1    

    return """" if min_length[0] == float(""inf"") else s[min_length[1] : min_length[2] + 1]",232
12818655687,max_overlapping,"def max_overlapping(intervals):
    # Sort intervals based on start time
    intervals.sort(key=lambda x: x[0])

    # Use a list to keep track of all active intervals at any point in time
    active_intervals = []

    max_overlap = 0
    for interval in intervals:
        # Remove any intervals that have already ended
        active_intervals = [x for x in active_intervals if x[1] > interval[0]]

        # Add the new interval to the list of active intervals
        active_intervals.append(interval)

        # Update max_overlap if necessary
        max_overlap = max(max_overlap, len(active_intervals))

    return max_overlap

# Testing the function with given test cases
assert max_overlapping([[1, 5], [2, 7], [4, 8], [3, 6]]) == 4
assert max_overlapping([[6, 7],[1, 4],[2, 4]]) == 2
assert max_overlapping([[1, 50],[1,100],[51, 100 ]]) == 2",232
17238465167,find_kth_smallest,"def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

def quick_select(arr, low, high, k):
    if low == high:
        return arr[low]
    pivot_index = partition(arr, low, high)
    if k == pivot_index:
        return arr[k]
    elif k < pivot_index:
        return quick_select(arr, low, pivot_index - 1, k)
    else:
        return quick_select(arr, pivot_index + 1, high, k)

def find_kth_smallest(arr, k):
    if 0 < k <= len(arr):
        return quick_select(arr, 0, len(arr) - 1, k - 1)
    else:
        raise ValueError('k is out of bounds')",231
2433342775,word_search,"def word_search(board, word):
    def dfs(x, y, word):
        if word == """":
            return True
        if not (0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] == word[0]):
            return False
        neighbors = ((1,0),(-1,0),(0,1),(0,-1))
        q = [(x,y)]
        curr = q.pop()
        keep = board[curr[0]][curr[1]]
        board[curr[0]][curr[1]] = ""#""
        for neighbor in neighbors:
            tmp = (curr[0] + neighbor[0], curr[1] + neighbor[1])
            if dfs(tmp[0], tmp[1], word[1:]):
                return True
        board[curr[0]][curr[1]] = keep
        return False
    for i in range(len(board)):
        for j in range(len(board[0])):
            if board[i][j] == word[0] and dfs(i, j, word):
                return True
    return False",231
12368078193,minSwapsToSort,"def minSwapsToSort(arr):
    n = len(arr)
    # Create two arrays and use 
    # as pairs where first array 
    # is element and second array 
    # is position of first element
    arrpos = [*enumerate(arr)]
    
    arrpos.sort(key = lambda it:it[1])
    
    # To keep track of visited 
    # elements. Initialize all 
    # elements as not visited 
    vis = {k:False for k in range(n)}
    
    ans = 0
    for i in range(n):
        # already swapped or 
        # alreadt present at 
        # correct position
        if vis[i] or arrpos[i][0] == i:
            continue
        
        cycle_size = 0
        j = i
        while not vis[j]:
            # mark node as visited
            vis[j] = True
            
            # move to next node
            j = arrpos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",231
25564437780,num_distinct_subseq,"def num_distinct_subseq(s: str) -> int:
    MOD = 10**9 + 7
    dp = [0] * (len(s) + 1)
    dp[0] = 1  # empty string
    last_occurrence = [-1] * 26  # initialize with -1
    for i in range(1, len(s) + 1):
        dp[i] = (2 * dp[i-1]) % MOD
        if last_occurrence[ord(s[i-1]) - ord('a')] != -1:
            dp[i] = (dp[i] - dp[last_occurrence[ord(s[i-1]) - ord('a')]]) % MOD
        last_occurrence[ord(s[i-1]) - ord('a')] = i - 1
    return (dp[len(s)] - 1) % MOD

print(num_distinct_subseq(""abc""))  # 7
print(num_distinct_subseq(""aba""))  # 6
print(num_distinct_subseq(""aaa""))  # 3",231
73437649737,smallest_window,"from collections import Counter

def smallest_window(str1, str2):
    str2_count = Counter(str2)
    required = len(str2_count)
    formed = 0
    window_counts = {}
    ans = float(""inf""), None, None
    l = 0
    for r in range(len(str1)):
        char = str1[r]
        window_counts[char] = window_counts.get(char, 0) + 1
        if char in str2_count and window_counts[char] == str2_count[char]:
            formed += 1
        while l <= r and formed == required:
            char = str1[l]
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)
            window_counts[char] -= 1
            if char in str2_count and window_counts[char] < str2_count[char]:
                formed -= 1
            l += 1   
    return """" if ans[0] == float(""inf"") else str1[ans[1] : ans[2] + 1]",231
17210705354,maximalRectangle,"def maximalRectangle(matrix):
    if not matrix:
        return 0


    nrows = len(matrix)
    ncols = len(matrix[0])

    max_area = 0

    height = [0] * (ncols + 1) # array length is ncols + 1 since we have to add a '0' in the end, similar to Largest Rectangle in Histogram


    for i in range(nrows):
        stack = []
        for j in range(ncols + 1):
            if j < ncols:
                if matrix[i][j] == '1':
                    height[j] += 1

                else:
                    height[j] = 0

            # same logic as Largest Rectangle in Histogram        
            if not stack or height[j] >= height[stack[-1]]:
                stack.append(j)

            else:
                while stack and height[stack[-1]] > height[j]:
                    top = stack.pop()
                    width = j if not stack else j -1 - stack[-1] 
                    max_area = max(max_area, height[top] * width)

                stack.append(j)


    return max_area",230
29334566160,fourSum,"def fourSum(nums, target):
    n = len(nums)
    nums.sort()
    res = []
    for i in range(n - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue

        for j in range(i + 1, n - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue

            l = j + 1
            r = n - 1
            while l < r:
                s = nums[i] + nums[j] + nums[l] + nums[r]
                if s == target:
                    res.append([nums[i], nums[j], nums[l], nums[r]])
                    l += 1
                    r -= 1
                    while l < r and nums[l] == nums[l - 1]:
                        l += 1
                    while l < r and nums[r] == nums[r + 1]:
                        r -= 1
                elif s < target:
                    l += 1
                else:
                    r -= 1
    return res",230
70444789876,longest_subarray_after_deletion,"from typing import List

def longest_subarray_after_deletion(nums: List[int]) -> int:
    i = 0
    n = len(nums)
    compressed = []

    while i<n:
        if nums[i] == 0:
            compressed.append(0)
        else:
            j = i
            cnt = 0
            while j<n and nums[j]==1:
                cnt += 1
                j += 1
            i = j
            compressed.append(cnt)
            if j<n:
                compressed.append(0)
        i += 1

    if len(compressed) == 1:
        if compressed[0] != 0:
            return compressed[0] - 1
        else:
            return 0
    else:
        ans = 0
        for i, cnt in enumerate(compressed):
            if cnt == 0:
                pre = 0 if i==0 else compressed[i-1]
                post = 0 if i==len(compressed)-1 else compressed[i+1]
                ans = max(ans, pre+post)
        return ans",230
33567494659,four_sum,"def four_sum(nums, target):
    nums.sort()
    result = []
    length = len(nums)
    for i in range(length - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        for j in range(i + 1, length - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue
            left = j + 1
            right = length - 1
            while left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                if total == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif total < target:
                    left += 1
                else:
                    right -= 1
    return result",230
74931332825,minimum_swaps,"def minimum_swaps(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans

if __name__ == '__main__':
    assert minimum_swaps([4, 3, 1, 2]) == 3
    assert minimum_swaps([2, 3, 4, 1, 5]) == 3
    assert minimum_swaps([1, 3, 5, 2, 4, 6, 7]) == 3
    print(""All tests passed!"")",229
2280089156,min_conference_rooms,"import heapq

def min_conference_rooms(meetings):
    """"""
    Finds the minimum number of conference rooms required for all the meetings to be held without any scheduling conflicts.
    
    :param meetings: List of tuples representing the start and end times of each meeting.
    :return: Minimum number of conference rooms required.
    """"""
    if not meetings:
        return 0

    # Sort the meetings based on start time
    meetings.sort(key=lambda x: x[0])

    # Initialize a min heap to keep track of end times of meetings
    end_times = []
    heapq.heappush(end_times, meetings[0][1])
    min_rooms = 1

    for i in range(1, len(meetings)):
        # If the current meeting starts after the earliest ending meeting, reuse the room
        if meetings[i][0] >= end_times[0]:
            heapq.heappop(end_times)
        heapq.heappush(end_times, meetings[i][1])
        # Update the minimum number of rooms required
        min_rooms = max(min_rooms, len(end_times))

    return min_rooms",229
20564024864,max_water_container,"def max_water_container(heights):
    """"""
    11. Container With Most Water
    https://leetcode.com/problems/container-with-most-water/

    1) Greedy, Sliding Window
    we moving two pointers from both ends, check the area against its bounded height
    at each index, and update the max area if the new area is larger

    we want to make sure that we wouldn't be in the situation that the opposite bounded
    height should be applied, so we are only going to update the pointer
    when its value is smaller than the other side

    time complexity: O(N), space complexity: O(1)
    """"""

    i, j = 0, len(heights) - 1
    max_area = 0

    while i < j:
        width = j - i
        height = min(heights[i], heights[j])
        area = width * height
        max_area = max(max_area, area)

        if heights[i] < heights[j]:
            i += 1
        else:
            j -= 1

    return max_area",229
12307870644,fourSum,"def fourSum(nums, target):
    nums.sort()
    results = []
    for i in range(len(nums) - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        for j in range(i + 1, len(nums) - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue
            left, right = j + 1, len(nums) - 1
            while left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                if total < target:
                    left += 1
                elif total > target:
                    right -= 1
                else:
                    results.append([nums[i], nums[j], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
    return results",229
308396264,is_palindrome_permutation,"def is_palindrome_permutation(str1):
    str1 = str1.replace(' ', '').lower()       # remove spaces and make all letters lowercase
    dict = {}                                  # initialize the dictionary
    for letter in str1:                        # iterate over the characters in the string
        if letter in dict:                     # if the letter is in the dictionary
            dict[letter] += 1                  # increment its count by 1
        else:
            dict[letter] = 1                   # otherwise, set its count to 1

    odd_count = 0                              # initialize a counter for odd counts
    for count in dict.values():                # iterate over the counts in the dictionary
        if count % 2 != 0:                     # if the count is odd
            odd_count += 1                     # increment the odd counter

    if odd_count > 1:                          # if there is more than one letter with an odd count
        return False                           # the string cannot be a permutation of a palindrome
    
    return True                                # otherwise, the string can be a permutation of a palindrome",229
14385950701,is_bst,"class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def is_bst(root):
    def is_bst_helper(root, min_val, max_val):
        if root is None:
            return True
        else:
            if not (min_val < root.val < max_val):
                return False
            return is_bst_helper(root.left, min_val, root.val) and is_bst_helper(root.right, root.val, max_val)

    return is_bst_helper(root, float('-inf'), float('inf'))

# Create a binary tree
#     2
#    / \
#   1   3
root = TreeNode(2)
root.left = TreeNode(1)
root.right = TreeNode(3)

assert is_bst(root) == True

# Create a binary tree
#     1
#    / \
#   2   3
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)

assert is_bst(root) == False",228
44016546564,max_area_histogram,"def max_area_histogram(heights):
    stack = []
    max_area = 0
    index = 0
    while index < len(heights):
        if not stack or heights[stack[-1]] <= heights[index]:
            stack.append(index)
            index += 1
        else:
            top = stack.pop()
            area = heights[top] * ((index - stack[-1] - 1) if stack else index)
            max_area = max(max_area, area)
    while stack:
        top = stack.pop()
        area = heights[top] * ((index - stack[-1] - 1) if stack else index)
        max_area = max(max_area, area)
    return max_area

print(max_area_histogram([2, 1, 5, 6, 2, 3]) == 10)
print(max_area_histogram([6, 2, 5, 4, 5, 1, 6]) == 12)
print(max_area_histogram([1, 2, 3, 4, 5]) == 9)",228
38473806232,longest_arith_seq_length,"from collections import defaultdict

def longest_arith_seq_length(nums):
    positions = defaultdict(list)
    lengths = defaultdict(int)
    for i, num in enumerate(nums):
        positions[num].append(i)
        lengths[num] += 1

    record = max(lengths.values())
    checked = set()

    for i in range(0, len(nums) - 1):
        for j in range(i + 1, len(nums)):
            diff = nums[j] - nums[i]
            if diff == 0: continue
            if (nums[j], nums[i]) in checked:
                continue
            checked.add((nums[j], nums[i]))
            next_num = nums[j] + diff
            largest = 2
            lowest_index = j
            while True:
                found_one = False
                for idx in positions[next_num]:
                    if idx > lowest_index:
                        largest += 1
                        next_num += diff
                        lowest_index = idx
                        found_one = True
                        break
                if not found_one: break
            record = max(largest, record)
    return record",228
11097835915,quad_sum,"def quad_sum(nums, target):
    nums.sort()
    result = []
    for i in range(len(nums)-3):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        for j in range(i+1, len(nums)-2):
            if j > i+1 and nums[j] == nums[j-1]:
                continue
            left = j+1
            right = len(nums)-1
            while left < right:
                if nums[i] + nums[j] + nums[left] + nums[right] == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left+1]:
                        left += 1
                    while left < right and nums[right] == nums[right-1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif nums[i] + nums[j] + nums[left] + nums[right] < target:
                    left += 1
                else:
                    right -= 1
    return result",227
15432227760,count_paths,"def count_paths(m, n):
    """"""
    Counts the number of unique paths from the top-left corner to the bottom-right corner of an MxN grid,
    moving only down or right at any point in time.
    :param m: int, number of rows in the grid
    :param n: int, number of columns in the grid
    :return: int, number of unique paths
    """"""
    if m == 1 or n == 1:
        return 1
    dp = [[0] * n for _ in range(m)]
    for i in range(m):
        dp[i][0] = 1
    for j in range(n):
        dp[0][j] = 1
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    return dp[m - 1][n - 1]

if __name__ == '__main__':
    print(count_paths(3, 3))",227
11254219171,unique_paths_with_obstacles,"def unique_paths_with_obstacles(obstacle_grid):
    m, n = len(obstacle_grid), len(obstacle_grid[0])
    if obstacle_grid[0][0] == 1:
        return 0
    obstacle_grid[0][0] = 1
    for i in range(1, m):
        obstacle_grid[i][0] = int(obstacle_grid[i][0] == 0 and obstacle_grid[i-1][0] == 1)
    for j in range(1, n):
        obstacle_grid[0][j] = int(obstacle_grid[0][j-1] == 1 and obstacle_grid[0][j] == 0)
    for i in range(1, m):
        for j in range(1, n):
            if obstacle_grid[i][j] == 0:
                obstacle_grid[i][j] = obstacle_grid[i-1][j] + obstacle_grid[i][j-1]
            else:
                obstacle_grid[i][j] = 0
    return obstacle_grid[m-1][n-1]",227
25389029921,find_quadruplets,"def find_quadruplets(nums, target):
    nums.sort()
    result = []
    n = len(nums)
    for i in range(n):
        if i > 0 and nums[i] == nums[i-1]: continue
        for j in range(i + 1, n):
            if j > i + 1 and nums[j] == nums[j-1]: continue
            lo, hi = j + 1, n - 1
            while lo < hi:
                sum_ = nums[i] + nums[j] + nums[lo] + nums[hi]
                if sum_ > target: hi -= 1
                elif sum_ < target: lo += 1
                else:
                    result.append([nums[i], nums[j], nums[lo], nums[hi]])
                    while lo < hi and nums[lo] == nums[lo+1]: lo += 1
                    while lo < hi and nums[hi] == nums[hi-1]: hi -= 1
                    lo += 1
                    hi -= 1
    return result",227
37066073955,shortest_distance,"from collections import deque

def shortest_distance(mat):
    m,n = len(mat),len(mat[0])
    ans = [[float(""inf"") for i in range(n)] for j in range(m)]
    
    q = deque()
    
    for i in range(m):
        for j in range(n):
            if mat[i][j] == 0:
                ans[i][j] = 0
                q.append((i,j))
                    
    directions = [[-1,0],[1,0],[0,-1],[0,1]] # up,down,left,right
        
    while q:
        row,col = q.popleft()
            
        for dr in directions:
            drow = row + dr[0]
            dcol = col + dr[1]
            if 0 <= drow < m and 0 <= dcol < n:
                if ans[drow][dcol] > ans[row][col] + 1:
                    ans[drow][dcol] = ans[row][col] + 1
                    q.append((drow,dcol))
                        
    return ans",227
13661287651,merge_items,"def merge_items(items1: list[list[int]], items2: list[list[int]]) -> list[list[int]]:
    items1.extend(items2)  # First, merge the two lists
    lenarr = len(items1)  # Get the length of the merged list
    newarr = sorted(items1, key=lambda x: x[0])  # Sort the list by keys
    reDict = {}  # Create a dictionary to hold keys and their total values
    for i in range(lenarr):  # Iterate through the merged and sorted list
        if newarr[i][0] in reDict:  # If the key is already in the dictionary
            reDict[newarr[i][0]] += newarr[i][1]  # Add the value to the existing value
        else:
            reDict[newarr[i][0]] = newarr[i][1]  # Otherwise, create a new entry in the dictionary
    # Convert the dictionary back to a list of lists and return it
    return [[key, value] for key, value in reDict.items()]",227
35017323632,nth_ugly_number,"def nth_ugly_number(n):
    ugly = [1]
    i2 = i3 = i5 = 0
    next_multiple_of_2 = 2
    next_multiple_of_3 = 3
    next_multiple_of_5 = 5
    next_ugly_number = 1
    for i in range(1, n):
        next_ugly_number = min(next_multiple_of_2, next_multiple_of_3, next_multiple_of_5)
        ugly.append(next_ugly_number)
        if next_ugly_number == next_multiple_of_2:
            i2 += 1
            next_multiple_of_2 = ugly[i2] * 2
        if next_ugly_number == next_multiple_of_3:
            i3 += 1
            next_multiple_of_3 = ugly[i3] * 3
        if next_ugly_number == next_multiple_of_5:
            i5 += 1
            next_multiple_of_5 = ugly[i5] * 5
    return next_ugly_number",227
69854597838,find_upper_bound,"from bisect import bisect_right

def find_upper_bound(arr, target):
    """"""
    Finds the index of the first element in a sorted list that is strictly greater than the target value.
    If all elements in the list are less than or equal to the target, returns the length of the list.
    
    :param arr: List of sorted elements.
    :param target: Value to find the upper bound for.
    :return: Index of the upper bound.
    """"""
    return bisect_right(arr, target)

# Test the function
if __name__ == ""__main__"":
    assert find_upper_bound([1, 2, 4, 4, 5, 6, 8], 4) == 4
    assert find_upper_bound([1, 2, 3, 4, 5, 6, 7], 3) == 3
    assert find_upper_bound([1, 2, 3, 4, 5, 6, 7], 8) == 7
    print(""All tests passed."")",226
3177983362,nth_ugly_number,"def nth_ugly_number(n):
    ugly = [1]
    i2 = i3 = i5 = 0
    next_multiple_of_2 = 2
    next_multiple_of_3 = 3
    next_multiple_of_5 = 5
    next_ugly_number = 1

    while len(ugly) < n:
        next_ugly_number = min(next_multiple_of_2, next_multiple_of_3, next_multiple_of_5)
        ugly.append(next_ugly_number)

        if next_ugly_number == next_multiple_of_2:
            i2 += 1
            next_multiple_of_2 = ugly[i2] * 2
        if next_ugly_number == next_multiple_of_3:
            i3 += 1
            next_multiple_of_3 = ugly[i3] * 3
        if next_ugly_number == next_multiple_of_5:
            i5 += 1
            next_multiple_of_5 = ugly[i5] * 5

    return ugly[-1]",226
4289399899,calculate_levenshtein_distance,"def calculate_levenshtein_distance(str1, str2):
  len_str1 = len(str1)
  len_str2 = len(str2)
  distance = [[0 for _ in range(len_str2+1)] for _ in range(len_str1+1)]
  
  for i in range(len_str1+1):
    distance[i][0] = i
  for j in range(len_str2+1):
    distance[0][j] = j
  
  for i in range(1, len_str1+1):
    for j in range(1, len_str2+1):
      if str1[i-1] == str2[j-1]:
        cost = 0
      else:
        cost = 1
      distance[i][j] = min(distance[i-1][j] + 1,      # Deletion
                            distance[i][j-1] + 1,      # Insertion
                            distance[i-1][j-1] + cost) # Substitution
  return distance[len_str1][len_str2]",226
35558435755,string_edit_distance,"def string_edit_distance(str1, str2):
    len1 = len(str1)
    len2 = len(str2)
    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]
    
    for i in range(len1 + 1):
        for j in range(len2 + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])
    return dp[len1][len2]

assert string_edit_distance(""horse"", ""ros"") == 3
assert string_edit_distance(""intention"", ""execution"") == 5
assert string_edit_distance(""kitten"", ""sitting"") == 3",226
23795370450,largest_rectangle,"def largest_rectangle(matrix):
    if not matrix:
        return 0
    m, n = len(matrix), len(matrix[0])
    left = [0] * n
    right = [n] * n
    height = [0] * n
    max_area = 0
    for i in range(m):
        cur_left, cur_right = 0, n
        for j in range(n):
            if matrix[i][j] == 1:
                height[j] += 1
                left[j] = max(left[j], cur_left)
            else:
                height[j] = 0
                left[j] = 0
                cur_left = j + 1
        for j in range(n-1, -1, -1):
            if matrix[i][j] == 1:
                right[j] = min(right[j], cur_right)
            else:
                right[j] = n
                cur_right = j
            max_area = max(max_area, height[j] * (right[j] - left[j]))
    return max_area",225
4152005742,is_one_edit_distance,"def is_one_edit_distance(s: str, t: str) -> bool:
    if not s and not t:
        return False
    
    if abs(len(s) - len(t)) == 1:
        if len(s) > len(t):
            for i in range(len(t)):
                if s[i] != t[i]:
                    if not s[:i] + s[i+1:] == t:
                        return False
                    else:
                        return True
            return True

        else:
            for i in range(len(s)):
                if s[i] != t[i]:
                    if not t[:i] + t[i+1:] == s:
                        return False
                    else:
                        return True
            return True

    elif len(s) == len(t):
        # replacement
        s_list = list(s)
        for i in range(len(s_list)):
            if s_list[i] != t[i]:
                s_list[i] = t[i]
                if ''.join(s_list) == t:
                    return True
                else:
                    return False

    else:
        return False",225
15519769459,find_kth_smallest,"def partition(arr, low, high):
    i = (low-1)
    pivot = arr[high]

    for j in range(low, high):
        if arr[j] <= pivot:
            i = i+1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i+1], arr[high] = arr[high], arr[i+1]
    return (i+1)


def quickselect(arr, low, high, k):
    if (k > 0 and k <= high - low + 1):
        pivot_index = partition(arr, low, high)
        if (pivot_index-low == k-1):
            return arr[pivot_index]
        if (pivot_index-low > k-1):
            return quickselect(arr, low, pivot_index-1, k)
        return quickselect(arr, pivot_index+1, high, k-pivot_index+low-1)
    return float('inf')

def find_kth_smallest(arr, k):
    return quickselect(arr, 0, len(arr)-1, k)",225
14022458537,uniquePathsWithObstacles,"def uniquePathsWithObstacles(obstacleGrid: list[list[int]]) -> int:
    m,n = len(obstacleGrid), len(obstacleGrid[0])
    if obstacleGrid[-1][-1] == 1: return 0
    paths = [[0 for _ in range(n)] for _ in range(m)]
    for j, entry in enumerate(paths[0]):
        if obstacleGrid[0][j] > 0:
            break
        paths[0][j] = 1
    for i, row in enumerate(paths):
        if obstacleGrid[i][0] > 0:
            break
        row[0] = 1
    for i in range(1, m):
        for j in range(1, n):
            paths[i][j] = (paths[i-1][j] if obstacleGrid[i-1][j] == 0 else 0) + (paths[i][j-1] if obstacleGrid[i][j-1] == 0 else 0)
    return paths[m-1][n-1]",225
9403061691,num_islands,"from collections import deque

def num_islands(grid):
    def bfs(r, c):
        que = deque()
        visited.add((r, c))
        que.append((r, c))
        while que:
            r, c = que.popleft()
            directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
            for row, col in directions:
                row, col = r + row, c + col
                if row in range(rows) and col in range(cols) and grid[row][col] == ""1"" and (row, col) not in visited:
                    que.append((row, col))
                    visited.add((row, col))

    rows = len(grid)
    cols = len(grid[0])
    visited = set()
    islands = 0
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == ""1"" and (r, c) not in visited:
                bfs(r, c)
                islands += 1
    return islands",225
3377379944,generate_spiral,"def generate_spiral(n):
    l, r, up, down = 0, n - 1, 0, n - 1
    k = 0
    ans = [[0] * n for _ in range(n)]
    while l < r and up < down:
        for i in range(l, r):
            k += 1
            ans[up][i] = k
        for i in range(up, down):
            k += 1
            ans[i][r] = k
        for i in range(r, l, -1):
            k += 1
            ans[down][i] = k
        for i in range(down, up, -1):
            k += 1
            ans[i][l] = k
        l, r, up, down = l + 1, r - 1, up + 1, down - 1
    if n % 2:
        ans[n // 2][n // 2] = k + 1
    return ans",223
42073209144,longest_palindrome,"def longest_palindrome(s):
    if len(s) == 0:
        return 0
    max_length = 1
    start = 0
    length = len(s)
    low = 0
    high = 0
    for i in range(1, length):
        low = i - 1
        high = i
        while low >= 0 and high < length and s[low] == s[high]:
            if (high - low + 1) > max_length:
                start = low
                max_length = high - low + 1
            low -= 1
            high += 1

        low = i - 1
        high = i + 1
        while low >= 0 and high < length and s[low] == s[high]:
            if (high - low + 1) > max_length:
                start = low
                max_length = high - low + 1
            low -= 1
            high += 1

    return s[start:start + max_length]",223
18406634749,is_pattern_match,"def is_pattern_match(word, pattern):
  p = 0  # pointer for pattern
  w = 0  # pointer for word
  stack = []
  while p < len(pattern) and w < len(word):
    if pattern[p] == '*':
      if not stack or stack[-1] != pattern[p-1]:
        stack.append((pattern[p-1], 0))
      else:
        stack[-1] = (pattern[p-1], stack[-1][1] + 1)
      p+=1
    elif pattern[p] == '.':
      w += 1
      p += 1
    elif pattern[p] == word[w]:
      w += 1
      p += 1
    else:
      if stack:
        p = stack[-1][0]
        w = w - stack[-1][1]
        stack.pop()
      else:
        return False
  while p < len(pattern):
    if pattern[p] != '*':
      return False
    p += 1
  return w == len(word)",223
32424899451,min_palindrome_cuts,"import sys

def min_palindrome_cuts(s):
    n = len(s)
    dp = [False] * n
    cut = [0] * n

    def is_pal(i, j):
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True

    for i in range(n):
        min_cut = sys.maxsize
        for j in range(i+1):
            if is_pal(j, i):
                cuts = 0 if j == 0 else cut[j-1] + 1
                min_cut = min(min_cut, cuts)
        cut[i] = min_cut
    return cut[n-1]

# Test cases
assert min_palindrome_cuts(""aab"") == 1
assert min_palindrome_cuts(""a"") == 0
assert min_palindrome_cuts(""aa"") == 0
assert min_palindrome_cuts(""ab"") == 1
assert min_palindrome_cuts(""abc"") == 2",223
74740118232,count_components,"class UnionFind:
    def __init__(self,size):
        self.root = [i for i in range(size)]
        self.rank = [1] * size

    def find(self,x):
        if x != self.root[x]:
            self.root[x] = self.find(self.root[x])
        return self.root[x]

    def union(self,x,y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            if self.rank[rootX] > self.rank[rootY]:
                self.root[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.root[rootX] = rootY
            else:
                self.root[rootY] = rootX
                self.rank[rootX] += 1

def count_components(n, edges):
    uf = UnionFind(n)
    for A,B in edges:
        uf.union(A,B)

    count = 0
    for i in range(n):
        if i == uf.find(i):
            count += 1
    return count",223
3820363717,is_valid_url,"import re

def is_valid_url(url: str) -> bool:
    regex = re.compile(
        r'^(?:http|ftp)s?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain
        r'localhost|'  # localhost
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|'  # ...or ipv4
        r'\[?[A-F0-9]*:[A-F0-9:]+\]?)'  # ...or ipv6
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(regex, url) is not None",223
24148813812,nth_ugly_number,"def nth_ugly_number(n):
    ugly_numbers = [1]
    i2, i3, i5 = 0, 0, 0
    next_multiple_of_2 = 2
    next_multiple_of_3 = 3
    next_multiple_of_5 = 5

    for _ in range(1, n):
        next_ugly = min(next_multiple_of_2, next_multiple_of_3, next_multiple_of_5)
        ugly_numbers.append(next_ugly)

        if next_ugly == next_multiple_of_2:
            i2 += 1
            next_multiple_of_2 = ugly_numbers[i2] * 2
        if next_ugly == next_multiple_of_3:
            i3 += 1
            next_multiple_of_3 = ugly_numbers[i3] * 3
        if next_ugly == next_multiple_of_5:
            i5 += 1
            next_multiple_of_5 = ugly_numbers[i5] * 5

    return ugly_numbers[-1]",223
36294742000,zigzag_conversion,"def zigzag_conversion(s, numRows):
    if numRows == 1:
        return s
    
    result = ''
    
    for firstLetterIndex in range(numRows):
        upSkip, downSkip = numToSkip(firstLetterIndex, numRows)
        goingDown = True
        doNotAppend = False
        cursor = firstLetterIndex
        while cursor < len(s):
            if not doNotAppend:
                result += s[cursor]
            doNotAppend = False
            if goingDown:
                goingDown = False
                if downSkip <= 0:
                    doNotAppend = True
                    continue
                cursor += downSkip
            else:
                goingDown = True
                if upSkip <= 0:
                    doNotAppend = True
                    continue
                cursor += upSkip
    return result

def numToSkip(rowNum, numRows):
    down = (numRows - rowNum - 1) * 2 - 1
    up = (rowNum) * 2 - 1
    return up + 1, down + 1",223
25464765320,min_window_substring,"from collections import Counter

def min_window_substring(s, t):
    if len(s) < len(t) or len(s) == 0 or len(t) == 0: return """"
    
    tdict = Counter(t)
    dict = Counter()
    start, count = 0, len(t)
    minID, minLen = 0, float('inf')
    
    for i, v in enumerate(s):
        if v in tdict: 
            dict[v] += 1
            if dict[v] <= tdict[v]: 
                count -= 1
                
        while count == 0:
            if minLen > i - start + 1:
                minLen = i - start + 1
                minID = start 

            if s[start] in tdict:
                dict[s[start]] -= 1
                if dict[s[start]] < tdict[s[start]]: 
                    count += 1
            
            start += 1
            
    return s[minID: minLen + minID] if minLen != float('inf') else """"",223
12452044756,find_quadruplets,"def find_quadruplets(nums, target):
    nums.sort()
    results = []
    n = len(nums)
    for i in range(n-3):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        for j in range(i+1, n-2):
            if j > i+1 and nums[j] == nums[j-1]:
                continue
            left, right = j+1, n-1
            while left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                if total == target:
                    results.append([nums[i], nums[j], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left+1]:
                        left += 1
                    while left < right and nums[right] == nums[right-1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif total < target:
                    left += 1
                else:
                    right -= 1
    return results",222
38756840103,validate_bst,"from typing import List


class Node:
    def __init__(self, data, left_node=None, right_node=None):
        self.data = data
        self.left_node = left_node
        self.right_node = right_node


def validate_bst(root: Node) -> bool:
    if root is None:
        return True

    if root.left_node is not None and root.left_node.data >= root.data:
        return False

    if root.right_node is not None and root.right_node.data <= root.data:
        return False

    return validate_bst(root.left_node) and validate_bst(root.right_node)


if __name__ == ""__main__"":
    assert validate_bst(Node(2, Node(1), Node(3))) == True
    assert validate_bst(Node(5, Node(1), Node(4, Node(3), Node(6)))) == False
    assert validate_bst(Node(10, Node(5, Node(2), Node(8)), Node(15, Node(12), Node(20)))) == True",222
3665060602,find_quadruplets,"def find_quadruplets(nums):
    nums.sort()
    n = len(nums)
    res = []
    for i in range(n-3):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        for j in range(i+1, n-2):
            if j > i+1 and nums[j] == nums[j-1]:
                continue
            l, r = j+1, n-1
            while l < r:
                s = nums[i] + nums[j] + nums[l] + nums[r]
                if s < 0:
                    l += 1
                elif s > 0:
                    r -= 1
                else:
                    res.append([nums[i], nums[j], nums[l], nums[r]])
                    while l < r and nums[l] == nums[l+1]:
                        l += 1
                    while l < r and nums[r] == nums[r-1]:
                        r -= 1
                    l += 1
                    r -= 1
    return res",222
13507036951,generate_spiral_matrix,"def generate_spiral_matrix(n):
    matrix = [[0]*n for _ in range(n)]
    row_start, row_end = 0, n-1
    col_start, col_end = 0, n-1
    current = 1

    while row_start <= row_end and col_start <= col_end:
        for c in range(col_start, col_end+1):
            matrix[row_start][c] = current
            current += 1
        row_start += 1

        for r in range(row_start, row_end+1):
            matrix[r][col_end] = current
            current += 1
        col_end -= 1

        for c in range(col_end, col_start-1, -1):
            matrix[row_end][c] = current
            current += 1
        row_end -= 1

        for r in range(row_end, row_start-1, -1):
            matrix[r][col_start] = current
            current += 1
        col_start += 1

    return matrix",222
38121968250,nth_ugly_number,"def nth_ugly_number(n):
    ugly_numbers = [1]
    i2 = i3 = i5 = 0
    next_multiple_of_2 = 2
    next_multiple_of_3 = 3
    next_multiple_of_5 = 5

    for i in range(1, n):
        next_ugly_number = min(next_multiple_of_2, next_multiple_of_3, next_multiple_of_5)
        ugly_numbers.append(next_ugly_number)

        if next_ugly_number == next_multiple_of_2:
            i2 += 1
            next_multiple_of_2 = ugly_numbers[i2] * 2
        if next_ugly_number == next_multiple_of_3:
            i3 += 1
            next_multiple_of_3 = ugly_numbers[i3] * 3
        if next_ugly_number == next_multiple_of_5:
            i5 += 1
            next_multiple_of_5 = ugly_numbers[i5] * 5

    return ugly_numbers[-1]",222
14431060073,max_sum_submatrix,"import bisect
import sys

def max_sum_submatrix(matrix, k):
    """"""
    Finds the max sum of a rectangle in the matrix such that its sum is no larger than k.
    """"""
    if not matrix:
        return 0

    m, n = len(matrix), len(matrix[0])
    ans = -sys.maxsize

    for l in range(n):
        cul_list = [0 for _ in range(m)]
        for r in range(l, n):
            for i in range(m):
                cul_list[i] += matrix[i][r]
            slist = []
            num = 0
            for val in cul_list:
                num += val
                if num == k:
                    return k
                if num < k:
                    ans = max(ans, num)
                i = bisect.bisect_left(slist, num - k)
                if i != len(slist):
                    ans = max(ans, num - slist[i])
                bisect.insort(slist, num)
    return ans if ans <= k else -1",221
34825466369,tree_sum,"# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def tree_sum(root):
    if root is None:
        return 0
    else:
        return root.val + tree_sum(root.left) + tree_sum(root.right)

# Construct the tree for the first test case
root1 = TreeNode(1)
root1.left = TreeNode(2)
root1.right = TreeNode(3)
root1.left.left = TreeNode(4)
root1.left.right = TreeNode(5)
root1.right.right = TreeNode(6)

# Construct the tree for the second test case
root2 = TreeNode(10)
root2.left = TreeNode(5)
root2.right = TreeNode(-3)
root2.left.left = TreeNode(3)
root2.left.right = TreeNode(2)
root2.right.right = TreeNode(11)

# Test the function
assert tree_sum(root1) == 21
assert tree_sum(root2) == 28",221
31160793371,min_length_substring,"from collections import Counter

def min_length_substring(s, t):
    if not s or not t:
        return -1

    t_count = Counter(t)
    required = len(t_count)
    formed = 0
    window_counts = Counter()
    ans = float(""inf""), None, None

    l = 0
    for r in range(len(s)):
        character = s[r]
        window_counts[character] += 1

        if character in t_count and window_counts[character] == t_count[character]:
            formed += 1

        while l <= r and formed == required:
            character = s[l]

            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)

            window_counts[character] -= 1
            if character in t_count and window_counts[character] < t_count[character]:
                formed -= 1

            l += 1

    return ans[0] if ans[0] != float(""inf"") else -1",221
21576088007,fourSum,"def fourSum(nums, target):
    nums.sort()
    result = []
    length = len(nums)
    for i in range(length-3):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        for j in range(i+1, length-2):
            if j > i+1 and nums[j] == nums[j-1]:
                continue
            left = j+1
            right = length-1
            while left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                if total == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left+1]:
                        left += 1
                    while left < right and nums[right] == nums[right-1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif total < target:
                    left += 1
                else:
                    right -= 1
    return result",220
31579946396,count_inversions,"def merge_count_split_inv(left, right):
    i, j = 0, 0
    inversions = 0
    merged = []
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
            inversions += len(left) - i
    merged += left[i:]
    merged += right[j:]
    return merged, inversions

def sort_and_count(arr):
    if len(arr) <= 1:
        return arr, 0
    mid = len(arr) // 2
    left_sorted, left_inv = sort_and_count(arr[:mid])
    right_sorted, right_inv = sort_and_count(arr[mid:])
    merged_sorted, split_inv = merge_count_split_inv(left_sorted, right_sorted)
    return merged_sorted, left_inv + right_inv + split_inv

def count_inversions(arr):
    _, inversions = sort_and_count(arr)
    return inversions",219
32538193695,find_longest_palindrome,"def find_longest_palindrome(s):
    if len(s) == 0:
        return """"
    max_length = 1
    start = 0
    length = len(s)
    low = 0
    high = 0
    for i in range(1, length):
        low = i - 1
        high = i
        while low >= 0 and high < length and s[low] == s[high]:
            if high - low + 1 > max_length:
                start = low
                max_length = high - low + 1
            low -= 1
            high += 1

        low = i - 1
        high = i + 1
        while low >= 0 and high < length and s[low] == s[high]:
            if high - low + 1 > max_length:
                start = low
                max_length = high - low + 1
            low -= 1
            high += 1

    return s[start:start + max_length]",219
24226769709,findTargetIndices,"def findTargetIndices(nums, target):
    first_occurrence = -1
    last_occurrence = -1
    left = 0
    right = len(nums) - 1
    
    # Find first occurrence
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            first_occurrence = mid
            right = mid - 1
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    left = 0
    right = len(nums) - 1
    
    # Find last occurrence
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            last_occurrence = mid
            left = mid + 1
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return [first_occurrence, last_occurrence]",219
37395181354,solution,"def solution(string):
    if len(string) == 0:
        return """"
    max_length = 1
    start = 0
    length = len(string)
    low = 0
    high = 0
    for i in range(1, length):
        low = i - 1
        high = i
        while low >= 0 and high < length and string[low] == string[high]:
            if (high - low + 1) > max_length:
                start = low
                max_length = high - low + 1
            low -= 1
            high += 1
        low = i - 1
        high = i + 1
        while low >= 0 and high < length and string[low] == string[high]:
            if (high - low + 1) > max_length:
                start = low
                max_length = high - low + 1
            low -= 1
            high += 1
    return string[start:start + max_length]",219
27092799050,minimum_distance,"import math

def minimum_distance(points):
    min_dist = float('inf')
    for i in range(len(points)):
        for j in range(i+1, len(points)):
            dist = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)
            if dist < min_dist:
                min_dist = dist
    return min_dist

assert minimum_distance([(0, 0), (3, 4), (1, 1)]) == 1.4142135623730951
assert minimum_distance([(1, 2), (4, 6), (5, 1), (2, 3)]) == 1.4142135623730951
assert minimum_distance([(0, 0), (1, 1), (2, 2)]) == 1.4142135623730951",218
33177927291,shortest_path,"from collections import deque

def shortest_path(grid):
    if not grid or not grid[0]:
        return -1
    
    m, n = len(grid), len(grid[0])
    if grid[0][0] == 1 or grid[-1][-1] != 2:
        return -1
    
    directions = [(0,1),(0,-1),(1,0),(-1,0)]
    queue = deque([(0,0,0)])
    visited = set([(0,0)])
    
    while queue:
        x, y, d = queue.popleft()
        if grid[x][y] == 2:
            return d
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != 1 and (nx, ny) not in visited:
                queue.append((nx, ny, d + 1))
                visited.add((nx, ny))
    return -1",218
30472465101,largest_rectangle_of_1s,"from typing import List

def largest_rectangle_of_1s(matrix: List[List[int]]) -> int:
    if not matrix:
        return 0
    m, n = len(matrix), len(matrix[0])
    heights = [0] * n
    max_area = 0
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                heights[j] += 1
            else:
                heights[j] = 0
        max_area = max(max_area, largest_rectangle_area(heights))
    return max_area

def largest_rectangle_area(heights: List[int]) -> int:
    heights.append(0)
    stack = [-1]
    ans = 0
    for i in range(len(heights)):
        while heights[i] < heights[stack[-1]]:
            h = heights[stack.pop()]
            w = i - stack[-1] - 1
            ans = max(ans, h * w)
        stack.append(i)
    heights.pop()
    return ans",218
74002480126,smallest_substring,"def smallest_substring(s, pattern):
    from collections import Counter
    pattern_count = Counter(pattern)
    required = len(pattern_count)
    formed = 0
    window_counts = Counter()
    ans = float(""inf""), None, None
    l = 0
    for r in range(len(s)):
        character = s[r]
        window_counts[character] += 1

        if character in pattern_count and window_counts[character] == pattern_count[character]:
            formed += 1

        while l <= r and formed == required:
            character = s[l]

            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)

            window_counts[character] -= 1
            if character in pattern_count and window_counts[character] < pattern_count[character]:
                formed -= 1

            l += 1    
    return """" if ans[0] == float(""inf"") else s[ans[1] : ans[2] + 1]",218
74960653305,find_odd,"def find_odd(integers):
    # Create a dictionary to store the count of each integer
    count_dict = {}
    
    # Iterate over the list and count the occurrences of each integer
    for num in integers:
        if num in count_dict:
            count_dict[num] += 1
        else:
            count_dict[num] = 1
    
    # Iterate over the dictionary and find the integer that appears an odd number of times
    for num, count in count_dict.items():
        if count % 2 != 0:
            return num


if __name__ == '__main__':
    from testfunc import test
    test_data = [
        ([20,1,-1,2,-2,3,3,5,5,1,2,2,20,20], 20),
        ([1,1,2,-2,5,2,4,4,-1,-2,5], -1),
        ([10], 10)
    ]
    test(find_odd, test_data)",218
2288777849,longest_palindromic_substring,"def longest_palindromic_substring(s):
    if not s:
        return """"
    
    n = len(s)
    start, max_length = 0, 1
    
    for i in range(n):
        # Odd length palindromes
        left, right = i - 1, i + 1
        while left >= 0 and right < n and s[left] == s[right]:
            if (right - left + 1) > max_length:
                start = left
                max_length = right - left + 1
            left -= 1
            right += 1
        
        # Even length palindromes
        left, right = i, i + 1
        while left >= 0 and right < n and s[left] == s[right]:
            if (right - left + 1) > max_length:
                start = left
                max_length = right - left + 1
            left -= 1
            right += 1
    
    return s[start:start + max_length]",218
2880598523,evaluate_expression,"def evaluate_expression(expression):
    expression = expression.replace(' ', '')
    tokens = []
    num = ''
    for char in expression:
        if char.isdigit():
            num += char
        else:
            tokens.append(int(num))
            tokens.append(char)
            num = ''
    tokens.append(int(num))

    i = 0
    while '*' in tokens or '/' in tokens:
        if tokens[i] == '*':
            tokens[i-1] = tokens[i-1] * tokens[i+1]
            del tokens[i:i+2]
        elif tokens[i] == '/':
            tokens[i-1] = tokens[i-1] // tokens[i+1]
            del tokens[i:i+2]
        else:
            i += 1
        if i == len(tokens):
            i = 0
    result = tokens[0]
    for i in range(1, len(tokens), 2):
        if tokens[i] == '+':
            result += tokens[i+1]
        else:
            result -= tokens[i+1]
    return result",218
24147786232,fourSum,"def fourSum(nums,target):

    nums.sort()
    ans = []
    n = len(nums)
    if not nums or n<4:
        return []
    for i in range(n):
        if i>0 and nums[i]==nums[i-1]:
            continue
        for j in range(i+1,n):
            if j>i+1 and nums[j]==nums[j-1]:
                continue
            p = j+1
            q = n-1
            while p<q:
                if nums[i]+nums[j]+nums[p]+nums[q]>target:
                    q-=1
                elif nums[i]+nums[j]+nums[p]+nums[q] < target:
                    p+=1
                else:
                    ans.append([nums[i],nums[j],nums[p],nums[q]])
                    p+=1
                    while p<q and nums[p]==nums[p-1]:
                        p+=1
                    q-=1
                    while p<q and nums[q]==nums[q+1]:
                        q-=1
    return ans",217
29292902836,four_sums,"def four_sums(nums):
    nums.sort()
    result = []
    for i in range(len(nums)-3):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        for j in range(i+1, len(nums)-2):
            if j > i+1 and nums[j] == nums[j-1]:
                continue
            l, r = j+1, len(nums)-1
            while l < r:
                total = nums[i] + nums[j] + nums[l] + nums[r]
                if total < 0:
                    l += 1
                elif total > 0:
                    r -= 1
                else:
                    result.append([nums[i], nums[j], nums[l], nums[r]])
                    while l < r and nums[l] == nums[l+1]:
                        l += 1
                    while l < r and nums[r] == nums[r-1]:
                        r -= 1
                    l += 1
                    r -= 1
    return result",217
11356723632,find_Kth_smallest,"def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1

def quick_select(arr, low, high, K):
    if low == high:
        return arr[low]

    pivot_index = partition(arr, low, high)

    if K == pivot_index:
        return arr[K]
    elif K < pivot_index:
        return quick_select(arr, low, pivot_index-1, K)
    else:
        return quick_select(arr, pivot_index+1, high, K)

def find_Kth_smallest(arr, K):
    if K < 0 or K >= len(arr):
        return None

    return quick_select(arr, 0, len(arr)-1, K-1)",217
73808855570,sum_of_tree,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def sum_of_tree(root):
    if root is None:
        return 0
    return root.val + sum_of_tree(root.left) + sum_of_tree(root.right)

# Test case 1
root1 = TreeNode(1)
root1.left = TreeNode(2)
root1.right = TreeNode(3)
root1.left.left = TreeNode(4)
root1.left.right = TreeNode(5)
root1.right.right = TreeNode(6)
assert sum_of_tree(root1) == 21

# Test case 2
root2 = TreeNode(1)
root2.left = TreeNode(2)
root2.right = TreeNode(3)
root2.left.left = TreeNode(4)
root2.left.right = TreeNode(5)
root2.right.left = TreeNode(6)
root2.right.right = TreeNode(7)
assert sum_of_tree(root2) == 28",217
14682162725,longest_common_subseq,"def longest_common_subseq(str1,str2):
  m = len(str1)
  n = len(str2)
  dp = [[0]*(n+1) for _ in range(m+1)]
  for i in range(1,m+1):
    for j in range(1,n+1):
      if str1[i-1] == str2[j-1]:
        dp[i][j] = dp[i-1][j-1]+1
      else:
        dp[i][j] = max(dp[i][j-1],dp[i-1][j])
  i,j = m,n
  result = """"
  while i>0 and j>0:
    if str1[i-1] == str2[j-1]:
      result = str1[i-1] + result
      i -= 1
      j -= 1
    elif dp[i][j-1] > dp[i-1][j]:
      j -= 1
    else:
      i -= 1
  return result",217
34574584835,find_list_intersection,"def find_list_intersection(list1, list2):
    """"""
    Finds the intersection of two lists.
    Returns a list of unique common elements sorted in ascending order.
    """"""
    set1 = set(list1)
    set2 = set(list2)
    intersection = list(set1.intersection(set2))
    return sorted(intersection)

# Testing the function with the provided test cases
assert find_list_intersection([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
assert find_list_intersection([5, 3, 2, 8], [3, 2]) == [2, 3]
assert find_list_intersection([10, 15, 20, 25], [20, 25, 30, 35]) == [20, 25]",216
12381552582,nth_prime,"def nth_prime(n):
    def is_prime(num):
        if num <= 1:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    prime_count = 0
    num = 2
    while True:
        if is_prime(num):
            prime_count += 1
            if prime_count == n:
                return num
        num += 1

# Testing the function
assert nth_prime(1) == 2
assert nth_prime(2) == 3
assert nth_prime(3) == 5
assert nth_prime(4) == 7
assert nth_prime(5) == 11
assert nth_prime(6) == 13
assert nth_prime(7) == 17
assert nth_prime(8) == 19
assert nth_prime(9) == 23
assert nth_prime(10) == 29",216
36888881751,fourSum,"def fourSum(nums, target):
    nums.sort()
    result = []
    n = len(nums)
    for i in range(n):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        for j in range(i+1, n):
            if j > i+1 and nums[j] == nums[j-1]:
                continue
            l, r = j+1, n-1
            while l < r:
                total = nums[i] + nums[j] + nums[l] + nums[r]
                if total == target:
                    result.append([nums[i], nums[j], nums[l], nums[r]])
                    l += 1
                    r -= 1
                    while l < r and nums[l] == nums[l-1]:
                        l += 1
                    while l < r and nums[r] == nums[r+1]:
                        r -= 1
                elif total < target:
                    l += 1
                else:
                    r -= 1
    return result",215
20064052562,count_distinct_elements,"def count_distinct_elements(arr, left, right):
    """"""
    Counts the distinct elements in a subarray of the given array.

    Parameters:
    arr (List[int]): The input array.
    left (int): The left index of the subarray (inclusive).
    right (int): The right index of the subarray (inclusive).

    Returns:
    int: The count of distinct elements in the subarray.
    """"""
    subarray = arr[left:right+1]
    distinct_elements = set(subarray)
    return len(distinct_elements)

# Test cases
assert count_distinct_elements([1, 2, 1, 3, 4, 3], 0, 2) == 2
assert count_distinct_elements([1, 2, 1, 3, 4, 3], 0, 5) == 4
assert count_distinct_elements([1, 2, 1, 3, 4, 3], 3, 3) == 1",215
17837926518,smallest_substring,"def smallest_substring(str, pattern):
    if not str or not pattern:
        return """"
    min_len = float('inf')
    min_substring = """"
    pattern_dict = {}
    for char in pattern:
        if char not in pattern_dict:
            pattern_dict[char] = 0
        pattern_dict[char] += 1
    
    start = 0
    matched = 0
    for end in range(len(str)):
        if str[end] in pattern_dict:
            if pattern_dict[str[end]] > 0:
                matched += 1
            pattern_dict[str[end]] -= 1
        
        while matched == len(pattern):
            if end - start + 1 < min_len:
                min_len = end - start + 1
                min_substring = str[start:end+1]
            
            if str[start] in pattern_dict:
                if pattern_dict[str[start]] == 0:
                    matched -= 1
                pattern_dict[str[start]] += 1
            start += 1
    return min_substring",215
44589069790,is_palindrome_with_trie,"class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

def is_palindrome_with_trie(s):
    s = ''.join(c.lower() for c in s if c.isalnum())
    trie = Trie()
    for i in range(len(s)):
        for j in range(i, len(s)):
            trie.insert(s[i:j+1])
    
    def check_palindrome(node, depth):
        if node.is_end_of_word and depth % 2 == 0:
            return True
        return any(check_palindrome(child, depth + 1) for child in node.children.values())
    
    return check_palindrome(trie.root, 0)",215
39814462551,next_permutation,"def next_permutation(nums):
    n = len(nums)
    # Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, the permutation is the last permutation.
    k = -1
    for i in range(n-2, -1, -1):
        if nums[i] < nums[i+1]:
            k = i
            break
    # If such an index is found, find the largest index l greater than k such that nums[k] < nums[l]
    if k != -1:
        for i in range(n-1, k, -1):
            if nums[i] > nums[k]:
                l = i
                break
        # Swap the value of nums[k] with that of nums[l]
        nums[k], nums[l] = nums[l], nums[k]
    # Reverse the sequence from nums[k + 1] up to and including the final element nums[n]
    nums[k+1:] = reversed(nums[k+1:])
    return nums",215
25074802973,calculate_levenshtein_distance,"def calculate_levenshtein_distance(s1, s2):
    """"""
    Calculates the Levenshtein distance between two strings.
    """"""
    if len(s1) < len(s2):
        return calculate_levenshtein_distance(s2, s1)

    # len(s1) >= len(s2)
    if len(s2) == 0:
        return len(s1)

    previous_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1  # j+1 instead of j since previous_row and current_row are one character longer
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
    
    return previous_row[-1]",215
26310558993,is_mountain_array,"def is_mountain_array(nums):
    n = len(nums)
    if n < 3:
        return False
    v =  bin_search(nums)

    if v == -1 or v == 0 or v == n-1:
        return False
    
    for i in range(v):
        if nums[i] >= nums[i+1]:
            return False
        
    for i in range(v, n-1):
        if nums[i] <= nums[i+1]:
            return False
    return True

def bin_search(nums):
    n = len(nums)
    if n < 3:
        return -1 
    left, right = 0, len(nums)-1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] < nums[mid+1]:
            left = mid + 1
        else:
            right = mid
    if left+1 != len(nums) and nums[left] > nums[left+1]:
        return left
    return -1",214
2260158137,unique_path_with_obstacles,"def unique_path_with_obstacles(obstacleGrid):
    columnLen = len(obstacleGrid[0])
    rowLen = len(obstacleGrid)
    note = [0] * columnLen
    ret = 0

    # 处理初始上边界并用记事本note保存
    for i,v in enumerate(obstacleGrid[0]):
        if v == 1:
            break
        note[i] = 1

    if rowLen == 1:
        return note[-1]

    for r in range(1, rowLen):
        for c in range(columnLen):

            # 当前位置为障碍物
            if obstacleGrid[r][c] == 1:
                ret = 0
                note[c] = 0
                continue
            # 当前位置位于左边界
            if c == 0:
                ret = note[c]
                continue

            # 普通情况
            ret = ret + note[c]
            note[c] = ret

    return ret",214
12289339661,find_occurrences,"from typing import List


def find_occurrences(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    first = last = -1

    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            first = mid
            right = mid - 1
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    if first == -1:
        return 0

    left, right = first, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            last = mid
            left = mid + 1
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return last - first + 1",214
32402467922,binary_search,"def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# Test cases
assert binary_search([1, 2, 3, 4, 5], 3) == 2
assert binary_search([1, 2, 3, 4, 5], 6) == -1
assert binary_search([1, 3, 5, 7, 9], 7) == 3
assert binary_search([1, 3, 5, 7, 9], 1) == 0
assert binary_search([1, 3, 5, 7, 9], 9) == 4",214
370918606,longest_balanced_subseq,"def longest_balanced_subseq(str, n): 
    max_len = 0
    count0 = 0
    count1 = 0
    diff = 0
    len1 = 0
    for i in range(n): 
        if str[i] == '0': 
            count0 += 1
        else: 
            count1 += 1
        if (count0 == count1): 
            len1 = i + 1
            if max_len < len1: 
                max_len = len1
    count0 = 0
    count1 = 0
    for i in range(n - 1, -1, -1): 
        if str[i] == '0': 
            count0 += 1
        else: 
            count1 += 1
        if (count0 == count1): 
            len1 = i + 1
            if max_len < len1: 
                max_len = len1
    return max_len",214
26126492226,valid_path,"from typing import List

def valid_path(n: int, edges: List[List[int]], source: int, destination: int) -> bool:
    origin = [[] for _ in range(n)]
    for e0, e1 in edges:
        origin[e0].append(e1)
        origin[e1].append(e0)
    visit = []

    def dfs(des):
        if des == source:
            return True
        if des not in visit:
            visit.append(des)
            for x in origin[des]:
                if dfs(x):
                    return True
        return False

    return dfs(destination)

if __name__ == '__main__':
    print(valid_path(3, [[0,1],[1,2],[2,0]], 0, 2))
    print(valid_path(6, [[0,1],[0,2],[3,4],[3,5]], 0, 5))
    print(valid_path(3, [[0,1],[1,2],[2,0]], 0, 1))",214
41694005286,min_operations_to_palindrome,"def min_operations_to_palindrome(s):
    n = len(s)
    dp = [[0] * (n+1) for _ in range(n+1)]
    for i in range(n):
        dp[i][i] = 1
    for cl in range(2, n+1):
        for i in range(n-cl+1):
            j = i+cl-1
            if s[i] == s[j] and cl == 2:
                dp[i][j] = 2
            elif s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i][j-1], dp[i+1][j])
    return n - dp[0][n-1]

assert min_operations_to_palindrome(""abcd"") == 3
assert min_operations_to_palindrome(""aabb"") == 2
assert min_operations_to_palindrome(""abcba"") == 0",213
39768219136,top_k_frequent,"import heapq
from collections import Counter

def top_k_frequent(nums, k):
    """"""
    Find the top k frequent elements in a given list of integers.

    :param nums: List of integers
    :param k: Integer indicating the number of top frequent elements to find
    :return: List of top k frequent elements
    """"""
    d = Counter(nums)
    heap = []
    for i in d:
        heapq.heappush(heap, (-d[i], i))
    res = []
    for _ in range(k):
        res.append(heapq.heappop(heap)[1])
    return res

# Test cases
assert top_k_frequent([1,1,1,2,2,3], 2) == [1, 2]
assert top_k_frequent([1], 1) == [1]
assert top_k_frequent([4,1,2,2,3,3,3,4,4,4], 3) == [4, 3, 2]",213
25617941880,largest_Divisible_by_3,"def largest_Divisible_by_3(n):
    digits = [int(d) for d in str(n)]
    digits.sort(reverse=True)
    total = sum(digits)
    remainder = total % 3
    if remainder == 0:
        return int("""".join([str(d) for d in digits]))
    elif remainder == 1:
        for i in range(len(digits)):
            if digits[i] % 3 == 1:
                del digits[i]
                return int("""".join([str(d) for d in digits]))
        del digits[0]
        del digits[0]
        return int("""".join([str(d) for d in digits]))
    elif remainder == 2:
        for i in range(len(digits)):
            if digits[i] % 3 == 2:
                del digits[i]
                return int("""".join([str(d) for d in digits]))
        del digits[0]
        del digits[1]
        return int("""".join([str(d) for d in digits]))",213
33829232777,count_inversions,"def merge_count_split_inv(left, right):
    i, j = 0, 0
    count = 0
    merged = []
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
            count += len(left) - i
    merged += left[i:]
    merged += right[j:]
    return merged, count

def sort_count_split_inv(arr):
    if len(arr) <= 1:
        return arr, 0
    mid = len(arr) // 2
    left, count_left = sort_count_split_inv(arr[:mid])
    right, count_right = sort_count_split_inv(arr[mid:])
    merged, count_split = merge_count_split_inv(left, right)
    return merged, count_left + count_right + count_split

def count_inversions(arr):
    _, count = sort_count_split_inv(arr)
    return count",212
4138783781,generate_combinations,"def generate_combinations(list_of_arrays):
    if not list_of_arrays:
        return []
    
    # Function to multiply arrays
    def multiply(arrays, prefix=""""):
        if not arrays:
            return [prefix]
        
        result = []
        current_array = arrays[0]
        for item in current_array:
            result.extend(multiply(arrays[1:], prefix + item))
        return result
    
    return multiply(list_of_arrays)


# Test cases
assert generate_combinations([[""a"", ""b""], [""c"", ""d""]]) == ['ac', 'ad', 'bc', 'bd']
assert generate_combinations([[""x"", ""y""], [""z""], [""m"", ""n""]]) == ['xzm', 'xzn', 'yzm', 'yzn']
assert generate_combinations([[""1"", ""2""], [""3""], [""4"", ""5""], [""6""]]) == ['1346', '1356', '2346', '2356']",212
39601309513,kth_smallest_element,"def partition(arr, low, high):
    i = (low-1)
    pivot = arr[high]

    for j in range(low, high):
        if arr[j] <= pivot:
            i = i+1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i+1], arr[high] = arr[high], arr[i+1]
    return (i+1)

def quickSelect(arr, low, high, k):
    if (k > 0 and k <= high - low + 1):
        index = partition(arr, low, high)

        if (index - low == k-1):
            return arr[index]
        if (index - low > k-1):
            return quickSelect(arr, low, index-1, k)

        return quickSelect(arr, index+1, high, k-index+low-1)

def kth_smallest_element(arr, k):
    return quickSelect(arr, 0, len(arr)-1, k)",212
32863125434,ways_to_sum,"def ways_to_sum(n):
    if n == 0:
        return 1
    if n < 0:
        return 0
    return ways_to_sum(n-1) + ways_to_sum(n-3) + ways_to_sum(n-4)

# This function will cause a recursion error for large n due to the exponential time complexity.
# To improve it, we can use dynamic programming to store the results of subproblems.
def ways_to_sum_dp(n):
    if n == 0:
        return 1
    dp = [0] * (n+1)
    dp[0] = 1
    for i in range(1, n+1):
        dp[i] += dp[i-1] if i-1 >= 0 else 0
        dp[i] += dp[i-3] if i-3 >= 0 else 0
        dp[i] += dp[i-4] if i-4 >= 0 else 0
    return dp[n]",211
36934158421,count_occurrences,"def binary_search_leftmost(arr, target):
    left = 0
    right = len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left

def binary_search_rightmost(arr, target):
    left = 0
    right = len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid - 1
    return right

def count_occurrences(arr, target):
    leftmost = binary_search_leftmost(arr, target)
    if leftmost >= len(arr) or arr[leftmost] != target:
        return 0
    rightmost = binary_search_rightmost(arr, target)
    return rightmost - leftmost + 1",211
40220104102,word_pattern_match,"def word_pattern_match(pattern: str, input_string: str) -> bool:
    def backtrack(pattern_index, string_index, mapping, reverse_mapping):
        if pattern_index == len(pattern) and string_index == len(input_string):
            return True
        if pattern_index >= len(pattern) or string_index >= len(input_string):
            return False

        char = pattern[pattern_index]
        for end in range(string_index, len(input_string)):
            word = input_string[string_index:end+1]
            if char in mapping and mapping[char] == word:
                if backtrack(pattern_index + 1, end + 1, mapping, reverse_mapping):
                    return True
            elif char not in mapping and word not in reverse_mapping:
                mapping[char] = word
                reverse_mapping[word] = char
                if backtrack(pattern_index + 1, end + 1, mapping, reverse_mapping):
                    return True
                del mapping[char], reverse_mapping[word]
        return False

    return backtrack(0, 0, {}, {})",211
21316943937,longest_substring_with_k_distinct,"def longest_substring_with_k_distinct(str1, k):
    window_start, max_length = 0, 0
    char_frequency = {}

    # in the following loop we'll try to extend the range [window_start, window_end]
    for window_end in range(len(str1)):
        right_char = str1[window_end]
        if right_char not in char_frequency:
            char_frequency[right_char] = 0
        char_frequency[right_char] += 1

        # shrink the sliding window, until we are left with 'k' distinct characters in the char_frequency
        while len(char_frequency) > k:
            left_char = str1[window_start]
            char_frequency[left_char] -= 1
            if char_frequency[left_char] == 0:
                del char_frequency[left_char]
            window_start += 1  # shrink the window
        # remember the maximum length so far
        max_length = max(max_length, window_end - window_start + 1)

    return max_length",211
20528048810,max_subarray_sum_circular,"def max_subarray_sum_circular(arr):
    def kadane(nums):
        n = len(nums)
        max_ending_here = max_so_far = nums[0]
        for i in range(1, n):
            max_ending_here = max(nums[i], max_ending_here + nums[i])
            max_so_far = max(max_so_far, max_ending_here)
        return max_so_far
    
    def reverse_kadane(nums):
        n = len(nums)
        min_ending_here = min_so_far = nums[0]
        for i in range(1, n):
            min_ending_here = min(nums[i], min_ending_here + nums[i])
            min_so_far = min(min_so_far, min_ending_here)
        return min_so_far
    
    max_kadane = kadane(arr)
    max_wrap = sum(arr) - reverse_kadane(arr)
    if max_wrap == 0:
        return max_kadane
    return max(max_kadane, max_wrap)",211
13148152299,nthUglyNumber,"def nthUglyNumber(n):
    ugly = [1]
    i2 = i3 = i5 = 0
    next_multiple_of_2 = 2
    next_multiple_of_3 = 3
    next_multiple_of_5 = 5
    
    for i in range(1, n):
        next_ugly = min(next_multiple_of_2, next_multiple_of_3, next_multiple_of_5)
        ugly.append(next_ugly)
        
        if next_ugly == next_multiple_of_2:
            i2 += 1
            next_multiple_of_2 = ugly[i2] * 2
        if next_ugly == next_multiple_of_3:
            i3 += 1
            next_multiple_of_3 = ugly[i3] * 3
        if next_ugly == next_multiple_of_5:
            i5 += 1
            next_multiple_of_5 = ugly[i5] * 5
            
    return ugly[-1]",211
6456587918,onesMinusZeros,"def onesMinusZeros(grid):
    lenRow = len(grid)
    lenCol = len(grid[0])
    rowWiseSum = [0 for _ in range(lenRow)]
    colWiseSum = [0 for _ in range(lenCol)]

    for i in range(lenRow):
        for j in range(lenCol):
            if grid[i][j] == 0:
                rowWiseSum[i] -= 1
            else:
                rowWiseSum[i] += 1
    for i in range(lenCol):
        for j in range(lenRow):
            if grid[j][i] == 0:
                colWiseSum[i] -= 1
            else:
                colWiseSum[i] += 1

    answer = [[] for i in range(lenRow)]

    for i in range(lenRow):
        for j in range(lenCol):
            net = rowWiseSum[i] + colWiseSum[j]
            answer[i].append(net)
    return answer",210
15951798591,is_valid_shuffle,"def is_valid_shuffle(str1, str2, shuffle):
    """"""
    Check if 'shuffle' is a valid shuffle of 'str1' and 'str2'.
    """"""
    if len(str1) + len(str2) != len(shuffle):
        return False
    
    dp = [[False] * (len(str2) + 1) for _ in range(len(str1) + 1)]
    dp[0][0] = True
    
    for i in range(len(str1) + 1):
        for j in range(len(str2) + 1):
            if i > 0:
                dp[i][j] |= dp[i - 1][j] and str1[i - 1] == shuffle[i + j - 1]
            if j > 0:
                dp[i][j] |= dp[i][j - 1] and str2[j - 1] == shuffle[i + j - 1]
    
    return dp[len(str1)][len(str2)]",210
6517998392,minPathSum,"def minPathSum(grid):
    # Create matrix to store min value
    nRow = len(grid)
    nCol = len(grid[0])
    dp = [[ 0 for i in range(nCol) ] for j in range(nRow) ]
        
    # Initialize matrix
    dp[0][0] = grid[0][0]
    for i in range(1,nCol):
        dp[0][i] = dp[0][i-1] + grid[0][i]
    for j in range(1,nRow):
        dp[j][0] = dp[j-1][0] + grid[j][0]
        
    # Dynamic programming for min path
    for i in range(1,nRow):
        for j in range(1,nCol):
            dp[i][j] = grid[i][j] + min( dp[i][j-1], dp[i-1][j] )
    
    return int(dp[nRow-1][nCol-1])",210
42590136093,minimum_Steps,"from collections import deque

def minimum_Steps(grid, src_row, src_col, dst_row, dst_col):
    N = len(grid)
    visited = [[False for _ in range(N)] for _ in range(N)]
    queue = deque([(src_row, src_col, 0)])
    visited[src_row][src_col] = True

    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while queue:
        row, col, steps = queue.popleft()

        if row == dst_row and col == dst_col:
            return steps

        for dr, dc in directions:
            nr, nc = row + dr, col + dc

            if 0 <= nr < N and 0 <= nc < N and grid[nr][nc] == 0 and not visited[nr][nc]:
                queue.append((nr, nc, steps + 1))
                visited[nr][nc] = True

    return -1",210
23656483833,shortest_trans_sequence,"from collections import defaultdict, deque

def shortest_trans_sequence(beginWord, endWord, wordList):
    length = len(beginWord)
    d = defaultdict(list)
    if not beginWord or not endWord or not wordList or endWord not in wordList:
        return 0

    for word in wordList:
        for i in range(length):
            d[word[:i] + ""*"" + word[i + 1:]].append(word)

    q = deque([(beginWord, 1)])
    seen = {beginWord: True}

    while q:
        curr_word, level = q.popleft()

        for i in range(length):

            temp = curr_word[:i] + ""*"" + curr_word[i + 1:]
            for intermediateWord in d[temp]:
                if intermediateWord == endWord:
                    return level + 1

                if intermediateWord not in seen:
                    seen[intermediateWord] = True
                    q.append((intermediateWord, level + 1))

    return 0",209
25052258927,levenshtein_distance,"def levenshtein_distance(str1, str2):
    len1 = len(str1)
    len2 = len(str2)
    matrix = [[0 for _ in range(len2 + 1)] for _ in range(len1 + 1)]
    for i in range(len1 + 1):
        matrix[i][0] = i
    for j in range(len2 + 1):
        matrix[0][j] = j
    for i in range(1, len1 + 1):
        for j in range(1, len2 + 1):
            if str1[i - 1] == str2[j - 1]:
                cost = 0
            else:
                cost = 1
            matrix[i][j] = min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost)
    return matrix[len1][len2]",209
41693760496,multiply_without_operator,"def multiply_without_operator(a, b):
    """"""
    Multiplies two integers without using the multiplication operator.
    
    :param a: First integer
    :param b: Second integer
    :return: The product of the two integers
    """"""
    # Determine the sign of the result
    sign = -1 if (a < 0) ^ (b < 0) else 1
    
    # Convert both numbers to positive for simplicity
    a, b = abs(a), abs(b)
    
    # Initialize result
    result = 0
    
    # Iterate over the bits of b
    while b > 0:
        # If the current bit of b is set, add the corresponding power of two times a to the result
        if b & 1:
            result += a
        
        # Double the value of a (equivalent to a*2)
        a <<= 1
        # Move to the next bit of b
        b >>= 1
    
    return sign * result",209
25218218993,count_inversions,"def merge_count_split_inv(left, right):
    i = j = inv_count = 0
    merged = []
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
            inv_count += len(left) - i
    merged += left[i:]
    merged += right[j:]
    return merged, inv_count

def sort_count(arr):
    if len(arr) <= 1:
        return arr, 0
    mid = len(arr) // 2
    left, left_inv = sort_count(arr[:mid])
    right, right_inv = sort_count(arr[mid:])
    merged, split_inv = merge_count_split_inv(left, right)
    total_inv = left_inv + right_inv + split_inv
    return merged, total_inv

def count_inversions(arr):
    _, inversions = sort_count(arr)
    return inversions",209
30646596091,find_max_meeting_rooms,"def find_max_meeting_rooms(meetings):
    if not meetings:
        return 0

    # Sort meetings based on start time
    meetings.sort(key=lambda x: x[0])

    # Initialize a min heap to store end times of meetings
    import heapq
    min_heap = []

    # Push end time of the first meeting to the heap
    heapq.heappush(min_heap, meetings[0][1])

    for i in range(1, len(meetings)):
        # If the current meeting starts after the end time of the meeting at the top of the heap,
        # pop the top of the heap as this meeting room can be reused
        if meetings[i][0] >= min_heap[0]:
            heapq.heappop(min_heap)

        # Push the end time of the current meeting to the heap
        heapq.heappush(min_heap, meetings[i][1])

    # The number of meeting rooms required is the size of the heap
    return len(min_heap)",208
3391264503,calculate_trapped_water,"def calculate_trapped_water(walls):
    """"""
    Calculate the total amount of trapped rainwater.
    
    :param walls: List of non-negative integers representing the heights of walls.
    :return: The total volume of trapped water.
    """"""
    n = len(walls)
    if n < 3:
        return 0

    left_max = [0] * n
    right_max = [0] * n
    water_trapped = 0

    left_max[0] = walls[0]
    for i in range(1, n):
        left_max[i] = max(left_max[i-1], walls[i])

    right_max[n-1] = walls[n-1]
    for i in range(n-2, -1, -1):
        right_max[i] = max(right_max[i+1], walls[i])

    for i in range(n):
        water_trapped += min(left_max[i], right_max[i]) - walls[i]

    return water_trapped",208
70196172155,find_kth_largest,"def find_kth_largest(nums, k):
    def partition(left, right):
        pivot = nums[right]
        i = left - 1
        for j in range(left, right):
            if nums[j] <= pivot:
                i += 1
                nums[i], nums[j] = nums[j], nums[i]
        nums[i + 1], nums[right] = nums[right], nums[i + 1]
        return i + 1
    def quickselect(left, right, k_smallest):
        if left == right:
            return nums[left]
        pivot_index = partition(left, right)
        if k_smallest == pivot_index:
            return nums[k_smallest]
        elif k_smallest < pivot_index:
            return quickselect(left, pivot_index - 1, k_smallest)
        else:
            return quickselect(pivot_index + 1, right, k_smallest)
    return quickselect(0, len(nums) - 1, len(nums) - k)",208
10665618716,is_match,"from functools import lru_cache

def is_match(s: str, p: str) -> bool:

    @lru_cache()
    def match(i: int, j: int) -> bool:
        if i == len(s) and j == len(p):
            return True
        if j == len(p):
            return False

        if j+1 < len(p) and p[j+1] == '*':
            if i < len(s) and (s[i] == p[j] or p[j] == '?'):
                return match(i+1, j) or match(i, j+2) or match(i+1, j+2)
            else:
                return match(i, j+2)
        else:
            if i < len(s) and (s[i] == p[j] or p[j] == '?' or p[j] == '*'):
                return match(i+1, j+1)
            else:
                return False
    return match(0, 0)",208
71057653806,smallest_window,"from collections import Counter

def smallest_window(str1, pattern):
    pattern_count = Counter(pattern)
    start = 0
    min_len = float('inf')
    min_window = """"
    required = len(pattern_count)
    formed = 0
    window_counts = {}
    
    for end in range(len(str1)):
        char = str1[end]
        window_counts[char] = window_counts.get(char, 0) + 1
        
        if char in pattern_count and window_counts[char] == pattern_count[char]:
            formed += 1
        
        while start <= end and formed == required:
            char = str1[start]
            
            if end - start + 1 < min_len:
                min_len = end - start + 1
                min_window = str1[start:end+1]
            
            window_counts[char] -= 1
            if char in pattern_count and window_counts[char] < pattern_count[char]:
                formed -= 1
            
            start += 1
    
    return min_window",208
15520250969,kth_smallest,"import random

def partition(nums, low, high):
    pivot = nums[high]
    i = low - 1
    for j in range(low, high):
        if nums[j] <= pivot:
            i += 1
            nums[i], nums[j] = nums[j], nums[i]
    nums[i+1], nums[high] = nums[high], nums[i+1]
    return i + 1

def quickselect(nums, k, low, high):
    if low == high:
        return nums[low]

    pivot_index = partition(nums, low, high)

    if k == pivot_index:
        return nums[k]
    elif k < pivot_index:
        return quickselect(nums, k, low, pivot_index - 1)
    else:
        return quickselect(nums, k, pivot_index + 1, high)

def kth_smallest(nums, k):
    return quickselect(nums, k-1, 0, len(nums) - 1)",207
26376917040,can_finish,"def can_finish(numCourses, prerequisites):
    # circle detection with DFS
    start_time = [0] * numCourses
    finish_time = [0] * numCourses
    color = [0] * numCourses # 0:not visit, 1:in visit, 2: end visit
    time = 0

    def dfs():
        for i in range(numCourses):
            if color[i] == 0:
                if dfs_visit(i):
                    return False
        return True

    def dfs_visit(i):
        nonlocal time
        time += 1
        start_time[i] = time
        color[i] = 1
        for p, q in prerequisites:
            if p == i:
                if color[q] == 1 or (color[q] == 0 and dfs_visit(q)):
                    return True
        time += 1
        finish_time[i] = time
        color[i] = 2
        return False

    return dfs()",207
73422123729,minEditDist,"def minEditDist(str1, str2): 
    len1 = len(str1) 
    len2 = len(str2) 
    dp = [[0 for x in range(len2 + 1)] for x in range(len1 + 1)] 
  
    for i in range(len1 + 1): 
        for j in range(len2 + 1): 
  
            if i == 0: 
                dp[i][j] = j
  
            elif j == 0: 
                dp[i][j] = i
  
            elif str1[i-1] == str2[j-1]: 
                dp[i][j] = dp[i-1][j-1] 
  
            else: 
                dp[i][j] = 1 + min(dp[i][j-1],        # Insert 
                                   dp[i-1][j],        # Remove 
                                   dp[i-1][j-1])      # Replace 
  
    return dp[len1][len2]",207
12458236295,is_valid_bst,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_valid_bst(root):
    def helper(node, lower=float('-inf'), upper=float('inf')):
        if not node:
            return True

        val = node.val
        if val <= lower or val >= upper:
            return False

        if not helper(node.right, val, upper):
            return False
        if not helper(node.left, lower, val):
            return False
        return True

    return helper(root)

# Test cases
root1 = TreeNode(2)
root1.left = TreeNode(1)
root1.right = TreeNode(3)

root2 = TreeNode(5)
root2.left = TreeNode(1)
root2.right = TreeNode(4, TreeNode(3), TreeNode(6))

assert is_valid_bst(root1) == True
assert is_valid_bst(root2) == False",207
25895361929,smallest_window,"from collections import Counter

def smallest_window(s, pattern):
    str_len = len(s)
    pat_len = len(pattern)
    pat_freq = Counter(pattern)
    min_len = float('inf')
    min_window = """"
    start = 0
    count = 0
    str_freq = {}

    for j in range(str_len):
        str_freq[s[j]] = str_freq.get(s[j], 0) + 1

        if str_freq[s[j]] <= pat_freq[s[j]]:
            count += 1

        if count == pat_len:
            while str_freq[s[start]] > pat_freq.get(s[start], 0):
                if str_freq[s[start]] > pat_freq.get(s[start], 0):
                    str_freq[s[start]] -= 1
                start += 1

            window_len = j - start + 1
            if min_len > window_len:
                min_len = window_len
                min_window = s[start:j+1]

    return min_window",207
41715052149,count_occurrences,"def count_occurrences(A, x):
    def find_leftmost():
        left, right = 0, len(A) - 1
        while left < right:
            mid = left + (right - left) // 2
            if A[mid] < x:
                left = mid + 1
            else:
                right = mid
        return left if A[left] == x else -1

    def find_rightmost():
        left, right = 0, len(A) - 1
        while left < right:
            mid = left + (right - left + 1) // 2
            if A[mid] > x:
                right = mid - 1
            else:
                left = mid
        return left if A[left] == x else -1

    leftmost = find_leftmost()
    if leftmost == -1:
        return 0
    rightmost = find_rightmost()
    return rightmost - leftmost + 1",206
27426571566,kth_to_last,"class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.length = 0

    def append(self, value):
        new_node = Node(value)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            self.tail = new_node
        self.length += 1

    def kth_to_last(self, k):
        slow = self.head
        fast = self.head
        for _ in range(k):
            fast = fast.next
        while fast is not None:
            slow = slow.next
            fast = fast.next
        return slow.value

def kth_to_last(k, lst):
    ll = LinkedList()
    for elem in lst:
        ll.append(elem)
    return ll.kth_to_last(k)",206
37412176563,find_target_positions,"def find_target_positions(nums, target):
    def find_left(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left if left < len(nums) and nums[left] == target else -1

    def find_right(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid - 1
        return right if right >= 0 and nums[right] == target else -1

    left = find_left(nums, target)
    right = find_right(nums, target)
    return [left, right]",206
33813325955,find_node_index,"class Node:
    def __init__(self, x, next=None):
        self.val = int(x)
        self.next = next

def find_node_index(head, target):
    index = 0
    current = head
    while current:
        if current.val == target.val:
            return index
        current = current.next
        index += 1
    return -1

# Create the linked list for testing
node1 = Node(7)
node2 = Node(13)
node3 = Node(11)
node4 = Node(10)
node5 = Node(1)
node1.next = node2
node2.next = node3
node3.next = node4
node4.next = node5
head = node1

# Test cases
assert find_node_index(head, Node(10)) == 3
assert find_node_index(head, Node(13)) == 1
assert find_node_index(head, Node(5)) == -1",206
39557091522,minimum_cost,"import heapq

def minimum_cost(costs, k, cand):
    n = len(costs)
    l , r = cand-1, n-cand
    leftHeap = costs[:min(l+1,n)] + [float(""inf"")]
    rightHeap = costs[max(0,r,l+1):] + [float(""inf"")]
    heapq.heapify(leftHeap)
    heapq.heapify(rightHeap)
    res = 0
    while k :
        min1,min2 = leftHeap[0],rightHeap[0]
        if min1 <= min2 :
            res += heapq.heappop(leftHeap)
            l += 1
            if l < r and l<n :
                heapq.heappush(leftHeap,costs[l])
        else:
            res += heapq.heappop(rightHeap)
            r -= 1
            if l < r and r>=0 :
                heapq.heappush(rightHeap,costs[r])
        k -= 1
    return res",206
19929119434,can_reorder_doubled,"def can_reorder_doubled(arr):
    from collections import Counter
    negative = Counter()
    positive = Counter()
    
    for each in arr:
        if each >= 0:
            positive[each] += 1
        else:
            negative[each] += 1
    
    for each in sorted(positive):
        if positive[each] > 0:
            if (each * 2 in positive) and positive[each * 2] >= positive[each]:
                positive[each * 2] -= positive[each]
                positive[each] = 0
            else:
                return False
    
    for each in sorted(negative, reverse=True):
        if negative[each] > 0:
            if (each * 2 in negative) and negative[each * 2] >= negative[each]:
                negative[each * 2] -= negative[each]
                negative[each] = 0
            else:
                return False
    
    return True",206
30651311516,count_pattern_ways,"def count_pattern_ways(s: str, pattern: str) -> int:
    m, n = len(s), len(pattern)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = 1
    for j in range(1, n + 1):
        if pattern[j - 1] == '*':
            dp[0][j] = dp[0][j - 1]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if pattern[j - 1] in {s[i - 1], '?'}:
                dp[i][j] = dp[i - 1][j - 1]
            elif pattern[j - 1] == '*':
                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
    return dp[m][n]",206
20112229981,uniquePaths,"def uniquePaths(obstacleGrid):
    m=len(obstacleGrid)
    n=len(obstacleGrid[0])
        
    dp=[[-1 for i in range (n+1)] for j in range (m+1)]
        
    ans=helper(obstacleGrid,m-1,n-1,dp)
        
    return ans 
        
def helper(obstacleGrid,row,col,dp):
        
        if row==0 and col==0 and obstacleGrid[row][col]!=1:
                return 1
        
        if row<0 or col<0:
                return 0
        
        if row>=0 and col>=0 and obstacleGrid[row][col]==1:
                return 0
        
        if dp[row][col]!=-1:
                return dp[row][col]
        
        up=helper(obstacleGrid,row-1,col,dp)
        
        left=helper(obstacleGrid,row,col-1,dp)
        
        dp[row][col]=up+left
        return dp[row][col]",206
1080200740,max_zero_sum_subarrays,"def max_zero_sum_subarrays(arr):
    sum_index = {0: -1}
    sum_val = 0
    max_len = 0
    for i in range(len(arr)):
        sum_val += arr[i]
        if sum_val in sum_index:
            max_len = max(max_len, i - sum_index[sum_val])
        else:
            sum_index[sum_val] = i
    return max_len

def max_zero_sum_subarrays_with_count(arr):
    sum_index = {0: [-1]}
    sum_val = 0
    max_count = 0
    for i in range(len(arr)):
        sum_val += arr[i]
        if sum_val in sum_index:
            max_count += len(sum_index[sum_val])
            sum_index[sum_val].append(i)
        else:
            sum_index[sum_val] = [i]
    return max_count

def max_zero_sum_subarrays(arr):
    return max_zero_sum_subarrays_with_count(arr)",205
1472474578,heap_sort,"def heapify(nums, heap_size, root_index):  
    largest = root_index
    left_child = (2 * root_index) + 1
    right_child = (2 * root_index) + 2

    if left_child < heap_size and nums[left_child] > nums[largest]:
        largest = left_child

    if right_child < heap_size and nums[right_child] > nums[largest]:
        largest = right_child

    if largest != root_index:
        nums[root_index], nums[largest] = nums[largest], nums[root_index]
        heapify(nums, heap_size, largest)

def heap_sort(nums):
    n = len(nums)

    for i in range(n, -1, -1):
        heapify(nums, n, i)

    for i in range(n - 1, 0, -1):
        nums[i], nums[0] = nums[0], nums[i]
        heapify(nums, i, 0)

    return nums",205
40438527209,search_range,"def search_range(nums, target):
    def find_left(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left

    def find_right(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid - 1
        return right

    start = find_left(nums, target)
    end = find_right(nums, target)
    if start <= end and start < len(nums) and nums[start] == target:
        return [start, end]
    else:
        return [-1, -1]",205
787483808,hasGroupsSizeX,"from math import gcd
from functools import reduce
from collections import Counter

def hasGroupsSizeX(deck) -> bool:
    def prime_factors(num):
        res = []
        i = 2
        while i * i <= num:
            if num % i:
                i += 1
            else:
                num //= i
                res.append(i)
        if num > 1:
            res.append(num)
        return res
    
    def common_prime_factor(prime_list):
        if not prime_list:
            return False
        first = prime_list[0]
        for prime in prime_list[1:]:
            if gcd(first, prime) > 1:
                return True
        return False
    
    c = Counter(deck)
    values = list(c.values())
    if len(values) == 1:
        return values[0] > 1
    if common_prime_factor(values):
        return True
    gcd_values = reduce(gcd, values)
    return gcd_values > 1",205
41849435661,find_first_and_last_position,"def find_first_and_last_position(nums, target):
    if not nums:
        return [-1, -1]
    
    left, right = 0, len(nums) - 1
    first = -1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1
        elif nums[mid] > target:
            right = mid - 1
        else:
            first = mid
            right = mid - 1
            
    left, right = 0, len(nums) - 1
    last = -1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1
        elif nums[mid] > target:
            right = mid - 1
        else:
            last = mid
            left = mid + 1
            
    return [first, last]",205
27699782254,maximum_xor,"class TrieNode:
    def __init__(self):
        self.children = {}
        
def maximum_xor(nums):
    root = TrieNode()
    for num in nums:
        node = root
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            if bit not in node.children:
                node.children[bit] = TrieNode()
            node = node.children[bit]
    max_xor = 0
    for num in nums:
        node = root
        current_xor = 0
        for i in range(31, -1, -1):
            bit = (num >> i) & 1
            toggle_bit = 1 - bit
            if toggle_bit in node.children:
                current_xor |= (1 << i)
                node = node.children[toggle_bit]
            else:
                node = node.children[bit]
        max_xor = max(max_xor, current_xor)
    return max_xor",205
70676322057,min_edit_cost,"def min_edit_cost(str1, str2, ic, dc, rc):
    dp = [[0] * (len(str2) + 1) for _ in range(len(str1) + 1)]
    
    for i in range(len(str1) + 1):
        dp[i][0] = i * dc
        
    for j in range(len(str2) + 1):
        dp[0][j] = j * ic
        
    for i in range(1, len(str1) + 1):
        for j in range(1, len(str2) + 1):
            if str1[i-1] == str2[j-1]:
                cost = 0
            else:
                cost = rc
                
            dp[i][j] = min(dp[i-1][j] + dc, dp[i][j-1] + ic, dp[i-1][j-1] + cost)
    
    return dp[-1][-1]",204
2013810863,isPossibleDivide,"from collections import Counter

def isPossibleDivide(nums, k):
    # If the length of nums is not divisible by k, return False
    if len(nums) % k != 0:
        return False
    # Count the frequency of each number in nums
    num_counts = Counter(nums)
    # Sort the keys of num_counts
    sorted_keys = sorted(num_counts.keys())
    # Iterate over the sorted keys
    for key in sorted_keys:
        # If the current key's count is non-zero
        if num_counts[key] > 0:
            # Iterate over the next k-1 numbers
            for i in range(1, k):
                # Check if the next number exists and has enough count
                if key + i in num_counts and num_counts[key + i] >= num_counts[key]:
                    num_counts[key + i] -= num_counts[key]
                else:
                    return False
    # If all checks pass, return True
    return True",204
70270870107,findSmallestMissingPositive,"def findSmallestMissingPositive(arr):
    # Mark elements that are out of range or negative by setting them to 0
    for i in range(len(arr)):
        if arr[i] <= 0 or arr[i] > len(arr):
            arr[i] = 0

    # Use array indices as a way to store the presence of elements
    for i in range(len(arr)):
        while 1 <= arr[i] <= len(arr) and arr[arr[i] - 1] != arr[i]:
            # Swap elements to their correct positions
            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]

    # Find the first index where its value does not match its index + 1
    for i in range(len(arr)):
        if arr[i] != i + 1:
            return i + 1

    # If all elements are present, return the next integer
    return len(arr) + 1",204
33760488118,edit_distance,"def edit_distance(s1, s2):
    len1, len2 = len(s1), len(s2)
    dp = [[0 for _ in range(len2 + 1)] for _ in range(len1 + 1)]
    for i in range(len1 + 1):
        dp[i][0] = i
    for j in range(len2 + 1):
        dp[0][j] = j
    for i in range(1, len1 + 1):
        for j in range(1, len2 + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
    return dp[len1][len2]",204
11695382466,threeSum,"def threeSum(nums):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        # Skip duplicate values
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            s = nums[i] + nums[left] + nums[right]
            if s < 0:
                left += 1
            elif s > 0:
                right -= 1
            else:
                # Found a triplet
                result.append([nums[i], nums[left], nums[right]])
                # Skip duplicates for left and right
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
    return result",204
483673882,spiral_traverse,"def spiral_traverse(matrix):
    res = []
    startRow, endRow = 0, len(matrix) - 1
    startCol, endCol = 0, len(matrix[0]) - 1

    while startRow <= endRow and startCol <= endCol:
        for col in range(startCol, endCol + 1):
            res.append(matrix[startRow][col])
        startRow += 1

        for row in range(startRow, endRow + 1):
            res.append(matrix[row][endCol])
        endCol -= 1

        if not (startRow <= endRow and startCol <= endCol):
            break

        for col in reversed(range(startCol, endCol + 1)):
            res.append(matrix[endRow][col])
        endRow -= 1

        for row in reversed(range(startRow, endRow + 1)):
            res.append(matrix[row][startCol])
        startCol += 1

    return res",204
22072103426,heap_sort,"def heapify(nums, heap_size, root_index):
    largest = root_index
    left_child = (2 * root_index) + 1
    right_child = (2 * root_index) + 2

    if left_child < heap_size and nums[left_child] > nums[largest]:
        largest = left_child

    if right_child < heap_size and nums[right_child] > nums[largest]:
        largest = right_child

    if largest != root_index:
        nums[root_index], nums[largest] = nums[largest], nums[root_index]
        heapify(nums, heap_size, largest)

def heap_sort(nums):
    n = len(nums)

    for i in range(n, -1, -1):
        heapify(nums, n, i)

    for i in range(n - 1, 0, -1):
        nums[i], nums[0] = nums[0], nums[i]
        heapify(nums, i, 0)

    return nums",204
2513135348,longest_palindrome_substring,"def longest_palindrome_substring(s: str) -> str:
    if len(s) == 0:
        return """"
    
    start = 0
    end = 0
    
    for i in range(len(s)):
        len1 = expand_around_center(s, i, i)
        len2 = expand_around_center(s, i, i + 1)
        max_len = max(len1, len2)
        
        if max_len > end - start:
            start = i - (max_len - 1) // 2
            end = i + max_len // 2
    
    return s[start:end + 1]

def expand_around_center(s: str, left: int, right: int) -> int:
    L = left
    R = right
    while L >= 0 and R < len(s) and s[L] == s[R]:
        L -= 1
        R += 1
    return R - L - 1",204
72445647759,median_sorted_arrays,"def median_sorted_arrays(arr1, arr2):
    merged_arr = []
    i, j = 0, 0

    # Merge the two arrays
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            merged_arr.append(arr1[i])
            i += 1
        else:
            merged_arr.append(arr2[j])
            j += 1

    # Add remaining elements from arr1
    while i < len(arr1):
        merged_arr.append(arr1[i])
        i += 1

    # Add remaining elements from arr2
    while j < len(arr2):
        merged_arr.append(arr2[j])
        j += 1

    n = len(merged_arr)
    if n % 2 == 0:
        return (merged_arr[n//2 - 1] + merged_arr[n//2]) / 2
    else:
        return merged_arr[n//2]",204
36789574469,longest_palindrome_dp,"def longest_palindrome_dp(s: str) -> str:
    n = len(s)
    if n == 0:
        return 0
    dp = [[False] * n for _ in range(n)]
    start = 0
    max_length = 1

    for i in range(n):
        dp[i][i] = True

    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            start = i
            max_length = 2

    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                start = i
                max_length = length

    return s[start:start + max_length]",204
2190241371,is_terminating_decimal,"def findDivisor(n):
    while n > 1:
        for i in range(2, n+1):
            if n % i == 0 :
                if i == 2 or i == 5:
                    continue
                else :
                    return False
                break
    return True

def findDiversorArray(n):
    array = []
    while n > 1:
        for i in range(2, n+1):
            if n % i == 0 :
                n //= i
                array.append(i)
                break  
    return array

def is_terminating_decimal(a, b):
    aArray = findDiversorArray(a)
    bArray = findDiversorArray(b)
    for i in aArray:
        if i in bArray:
            bArray.remove(i)
    for i in list(set(bArray)) :
        if i != 2 and i != 5:
            return 2
    return 1",203
26212827936,canFinish,"def canFinish(numCourses, prerequisites):
    def dfs(i, adjacency, flags):
        if flags[i] == -1: return True
        if flags[i] == 1: return False
        flags[i] = 1
        for j in adjacency[i]:
            if not dfs(j, adjacency, flags): return False
        flags[i] = -1
        return True

    adjacency = [[] for _ in range(numCourses)]
    flags = [0 for _ in range(numCourses)]
    for cur, pre in prerequisites:
        adjacency[pre].append(cur)
    for i in range(numCourses):
        if not dfs(i, adjacency, flags): return False
    return True

print(canFinish(2, [[1,0]])) # Expected: True
print(canFinish(2, [[1,0],[0,1]])) # Expected: False
print(canFinish(3, [[1,0],[2,1]])) # Expected: True",203
74795259465,radix_sort,"def counting_sort(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10

    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1

    for i in range(1, 10):
        count[i] += count[i - 1]

    i = n - 1
    while i >= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1

    for i in range(n):
        arr[i] = output[i]

def radix_sort(arr):
    max1 = max(arr)
    exp = 1
    while max1 // exp > 0:
        counting_sort(arr, exp)
        exp *= 10
    return arr",203
1186119524,find_target_positions,"def find_target_positions(nums, target):
    left, right = 0, len(nums) - 1
    first = last = -1

    # Find the first occurrence of target
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1
        elif nums[mid] > target:
            right = mid - 1
        else:
            first = mid
            right = mid - 1

    left, right = 0, len(nums) - 1

    # Find the last occurrence of target
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1
        elif nums[mid] > target:
            right = mid - 1
        else:
            last = mid
            left = mid + 1

    return [first, last]",203
37421475923,min_edit_distance,"def min_edit_distance(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    for i in range(n + 1):
        dp[i][0] = i
    for j in range(m + 1):
        dp[0][j] = j
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if str1[j - 1] == str2[i - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1)
    return dp[-1][-1]",203
74248664151,check_url,"import re

def check_url(url):
    regex = re.compile(
        r'^(?:http|ftp)s?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    if re.match(regex, url) is not None:
        return 'Valid URL'
    else:
        return 'Invalid URL'",203
3631760351,binary_search_occurrences,"def binary_search_occurrences(arr, target):
    def find_left(arr, target):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left

    def find_right(arr, target):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if arr[mid] <= target:
                left = mid + 1
            else:
                right = mid - 1
        return right

    left_index = find_left(arr, target)
    right_index = find_right(arr, target)

    if left_index <= right_index:
        return right_index - left_index + 1
    else:
        return 0",203
20000952739,min_jumps,"from collections import defaultdict, deque

def min_jumps(arr):
    maps = defaultdict(list)
    for i, num in enumerate(arr):
        maps[num].append(i)

    queue = deque([0])
    visited = {0}
    rank = 0
    while queue:
        n = len(queue)
        for _ in range(n):
            node = queue.popleft()
            if node == len(arr) - 1:
                return rank
            children = maps[arr[node]]
            for child in children:
                if child not in visited:
                    visited.add(child)
                    queue.append(child)
            maps[arr[node]].clear()
            if node + 1 not in visited and node + 1 < len(arr):
                visited.add(node + 1)
                queue.append(node + 1)
            if node - 1 not in visited and node - 1 >= 0:
                visited.add(node - 1)
                queue.append(node - 1)
        rank += 1",203
74397686535,num_connected_components,"from collections import defaultdict

def num_connected_components(graph):
    def dfs(node, visited):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor, visited)

    visited = set()
    count = 0
    for node in graph:
        if node not in visited:
            dfs(node, visited)
            count += 1
    return count

graph1 = {""0"": [""1"", ""2""], ""1"": [""0"", ""2""], ""2"": [""0"", ""1""], ""3"": []}
graph2 = {""0"": [""1""], ""1"": [""0""], ""2"": [""3""], ""3"": [""2""], ""4"": []}
graph3 = {""0"": [], ""1"": [], ""2"": [], ""3"": []}

assert num_connected_components(graph1) == 2
assert num_connected_components(graph2) == 3
assert num_connected_components(graph3) == 4",203
42598071593,get_happy_string,"from typing import List

def get_happy_string(n: int, k: int) -> str:
    def generate_happy_strings(length: int, current: str, result: List[str]):
        if length == 0:
            result.append(current)
            return
        for char in ['a', 'b', 'c']:
            if not current or char != current[-1]:
                generate_happy_strings(length - 1, current + char, result)

    result = []
    generate_happy_strings(n, """", result)
    result.sort()
    return result[k-1] if k <= len(result) else """"

print(get_happy_string(1, 3)) # ""c""
print(get_happy_string(1, 1)) # ""a""
print(get_happy_string(1, 2)) # ""b""
print(get_happy_string(2, 4)) # ""ba""
print(get_happy_string(3, 9)) # ""cab""",203
1451942254,kthSmallest,"def partition(nums, low, high):
    pivot = nums[high]
    i = low - 1
    for j in range(low, high):
        if nums[j] < pivot:
            i += 1
            nums[i], nums[j] = nums[j], nums[i]
    nums[i + 1], nums[high] = nums[high], nums[i + 1]
    return i + 1

def quickSelect(nums, low, high, k):
    if low == high:
        return nums[low]

    pi = partition(nums, low, high)

    if k == pi:
        return nums[pi]
    elif k < pi:
        return quickSelect(nums, low, pi - 1, k)
    else:
        return quickSelect(nums, pi + 1, high, k)

def kthSmallest(nums, k):
    return quickSelect(nums, 0, len(nums) - 1, k - 1)",203
34031010230,decimal_to_base,"def makeTable():
    table = [str(i) for i in range(10)]
    
    for i in range(ord('A'), ord('F')+1):
        table.append(chr(i))
        
    return table

def numToDigit(num, n, numTable):
    res = """"
    while num != 0:
        res += numTable[num%n]
        num = num//n
    
    return res[::-1]

def decimal_to_base(number, base):
    answer = ''
    numTable = makeTable()
    
    real, decimal = divmod(number, 1)
    answer += numToDigit(int(real), base, numTable)
    
    if decimal != 0:
        answer += '.'
        for _ in range(10):
            decimal *= base
            digit, decimal = divmod(decimal, 1)
            answer += numToDigit(int(digit), base, numTable)
            if decimal == 0:
                break
    
    return answer",202
37878297029,is_valid_bst,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_valid_bst(root):
    def validate(node, low=-float('inf'), high=float('inf')):
        if not node:
            return True
        if not low < node.val < high:
            return False
        return (validate(node.right, node.val, high) and
                validate(node.left, low, node.val))

    return validate(root)

# Test cases
root1 = TreeNode(2)
root1.left = TreeNode(1)
root1.right = TreeNode(3)
root2 = TreeNode(5)
root2.left = TreeNode(1)
root2.right = TreeNode(4)
root2.right.left = TreeNode(3)
root2.right.right = TreeNode(6)

assert is_valid_bst(root1) == True
assert is_valid_bst(root2) == False",202
12288729031,find_shortest_unsorted_subarray,"def find_shortest_unsorted_subarray(arr):
    if not arr or len(arr) < 2: return 0
    # find the left bound which is 6, and the right bound is 10, these two violates the mono increasing/decreasing stack
    l, r = len(arr) - 1, 0

    mono_stack = []
    # use increasing mono stack to find left bound
    for i, v in enumerate(arr):
        while mono_stack and v < arr[mono_stack[-1]]:
            l = min(l, mono_stack.pop())
        mono_stack.append(i)

    # use decreasing mono stack to find the right bound
    mono_stack = []
    for i in reversed(range(len(arr))):
        while mono_stack and arr[i] > arr[mono_stack[-1]]:
            r = max(r, mono_stack.pop())
        mono_stack.append(i)

    return r - l + 1 if r - l > 0 else 0",202
32619608672,count_subarrays_with_given_sum,"def count_subarrays_with_given_sum(arr, k):
    # Initialize result
    count = 0

    # Initialize prefix sum
    prefix_sum = 0

    # Create a dictionary to store the frequency of prefix sums
    prefix_sum_dict = {0: 1}

    # Traverse the array
    for i in range(len(arr)):
        # Update prefix sum
        prefix_sum += arr[i]

        # If prefix sum minus k is already in the dictionary, it means there exists a subarray ending at i with sum k
        if prefix_sum - k in prefix_sum_dict:
            count += prefix_sum_dict[prefix_sum - k]

        # Update the frequency of the current prefix sum in the dictionary
        if prefix_sum in prefix_sum_dict:
            prefix_sum_dict[prefix_sum] += 1
        else:
            prefix_sum_dict[prefix_sum] = 1

    # Return the count of subarrays with the given sum
    return count",202
26569247714,largest_number_in_binary_tree,"class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def largest_number_in_binary_tree(tree_list):
    def helper(node):
        if node is None:
            return float('-inf')
        left_max = helper(node.left)
        right_max = helper(node.right)
        return max(node.val, left_max, right_max)
    
    root = TreeNode(tree_list[0])
    queue = [root]
    i = 1
    while queue and i < len(tree_list):
        node = queue.pop(0)
        if tree_list[i] is not None:
            node.left = TreeNode(tree_list[i])
            queue.append(node.left)
        i += 1
        if i >= len(tree_list):
            break
        if tree_list[i] is not None:
            node.right = TreeNode(tree_list[i])
            queue.append(node.right)
        i += 1
    return helper(root)",202
33782665066,longest_increasing_subseq,"def longest_increasing_subseq(nums):
    if not nums:
        return 0

    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)

print(longest_increasing_subseq([10, 9, 2, 5, 3, 7, 101, 18]))  # Expected output: 4
print(longest_increasing_subseq([0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]))  # Expected output: 6
print(longest_increasing_subseq([5, 4, 3, 2, 1]))  # Expected output: 1",202
31588179820,smallest_k_elements,"def smallest_k_elements(arr, k):
    begin = 0
    end = len(arr) - 1
    result = []
    while begin < end:
        low = begin
        high = end
        key = arr[low]
        while low < high:
            while low < high and arr[high] >= key:
                high -= 1
            if arr[high] < key:
                arr[low] = arr[high]
                low += 1

            while low < high and arr[low] <= key:
                low += 1
            if arr[low] > key:
                arr[high] = arr[low]
                high -= 1

        arr[low] = key
        if low == k - 1:
            return arr[:k]

        if low > k - 1:
            end = low - 1
        else:
            begin = low + 1

    return arr[:k]",202
9570878503,find_anagrams_indices,"import collections
from typing import List

def find_anagrams_indices(s: str, p: str) -> List[int]:
    ans = []
    target = collections.Counter()
    for ch in p:
        target[ch] += 1

    curr = collections.Counter()
    len_p = len(p)
    len_s = len(s)
    if len_s < len_p:
        return ans
    for i in range(len_p):
        curr[s[i]] += 1

    start_idx = 0
    while start_idx <= len_s - len_p:
        if curr == target:
            ans.append(start_idx)

        start_idx += 1

        if start_idx <= len_s - len_p:
            curr[s[start_idx - 1]] -= 1
            if curr[s[start_idx - 1]] == 0:
                del curr[s[start_idx - 1]]
            curr[s[start_idx + len_p - 1]] += 1

    return ans",202
18589285404,find_Smallest_Window,"from collections import Counter

def find_Smallest_Window(str, pat):

    str_len = len(str)
    pat_len = len(pat)

    pat_count = Counter(pat)
    str_count = Counter()

    start, start_index, min_len = 0, -1, float('inf')
    count = 0

    for j in range(str_len):

        str_count[str[j]] += 1

        if str_count[str[j]] <= pat_count.get(str[j], 0):
            count += 1

        if count == pat_len:

            while str_count[str[start]] > pat_count.get(str[start], 0):
                str_count[str[start]] -= 1
                start += 1

            curr_len = j - start + 1
            if curr_len < min_len:
                min_len = curr_len
                start_index = start

    if start_index == -1:
        return """"

    return str[start_index:start_index + min_len]",202
30350815818,longest_Palindrome,"def longest_Palindrome(s: str) -> str:
    if len(s) == 0:
        return """"

    start = 0
    end = 0

    for i in range(len(s)):
        len1 = expand_around_center(s, i, i)
        len2 = expand_around_center(s, i, i + 1)
        max_len = max(len1, len2)
        if max_len > end - start:
            start = i - (max_len - 1) // 2
            end = i + max_len // 2

    return s[start:end + 1]

def expand_around_center(s: str, left: int, right: int) -> int:
    L = left
    R = right
    while L >= 0 and R < len(s) and s[L] == s[R]:
        L -= 1
        R += 1
    return R - L - 1",201
1699718993,match_pattern,"def match_pattern(str, pattern):
    dp = [[False] * (len(pattern) + 1) for _ in range(len(str) + 1)]
    dp[0][0] = True

    for i in range(1, len(pattern) + 1):
        dp[0][i] = pattern[i - 1] == '?' and dp[0][i - 1]

    for i in range(1, len(str) + 1):
        for j in range(1, len(pattern) + 1):
            if pattern[j - 1] == '?' or str[i - 1] == pattern[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            elif pattern[j - 1] == '*':
                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
    
    return dp[len(str)][len(pattern)]",201
16288122012,count_rotations,"def count_rotations(nums):
    low = 0
    high = len(nums) - 1
    while low <= high:
        if nums[low] <= nums[high]:  # Case when the array is not rotated or already found the rotation point
            return low
        mid = (low + high) // 2
        next = (mid + 1) % len(nums)
        prev = (mid - 1 + len(nums)) % len(nums)
        # Check if mid is the rotation point
        if nums[mid] <= nums[next] and nums[mid] <= nums[prev]:
            return mid
        elif nums[mid] <= nums[high]:  # Right side is sorted, so the rotation point must be on the left side
            high = mid - 1
        else:  # Left side is sorted, so the rotation point must be on the right side
            low = mid + 1
    return 0",201
75042490264,canPartition,"def canPartition(nums):
    if sum(nums)%2==1 or not nums:
        return False
    bag = int(sum(nums)/2)
    dp = []
    for i in range(0, len(nums)+1):
        array = []
        for j in range(0, bag+1):
            array.append(False)
        dp.append(array)
    for i in range(0, len(nums)+1):
        dp[i][0] = True
    for i in range(1, len(nums)+1):
        for j in range(1, bag+1):
            if j-nums[i-1]>=0:
                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]
            else:
                dp[i][j] = dp[i-1][j]
        
    for i in range(len(nums)+1):
        if dp[i][bag]:
            return True
    return False",200
33077960957,num_buses_to_destination,"from collections import defaultdict, deque

def num_buses_to_destination(routes, source, target):
    if source == target:
        return 0

    # Create Graph using stop as nodes and routes as edges
    graph = defaultdict(set)
    for route, stops in enumerate(routes):
        for stop in stops:
            graph[stop].add(route)

    # Use BFS to move from around edges(routes)
    q = deque([(source, 0)])
    seen_stops = set([source])
    seen_routes = set()

    while q:
        stop, buses = q.popleft()
        for route in graph[stop]:
            if route not in seen_routes:
                for next_stop in routes[route]:
                    if next_stop == target:
                        return buses + 1
                    if next_stop not in seen_stops:
                        seen_stops.add(next_stop)
                        q.append((next_stop, buses + 1))
                seen_routes.add(route)
    return -1",200
33086998203,canFinish,"from collections import defaultdict, deque

def canFinish(numCourses, prerequisites):
    if len(prerequisites)==0:
        return True
    Indegree = [0] * 2000
    graph = defaultdict(list)
    nodes = set()
    for b,a in prerequisites:
        nodes.add(a)
        nodes.add(b)
        graph[a].append(b)
        
    for node,dependency in graph.items():
        for eachDependency in dependency:
            Indegree[eachDependency] += 1
            
    zeroIndegree = [node for node in nodes if Indegree[node] == 0]
        
    queue = deque(zeroIndegree)
    topSort = []
    while queue:
        node = queue.popleft()
        topSort.append(node)
        for dependency in graph[node]:
            Indegree[dependency] -= 1
            if Indegree[dependency] == 0:
                queue.append(dependency)
                
    return len(topSort)==len(nodes)",200
40026026223,count_distinct_islands,"def dfs(grid, i, j, direction, shape):
    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:
        return
    grid[i][j] = 0
    shape.append(direction)
    dfs(grid, i + 1, j, ""D"", shape)
    dfs(grid, i - 1, j, ""U"", shape)
    dfs(grid, i, j + 1, ""R"", shape)
    dfs(grid, i, j - 1, ""L"", shape)

def count_distinct_islands(grid):
    shapes = set()
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                shape = []
                dfs(grid, i, j, ""S"", shape)
                shapes.add(tuple(shape))
    return len(shapes)",200
15210644639,is_tree,"def is_tree(edges):
    parent = {}
    rank = {}

    def make_set(u):
        parent[u] = u
        rank[u] = 0

    def find(u):
        if parent[u] != u:
            parent[u] = find(parent[u])
        return parent[u]

    def union(u, v):
        root1 = find(u)
        root2 = find(v)
        if root1 != root2:
            if rank[root1] > rank[root2]:
                parent[root2] = root1
            elif rank[root1] < rank[root2]:
                parent[root1] = root2
            else:
                parent[root2] = root1
                rank[root1] += 1

    for u, v in edges:
        make_set(u)
        make_set(v)
        if find(u) == find(v):
            return False
        union(u, v)

    return len(edges) == len(parent) - 1",200
43534186225,smallestWindow,"from collections import Counter

def smallestWindow(s):
    n = len(s)
    if n == 0:
        return """"

    dist_count_char = len(set(list(s)))

    count = {}
    start = 0
    min_len = float('inf')
    start_index = 0
    count_distinct = 0

    for j in range(n):
        count[s[j]] = count.get(s[j], 0) + 1

        if count[s[j]] == 1:
            count_distinct += 1

        if count_distinct == dist_count_char:
            while count[s[start]] > 1:
                if count[s[start]] > 1:
                    count[s[start]] -= 1
                start += 1

            len_window = j - start + 1
            if min_len > len_window:
                min_len = len_window
                start_index = start

    return s[start_index:start_index + min_len]",200
72324630593,count_primes,"def count_primes(n: int) -> int:
    if n <= 2:
        return 0

    # Initialize numbers[0] and numbers[1] as False because 0 and 1 are not prime.
    # Initialze numbers[2] through numbers[n-1] as True because we assume each number
    # is prime until we find a prime number (p) that is a divisor of the number.
    numbers = [False, False] + [True] * (n - 2)
    for p in range(2, int(sqrt(n)) + 1):
        if numbers[p]:
            # Set all multiples of p to false because they are not prime.
            for multiple in range(p * p, n, p):
                numbers[multiple] = False
    
    # numbers[index] will only be true where index is a prime number.
    # return the number of indices whose value is true.
    return sum(numbers)",199
72903943384,min_distance,"from collections import deque

def min_distance(grid, point):
    num_rows, num_cols = len(grid), len(grid[0])
    queue = deque([(i, j) for j in range(num_cols) for i in range(num_rows) if grid[i][j]])
    visited = set(queue)
    steps = 0

    while queue:
        for _ in range(len(queue)):
            i, j = queue.popleft()
            if (i, j) == tuple(point):
                return steps
            for _i, _j in [(i+1, j), (i, j+1), (i-1, j), (i, j-1)]:
                if 0 <= _i < num_rows and 0 <= _j < num_cols and (_i, _j) not in visited:
                    queue.append((_i, _j))
                    visited.add((_i, _j))
        steps += 1
    return -1",199
69954211797,convert_to_base,"def convert_to_base(num: int, base: int) -> str:
    """"""
    Convert a decimal number to a specified base and return the result as a string.
    
    Parameters:
    num (int): The decimal number to convert.
    base (int): The base to convert the number to.
    
    Returns:
    str: The converted number as a string.
    """"""
    if num == 0:
        return '0'
    if base < 2 or base > 36:
        raise ValueError(""Base must be between 2 and 36."")
    
    flag = ''
    if num < 0:
        flag = '-'
    num = abs(num)
    
    digits = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    res = []
    
    while num > 0:
        num, remainder = divmod(num, base)
        res.append(digits[remainder])
    
    return flag + """".join(res[::-1])",199
4522356219,wildcard_matching,"def wildcard_matching(s, p):
    i = 0
    j = 0
    m = len(s)
    n = len(p)
    i_backup = -1
    j_backup = -1
    while i < m:
        if j < n and p[j] == '*':
            while j < n and p[j] == '*':
                j += 1
            if j == n:
                return True
            i_backup = i
            j_backup = j
        elif j < n and (p[j] == '?' or p[j] == s[i]):
            i += 1
            j += 1
        else:
            if i_backup >= 0:
                i_backup += 1
                i = i_backup
                j = j_backup
            else:
                return False

    while j < n and p[j] == '*':
        j += 1

    return True if j == n else False",199
22788954678,levenshtein_distance,"def levenshtein_distance(s1, s2):
    if len(s1) < len(s2):
        return levenshtein_distance(s2, s1)

    # len(s1) >= len(s2)
    if len(s2) == 0:
        return len(s1)

    previous_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1 # j+1 instead of j since previous_row and current_row are one character longer
            deletions = current_row[j] + 1       # than s2
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
    
    return previous_row[-1]",199
23777109303,unique_paths_with_obstacles,"from typing import List

def unique_paths_with_obstacles(obstacle_grid: List[List[int]]) -> int:
    m = len(obstacle_grid)
    n = len(obstacle_grid[0])
    dp = [[0 for _ in range(n)] for _ in range(m)]

    # Initialize dp
    for j in range(n):
        if obstacle_grid[0][j] == 1:
            break
        dp[0][j] = 1

    for i in range(m):
        if obstacle_grid[i][0] == 1:
            break
        dp[i][0] = 1

    # Fill dp table
    for i in range(1, m):
        for j in range(1, n):
            if obstacle_grid[i][j] == 0:
                dp[i][j] = dp[i-1][j] + dp[i][j-1]

    return dp[m-1][n-1]",199
7254021770,levenshtein_distance,"def levenshtein_distance(s1, s2):
    if len(s1) < len(s2):
        return levenshtein_distance(s2, s1)

    # len(s1) >= len(s2)
    if len(s2) == 0:
        return len(s1)

    previous_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1 # j+1 instead of j since previous_row and current_row are one character longer
            deletions = current_row[j] + 1       # than s2
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
    
    return previous_row[-1]",199
22084591672,check_url,"import re

def check_url(url):
    regex = re.compile(
        r'^(?:http|ftp)s?://' # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'localhost|' #localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    if re.match(regex, url) is not None:
        return (""Valid URL"")
    else:
        return (""Invalid URL"")",198
71193730625,longest_palindrome,"def longest_palindrome(s: str) -> str:
    if len(s) == 0:
        return """"
    start, end = 0, 0
    for i in range(len(s)):
        len1 = expand_around_center(s, i, i)
        len2 = expand_around_center(s, i, i + 1)
        max_len = max(len1, len2)
        if max_len > end - start:
            start = i - (max_len - 1) // 2
            end = i + max_len // 2
    return s[start:end + 1]

def expand_around_center(s: str, left: int, right: int) -> int:
    L, R = left, right
    while L >= 0 and R < len(s) and s[L] == s[R]:
        L -= 1
        R += 1
    return R - L - 1",198
28293319144,find_rotation_count,"def find_rotation_count(arr):
    low = 0
    high = len(arr) - 1
    while low <= high:
        if arr[low] <= arr[high]:  # Case when the subarray is already sorted
            return low
        mid = (low + high) // 2
        next = (mid + 1) % len(arr)
        prev = (mid - 1 + len(arr)) % len(arr)
        if arr[mid] <= arr[next] and arr[mid] <= arr[prev]:  # Check if mid is the smallest element
            return mid
        elif arr[mid] <= arr[high]:  # Right subarray is sorted, so the smallest element is in the left subarray
            high = mid - 1
        else:  # Left subarray is sorted, so the smallest element is in the right subarray
            low = mid + 1
    return 0",198
15907308048,filter_primes,"def filter_primes(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return [num for num in numbers if is_prime(num)]

print(filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]))  # [2, 3, 5, 7]
print(filter_primes([11, 13, 17, 19, 23, 29]))     # [11, 13, 17, 19, 23, 29]
print(filter_primes([0, 1, 4, 6, 8, 10]))          # []",198
14172051448,check_URL,"import re

def check_URL(url):
    regex = re.compile(
        r'^(?:http|ftp)s?://' # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'localhost|' #localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)

    if re.match(regex, url) is not None:
        return ""Valid URL""
    else:
        return ""Invalid URL""",198
34592975893,largest_palindrome,"def largest_palindrome(s: str) -> str:
    if len(s) == 0:
        return """"
    start, end = 0, 0
    for i in range(len(s)):
        len1 = expand_around_center(s, i, i)
        len2 = expand_around_center(s, i, i + 1)
        max_len = max(len1, len2)
        if max_len > end - start:
            start = i - (max_len - 1) // 2
            end = i + max_len // 2
    return s[start:end + 1]

def expand_around_center(s: str, left: int, right: int) -> int:
    L, R = left, right
    while L >= 0 and R < len(s) and s[L] == s[R]:
        L -= 1
        R += 1
    return R - L - 1",198
19605928865,findShortestSubarray,"from bisect import bisect

def findShortestSubarray(arr):
    front = []

    for num in arr:
        if not front or front[-1] <= num:
            front.append(num)
        else:
            break
            
    tail = []
    for i in range(len(arr) - 1, -1, -1):
        if not tail or tail[-1] >= arr[i]:
            tail.append(arr[i])
        else:
            break
            
    if len(tail) + len(front) > len(arr): return 0
    
    middle = len(arr) - len(tail) - len(front)
    tail.reverse()
    res = len(arr) - max(len(tail), len(front))
    
    for i, v in enumerate(front):
        ind = bisect.bisect_left(tail, v)
        res = min(res, len(arr) - (i + len(tail) - ind + 1))
    
    return res",198
31653605000,reduce_to_single_digit,"import sys
sys.setrecursionlimit(10**6)

def reduce_to_single_digit(floor):
    def brute_force(floor, prev_click, min_click):
        if floor == 0:
            min_click[0] = min(prev_click, min_click[0])
            return
        
        digit = floor%10
        
        olim_click = 10-digit
        berim_click = digit
        
        if floor < 10:
            brute_force(0, prev_click+olim_click+1, min_click)
        else:
            brute_force(int((floor+10-digit)/10), prev_click+olim_click, min_click)
        brute_force(int((floor-digit)/10), prev_click+berim_click, min_click)
    
    min_click = [100000000000000]
    brute_force(floor, 0, min_click)
    return min_click[0]",198
2279435486,longest_palindromic_substring,"def longest_palindromic_substring(s: str) -> str:
    if not s:
        return """"

    start = 0
    end = 0

    for i in range(len(s)):
        len1 = expand_around_center(s, i, i)
        len2 = expand_around_center(s, i, i+1)
        max_len = max(len1, len2)
        if max_len > end - start:
            start = i - (max_len - 1) // 2
            end = i + max_len // 2

    return s[start:end+1]

def expand_around_center(s: str, left: int, right: int) -> int:
    L = left
    R = right
    while L >= 0 and R < len(s) and s[L] == s[R]:
        L -= 1
        R += 1
    return R - L - 1",198
11936249299,is_toeplitz,"def is_toeplitz(matrix):
    ROWS = len(matrix)
    COLS = len(matrix[0])
    c = 1
    r = ROWS - 1
    ans = True
    while r >= 0:
        ans = ans and check_diagonal(matrix,r,0)
        r -=1
     
    while c < COLS:
        ans = ans and check_diagonal(matrix,0,c)
        c +=1
    return ans

def check_diagonal(matrix,r,c):
    ROWS = len(matrix)
    COLS = len(matrix[0])
    while c >= 0 and c < COLS and r >= 0 and r < ROWS:
        if r+1 < ROWS and c+1 < COLS: 
            if matrix[r][c] != matrix[r+1][c+1]:
                return False
        r += 1
        c += 1
    return True",197
72817601877,max_level_values,"from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def max_level_values(root):
    res = []
    if not root:
        return res
    q = deque([root])
    while q:
        max_val = float('-inf')
        for _ in range(len(q)):
            cur = q.popleft()
            max_val = max(max_val, cur.val)
            for child in filter(None, [cur.left, cur.right]):
                q.append(child)
        res.append(max_val)
    return res

# Test the function
root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)

assert max_level_values(root) == [3, 20, 15]",197
41863779520,max_triangle_area_semicircle,"import math
def max_triangle_area_semicircle(r):
  # The largest triangle that can be inscribed in a semicircle is a right angled triangle with its hypotenuse as the diameter of the semicircle.
  # The area of such a triangle is 1/2 * base * height
  # Since the hypotenuse is the diameter of the semicircle, it is equal to 2r
  # The base and height of the triangle are equal to the radius of the semicircle
  # Hence, the area of the triangle is 1/2 * r * r = 1/2 * r^2
  # But since the triangle is a right angled triangle, the area is maximized when the base and height are equal
  # Hence, the area of the triangle is maximized when it is 1/2 * (2r) * r = r^2
  return r * r",197
16208102563,minDepth,"from typing import Optional

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
def minDepth(root: Optional[TreeNode]) -> int:
    if not root:
        return 0

    # If the node is a leaf node
    if not root.left and not root.right:
        return 1

    # If the left subtree is empty, recur for the right subtree
    if not root.left:
        return minDepth(root.right) + 1

    # If the right subtree is empty, recur for the left subtree
    if not root.right:
        return minDepth(root.left) + 1

    # If both subtrees are present, find the minimum of both and add 1
    return min(minDepth(root.left), minDepth(root.right)) + 1",197
4049772477,find_lcs,"def find_lcs(s1, s2):
    m = len(s1)
    n = len(s2)
    dp = [['' for _ in range(n+1)] for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + s1[i-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)
    return dp[m][n]

print(find_lcs(""ABCDGH"", ""AEDFHR"")) # ""ADH""
print(find_lcs(""AGGTAB"", ""GXTXAYB"")) # ""GTAB""
print(find_lcs(""ABC"", ""AC"")) # ""AC""",197
20817165723,one_edit_away,"def one_edit_away(first: str, second: str) -> bool:
    len1 = len(first)
    len2 = len(second)
    if abs(len1 - len2) >= 2:
        return False
    if len1 == len2:
        return sum([x != y for x, y in zip(first, second)]) <= 1
    if len1 > len2:
        first, second = second, first
        len1, len2 = len2, len1
    i = 0
    shift = len2 - len1
    while i < len1 and first[i] == second[i]:
        i += 1
    if i == len1:
        return True
    if first[i] == second[i + shift]:
        i += 1
    while i < len1 and first[i] == second[i + shift]:
        i += 1
    return i == len1",197
25798762056,sort_versions,"def sort_versions(l):
    def split2int(l):
        m = []
        vi = ['major', 'feature', 'minor']
        for ver in l:
            temp = ver.split('.')
            ver_det = {key: None for key in vi}
            for n, key in zip(temp, vi):
                ver_det[key] = int(n)
            m.append(ver_det.copy())
        return m
    def pack2list(l):
        fl = []
        for x in l:
            ver = ''
            for y in x:
                if (x[y] is not None):
                    ver += str(x[y]) + '.'
            fl.append(ver[:-1])
        return fl
    l2int = split2int(l)
    l2i_sor = sorted(l2int, key=lambda i: (i['major'], i['feature'], i['minor']))
    sol = pack2list(l2i_sor)
    return sol",196
29375583033,smallest_substring,"def smallest_substring(s):
    if not s:
        return """"
    unique_chars = set(s)
    min_len = float('inf')
    min_substring = """"
    left = 0
    count = 0
    current = {}
    for right in range(len(s)):
        if s[right] in unique_chars:
            if s[right] not in current or current[s[right]] == 0:
                count += 1
            current[s[right]] = current.get(s[right], 0) + 1
        while count == len(unique_chars):
            if right - left + 1 < min_len:
                min_len = right - left + 1
                min_substring = s[left:right+1]
            if s[left] in unique_chars:
                current[s[left]] -= 1
                if current[s[left]] == 0:
                    count -= 1
            left += 1
    return min_substring",196
5769776548,letter_combinations,"KEYBOARD = {
    ""2"": [""a"", ""b"", ""c""],
    ""3"": [""d"", ""e"", ""f""],
    ""4"": [""g"", ""h"", ""i""],
    ""5"": [""j"", ""k"", ""l""],
    ""6"": [""m"", ""n"", ""o""],
    ""7"": [""p"", ""q"", ""r"", ""s""],
    ""8"": [""t"", ""u"", ""v""],
    ""9"": [""w"", ""x"", ""y"", ""z""],
}

def letter_combinations(digits):
    def backtrack(index):
        if index == len(digits):
            res.append("""".join(letters))
        else:
            digit = digits[index]
            for letter in KEYBOARD[digit]:
                letters.append(letter)
                backtrack(index + 1)
                letters.pop()
    res = []
    letters = []
    if digits:
        backtrack(0)
    return res",196
364918005,count_target,"def count_target(nums, target):
    def find_left(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left

    def find_right(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid - 1
        return right

    left = find_left(nums, target)
    if left == len(nums) or nums[left] != target:
        return 0
    right = find_right(nums, target)
    return right - left + 1",196
12243314320,find_level_in_bst,"class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def insert(root, value):
    if root is None:
        return Node(value)
    else:
        if value < root.value:
            root.left = insert(root.left, value)
        else:
            root.right = insert(root.right, value)
    return root

def find_level_in_bst(arr, target):
    root = Node(arr[0])
    for value in arr[1:]:
        insert(root, value)

    level = 0
    queue = [(root, level)]
    while queue:
        node, level = queue.pop(0)
        if node.value == target:
            return level + 1
        if node.left:
            queue.append((node.left, level + 1))
        if node.right:
            queue.append((node.right, level + 1))
    return -1",196
74067302554,count_distinct_islands,"def count_distinct_islands(grid):
    def dfs(r, c, r0, c0):
        if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == 1:
            grid[r][c] = 0
            shape.append((r - r0, c - c0))
            dfs(r + 1, c, r0, c0)
            dfs(r - 1, c, r0, c0)
            dfs(r, c + 1, r0, c0)
            dfs(r, c - 1, r0, c0)

    shapes = set()
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == 1:
                shape = []
                dfs(r, c, r, c)
                shapes.add(tuple(shape))
    return len(shapes)",196
9360243930,largest_palindrome_subsequence,"def largest_palindrome_subsequence(s: str) -> int:

    # Function to find the longest palindromic subsequence
    def lps(str, i, j):
        # Base Case 1: If there is only 1 character
        if i == j:
            return 1

        # Base Case 2: If there are only 2 characters and both are same
        if str[i] == str[j] and i + 1 == j:
            return 2

        # If the first and last characters match
        if str[i] == str[j]:
            return lps(str, i + 1, j - 1) + 2

        # If the first and last characters do not match
        return max(lps(str, i, j - 1), lps(str, i + 1, j))

    return lps(s, 0, len(s) - 1)",196
24060963630,is_valid_bst,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_valid_bst(root: TreeNode) -> bool:
    def validate(node, low, high):
        if not node:
            return True
        if not (low < node.val < high):
            return False
        return validate(node.left, low, node.val) and validate(node.right, node.val, high)

    return validate(root, float('-inf'), float('inf'))

# Test cases
root = TreeNode(2)
root.left = TreeNode(1)
root.right = TreeNode(3)
assert is_valid_bst(root) == True

root = TreeNode(5)
root.left = TreeNode(1)
root.right = TreeNode(4)
root.right.left = TreeNode(3)
root.right.right = TreeNode(6)
assert is_valid_bst(root) == False",196
30097536847,max_on_same_line,"from collections import defaultdict

def calculate_slope(p1, p2):
    if p2[0]-p1[0] == 0:
        return float('inf')
    return (p2[1] - p1[1]) / (p2[0] - p1[0])

def max_on_same_line(points):
    n = len(points)
    if n < 3:
        return n
    
    max_points_on_line = 0
    
    for i in range(n):
        slopes = defaultdict(int)
        duplicate_point = 1
        
        for j in range(i + 1, n):
            if points[i] == points[j]:
                duplicate_point += 1
                continue
            slopes[calculate_slope(points[i], points[j])] += 1
            
        max_points_on_line = max(max_points_on_line, max(slopes.values(), default=0) + duplicate_point)
        
    return max_points_on_line",195
74562552155,count_unique_prime_factors,"def count_unique_prime_factors(num):
    if num < 2:
        return 0
    factors = set()
    # Check for 2 as a prime factor
    if num % 2 == 0:
        factors.add(2)
        while num % 2 == 0:
            num //= 2
    # Check for odd prime factors
    for i in range(3, int(num**0.5) + 1, 2):
        if num % i == 0:
            factors.add(i)
            while num % i == 0:
                num //= i
    # If num is a prime number greater than 2
    if num > 2:
        factors.add(num)
    return len(factors)

assert count_unique_prime_factors(100) == 2
assert count_unique_prime_factors(45) == 2
assert count_unique_prime_factors(13) == 1",195
1764612462,smallest_window,"from collections import Counter

def smallest_window(s, t):
    if len(t) > len(s):
        return """"
    t_count = Counter(t)
    s_count = Counter()
    min_len = float('inf')
    min_win = """"
    start = 0
    matched = 0
    for end in range(len(s)):
        s_count[s[end]] += 1
        if s[end] in t_count and s_count[s[end]] <= t_count[s[end]]:
            matched += 1
        while matched == len(t):
            window_len = end - start + 1
            if window_len < min_len:
                min_len = window_len
                min_win = s[start:end+1]
            s_count[s[start]] -= 1
            if s[start] in t_count and s_count[s[start]] < t_count[s[start]]:
                matched -= 1
            start += 1
    return min_win",195
14088189006,find_min_operations,"def find_min_operations(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j],    # Delete
                                   dp[i][j - 1],    # Insert
                                   dp[i - 1][j - 1] # Replace
                                  )
    return dp[m][n]",195
30698878754,shortest_subarray,"def shortest_subarray(nums, target):
    n = len(nums)
    pre_sum = [0] * (n + 1)
    for i in range(n):
        pre_sum[i + 1] = pre_sum[i] + nums[i]

    if pre_sum[-1] < target:
        return 0

    res = n + 1
    for i in range(1, n + 1):
        tmp_tar = pre_sum[i] - target
        if tmp_tar < 0:
            continue
        left = 0
        right = i
        while left < right:
            mid = (left + right) // 2
            if pre_sum[mid] < tmp_tar:
                left = mid + 1
            else:
                right = mid

        if pre_sum[left] >= tmp_tar:
            res = min(res, i - left)

    return res if res <= n else 0",195
17210186184,find_shortest_subarray,"def find_shortest_subarray(nums):
  if not nums:
    return 0

  low = 0
  high = len(nums) - 1

  while low < len(nums) - 1 and nums[low] <= nums[low + 1]:
    low += 1

  if low == len(nums) - 1:
    return 0

  while high > 0 and nums[high] >= nums[high - 1]:
    high -= 1

  if high == 0:
    return 0

  minVal = min(nums[low: high + 1])
  maxVal = max(nums[low: high + 1])

  while low >= 0 and nums[low] > minVal:
    low -= 1

  while high < len(nums) and nums[high] < maxVal:
    high += 1

  return high - low - 1",195
74520913725,largest_overlap,"from collections import defaultdict

def largest_overlap(img1, img2):
    bestMax = 0
    img1Ones = []
    img2Ones = []
    shiftCount = defaultdict(int)

    for i in range(len(img1)):
        for j in range(len(img1[0])):
            if img1[i][j] == 1: img1Ones.append((i, j))
            if img2[i][j] == 1: img2Ones.append((i, j))

    for r_1, c_1 in img1Ones:
        for r_2, c_2 in img2Ones:
            rowShift, ColShift = r_1 - r_2, c_1 - c_2
            shiftCount[(rowShift, ColShift)] += 1
                
            bestMax = max(bestMax, shiftCount[(rowShift, ColShift)])

    return bestMax",194
13397509372,letter_combinations,"def letter_combinations(digits):
    d_map = { ""2"": [""a"", ""b"", ""c""],
      ""3"": [""d"", ""e"", ""f""],
      ""4"": [""g"", ""h"", ""i""],
      ""5"": [""j"", ""k"", ""l""],
      ""6"": [""m"", ""n"", ""o""],
      ""7"": [""p"", ""q"", ""r"", ""s""],
      ""8"": [""t"", ""u"", ""v""],
      ""9"": [""w"", ""x"", ""y"", ""z""]}

    def make_comb(comb, rem_digits):
        if len(rem_digits) == 0:
            ans.append(comb)
            return
        else:
            for char in d_map[rem_digits[0]]:
                make_comb(comb+char, rem_digits[1:])

    ans = []
    if digits:
        make_comb("""", digits)

    return ans",194
28650492158,containsNearbyAlmostDuplicate,"def containsNearbyAlmostDuplicate(nums, k, t):
    """"""
    :type nums: List[int]
    :type k: int
    :type t: int
    :rtype: bool
    """"""
    if t < 0: return False
    n = len(nums)
    buckets = {}
    bucket_size = t + 1
    for i in range(n):
        bucket_num = nums[i] // bucket_size
        if bucket_num in buckets:
            return True
        if bucket_num - 1 in buckets and abs(nums[i] - buckets[bucket_num - 1]) < bucket_size:
            return True
        if bucket_num + 1 in buckets and abs(nums[i] - buckets[bucket_num + 1]) < bucket_size:
            return True
        buckets[bucket_num] = nums[i]
        if i >= k: del buckets[nums[i-k] // bucket_size]
    return False",194
37346937782,reverse_linked_list,"class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def to_link(ls):
    node = ListNode(ls[0])
    f1 = node
    for i in ls[1:]:
        node2 = ListNode(i)
        node.next = node2
        node = node2
    return f1

def to_list(node):
    l = []
    while node:
        l.append(node.val)
        node = node.next
    return l

class Solution:
    def reverseList(self, head):
        prev = None
        current = head
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        return prev

so = Solution()
def reverse_linked_list(ls):
    node = to_link(ls)
    pp = so.reverseList(node)
    l = to_list(pp)
    return l",193
15907256938,third_max,"def third_max(nums):
    unique_nums = set(nums)
    if len(unique_nums) < 3:
        max_num = float('-inf')
        for num in unique_nums:
            if num > max_num:
                max_num = num
        return max_num
    else:
        max_nums = [float('-inf')] * 3
        for num in unique_nums:
            if num > max_nums[0]:
                max_nums[0], max_nums[1], max_nums[2] = num, max_nums[0], max_nums[1]
            elif num > max_nums[1] and num != max_nums[0]:
                max_nums[1], max_nums[2] = num, max_nums[1]
            elif num > max_nums[2] and num != max_nums[0] and num != max_nums[1]:
                max_nums[2] = num
        return max_nums[2]",193
20588184051,string_multiply,"def string_multiply(num1, num2):
    if num1 == ""0"" or num2 == ""0"":
        return ""0""
        
    n1, n2 = len(num1), len(num2)
    product = [0] * (n1 + n2)

    for i in range(n1 - 1, -1, -1):
        for j in range(n2 - 1, -1, -1):
            mult = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))
            p1, p2 = i + j, i + j + 1
            sum = mult + product[p2]

            product[p1] += sum // 10
            product[p2] = sum % 10

    result = ''.join(map(str, product))
    return result.lstrip(""0"")  # remove leading zeros",193
30659950688,find_target_range,"def find_target_range(nums, target):
    def find_left(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left

    def find_right(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid - 1
        return right

    left, right = find_left(nums, target), find_right(nums, target)
    if left <= right:
        return [left, right]
    else:
        return [-1, -1]",193
41953873284,is_valid_url,"import re

def is_valid_url(url):
    pattern = re.compile(
        r'^(https?://)'  # scheme is http or https
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+'  # domain...
        r'(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain name
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(pattern, url) is not None",193
38069383954,longest_palindromic_substring,"def longest_palindromic_substring(s):
    if len(s) < 2:
        return s

    def expand_around_center(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left+1:right]

    longest_palindrome = """"
    for i in range(len(s)):
        # Odd length palindromes
        palindrome1 = expand_around_center(i, i)
        # Even length palindromes
        palindrome2 = expand_around_center(i, i+1)

        # Update the longest palindrome found
        longer_palindrome = palindrome1 if len(palindrome1) > len(palindrome2) else palindrome2
        if len(longer_palindrome) > len(longest_palindrome):
            longest_palindrome = longer_palindrome

    return longest_palindrome",193
40123624030,minimum_lines,"from typing import List
from decimal import Decimal

def minimum_lines(stock_prices: List[List[int]]) -> int:
    if not stock_prices:
        return 0
    stock_prices.sort(key=lambda x: x[0])
    if len(stock_prices) == 1:
        return 0
    if len(stock_prices) == 2:
        return 1
    res = 1
    pre = Decimal(stock_prices[1][1] - stock_prices[0][1]) / Decimal(stock_prices[1][0] - stock_prices[0][0])
    for i in range(2, len(stock_prices)):
        val = Decimal(stock_prices[i][1] - stock_prices[i-1][1]) / Decimal(stock_prices[i][0] - stock_prices[i-1][0])
        if val == pre:
            continue
        else:
            pre = val
            res += 1
    return res",192
23700568348,lca,"class node():
    def __init__(self, num):
        self.num = num
        self.left = None
        self.right = None

def lca(root, p, q):
    if root is None:
        return None
    if root == p or root == q:
        return root
    left = lca(root.left, p, q)
    right = lca(root.right, p, q)
    if left and right:
        return root
    return left if left else right

root = node(1)
node2 = node(2)
node3 = node(3)
node4 = node(4)
node5 = node(5)
node6 = node(6)
node7 = node(7)

root.left = node2; root.right = node3
node2.left = node4; node2.right = node5
node3.left = node6; node3.right = node7",192
23658511263,max_sum_two_subarrays,"def max_sum_two_subarrays(A: list, L: int, M: int) -> int:
    preSum = [0] * (len(A) + 1)
    for i in range(1, len(preSum)):
        preSum[i] = preSum[i - 1] + A[i - 1]
        
    Lmax, Mmax, ans = preSum[L], preSum[M], preSum[L + M]
    for i in range(L + M + 1, len(preSum)):
        Lmax = max(Lmax, preSum[i - M] - preSum[i - M - L])
        Mmax = max(Mmax, preSum[i - L] - preSum[i - L - M])
        ans = max(ans, Lmax + preSum[i] - preSum[i - M], Mmax + preSum[i] - preSum[i - L])
    return ans",192
20021872952,search_range,"def search_range(nums, target):
    def find_left(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left

    def find_right(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid - 1
        return right

    left, right = find_left(nums, target), find_right(nums, target)
    if left <= right:
        return [left, right]
    else:
        return [-1, -1]",192
4025124952,binary_search_count,"def binary_search_count(arr, target):
    def find_left(arr, target):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left

    def find_right(arr, target):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] <= target:
                left = mid + 1
            else:
                right = mid - 1
        return right

    left = find_left(arr, target)
    right = find_right(arr, target)
    if left <= right:
        return right - left + 1
    else:
        return 0",192
3861073133,count_longest_increasing_subarray,"def count_longest_increasing_subarray(arr):
    n = len(arr)
    if n == 0:
        return 0
    dp = [1]*n
    count = [1]*n
    max_length = 1
    max_count = 1
    for i in range(1, n):
        if arr[i] > arr[i-1]:
            dp[i] = dp[i-1] + 1
            count[i] = count[i-1]
        elif arr[i] == arr[i-1]:
            dp[i] = 1
            count[i] = 1
        else:
            dp[i] = 1
            count[i] = 1
        if dp[i] > max_length:
            max_length = dp[i]
            max_count = count[i]
        elif dp[i] == max_length:
            max_count += count[i]
    return max_count",192
13124959180,maxSlidingWindow,"from collections import deque

def maxSlidingWindow(nums, k):
    res = []
    l = r = 0 # window's frame
    queue = deque() # put indices
    
    while r < len(nums): # while the r is still inbound
        while queue and nums[queue[-1]] < nums[r]:
            queue.pop()
        
        queue.append(r) 
            
        # if the left-most val in the queue is out of the window's bound, we remove it from the queue
        if l > queue[0]:
            queue.popleft()
                
        # edge case, if we wanna append result, we need to make sure the windows is in size of k
        if (r + 1) >= k:
            res.append(nums[queue[0]])
            l += 1 # move left pointer only if the size of the window reaches ""k""
                
        r += 1
    
    return res",192
15390111286,find_fibonacci,"def matrix_mult(a, b):
    c = [[0, 0], [0, 0]]
    for i in range(2):
        for j in range(2):
            for k in range(2):
                c[i][j] += a[i][k] * b[k][j]
    return c

def matrix_power(a, n):
    result = [[1, 0], [0, 1]]
    while n > 0:
        if n % 2 == 1:
            result = matrix_mult(result, a)
        a = matrix_mult(a, a)
        n //= 2
    return result

def find_fibonacci(n):
    if n <= 0:
        return 0
    fib_matrix = [[1, 1], [1, 0]]
    result = matrix_power(fib_matrix, n - 1)
    return result[0][0]",192
25173722973,find_longest_palindrome,"def find_longest_palindrome(s: str) -> str:
    if len(s) <= 1:
        return s

    def expand_around_center(left: int, right: int) -> str:
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]

    longest = """"
    for i in range(len(s)):
        # Odd length palindromes
        palindrome1 = expand_around_center(i, i)
        # Even length palindromes
        palindrome2 = expand_around_center(i, i + 1)

        # Update the longest palindrome found so far
        if len(palindrome1) > len(longest):
            longest = palindrome1
        if len(palindrome2) > len(longest):
            longest = palindrome2

    return longest",192
35194158118,count_subarrays_with_k_distinct,"def count_subarrays_with_k_distinct(arr, k):
    def at_most_k_distinct(arr, k):
        start, end = 0, 0
        count = 0
        freq = {}
        while end < len(arr):
            if arr[end] not in freq:
                k -= 1
                freq[arr[end]] = 0
            freq[arr[end]] += 1
            if k >= 0:
                count += end - start + 1
            else:
                while k < 0:
                    freq[arr[start]] -= 1
                    if freq[arr[start]] == 0:
                        del freq[arr[start]]
                        k += 1
                    start += 1
                count += end - start + 1
            end += 1
        return count

    return at_most_k_distinct(arr, k) - at_most_k_distinct(arr, k-1)",191
6303845580,can_transform,"def can_transform(start: str, end: str) -> bool:
    n = len(start)
    i = j = 0
    while i < n and j < n:
        while i < n and start[i] == 'X':
            i += 1
        while j < n and end[j] == 'X':
            j += 1
        if i < n and j < n:
            if start[i] != end[j]:
                return False
            if (start[i] == 'L' and i < j) or (start[i] == 'R' and i > j):
                return False
            i += 1
            j += 1

    while i < n and start[i] == 'X':
        i += 1
    while j < n and end[j] == 'X':
        j += 1

    return i == n and j == n",191
24269603265,maxProductSubarray,"def maxProductSubarray(nums):
    if not nums:
        return 0

    n = len(nums)
    max_dp = [0] * n
    min_dp = [0] * n
    max_dp[0] = min_dp[0] = nums[0]
    for i in range(1, n):
        max_dp[i] = max(nums[i], max_dp[i - 1] * nums[i], min_dp[i - 1] * nums[i])
        min_dp[i] = min(nums[i], max_dp[i - 1] * nums[i], min_dp[i - 1] * nums[i])
    
    return max(max_dp)

assert maxProductSubarray([2,3,-2,4]) == 6
assert maxProductSubarray([-2,0,-1]) == 0
assert maxProductSubarray([-2,3,-4]) == 24",191
72623434085,edit_distance,"def edit_distance(str1, str2):
    len1, len2 = len(str1)+1, len(str2)+1
    dp = [[0 for j in range(len2)] for i in range(len1)]

    for i in range(len1):
        for j in range(len2):
            if i == 0: dp[i][j] = j
            elif j == 0: dp[i][j] = i

    for i in range(1, len1):
        for j in range(1, len2):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])

    return dp[-1][-1]",191
75280956526,minimum_cost_path,"def minimum_cost_path(grid):
    m, n = len(grid), len(grid[0])
    dp = [[float('inf')] * n for _ in range(m)]
    dp[0][0] = grid[0][0]
    
    for i in range(m):
        for j in range(n):
            if i > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])
    return dp[-1][-1]

print(minimum_cost_path([[1,3,1],[1,5,1],[4,2,1]]))
print(minimum_cost_path([[1,2,5],[3,2,1]]))
print(minimum_cost_path([[4]]))",191
37338712695,binary_search_count,"def binary_search_count(nums, target):
    def find_left(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left

    def find_right(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid - 1
        return right

    left_index = find_left(nums, target)
    right_index = find_right(nums, target)
    return right_index - left_index + 1 if left_index <= right_index else 0",191
71363635544,multiply_strings,"def multiply_strings(num1, num2):
    if num1 == ""0"" or num2 == ""0"":
        return ""0""
    
    len1, len2 = len(num1), len(num2)
    result = [0] * (len1 + len2)
    
    for i in range(len1-1, -1, -1):
        for j in range(len2-1, -1, -1):
            mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))
            p1, p2 = i + j, i + j + 1
            sum = mul + result[p2]
            
            result[p1] += sum // 10
            result[p2] = sum % 10
    
    result_str = ''.join(map(str, result))
    return result_str.lstrip('0')",190
13618448682,n_queens,"def attackable(r1, c1, r2, c2):
    if c1 == c2:
        return True
    if r1 - c1 == r2 - c2:
        return True
    if r1 + c1 == r2 + c2:
        return True
    return False

def dfs(row, col, n):
    if row == n:
        return 1
    else:
        count = 0
        for cand in range(n):
            possible = True
            for i in range(row):
                if attackable(row, cand, i, col[i]):
                    possible = False
                    break
            if possible:
                col[row] = cand
                count += dfs(row + 1, col, n)
        return count

def n_queens(n):
    col = [0 for _ in range(n)]
    return dfs(0, col, n)",190
2742943275,longestPalindrome,"def longestPalindrome(s):
    Lstart,Lend=0,0
    left1,left2,right1,right2=0,0,0,0
    for i in range(len(s)):
        left1,right1=expand(s,i,i)
        if (i+1)<=(len(s)-1) and s[i]==s[i+1]:
            left2,right2=expand(s,i,i+1)
        if (right1-left1)>(Lend-Lstart):
            Lstart,Lend=left1,right1
        if (right2-left2)>(Lend-Lstart):
            Lstart,Lend=left2,right2
    return s[Lstart:Lend+1]

def expand(s,start,end):
    while(start>=0 and end<len(s) and s[start]==s[end]):
        start=start-1
        end=end+1
    return start+1,end-1",190
28590827957,is_valid_word,"class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = ''

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word):
        node = self.root
        for char in word:
            if char in node.children:
                node = node.children[char]
            else:
                new_node = TrieNode()
                node.children[char] = new_node
                node = new_node
        node.word = word

    def is_valid_word(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
            if node.word == '':
                return False
        return True

def is_valid_word(dictionary, word):
    trie = Trie()
    for w in dictionary:
        trie.addWord(w)
    return trie.is_valid_word(word)",190
23842293943,count_target_sum,"def count_target_sum(input_list, target):
    sum_ = sum(input_list)
    if (sum_ + target) % 2 == 1:
        return 0
    return knapsack_0_1_count_sub_set_sum(input_list, (target + sum_) // 2, len(input_list))

def knapsack_0_1_count_sub_set_sum(arr, target, n):
    if target == 0:
        return 1
    if n == 0:
        return 0
    if arr[n - 1] > target:
        return knapsack_0_1_count_sub_set_sum(arr, target, n - 1)
    return knapsack_0_1_count_sub_set_sum(arr, target, n - 1) + knapsack_0_1_count_sub_set_sum(arr, target - arr[n - 1], n - 1)",190
40994414073,decode_ways,"def decode_ways(s: str) -> int:
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if 10 <= int(s[i-2:i]) <= 26 and s[i-1] != '0':
            dp[i] = dp[i-1] + dp[i-2]
        elif int(s[i-2:i]) == 10 or int(s[i-2:i]) == 20:
            dp[i] = dp[i-2]
        elif s[i-1] != '0':
            dp[i] = dp[i-1]
        else:
            return 0
    return dp[n]",190
73884221228,fib_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def fib_prime(n):
    def fib(n):
        a, b = 0, 1
        for _ in range(n):
            a, b = b, a + b
        return a
    i = 1
    count = 0
    while True:
        f = fib(i)
        if is_prime(f):
            count += 1
            if count == n:
                return f
        i += 1",190
15907052498,find_pairs,"def find_pairs(lst, target):
    seen = set()
    result = []
    for num in lst:
        complement = target - num
        if complement in seen:
            result.append((min(num, complement), max(num, complement)))
        seen.add(num)
    return sorted(list(set(result)))

print(find_pairs([1, 3, 2, 2, 4, 0], 4))  # [(0, 4), (1, 3), (2, 2)]
print(find_pairs([10, 7, 5, 3, 1, 8], 11))  # [(3, 8), (5, 6)]
print(find_pairs([5, 5, 5, 5], 10))  # [(5, 5)]
print(find_pairs([1, 2, 3], 7))  # []",190
1621570251,decode_variations,"def decode_variations(s):
    """"""
    Calculate the number of ways to decode a string encoded by a substitution cipher.
    
    :param s: A string consisting of digits, representing the encoded message.
    :return: The number of ways to decode the message.
    """"""
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] != '0':
            dp[i] += dp[i-1]
        if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] <= '6'):
            dp[i] += dp[i-2]
    return dp[n]",190
34655015714,longest_substring_with_k_unique,"def longest_substring_with_k_unique(s, k):
    """"""
    :type s: str
    :type k: int
    :rtype: str
    """"""
    if k == 0:
        return """"
    
    char_map = {}
    left, right = 0, 0
    max_length = 0
    max_substring = """"

    while right < len(s):
        char_map[s[right]] = char_map.get(s[right], 0) + 1

        while len(char_map) > k:
            char_map[s[left]] -= 1
            if char_map[s[left]] == 0:
                del char_map[s[left]]
            left += 1

        if right - left + 1 > max_length:
            max_length = right - left + 1
            max_substring = s[left:right+1]

        right += 1

    return max_substring",190
22208848047,longestPalindrome,"def longestPalindrome(s: str) -> str:
    res = """"
    resLen = 0

    for i in range(len(s)):
        #odd length
        l,r = i,i
        while l >= 0 and r < len(s) and s[l] == s[r]:
            if (r - l + 1) > resLen:
                res = s[l:r+1]
                resLen = r - l + 1
            l -= 1
            r += 1

        #even length
        l,r = i,i+1
        while l >= 0 and r < len(s) and s[l] == s[r]:
            if (r - l + 1) > resLen:
                res = s[l:r+1]
                resLen = r - l + 1
            l -= 1
            r += 1

    return res",190
27438987081,decodeWays,"def decodeWays(s: str) -> int:
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if 10 <= int(s[i-2:i]) <= 26 and s[i-1] != '0':
            dp[i] = dp[i-1] + dp[i-2]
        elif int(s[i-2:i]) == 10 or int(s[i-2:i]) == 20:
            dp[i] = dp[i-2]
        elif s[i-1] != '0':
            dp[i] = dp[i-1]
        else:
            return 0
    return dp[n]",190
20855039910,is_valid_stack_sequence,"def is_valid_stack_sequence(push_sequence, pop_sequence):
    stack = []
    j = 0
    for x in push_sequence:
        stack.append(x)
        while stack and j < len(pop_sequence) and stack[-1] == pop_sequence[j]:
            stack.pop()
            j += 1
    return j == len(pop_sequence)

push_sequence = [1, 2, 3, 4, 5]
pop_sequence1 = [4, 5, 3, 2, 1]
pop_sequence2 = [4, 3, 5, 1, 2]
pop_sequence3 = [5, 4, 3, 2, 1]

assert is_valid_stack_sequence(push_sequence, pop_sequence1) == True
assert is_valid_stack_sequence(push_sequence, pop_sequence2) == False
assert is_valid_stack_sequence(push_sequence, pop_sequence3) == True",190
21722590261,longest_common_subsequence,"def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [["""" for _ in range(n+1)] for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + s1[i-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)
    return dp[m][n]

print(longest_common_subsequence(""ABCDGH"", ""AEDFHR""))
print(longest_common_subsequence(""AGGTAB"", ""GXTXAYB""))
print(longest_common_subsequence(""ABC"", ""AC""))",189
70452258132,numberOfBinaryTreeTopologies,"def numberOfBinaryTreeTopologies(n):
	'''
	Time: O(2n choose n)
	Space: O(n) due to the dictionary and the recursive function calls on the call stack

	Idea:
	
	By memoization. Solution by recursion.
	A tree with n + 1 node has left subtree of size i and right subtree of size n - i
	where i is in {0, 1, ..., n} and use multiplication rule.
	'''
	return helperNumTopology(n)


def helperNumTopology(n, memoize={0: 1, 1: 1, 2: 2}):

	if n in memoize:
		return memoize[n]

	total = 0

	for k in range(0, n):
		total += helperNumTopology(k, memoize) * helperNumTopology(n - k - 1, memoize)

	memoize[n] = total

	return total",189
43661529514,zero_sum_triplets,"def zero_sum_triplets(nums):
    nums.sort()
    triplets = []
    for i in range(len(nums)-2):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        left, right = i+1, len(nums)-1
        while left < right:
            sum = nums[i] + nums[left] + nums[right]
            if sum < 0:
                left += 1
            elif sum > 0:
                right -= 1
            else:
                triplets.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left+1]:
                    left += 1
                while left < right and nums[right] == nums[right-1]:
                    right -= 1
                left += 1
                right -= 1
    return len(set(tuple(i) for i in triplets))",189
75276145395,find_target_position,"def find_target_position(nums, target):
    def binary_search(left, right, find_first):
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                if find_first:
                    if mid == left or nums[mid-1] < target:
                        return mid
                    right = mid - 1
                else:
                    if mid == right or nums[mid+1] > target:
                        return mid
                    left = mid + 1
        return -1

    first = binary_search(0, len(nums)-1, True)
    if first == -1:
        return [-1, -1]
    last = binary_search(0, len(nums)-1, False)
    return [first, last]",189
35239527603,min_window,"import collections

def min_window(s: str, t: str) -> str:
    answer = ''
    targets = collections.Counter(t)
    tracks = collections.Counter()

    target_keys = set(targets.keys())

    lt = next((idx for idx in range(len(s)) if s[idx] in target_keys), 0)

    for rt in range(lt, len(s)):
        if s[rt] in target_keys:
            tracks[s[rt]] += 1

            while all(tracks[char] >= targets[char] for char in target_keys):
                substring = s[lt: rt + 1]
                if answer == '' or len(substring) < len(answer):
                    answer = substring

                tracks[s[lt]] -= 1
                lt = next((j for j in range(lt + 1, rt + 1) if s[j] in target_keys), lt)

    return answer",189
365628627,edit_distance,"def edit_distance(str1, str2):
    len1 = len(str1)
    len2 = len(str2)
    step = [[0 for i in range(len2+1)] for j in range(len1+1)]
    for i in range(len2+1):
        step[0][i] = i
    for j in range(len1+1):
        step[j][0] = j
    for i in range(1,len1+1):
        for j in range(1,len2+1):
            if str2[j-1] == str1[i-1]:
                step[i][j] = step[i-1][j-1]
            else:
                step[i][j] = min(step[i-1][j-1],step[i-1][j],step[i][j-1]) + 1
    return step[len1][len2]",189
10243078727,longest_Palindrome,"def longest_Palindrome(s: str) -> str:
    if len(s) < 2:
        return s

    def expand_around_center(left: int, right: int) -> str:
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]

    longest = """"
    for i in range(len(s)):
        # Odd length palindromes
        palindrome1 = expand_around_center(i, i)
        # Even length palindromes
        palindrome2 = expand_around_center(i, i + 1)

        # Update the longest palindrome found
        if len(palindrome1) > len(longest):
            longest = palindrome1
        if len(palindrome2) > len(longest):
            longest = palindrome2

    return longest",189
25398272016,find_Nth_Prime,"from math import sqrt

def find_Nth_Prime(n):
    pn = n

    sieve_size = 110000
    sieve = list(range(sieve_size))
    sieve[0] = None
    sieve[1] = None

    pi = 1
    for i in range(sieve_size):
        if sieve[i] == None:
            continue
        pi += 1
        j = 2
        while i*j < sieve_size:
            sieve[i*j] = None
            j += 1
    
    if pi < pn:
        return f'Only {pi} primes out of {pn} found. Increase sieve_size.'
    else:
        sieve = [x for x in sieve if x is not None]
        return sieve[pn-1]

if __name__ == '__main__':
    print(find_Nth_Prime(10001))",189
4176786734,hex_to_decimal,"def hex_to_decimal(hex_string):
    hex_values = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,
                  'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15, 'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15}
    decimal_value = 0
    for char in hex_string:
        decimal_value = decimal_value * 16 + hex_values[char]
    return decimal_value",189
27278959951,longestCommonSubsequence,"def longestCommonSubsequence(text1, text2):
    n = len(text1)
    m = len(text2)
    dp = [[-1 for i in range(m + 1)] for i in range(n + 1)]
    
    for i in range(n + 1):
        dp[i][0] = 0
    for i in range(m + 1):
        dp[0][i] = 0
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = 1 + dp[i - 1][j - 1]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[n][m]",189
17870625191,remove_value_doubly_linked_list,"class Node:
    def __init__(self, data=None):
        self.data = data
        self.prev = None
        self.next = None

def remove_value_doubly_linked_list(val, arr):
    head = Node(arr[0])
    current = head
    for i in range(1, len(arr)):
        node = Node(arr[i])
        current.next = node
        node.prev = current
        current = current.next

    current = head
    while current:
        if current.data == val:
            if current.prev:
                current.prev.next = current.next
            if current.next:
                current.next.prev = current.prev
            current.data = None
        current = current.next

    while head and head.data is None:
        head = head.next

    result = []
    current = head
    while current:
        result.append(current.data)
        current = current.next

    return result",189
74712023418,kth_permutation,"def find_fac(n):
    result = 1
    for i in range(1, n + 1):
        result = result * i
    return result

def kth_permutation(n, k):
    result = []
    opt_list = [x for x in range(1, n + 1)]
    k = k - 1
    while len(opt_list) > 1:
        fac = find_fac(len(opt_list) - 1)
        numb = k // (find_fac(len(opt_list) - 1))
        result.append(opt_list[numb])
        opt_list = opt_list[:numb] + opt_list[numb + 1:]
        k = k - numb * fac
    if len(opt_list) == 1:
        result.append(opt_list[0])
    result_str = ''
    for i in result:
        result_str += str(i)
    return result_str",189
6203700740,count_islands,"def count_islands(grid):
    if not grid:
        return 0
    m, n = len(grid), len(grid[0])
    count = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                count += 1
                grid[i][j] = 0
                stack = [(i, j)]
                while stack:
                    x, y = stack.pop()
                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:
                            stack.append((nx, ny))
                            grid[nx][ny] = 0
    return count",189
180991771,minimum_operations,"def minimum_operations(str1, str2):
    len1, len2 = len(str1), len(str2)
    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]
    
    for i in range(len1 + 1):
        for j in range(len2 + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
                
    return dp[len1][len2]",189
10108254239,is_valid_url,"import re

def is_valid_url(url):
    regex = re.compile(
        r'^(?:http|ftp)s?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(regex, url) is not None",188
14031907100,count_decodings,"def count_decodings(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1

    for i in range(2, n + 1):
        if 10 <= int(s[i-2:i]) <= 26 and s[i-1] != '0':
            dp[i] = dp[i-1] + dp[i-2]
        elif int(s[i-2:i]) == 10 or int(s[i-2:i]) == 20:
            dp[i] = dp[i-2]
        elif s[i-1] != '0':
            dp[i] = dp[i-1]
        else:
            dp[i] = 0

    return dp[n]",188
41957071541,is_valid_url,"import re

def is_valid_url(url):
    regex = re.compile(
        r'^(?:http|ftp)s?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(regex, url) is not None",188
35486107143,check_intersection,"def check_intersection(top_left1, bottom_right1, top_left2, bottom_right2):
    x1, y1 = top_left1
    x2, y2 = bottom_right1
    x3, y3 = top_left2
    x4, y4 = bottom_right2
    
    # Check if one rectangle is to the left of the other
    if x1 > x4 and x2 < x3:
        return False

    # Check if one rectangle is above the other
    if y1 > y4 and y2 < y3:
        return False

    # Check if one rectangle is to the right of the other
    if x3 > x2 and x4 < x1:
        return False

    # Check if one rectangle is below the other
    if y3 > y2 and y4 < y1:
        return False

    return True",188
36094875741,max_score,"from collections import deque

def max_score(nums, k):
    n = len(nums)
    window = deque([])
    dp = [float('-inf')] * n
    dp[0] = nums[0]
    window.append(dp[0])
    for p in range(1, n):
        dp[p] = max(window) + nums[p]
        if len(window) == k:
            window.popleft()
        window.append(dp[p])
    
    return dp[n-1]

# Test cases
assert max_score([1, 10, -1, 5, 1], 3) == 17
assert max_score([1, -1, -2, 4, -7, 3], 2) == 7
assert max_score([10, -5, -2, 4, 0, 3], 3) == 17",188
10891773850,find_zero_sum_triplets,"def find_zero_sum_triplets(nums):
    nums.sort()
    triplets = set()
    for i in range(len(nums)):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                triplets.add((nums[i], nums[left], nums[right]))
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    return len(triplets)",188
74491402105,triplet_sum,"def triplet_sum(nums, target):
    nums.sort()
    triplets = []
    n = len(nums)
    for i in range(n):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        left = i + 1
        right = n - 1
        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]
            if current_sum == target:
                triplets.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif current_sum < target:
                left += 1
            else:
                right -= 1
    return triplets",188
41048458666,min_operations_to_equal,"def min_operations_to_equal(str1: str, str2: str) -> int:
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])

    return dp[m][n]",188
35211741655,largestRectangle,"from collections import deque

def largestRectangle(matrix):
    if not matrix:
        return 0

    n = len(matrix)
    m = len(matrix[0])
    height = [0]*m
    max_area = 0

    for i in range(n):
        for j in range(m):
            if matrix[i][j] == 1:
                height[j] += 1
            else:
                height[j] = 0

        stack = deque()
        area = 0
        for j in range(m+1):
            while stack and (j == m or height[stack[-1]] >= height[j]):
                h = height[stack.pop()]
                w = j if not stack else j - stack[-1] - 1
                area = max(area, h * w)
            stack.append(j)
        max_area = max(max_area, area)

    return max_area",187
39659228510,edit_distance,"def edit_distance(s, t):
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        dp[i][0] = i

    for j in range(n + 1):
        dp[0][j] = j

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1

    return dp[m][n]",187
15445896928,merge_sort,"def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)
        merge_sort(right_half)

        i = j = k = 0

        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1
    return arr",187
10793914792,ways_to_sum,"def ways_to_sum(n):
    if n == 0:
        return 1
    if n < 0:
        return 0
    return ways_to_sum(n-1) + ways_to_sum(n-3) + ways_to_sum(n-4)

# This function can be optimized using dynamic programming to avoid recalculating the same values multiple times.
# Since the above solution has overlapping sub-problems and optimal substructure, we can use dynamic programming.
def ways_to_sum_dp(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        dp[i] = dp[i-1]
        if i >= 3:
            dp[i] += dp[i-3]
        if i >= 4:
            dp[i] += dp[i-4]
    return dp[n]",187
43931120006,largest_histogram,"def largest_histogram(histogram):
    stack = list()
    max_area = 0
    index = 0

    while index < len(histogram):
        if (not stack) or (histogram[stack[-1]] <= histogram[index]):
            stack.append(index)
            index += 1
        else:
            top_of_stack = stack.pop()
            if not stack:
                area = histogram[top_of_stack] * index
            else:
                area = histogram[top_of_stack] * (index - stack[-1] - 1)
            max_area = max(max_area, area)

    while stack:
        top_of_stack = stack.pop()
        if not stack:
            area = histogram[top_of_stack] * index
        else:
            area = histogram[top_of_stack] * (index - stack[-1] - 1)
        max_area = max(max_area, area)

    return max_area",187
12545836259,longest_common_substring,"def longest_common_substring(str1, str2):
    m = len(str1)
    n = len(str2)
    result = 0
    end = 0
    L = [[0 for x in range(n+1)] for x in range(m+1)]
 
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif str1[i-1] == str2[j-1]:
                L[i][j] = L[i-1][j-1] + 1
                if L[i][j] > result:
                    result = L[i][j]
                    end = i - 1
            else:
                L[i][j] = 0
    return str1[end-result+1:end+1]",187
40152278138,max_abs_diff,"from typing import List

def max_abs_diff(array: List[int]) -> int:
    if not array or len(array) < 2:
        return 0

    left_max = array[0]
    left_maxes = [left_max]
    for i in range(1, len(array)):
        if array[i] > left_max:
            left_max = array[i]
        left_maxes.append(left_max)

    right_max = array[-1]
    right_maxes = [right_max]
    for i in range(len(array) - 2, -1, -1):
        if array[i] > right_max:
            right_max = array[i]
        right_maxes.insert(0, right_max)

    max_diff = 0
    for i in range(len(array)):
        max_diff = max(max_diff, abs(left_maxes[i] - right_maxes[i]))

    return max_diff",187
14296983059,check_URL,"import re

def check_URL(url):
    regex = re.compile(
        r'^(?:http|ftp)s?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(regex, url) is not None",187
40557682739,merge_sort,"def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)
        merge_sort(right_half)

        i = j = k = 0

        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1

    return arr",187
16044441620,find_largest_in_binary_tree,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def create_tree(arr):
    if not arr:
        return None
    nodes = [None if val is None else TreeNode(val) for val in arr]
    kids = nodes[::-1]
    root = kids.pop()
    for node in nodes:
        if node:
            if kids: node.left  = kids.pop()
            if kids: node.right = kids.pop()
    return root

def find_largest_in_binary_tree(arr):
    tree = create_tree(arr)
    max_val = float('-inf')
    stack = [tree]
    while stack:
        node = stack.pop()
        if node:
            max_val = max(max_val, node.val)
            stack.extend([node.left, node.right])
    return max_val",187
25308238081,num_ways_to_decode,"def num_ways_to_decode(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if 10 <= int(s[i-2:i]) <= 26 and s[i-1] != '0':
            dp[i] = dp[i-1] + dp[i-2]
        elif int(s[i-2:i]) == 10 or int(s[i-2:i]) == 20:
            dp[i] = dp[i-2]
        elif s[i-1] != '0':
            dp[i] = dp[i-1]
        else:
            return 0
    return dp[n]",187
15951728651,longest_palindromic_substring,"def longest_palindromic_substring(s: str) -> str:
    if len(s) <= 1:
        return s
    
    def expand_around_center(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]
    
    longest = """"
    for i in range(len(s)):
        # Odd length palindromes
        palindrome1 = expand_around_center(i, i)
        # Even length palindromes
        palindrome2 = expand_around_center(i, i + 1)
        
        # Update the longest palindrome found
        if len(palindrome1) > len(longest):
            longest = palindrome1
        if len(palindrome2) > len(longest):
            longest = palindrome2
            
    return longest",187
23520921287,is_valid_date,"def is_valid_date(date_str):
    # Function to check if a given string represents a valid date in the format 'YYYY-MM-DD'
    try:
        year, month, day = map(int, date_str.split('-'))
        if year < 1 or month < 1 or month > 12 or day < 1:
            return False
        if month in [4, 6, 9, 11] and day > 30:
            return False
        if month == 2:
            if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
                if day > 29:
                    return False
            elif day > 28:
                return False
        elif day > 31:
            return False
        return True
    except ValueError:
        return False",186
71864173008,minimum_edit_distance,"def minimum_edit_distance(str1, str2):
    len_str1 = len(str1)
    len_str2 = len(str2)
    dp = [[0 for _ in range(len_str2+1)] for _ in range(len_str1+1)]
    for i in range(len_str1+1):
        for j in range(len_str2+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    return dp[len_str1][len_str2]",186
1498675916,can_segment_string,"from typing import List

def can_segment_string(s: str, dictionary: List[str]) -> bool:
    word_set = set(dictionary)
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break
    return dp[len(s)]

if __name__ == '__main__':
    assert can_segment_string(""pineapplepenapple"", [""apple"", ""pen"", ""applepen"", ""pine"", ""pineapple""]) == True
    assert can_segment_string(""catsandog"", [""cats"", ""dog"", ""sand"", ""and"", ""cat""]) == False
    assert can_segment_string(""hello"", [""hello"", ""world""]) == True",186
34587222511,min_subarray_length,"def min_subarray_length(nums, target):
    """"""
    To get the shortest subarray whose sum is more than target value, we need a start and end. Once nums[start:end] is more than target, it's pointless to extend more end cuz all elements are positive,
    people should extend start to try other subarray which could obtain shorter length
    """"""
    target_length = len(nums) + 1  # the length of subarray having shortest length
    start = sum_subarray = 0
    for end in range(len(nums)):
        sum_subarray += nums[end]
        while sum_subarray >= target and start <= end:
            target_length = min(target_length, end - start + 1)
            sum_subarray -= nums[start]
            start += 1
    if target_length == len(nums) + 1:
        return 0
    else:
        return target_length",186
24098652526,find_triplets,"def find_triplets(nums):
    nums.sort()
    triplets = set()
    for i in range(len(nums)-2):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        left, right = i+1, len(nums)-1
        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]
            if current_sum == 0:
                triplets.add((nums[i], nums[left], nums[right]))
                while left < right and nums[left] == nums[left+1]:
                    left += 1
                while left < right and nums[right] == nums[right-1]:
                    right -= 1
                left += 1
                right -= 1
            elif current_sum < 0:
                left += 1
            else:
                right -= 1
    return len(triplets)",186
42531104128,grid_min_path,"def grid_min_path(grid):
    m = len(grid)
    n = len(grid[0])
    
    # Initialize the first cell
    min_cost = grid[0][0]
    
    # Update the first row
    for j in range(1, n):
        grid[0][j] += grid[0][j-1]
    
    # Update the first column
    for i in range(1, m):
        grid[i][0] += grid[i-1][0]
    
    # Update the rest of the cells
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    
    # The last cell contains the minimum path sum
    min_cost = grid[m-1][n-1]
    
    return min_cost",186
39666508947,letter_combinations,"def letter_combinations(digit_string):
    phone = {'2': ['a', 'b', 'c'],
             '3': ['d', 'e', 'f'],
             '4': ['g', 'h', 'i'],
             '5': ['j', 'k', 'l'],
             '6': ['m', 'n', 'o'],
             '7': ['p', 'q', 'r', 's'],
             '8': ['t', 'u', 'v'],
             '9': ['w', 'x', 'y', 'z']}
    if not digit_string:
        return []
    if len(digit_string) == 1:
        return phone[digit_string]
    combinations = []
    for letter in phone[digit_string[0]]:
        for combination in letter_combinations(digit_string[1:]):
            combinations.append(letter + combination)
    return combinations",186
75246721625,find_longest_palindrome,"def find_longest_palindrome(s):
    if len(s) < 2:
        return s

    def expand_around_center(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]

    longest_palindrome = """"
    for i in range(len(s)):
        # Odd length palindrome
        palindrome1 = expand_around_center(i, i)
        # Even length palindrome
        palindrome2 = expand_around_center(i, i + 1)
        # Choose the longer palindrome
        longer_palindrome = palindrome1 if len(palindrome1) > len(palindrome2) else palindrome2
        if len(longer_palindrome) > len(longest_palindrome):
            longest_palindrome = longer_palindrome

    return longest_palindrome",186
22056289228,min_sub_array_len,"from typing import List


def min_sub_array_len(target: int, nums: List[int]) -> int:
    left = 0
    current_sum = 0
    min_length = float('inf')

    for right in range(len(nums)):
        current_sum += nums[right]

        while current_sum >= target:
            min_length = min(min_length, right - left + 1)
            current_sum -= nums[left]
            left += 1

    return 0 if min_length == float('inf') else min_length


# Test cases
assert min_sub_array_len(7, [2,3,1,2,4,3]) == 2
assert min_sub_array_len(4, [1,4,4]) == 1
assert min_sub_array_len(11, [1,1,1,1,1,1,1,1]) == 0",186
29375464673,can_become_palindrome,"def can_become_palindrome(s):
    char_count = {}
    odd_count = 0
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1

if __name__ == '__main__':
    assert can_become_palindrome(""radar"") == True
    assert can_become_palindrome(""racecar"") == True
    assert can_become_palindrome(""abc"") == True
    assert can_become_palindrome(""abcd"") == True
    assert can_become_palindrome(""abcde"") == True
    assert can_become_palindrome(""abcdea"") == False
    print(""All test cases passed."")",185
71036679703,num_unique_bst,"def num_unique_bst(n):
    # Initialize a list to store the number of unique binary search trees for each number up to n
    dp = [0] * (n + 1)
    # There is 1 unique binary search tree for 0 and 1 nodes
    dp[0], dp[1] = 1, 1

    # Iterate over each number from 2 to n
    for i in range(2, n + 1):
        # Iterate over each possible root value for the current number
        for j in range(1, i + 1):
            # The number of unique binary search trees for the current number is the sum of the number of unique binary search trees for the left and right subtrees of each possible root value
            dp[i] += dp[j - 1] * dp[i - j]

    return dp[n]",185
37569348567,smallest_substring,"def smallest_substring(s):
    if not s:
        return """"
    unique_chars = set(s)
    n = len(s)
    start = 0
    min_len = n
    min_start = 0
    count = {}
    for end in range(n):
        if s[end] in unique_chars:
            if s[end] in count:
                count[s[end]] += 1
            else:
                count[s[end]] = 1
        while len(count) == len(unique_chars):
            if end - start + 1 < min_len:
                min_len = end - start + 1
                min_start = start
            if s[start] in count:
                count[s[start]] -= 1
                if count[s[start]] == 0:
                    del count[s[start]]
            start += 1
    return s[min_start: min_start + min_len]",185
39769626391,search_in_matrix,"def search_in_matrix(matrix, target):
    top = 0
    bot = len(matrix) - 1

    while top <= bot:
        mid = (top + bot) // 2

        if matrix[mid][0] < target and matrix[mid][-1] > target:
            break
        elif matrix[mid][0] > target:
            bot = mid - 1
        else:
            top = mid + 1
    
    row = (top + bot) // 2

    left = 0
    right = len(matrix[row]) - 1

    while left <= right:
        mid = (left + right) // 2

        if matrix[row][mid] == target:
            return True
        elif matrix[row][mid] > target:
            right = mid - 1
        else:
            left = mid + 1
    
    return False",185
6423472685,shortest_path,"from collections import deque

def shortest_path(grid, start, end):
    rows, cols = len(grid), len(grid[0])
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    visited = set()
    queue = deque([(start, 0)])
    visited.add(start)

    while queue:
        (x, y), distance = queue.popleft()
        if (x, y) == end:
            return distance

        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited:
                visited.add((nx, ny))
                queue.append(((nx, ny), distance + 1))

    return -1",185
44158530546,smallestChair,"import heapq

def smallestChair(times, targetFriend):
    friendsCount = len(times)
    times = sorted([(arr, lea, i) for i, (arr, lea) in enumerate(times)])
    chairs = list(range(friendsCount))
    heapq.heapify(chairs)
    occupiedChairs = []  # [time till it is occupied, chair number]
    heapq.heapify(occupiedChairs)
    
    for arrival, leaving, index in times:
        while occupiedChairs and occupiedChairs[0][0] <= arrival:
            _, chairAvailable = heapq.heappop(occupiedChairs)
            heapq.heappush(chairs, chairAvailable)
        smallestChairNumberAvailable = heapq.heappop(chairs)
        if index == targetFriend:
            return smallestChairNumberAvailable
        heapq.heappush(occupiedChairs, (leaving, smallestChairNumberAvailable))",185
16612919276,find_zero_sum_triplets,"def find_zero_sum_triplets(nums):
    nums.sort()
    triplets = set()
    for i in range(len(nums)-2):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        left, right = i+1, len(nums)-1
        while left < right:
            s = nums[i] + nums[left] + nums[right]
            if s > 0:
                right -= 1
            elif s < 0:
                left += 1
            else:
                triplets.add((nums[i], nums[left], nums[right]))
                while left < right and nums[left] == nums[left+1]:
                    left += 1
                while left < right and nums[right] == nums[right-1]:
                    right -= 1
                left += 1
                right -= 1
    return len(triplets)",185
71609902248,three_subset_partition,"def three_subset_partition(nums):
    total = sum(nums)
    if len(nums) < 3 or total % 3:
        return False
    third = total // 3
    table = [[0] * (len(nums) + 1) for _ in range(third + 1)]

    for i in range(1, third + 1):
        for j in range(1, len(nums) + 1):
            ii = i - nums[j - 1]
            if nums[j - 1] == i or (ii > 0 and table[ii][j - 1]):
                table[i][j] = 1 if table[i][j - 1] == 0 else 2
            else:
                table[i][j] = table[i][j - 1]

    return True if table[-1][-1] == 2 else False",185
38122137720,get_fibonacci,"def get_fibonacci(n):
    # If n is less than or equal to 1, then the number is n itself
    if n <= 1:
        return n

    # Create a list to store the Fibonacci numbers
    dp = [0] * (n+1)

    # The 0th and 1st Fibonacci numbers are 0 and 1
    dp[0] = 0
    dp[1] = 1

    # Start from the 2nd number and fill up the dp list using the formula:
    # dp[i] = dp[i-1] + dp[i-2]
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]

    return dp[n]  # Return the nth Fibonacci number
#time O(n)
#space O(n)",185
30898268513,find_longest_palindrome,"def find_longest_palindrome(s):
    if len(s) <= 1:
        return s

    def expand_around_center(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]

    longest = """"
    for i in range(len(s)):
        # Odd length palindromes
        palindrome1 = expand_around_center(i, i)
        # Even length palindromes
        palindrome2 = expand_around_center(i, i + 1)

        # Update the longest palindrome found
        longer_palindrome = palindrome1 if len(palindrome1) > len(palindrome2) else palindrome2
        if len(longer_palindrome) > len(longest):
            longest = longer_palindrome

    return longest",185
17489646513,length_of_longest_substring_k_distinct,"def length_of_longest_substring_k_distinct(s, k):
    """"""
    :type s: str
    :type k: int
    :rtype: int
    """"""
    ans = 0

    if not s or not k or k < 0:
        return ans

    freqs = {}
    i = cnt = 0

    for j in range(len(s)):
        if s[j] in freqs:
            freqs[s[j]] += 1
        else:
            freqs[s[j]] = 1
            cnt += 1

        while cnt > k:
            if freqs[s[i]] == 1:
                del freqs[s[i]]
                cnt -= 1
            else:
                freqs[s[i]] -= 1
                
            i += 1

        ans = max(ans, j - i + 1)

    return ans",185
71316318526,isValidBrackets,"def isValidBrackets(s):
    # Dictionary to hold the mapping of brackets
    bracketMap = {')': '(', ']': '[', '}': '{'}
    # Stack to hold the opening brackets
    stack = []
    for char in s:
        if char in bracketMap.values():
            # If the character is an opening bracket, push it onto the stack
            stack.append(char)
        elif char in bracketMap.keys():
            # If the character is a closing bracket and the stack is empty or the top of the stack is not the corresponding opening bracket, return False
            if not stack or stack[-1] != bracketMap[char]:
                return False
            # If the top of the stack is the corresponding opening bracket, pop it from the stack
            stack.pop()
    # If the stack is empty, all brackets were correctly closed and opened in the correct order
    return not stack",185
34587203681,maxLen,"def maxLen(arr, n): 
    # Creates an empty hashMap hM 
    hM = {} 
    # Initialize result 
    max_len = 0
    # Initialize sum of elements 
    curr_sum = 0
  
    # Traverse through the given array 
    for i in range (0, n): 
  
        # Add current element to sum 
        curr_sum = curr_sum + arr[i] 
  
        # To handle sum=0 at last index 
        if (curr_sum==0): 
            max_len = i+1
  
        # If this sum is seen before, then update max_len 
        # if required 
        if curr_sum in hM: 
            max_len = max(max_len, i-hM[curr_sum]) 
        else: 
  
            # else put this sum in hash table 
            hM[curr_sum] = i 
  
    return max_len",185
11492010179,min_steps_palindrome,"def min_steps_palindrome(arr):
    def helper(i, j):
        if i >= j:
            return 0
        if dp[i][j] != -1:
            return dp[i][j]
        if arr[i] == arr[j]:
            dp[i][j] = helper(i + 1, j - 1)
        else:
            dp[i][j] = 1 + min(helper(i + 1, j), helper(i, j - 1))
            dp[i][j] = min(dp[i][j], 1 + min(helper(i + 1, j - 1), helper(i + 1, j - 1) + 1))
        return dp[i][j]

    n = len(arr)
    dp = [[-1 for _ in range(n)] for _ in range(n)]
    return helper(0, n - 1)",185
39065113978,shortest_subarray,"import collections

def shortest_subarray(A, K):
	""""""
	:type A: List[int]
	:type K: int
	:rtype: int
	""""""
	sum_dict = {}
	sum_temp = 0
	sum_dict[0] = 0
	length = len(A) + 1
	for i in range(1, len(A) + 1):
		sum_temp += A[i - 1]
		sum_dict[i] = sum_temp
	queue = collections.deque()

	for i in range(len(A) + 1):
		while (queue and sum_dict[queue[-1]] >= sum_dict[i]):
			queue.pop()
		while (queue and sum_dict[i] - sum_dict[queue[0]] >= K):
			length = min(length, i - queue.popleft())
		queue.append(i)
	if length > len(A):
		length = -1
	return length",184
26229275690,non_repeat_substring,"def non_repeat_substring(s):
    if len(s) == 0:
        return 0
    window_start = 0
    max_len = 0
    my_map = {}

    for window_end in range(len(s)):
        right_char = s[window_end]

        if right_char in my_map:
            window_start = max(window_start, my_map[right_char]+1)

        my_map[right_char] = window_end

        max_len = max(max_len, window_end - window_start + 1)

    return max_len


def main():
    print(""Length of the longest substring: "" +
          str(non_repeat_substring(""aabccbb"")))
    print(""Length of the longest substring: "" +
          str(non_repeat_substring(""abbbb"")))
    print(""Length of the longest substring: "" +
          str(non_repeat_substring(""abccde"")))


main()",184
41978546995,numberOfWays,"def numberOfWays(m, n): 
    # Create a 2D table to store results of subproblems 
    count = [[0 for x in range(n)] for x in range(m)] 
  
    # Count of paths to reach any cell in first column is 1 
    for i in range(m): 
        count[i][0] = 1; 
  
    # Count of paths to reach any cell in first column is 1 
    for j in range(n): 
        count[0][j] = 1; 
  
    # Calculate count of paths for other cells in bottom-up manner using the recursive solution 
    for i in range(1, m): 
        for j in range(n): 
            count[i][j] = count[i-1][j] + count[i][j-1] 
    return count[m-1][n-1]",184
22376782791,find_largest_palindrome,"def find_largest_palindrome(orig: str) -> str:
    if len(orig) <= 1:
        return orig
    best = """"  # best palindrome string
    for i in range(len(orig)):
        # Case 1: odd length palindrome
        acc = expand_around_center(orig, i, i)
        if len(acc) > len(best):
            best = acc
        # Case 2: even length palindrome
        acc = expand_around_center(orig, i, i+1)
        if len(acc) > len(best):
            best = acc
    return best

def expand_around_center(s: str, left: int, right: int) -> str:
    while left >= 0 and right < len(s) and s[left] == s[right]:
        left -= 1
        right += 1
    return s[left+1:right]",184
22961543392,max_unique_substring,"def max_unique_substring(s: str) -> int:
    # Initialize the start index of the current substring and the maximum length
    start, max_len = 0, 0
    # Initialize a dictionary to store the last index of each character
    char_index = {}

    for i, char in enumerate(s):
        # If the character is already in the dictionary and its last index is greater than or equal to the start index of the current substring
        if char in char_index and char_index[char] >= start:
            # Update the start index to the next index after the last occurrence of the character
            start = char_index[char] + 1
        # Update the last index of the character
        char_index[char] = i
        # Update the maximum length if necessary
        max_len = max(max_len, i - start + 1)

    return max_len",184
23908943673,minEditDistance,"def minEditDistance(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
    
    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i][j-1],    # Insert
                                   dp[i-1][j],    # Remove
                                   dp[i-1][j-1])  # Replace
    return dp[m][n]",184
4195158827,max_distance,"from collections import deque

def max_distance(grid):
    N = len(grid)
    queue = deque()
    seen = set()
    for i in range(N):
        for j in range(N):
            if grid[i][j]:
                seen.add((i, j))
                queue.append((i, j, 0))
    ans = 0
    while queue:
        i, j, d = queue.popleft()
        ans = d
        for ni, nj in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):
            if 0 <= ni < N and 0 <= nj < N and (ni, nj) not in seen:
                seen.add((ni, nj))
                queue.append((ni, nj, d + 1))
    return ans if ans else -1",184
27612370799,unique_pair_sum,"def unique_pair_sum(nums, target):
    nums.sort()
    left = 0
    right = len(nums) - 1
    seen_pairs = set()
    unique_pairs = 0
    
    while left < right:
        current_sum = nums[left] + nums[right]
        
        if current_sum == target:
            pair = (nums[left], nums[right])
            if pair not in seen_pairs:
                unique_pairs += 1
                seen_pairs.add(pair)
            left += 1
            right -= 1
            
            # Skip duplicates
            while left < right and nums[left] == nums[left - 1]:
                left += 1
            while left < right and nums[right] == nums[right + 1]:
                right -= 1
        elif current_sum < target:
            left += 1
        else:
            right -= 1
            
    return unique_pairs",184
38559263057,month_days,"def month_days(month, year):
    # List of days in each month for non-leap year
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    # Check for leap year
    if year % 4 == 0:
        if year % 100 == 0:
            if year % 400 == 0:
                # It's a leap year
                days_in_month[1] = 29
            # Not a leap year
        elif year % 4 == 0:
            # It's a leap year
            days_in_month[1] = 29

    return days_in_month[month - 1]",184
18585925374,find_zero_sum_triplets,"def find_zero_sum_triplets(nums):
    triplets = []
    nums.sort()
    for i in range(len(nums)):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                triplets.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
    return triplets",184
34048954400,find_first_and_last,"def find_first_and_last(arr, target):
    i = 0
    j = len(arr) - 1
    ans = -1
    while(i <= j):
        m = i + (j - i) // 2
        if(arr[m] <= target):
            if(arr[m] == target):
                ans = m
            i = m + 1
        else:
            j = m - 1
    i = 0
    j = len(arr) - 1
    ans1 = -1
    while(i <= j):
        m = i + (j - i) // 2
        if(arr[m] >= target):
            if(arr[m] == target):
                ans1 = m
            j = m - 1
        else:
            i = m + 1
    return [ans1, ans]",183
26719195545,is_valid_url,"import re
def is_valid_url(url):
    regex = re.compile(
        r'^(?:http|ftp)s?://' # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'localhost|' #localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(regex, url) is not None",183
39005162378,is_valid_url,"import re

def is_valid_url(url):
    regex = re.compile(
        r'^(?:http|ftp)s?://' # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' # domain...
        r'localhost|' # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(regex, url) is not None",183
33322398263,smallest_window,"def smallest_window(s: str) -> str:
    distinct_chars = len(set(s))
    count = {}
    start, min_len = 0, float('inf')
    min_start = 0
    distinct_count = 0

    for end in range(len(s)):
        if s[end] in count:
            count[s[end]] += 1
        else:
            count[s[end]] = 1

        if count[s[end]] == 1:
            distinct_count += 1

        while distinct_count == distinct_chars:
            if end - start + 1 < min_len:
                min_len = end - start + 1
                min_start = start

            count[s[start]] -= 1
            if count[s[start]] == 0:
                distinct_count -= 1
            start += 1

    return s[min_start:min_start + min_len]",183
19654868001,find_median_sorted_arrays,"def find_median_sorted_arrays(nums1, nums2):
    merged_list = []
    i, j = 0, 0
    while i < len(nums1) and j < len(nums2):
        if nums1[i] < nums2[j]:
            merged_list.append(nums1[i])
            i += 1
        else:
            merged_list.append(nums2[j])
            j += 1
    while i < len(nums1):
        merged_list.append(nums1[i])
        i += 1
    while j < len(nums2):
        merged_list.append(nums2[j])
        j += 1
    n = len(merged_list)
    if n % 2 == 0:
        return (merged_list[n // 2 - 1] + merged_list[n // 2]) / 2
    else:
        return merged_list[n // 2]",183
41762888418,longest_palindrome_subsequence,"def longest_palindrome_subsequence(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
                
    return dp[0][n - 1]

print(longest_palindrome_subsequence(""abdbca"")) # 5
print(longest_palindrome_subsequence(""cddpd"")) # 3
print(longest_palindrome_subsequence(""pqr"")) # 1",183
25343157955,longest_common_substring,"def longest_common_substring(str1, str2):
    m = len(str1)
    n = len(str2)
    result = 0
    end = 0
    L = [[0 for x in range(n+1)] for x in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif str1[i-1] == str2[j-1]:
                L[i][j] = L[i-1][j-1] + 1
                if L[i][j] > result:
                    result = L[i][j]
                    end = i-1
            else:
                L[i][j] = 0
    return str1[end-result+1:end+1]",183
32720639400,count_primes,"def count_primes(n):
    if n <= 2:
        return 0

    # Initialize a boolean array indicating the primality of each number.
    # Initially, we assume all numbers are prime (True), except for 0 and 1,
    # which are not prime.
    is_prime = [True] * n
    is_prime[0] = is_prime[1] = False

    # Iterate over each number starting from 2 to the square root of n.
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            # Mark multiples of i as not prime.
            for multiple in range(i*i, n, i):
                is_prime[multiple] = False

    # Return the count of prime numbers by summing up the boolean values in the array.
    return sum(is_prime)",183
20107890778,is_valid_URL,"import re

def is_valid_URL(url):
    regex = re.compile(
        r'^(?:http|ftp)s?://' # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'localhost|' #localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(regex, url) is not None",183
36699444443,longest_common_substring,"def longest_common_substring(str1, str2):
    m = len(str1)
    n = len(str2)
    result = 0
    end = 0
    L = [[0 for x in range(n+1)] for x in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif str1[i-1] == str2[j-1]:
                L[i][j] = L[i-1][j-1] + 1
                if L[i][j] > result:
                    result = L[i][j]
                    end = i-1
            else:
                L[i][j] = 0
    return str1[end-result+1:end+1]",183
18958592620,three_sum,"def three_sum(nums):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            s = nums[i] + nums[left] + nums[right]
            if s < 0:
                left += 1
            elif s > 0:
                right -= 1
            else:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
    return result",183
71446583393,is_valid_URL,"import re

def is_valid_URL(url):
    regex = re.compile(
        r'^(?:http|ftp)s?://' # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'localhost|' #localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(regex, url) is not None",183
72699846478,longest_common_substring,"def longest_common_substring(str1, str2):
    m = len(str1)
    n = len(str2)
    result = """"
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    maxLength = 0

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 or j == 0:
                dp[i][j] = 0
            elif str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > maxLength:
                    maxLength = dp[i][j]
                    result = str1[i - maxLength:i]
            else:
                dp[i][j] = 0

    return result",182
72907389518,binary_search_count,"def binary_search_count(nums, target):
    def find_left(nums, target):
        left, right = 0, len(nums)
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left

    def find_right(nums, target):
        left, right = 0, len(nums)
        while left < right:
            mid = (left + right) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid
        return left

    left_index = find_left(nums, target)
    right_index = find_right(nums, target)

    return right_index - left_index if left_index < len(nums) and nums[left_index] == target else 0",182
72618035905,min_delete_operations,"def min_delete_operations(str1: str, str2: str) -> int:
    len_str1 = len(str1)
    len_str2 = len(str2)
    dp = [[0] * (len_str2 + 1) for _ in range(len_str1 + 1)]
    
    for i in range(len_str1 + 1):
        for j in range(len_str2 + 1):
            if i == 0 or j == 0:
                dp[i][j] = i + j
            elif str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]",182
20069902840,max_points_on_line,"from collections import defaultdict

def max_points_on_line(points):
    if len(points) <= 2:
        return len(points)

    def compute_slope(p1, p2):
        deltaX = p2[0] - p1[0]
        deltaY = p2[1] - p1[1]
        if deltaX == 0:
            return float('inf')
        return deltaY / deltaX

    max_points = 0

    for i in range(len(points)):
        slope_map = defaultdict(int)
        max_points_line = 1
        for j in range(i + 1, len(points)):
            slope = compute_slope(points[i], points[j])
            slope_map[slope] += 1
            max_points_line = max(max_points_line, slope_map[slope] + 1)

        max_points = max(max_points, max_points_line)

    return max_points",182
24073877767,valid_url,"import re

def valid_url(url):
    regex = re.compile(
        r'^(?:http|ftp)s?://' # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'localhost|' #localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(regex, url) is not None",182
41388258639,can_complete_schedule,"from collections import defaultdict, deque

def can_complete_schedule(numCourses, prerequisites):
    children = defaultdict(set)
    parents = defaultdict(set)
    # Build dependency
    for req in prerequisites:
        children[req[1]].add(req[0])
        parents[req[0]].add(req[1])
    # Populate children dict in case some courses doesn't have child nor parents
    for i in range(numCourses[0]):
        children[i]
    queue = deque()
    for course in children.keys():
        if course not in parents:
            queue.append(course)
    while queue:
        curr = queue.popleft()
        for child in children[curr]:
            parents[child].remove(curr)
            if len(parents[child]) == 0:
                queue.append(child)
    for _, parent in parents.items():
        if len(parent) != 0:
            return False
    return True",182
18924613562,peak_element,"def peak_element(nums):
    if len(nums) == 1:
        return 0

    lowIndex = 0
    highIndex = len(nums)-1

    if nums[lowIndex] > nums[lowIndex+1]:
        return lowIndex
    if nums[highIndex] > nums[highIndex-1]:
        return highIndex

    pivot = (lowIndex + highIndex)//2

    while pivot != lowIndex and pivot != highIndex:
            
        if nums[pivot] > nums[pivot-1] and nums[pivot] > nums[pivot+1]:
            return pivot

        if nums[pivot] < nums[pivot+1]:
            lowIndex = pivot
        elif nums[pivot] < nums[pivot-1]:
            highIndex = pivot
        pivot = (lowIndex + highIndex)//2

    return pivot",182
43370808747,generate_combinations,"KEYBOARD = {
    '2': ['a','b','c'],
    '3': ['d','e','f'],
    '4': ['g','h','i'],
    '5': ['j','k','l'],
    '6': ['m','n','o'],
    '7': ['p','q','r','s'],
    '8': ['t','u','v'],
    '9': ['w','x','y','z'],
}

def generate_combinations(digits):
    results = []
    if not digits:
        return results
    dfs(digits, 0, """", results)
    return results

def dfs(digits, idx, stringlist, results):
    if idx == len(digits):
        results.append(stringlist)
        return 
    for char in KEYBOARD[digits[idx]]:
        dfs(digits, idx+1, stringlist+char, results)",182
23598801153,count_paths,"def count_paths(m: int, n: int) -> int:
    # Create a 2D table to store results of subproblems
    dp = [[0 for x in range(n)] for x in range(m)]
 
    # Count of paths to reach any cell in first column is 1
    for i in range(m):
        dp[i][0] = 1
 
    # Count of paths to reach any cell in first column is 1
    for j in range(n):
        dp[0][j] = 1

    # Calculate count of paths for other cells in bottom-up manner using the recursive solution
    for i in range(1, m):
        for j in range(n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[m-1][n-1]",182
32607077939,has_cycle,"from typing import List, Tuple

def has_cycle(edges: List[Tuple[int, int]]) -> bool:
    def dfs(node, visited, recursion_stack):
        visited.add(node)
        recursion_stack.add(node)

        for neighbor in adjacency_list[node]:
            if neighbor not in visited:
                if dfs(neighbor, visited, recursion_stack):
                    return True
            elif neighbor in recursion_stack:
                return True

        recursion_stack.remove(node)
        return False

    nodes = set()
    for edge in edges:
        nodes.add(edge[0])
        nodes.add(edge[1])

    adjacency_list = {node: [] for node in nodes}
    for src, dest in edges:
        adjacency_list[src].append(dest)

    visited = set()
    for node in nodes:
        if node not in visited:
            if dfs(node, visited, set()):
                return True

    return False",182
6126571037,largestRectangle,"from collections import deque

def largestRectangle(matrix):
    if not matrix:
        return 0
    rows, cols = len(matrix), len(matrix[0])
    heights = [0] * cols
    max_area = 0

    for row in matrix:
        for col in range(cols):
            if row[col] == 1:
                heights[col] += 1
            else:
                heights[col] = 0

        stack = deque()
        area = 0
        for i, height in enumerate(heights + [0]):
            while stack and heights[stack[-1]] >= height:
                h = heights[stack.pop()]
                w = i if not stack else i - stack[-1] - 1
                area = max(area, h * w)
            stack.append(i)
        max_area = max(max_area, area)
    return max_area",182
1694201706,longest_Palindrome,"def longest_Palindrome(s: str) -> str:
    if len(s) < 2 or s == s[::-1]:
        return s

    start, max_len = 0, 1

    def expand_around_center(left, right):
        nonlocal start, max_len
        while left >= 0 and right < len(s) and s[left] == s[right]:
            if (right - left + 1) > max_len:
                start, max_len = left, right - left + 1
            left -= 1
            right += 1

    for i in range(1, len(s)):
        expand_around_center(i - 1, i)  # Even length palindrome
        expand_around_center(i - 1, i + 1)  # Odd length palindrome

    return s[start:start + max_len]",181
30239194688,levenshtein_distance,"def levenshtein_distance(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n+1) for _ in range(m+1)]

    for i in range(m+1):
        dp[i][0] = i
    for j in range(n+1):
        dp[0][j] = j

    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    return dp[m][n]",181
19454290049,count_Islands,"from typing import List

def dfs(grid: List[List[str]], i: int, j: int) -> None:
    if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == ""0"":
        return
    grid[i][j] = ""0""
    dfs(grid, i + 1, j)
    dfs(grid, i - 1, j)
    dfs(grid, i, j + 1)
    dfs(grid, i, j - 1)

def count_Islands(grid: List[List[str]]) -> int:
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == ""1"":
                dfs(grid, i, j)
                count += 1
    return count",181
12233768740,word_search,"def word_search(board, word):
    def dfs(x, y, k):
        if not 0 <= x < len(board) or not 0 <= y < len(board[0]) or board[x][y] != word[k]:
            return False
        if k == len(word) - 1:
            return True
        temp, board[x][y] = board[x][y], '/'
        found = dfs(x+1, y, k+1) or dfs(x-1, y, k+1) or dfs(x, y+1, k+1) or dfs(x, y-1, k+1)
        board[x][y] = temp
        return found

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False",181
30002075965,find_missing_positive,"def find_missing_positive(nums):
    if not nums:
        return 1
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1

print(find_missing_positive([3, 4, -1, 1]))  # Output: 2
print(find_missing_positive([1, 2, 0]))  # Output: 3
print(find_missing_positive([7, 8, 9, 11, 12]))  # Output: 1",181
26230534992,median_sorted_arrays,"def median_sorted_arrays(nums1, nums2):
    nums3 = []
    i, j = 0, 0
    while i < len(nums1) and j < len(nums2):
        if nums1[i] < nums2[j]:
            nums3.append(nums1[i])
            i += 1
        else:
            nums3.append(nums2[j])
            j += 1
    while i < len(nums1):
        nums3.append(nums1[i])
        i += 1
    while j < len(nums2):
        nums3.append(nums2[j])
        j += 1
    n = len(nums3)
    if n % 2 == 0:
        return (nums3[n // 2 - 1] + nums3[n // 2]) / 2
    else:
        return nums3[n // 2]",181
7875530666,pick_max_coins,"def pick_max_coins(matrix):
    if not matrix or not matrix[0]:
        return 0
    m, n = len(matrix), len(matrix[0])
    dp = [[0]*n for _ in range(m)]
    dp[0][0] = matrix[0][0]
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + matrix[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + matrix[0][j]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]
    return dp[-1][-1]",181
17232445276,max_water_container,"def max_water_container(height):
    max_area = 0
    left = 0
    right = len(height) - 1
    while left < right:
        width = right - left
        height_left = height[left]
        height_right = height[right]
        max_area = max(max_area, min(height_left, height_right) * width)
        if height_left < height_right:
            left += 1
        else:
            right -= 1
    return max_area

# Test cases
print(max_water_container([1,8,6,2,5,4,8,3,7])) # 49
print(max_water_container([1,1])) # 1
print(max_water_container([4,3,2,1,4])) # 16
print(max_water_container([1,2,1])) # 2",181
6646006464,count_occurrence,"def count_occurrence(arr, num):
    first_occurrence = find_occurrence(arr, num, True)
    if first_occurrence == -1:
        return 0

    last_occurrence = find_occurrence(arr, num, False)
    return last_occurrence - first_occurrence + 1


def find_occurrence(arr, num, is_first):
    start, end = 0, len(arr) - 1
    result = -1
    while start <= end:
        mid = (start + end) // 2
        if arr[mid] > num:
            end = mid - 1
        elif arr[mid] < num:
            start = mid + 1
        else:
            result = mid
            if is_first:
                end = mid - 1
            else:
                start = mid + 1
    return result",180
36993508089,longest_bitonic_subsequence,"def longest_bitonic_subsequence(arr):
    n = len(arr)
    inc = [1]*n
    dec = [1]*n

    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j] and inc[i] < inc[j] + 1:
                inc[i] = inc[j] + 1

    for i in range(n-2, -1, -1):
        for j in range(n-1, i, -1):
            if arr[i] > arr[j] and dec[i] < dec[j] + 1:
                dec[i] = dec[j] + 1

    max_length = 0
    for i in range(n):
        max_length = max(max_length, inc[i] + dec[i] - 1)
    
    return max_length",180
13268086992,max_unique_subseq,"from collections import defaultdict

def max_unique_subseq(s, t):
    max_subseq = """"
    for i in range(len(s)):
        char_count = defaultdict(int)
        subseq = """"
        for j in range(i, min(i + t, len(s))):
            if char_count[s[j]] == 0:
                subseq += s[j]
                char_count[s[j]] += 1
            else:
                break
        if len(subseq) > len(max_subseq):
            max_subseq = subseq
    return max_subseq

# Test cases
assert max_unique_subseq(""abcabc"", 3) == ""abc""
assert max_unique_subseq(""abacab"", 3) == ""bac""
assert max_unique_subseq(""awaglknagawunagwkwagl"", 4) == ""wagl""",180
12094516550,find_longest_increasing_subsequence,"def find_longest_increasing_subsequence(arr):
    if not arr:
        return 0

    dp = [1] * len(arr)
    for i in range(1, len(arr)):
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)

print(find_longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18])) # 4
print(find_longest_increasing_subsequence([0, 1, 0, 3, 2, 3])) # 4
print(find_longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7])) # 1",180
71725177746,min_operations,"def min_operations(x, y):
    if x >= y:
        return x - y
    if y % 2 == 0:
        return 1 + min_operations(x, y // 2)
    else:
        return 1 + min_operations(x, y + 1)

# Optimal solution using memoization
def min_operations_optimized(x, y, memo = {}):
    if x >= y:
        return x - y
    if (x, y) in memo:
        return memo[(x, y)]
    if y % 2 == 0:
        memo[(x, y)] = 1 + min_operations_optimized(x, y // 2, memo)
    else:
        memo[(x, y)] = 1 + min_operations_optimized(x, y + 1, memo)
    return memo[(x, y)]",180
15307175475,unique_path_with_obstacles,"def unique_path_with_obstacles(obstacleGrid):
    m, n = len(obstacleGrid), len(obstacleGrid[0])
    if obstacleGrid[0][0] == 1 or obstacleGrid[m-1][n-1] == 1:
        return 0
    dp = [[0 for _ in range(n)] for _ in range(m)]
    dp[0][0] = 1
    for i in range(m):
        for j in range(n):
            if obstacleGrid[i][j] == 1:
                dp[i][j] = 0
            else:
                if i > 0:
                    dp[i][j] += dp[i-1][j]
                if j > 0:
                    dp[i][j] += dp[i][j-1]
    return dp[m-1][n-1]",179
37809597094,tree_height,"from typing import Optional

class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

def tree_height(root: Optional[TreeNode]) -> int:
    if root is None:
        return 0
    else:
        left_height = tree_height(root.left)
        right_height = tree_height(root.right)
        return max(left_height, right_height) + 1

# Create a binary tree
#       1
#      / \
#     2   3
#    / \
#   4   5
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

assert tree_height(root) == 3",179
74184800885,numDecodings,"def numDecodings(s: str) -> int:
    """"""
    Dynamic programming approach to solve the decode ways problem.
    dp[i] represents the number of ways to decode the string s[:i].
    """"""
    n = len(s)
    if n == 0 or s[0] == '0':
        return 0
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] > '0':
            dp[i] = dp[i-1]
        if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] < '7'):
            dp[i] += dp[i-2]
    return dp[n]",179
4875444799,min_operations,"def min_operations(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
    return dp[m][n]",179
18674604401,longest_common_substring,"def longest_common_substring(str1, str2):
    m = len(str1)
    n = len(str2)
    dp = [[0] * (n+1) for _ in range(m+1)]
    max_len = 0
    end_index = 0
    
    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_index = i - 1
            else:
                dp[i][j] = 0
                
    return str1[end_index - max_len + 1:end_index + 1]",178
38393988640,can_form_string,"def can_form_string(target, words):
    """"""
    Determines if the target string can be formed by concatenating words from the given list of words.

    :param target: A string to be formed by concatenating words.
    :param words: A list of strings that can be used to form the target string.
    :return: True if the target string can be formed, False otherwise.
    """"""
    word_set = set(words)
    memo = {}

    def can_form_helper(s):
        if s in memo:
            return memo[s]

        if s in word_set:
            return True

        for word in words:
            if s.startswith(word):
                suffix = s[len(word):]
                if can_form_helper(suffix):
                    memo[s] = True
                    return True

        memo[s] = False
        return False

    return can_form_helper(target)",178
37304495218,find_combinations,"from typing import List

def find_combinations(nums: List[int], target: int) -> List[List[int]]:
    def backtrack(remain, combo, start):
        if remain == 0:
            # make a deep copy of the current combination,
            # since the combination would be backtracked later.
            result.append(list(combo))
            return
        elif remain < 0:
            # exceed the scope, stop exploration.
            return

        for i in range(start, len(nums)):
            # add the number into the combination
            combo.append(nums[i])
            # give the current number another chance,
            # rather than moving on
            backtrack(remain - nums[i], combo, i)
            # backtrack, remove the number from the combination
            combo.pop()

    nums.sort()
    result = []
    backtrack(target, [], 0)
    return result",178
5114702336,max_depth,"class TreeNode:
    """"""Definition for a binary tree node""""""

    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def max_depth(root):
    if root is None:
        return 0
    else:
        left_depth = max_depth(root.left)
        right_depth = max_depth(root.right)
        return max(left_depth, right_depth) + 1

# Testing with sample data
root1 = TreeNode(1)
root1.left = TreeNode(2)
root1.right = TreeNode(3)

root2 = TreeNode(1)
root2.left = TreeNode(2)
root2.right = TreeNode(3)
root2.left.left = TreeNode(4)
root2.right.left = TreeNode(5)
root2.right.right = TreeNode(6)
root2.right.left.left = TreeNode(7)",178
74604685927,find_busiest_period,"from collections import OrderedDict

def find_busiest_period(data):
  visitor_log = OrderedDict()
  
  for item in data:
    timestamp, num, entrance_flag = item
    if timestamp in visitor_log:
      visitor_log[timestamp] = update_log(visitor_log[timestamp], num, entrance_flag)
    else:
      visitor_log[timestamp] = update_log(0, num, entrance_flag)
      
  max_total = float('-inf')
  running_sum = 0
  max_timestamp = 0
  
  for key, val in visitor_log.items():
    running_sum += val
    if running_sum > max_total:
      max_total = running_sum
      max_timestamp = key
    
  return max_timestamp

def update_log(current, num, entrance_flag):
  if entrance_flag == 1:
    return current + num
  else:
    return current - num",178
38018546795,longest_substring_two_distinct,"def longest_substring_two_distinct(s: str) -> int:
    if len(s) < 3:
        return len(s)
    
    left = 0
    right = 0
    max_length = 0
    char_map = {}
    distinct_count = 0
    
    while right < len(s):
        if s[right] not in char_map:
            char_map[s[right]] = 0
            distinct_count += 1
        char_map[s[right]] += 1
        
        while distinct_count > 2:
            char_map[s[left]] -= 1
            if char_map[s[left]] == 0:
                del char_map[s[left]]
                distinct_count -= 1
            left += 1
        
        max_length = max(max_length, right - left + 1)
        right += 1
    
    return max_length",178
22822962293,count_Palindromic_Substrings,"def count_Palindromic_Substrings(s: str) -> int:
    length = len(s)
    dp = [[False] * length for _ in range(length)]
    count = 0

    for i in range(length):
        dp[i][i] = True
        count += 1

    for i in range(length - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            count += 1

    for k in range(3, length + 1):
        for i in range(length - k + 1):
            j = i + k - 1
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                count += 1

    return count",178
21118387739,levenshtein_distance,"def levenshtein_distance(s1, s2):
    if len(s1) < len(s2):
        return levenshtein_distance(s2, s1)

    # len(s1) >= len(s2)
    if len(s2) == 0:
        return len(s1)

    previous_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
    
    return previous_row[-1]",177
74546448372,is_bst,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_bst(root):
    def helper(node, lower = float('-inf'), upper = float('inf')):
        if not node:
            return True

        val = node.val
        if val <= lower or val >= upper:
            return False

        if not helper(node.right, val, upper):
            return False
        if not helper(node.left, lower, val):
            return False
        return True

    return helper(root)

# Test case
root = TreeNode(4)
root.left = TreeNode(2, TreeNode(1), TreeNode(3))
root.right = TreeNode(6, TreeNode(5), TreeNode(7))
assert is_bst(root) == True",177
25807387711,find_subarray_xor,"from collections import defaultdict

def find_subarray_xor(nums, k):
    xor_count = defaultdict(int)
    xor_count[0] = 1
    current_xor = 0
    count = 0
    for num in nums:
        current_xor = current_xor ^ num
        count += xor_count[current_xor ^ k]
        xor_count[current_xor] += 1
    return count

if __name__ == ""__main__"":
    print(find_subarray_xor([4, 2, 2, 6, 4], 6))  # 4
    print(find_subarray_xor([5, 6, 7, 8, 9], 5))  # 2
    print(find_subarray_xor([1, 2, 3, 4, 5], 0))  # 2",177
19104411194,beautiful_arrangements,"from collections import defaultdict

def beautiful_arrangements(n: int) -> int:
    allowed = defaultdict(list)
    for i in range(1, n+1):
        for j in range(1, n+1):
            if i % j == 0 or j % i == 0:
                allowed[i].append(j)
    
    count = 0
    queue = []
    queue.append((set(), 0))
    
    while len(queue) > 0:
        curr_set, curr_len = queue.pop(0)
        if curr_len == n:
            count += 1
        else:
            for candidate in allowed[curr_len + 1]:
                if candidate not in curr_set:
                    new_set = curr_set.copy()
                    new_set.add(candidate)
                    queue.append((new_set, curr_len+1))
    
    return count",177
71026562114,levenshtein_distance,"def levenshtein_distance(s1, s2):
    if len(s1) < len(s2):
        return levenshtein_distance(s2, s1)

    # len(s1) >= len(s2)
    if len(s2) == 0:
        return len(s1)

    previous_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1 
            deletions = current_row[j] + 1   
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
    
    return previous_row[-1]",177
31906430991,decode_variations,"def decode_variations(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if 10 <= int(s[i-2:i]) <= 26 and s[i-1] != '0':
            dp[i] = dp[i-1] + dp[i-2]
        elif 10 <= int(s[i-2:i]) <= 26:
            dp[i] = dp[i-2]
        elif s[i-1] != '0':
            dp[i] = dp[i-1]
        else:
            return 0
    return dp[n]",177
72288060186,next_greater_permutation,"def next_greater_permutation(n: int) -> int:
    a = list(map(int, str(n)))
    i = len(a) - 2
    while i >= 0 and a[i + 1] <= a[i]:
        i -= 1
        
    if i < 0:
        return -1
    
    j = len(a) - 1
    while j >= 0 and a[j] <= a[i]:
        j -= 1
    
    a[i], a[j] = a[j], a[i]
    a[:] = a[: i + 1] + a[-1 : i : -1]
    a = [str(integer) for integer in a]
    res = int("""".join(a))
    return  res if (res > n and res <= (2**31 - 1)) else -1",177
71449614554,height,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def height(root):
    if root is None:
        return 0
    else:
        left_height = height(root.left)
        right_height = height(root.right)
        return max(left_height, right_height) + 1

# Create a binary tree for testing
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

# Test the function
assert height(None) == 0
assert height(TreeNode(1)) == 1
assert height(TreeNode(1, TreeNode(2), TreeNode(3))) == 2
assert height(root) == 3",177
33220530870,maxLen,"def maxLen(arr):
    # Initialize current sum and maxLen
    curr_sum = 0
    max_len = 0
 
    # Initialize a dictionary
    hash_map = {}
 
    # Traverse through the given array
    for i in range(len(arr)):
 
        # Add current element to sum
        curr_sum += arr[i]
 
        # If curr_sum is 0, then a subarray with zero sum exists
        if curr_sum == 0:
            max_len = i + 1
 
        # If curr_sum already exists in the dictionary, then subarray with zero sum exists
        if curr_sum in hash_map:
            max_len = max(max_len, i - hash_map[curr_sum])
        else:
            # Else put this sum in the hash table
            hash_map[curr_sum] = i
 
    return max_len",177
19973320464,convert_string,"def convert_string(word1, word2):
    len1 = len(word1)
    len2 = len(word2)
    dp = [[0 for _ in range(len2+1)] for _ in range(len1+1)]
    for i in range(len1+1):
        for j in range(len2+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    return dp[len1][len2]",177
25487715318,spiral_traversal,"def spiral_traversal(matrix):
    top, right, down, left = 0, len(matrix[0]) - 1, len(matrix) - 1, 0
    ans = []
    while top <= down and left <= right:
        for i in range(left, right + 1):
            ans.append(matrix[top][i])
        top += 1
        for i in range(top, down + 1):
            ans.append(matrix[i][right])
        right -= 1
        if top <= down:
            for i in range(right, left - 1, -1):
                ans.append(matrix[down][i])
            down -= 1
        if left <= right:
            for i in range(down, top - 1, -1):
                ans.append(matrix[i][left])
            left += 1
    return ans",177
20854862370,cut_rope,"def cut_rope(n):
    if n < 2:
        return 0
    if n == 2:
        return 1
    if n == 3:
        return 2

    # Optimal solution is close to cutting the rope into pieces of 3
    times_of_3 = n // 3

    # If the remaining length is 1, one 3-piece should be converted to 4 (2+2)
    if (n - times_of_3 * 3) == 1:
        times_of_3 -= 1

    # The remaining length will be cut into pieces of 2
    times_of_2 = (n - times_of_3 * 3) // 2

    return pow(3, times_of_3) * pow(2, times_of_2)",177
43552806674,max_depth_dfs,"from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def max_depth_dfs(root: Optional[TreeNode]) -> int:
    if not root:
        return 0
    else:
        stack = [[1, root]]
        res = 0

    while stack:
        depth, node = stack.pop()
        if node:
            res = max(res, depth)
            stack.append([depth + 1, node.left])
            stack.append([depth + 1, node.right])

    return res


def max_depth_rec(root: Optional[TreeNode]) -> int:
    if not root:
        return 0

    return max(max_depth_rec(root.left), max_depth_rec(root.right)) + 1",177
26585637311,longestPalindrome,"def longestPalindrome(s):
    if len(s) < 2:
        return s

    def expandAroundCenter(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]

    result = """"
    for i in range(len(s)):
        # check for odd length palindromes
        palindrome1 = expandAroundCenter(i, i)
        # check for even length palindromes
        palindrome2 = expandAroundCenter(i, i + 1)

        # update result if longer palindrome is found
        if len(result) < len(palindrome1):
            result = palindrome1
        if len(result) < len(palindrome2):
            result = palindrome2

    return result",176
3270667119,diagonal_sum,"def diagonal_sum(mat: list) -> int:
    """"""
    Return the sum of the matrix diagonals, given a matrix of integers.

    Time Complexity: O(N) - iterate through each array (performed > 99.7%)
    Space Complexity: O(1) - store single number indexes

    :param mat: list of lists containing integers
    :return: an int, the sum of the diagonal values in the matrix
    """"""
    n = len(mat)
    total_sum = 0
    for i in range(n):
        total_sum += mat[i][i] + mat[i][n - 1 - i]
    # Adjust for the center element in odd-sized matrix
    if n % 2 != 0:
        total_sum -= mat[n // 2][n // 2]
    return total_sum",176
19605810505,pattern_match,"def pattern_match(s, p):
    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]
    dp[-1][-1] = True
    for i in range(len(s), -1, -1):
        for j in range(len(p) - 1, -1, -1):
            match = i < len(s) and (p[j] == s[i] or p[j] == '.')
            if j + 1 < len(p) and p[j + 1] == '*':
                dp[i][j] = dp[i][j + 2] or (match and dp[i + 1][j])
            elif match:
                dp[i][j] = dp[i + 1][j + 1]
    return dp[0][0]",176
23928907438,find_pair,"def find_pair(array, target_sum):
    i, j = 0, len(array) - 1
    while i < j:
        current_sum = array[i] + array[j]
        if current_sum == target_sum:
            return [i, j]
        elif current_sum < target_sum:
            i += 1
        else:
            j -= 1
    return [-1, -1]

# Check function to verify the solution
def check_solution():
    assert find_pair([1,2,3,9], 8)==[-1,-1]
    assert find_pair([1,2,4,4], 8)==[2,3]
    assert find_pair([1,3,4,7,10], 14)==[2,4]
    print(""All test cases passed."")

check_solution()",176
12228186273,is_magic_square,"def is_magic_square(grid):
    n = len(grid)
    expected_sum = sum(grid[0])
    
    # Check rows and columns
    for i in range(n):
        if sum(grid[i]) != expected_sum or sum([grid[j][i] for j in range(n)]) != expected_sum:
            return False
    
    # Check diagonals
    if sum([grid[i][i] for i in range(n)]) != expected_sum or sum([grid[i][n-1-i] for i in range(n)]) != expected_sum:
        return False
    
    # Check distinct numbers
    numbers = [grid[i][j] for i in range(n) for j in range(n)]
    if len(set(numbers)) != n * n or min(numbers) < 1 or max(numbers) > n * n:
        return False
    
    return True",176
24839154407,longest_palindromic_substring,"def longest_palindromic_substring(s: str) -> str:
    n = len(s)
    if n == 0:
        return """"
    start, max_len = 0, 1

    def expand_around_center(left, right):
        nonlocal start, max_len
        while left >= 0 and right < n and s[left] == s[right]:
            if (right - left + 1) > max_len:
                start, max_len = left, right - left + 1
            left -= 1
            right += 1

    for i in range(n):
        expand_around_center(i, i)
        if i < n - 1 and s[i] == s[i + 1]:
            expand_around_center(i, i + 1)

    return s[start:start + max_len]",176
31114748326,find_connected_provinces,"class UnionFind:
    def __init__(self, cnt):
        self.root = [i for i in range(cnt)]
        self.cnt = cnt

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            self.root[rootY] = rootX
            self.cnt -= 1

    def find(self, x):
        while x != self.root[x]:
            x = self.root[x]
        return x

def find_connected_provinces(isConnected):
    provinces_cnt = len(isConnected)
    uf = UnionFind(provinces_cnt)

    for i in range(provinces_cnt):
        for j in range(i + 1, provinces_cnt):
            if isConnected[i][j]:
                uf.union(i, j)

    return uf.cnt",175
71127178067,longest_palindromic_subseq,"def longest_palindromic_subseq(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n):
        dp[i][i] = 1
    for cl in range(2, n+1):
        for i in range(n - cl + 1):
            j = i + cl - 1
            if s[i] == s[j] and cl == 2:
                dp[i][j] = 2
            elif s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i][j-1], dp[i+1][j])
    return dp[0][n-1]",175
18735788719,lucas,"from functools import cache

def lucas(n: int) -> int:
    @cache
    def inner_lucas(n):
        if n == 1:
            return 2
        elif n == 2:
            return 1
        else:
            return inner_lucas(n - 1) + inner_lucas(n - 2)
    return inner_lucas(n)

# check function to verify the correctness of the solution
def check_lucas():
    assert lucas(1) == 2
    assert lucas(2) == 1
    assert lucas(3) == 3
    assert lucas(4) == 4
    assert lucas(5) == 7
    assert lucas(10) == 76
    print(""All test cases passed."")

check_lucas()",175
17294795624,longest_subarray,"from collections import deque

def longest_subarray(nums, limit):
    max_stack = deque() 
    min_stack = deque() 
    left = 0
    length = 0
    
    for right, num in enumerate(nums):
        while max_stack and nums[max_stack[-1]] < num:
            max_stack.pop()
        while min_stack and nums[min_stack[-1]] > num:
            min_stack.pop()
        
        max_stack.append(right)
        min_stack.append(right)
        
        while nums[max_stack[0]] - nums[min_stack[0]] > limit:
            if max_stack[0] < min_stack[0]:
                left = max_stack.popleft() + 1
            else:
                left = min_stack.popleft() + 1
        
        length = max(length, right - left + 1)
        
    return length",175
8196420916,count_distinct_subsequences,"def count_distinct_subsequences(s: str) -> int:
    MOD = 10**9 + 7
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    last = [-1] * 26
    for i in range(1, n + 1):
        dp[i] = (2 * dp[i - 1]) % MOD
        if last[ord(s[i - 1]) - ord('a')] != -1:
            dp[i] = (dp[i] - dp[last[ord(s[i - 1]) - ord('a')]] + MOD) % MOD
        last[ord(s[i - 1]) - ord('a')] = i - 1
    return dp[n] - 1",175
41734686203,word_sequence,"from typing import List

def word_sequence(s: str, wordDict: List[str]) -> bool:
    word_set = set(wordDict)
    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break

    return dp[len(s)]

if __name__ == ""__main__"":
    assert word_sequence(""pineapplepenapple"", [""apple"",""pen"",""applepen"",""pine"",""pineapple""]) == True
    assert word_sequence(""catsandog"", [""cats"",""dog"",""sand"",""and"",""cat""]) == False
    assert word_sequence(""leetcode"", [""leet"",""code""]) == True",175
5025860787,check_inclusion,"from collections import Counter

def check_inclusion(s1: str, s2: str) -> bool:
    len_s1 = len(s1)
    len_s2 = len(s2)

    if len_s1 > len_s2:
        return False

    s1_dict = Counter(s1)
    s2_dict = Counter(s2[:len_s1])

    if s1_dict == s2_dict:
        return True

    for i in range(len_s1, len_s2):
        s2_dict[s2[i]] += 1
        s2_dict[s2[i-len_s1]] -= 1

        if s2_dict[s2[i-len_s1]] == 0:
            s2_dict.pop(s2[i-len_s1])

        if s1_dict == s2_dict:
            return True

    return False",175
72903923864,min_palindrome_ops,"def min_palindrome_ops(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 0
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1]
            else:
                dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1
    return dp[0][n - 1]

# Test cases
assert min_palindrome_ops(""abcd"") == 3
assert min_palindrome_ops(""aabb"") == 2
assert min_palindrome_ops(""abcba"") == 0",175
15879853249,longest_palindrome,"def longest_palindrome(s):
    if len(s) < 2:
        return s
    start = 0
    end = 0
    for i in range(len(s)):
        len1 = expand_around_center(s, i, i)
        len2 = expand_around_center(s, i, i+1)
        max_len = max(len1, len2)
        if max_len > end - start:
            start = i - (max_len - 1) // 2
            end = i + max_len // 2
    return s[start:end+1]

def expand_around_center(s, left, right):
    while left >= 0 and right < len(s) and s[left] == s[right]:
        left -= 1
        right += 1
    return right - left - 1",175
16939172949,largest_two,"def largest_two(numbers):
    if len(numbers) < 2:
        return None
    first, second = (numbers[0], numbers[1]) if numbers[0] > numbers[1] else (numbers[1], numbers[0])
    for n in numbers[2:]:
        if n > first:
            second = first
            first = n
        elif n > second:
            second = n
    return (first, second)

assert largest_two([1,2,3,4,5]) == (5,4)
assert largest_two([10,20,30,40,50]) == (50,40)
assert largest_two([100,200,300,400,500]) == (500,400)",175
73148541386,decimal_to_roman,"def decimal_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
    ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",174
21341696328,int_to_roman,"def int_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",174
5841201945,number_to_roman,"def number_to_roman(num):
    value = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    symbol = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
    ]
    roman_numeral = ''
    i = 0
    while num > 0:
        for _ in range(num // value[i]):
            roman_numeral += symbol[i]
            num -= value[i]
        i += 1
    return roman_numeral",174
34657460924,find_median_sorted_arrays,"def find_median_sorted_arrays(nums1, nums2):
    merged = []
    i, j = 0, 0
    while i < len(nums1) and j < len(nums2):
        if nums1[i] < nums2[j]:
            merged.append(nums1[i])
            i += 1
        else:
            merged.append(nums2[j])
            j += 1
    while i < len(nums1):
        merged.append(nums1[i])
        i += 1
    while j < len(nums2):
        merged.append(nums2[j])
        j += 1
    n = len(merged)
    if n % 2 == 0:
        return (merged[n // 2 - 1] + merged[n // 2]) / 2
    else:
        return merged[n // 2]",174
35623546149,decimal_to_roman,"def decimal_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syb = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syb[i]
            num -= val[i]
        i += 1
    return roman_num",174
21969585371,count_islands,"def count_islands(grid):
    if not grid:
        return 0
    m, n = len(grid), len(grid[0])
    count = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                dfs(grid, i, j)
                count += 1
    return count

def dfs(grid, i, j):
    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:
        return
    grid[i][j] = 0
    dfs(grid, i+1, j)
    dfs(grid, i-1, j)
    dfs(grid, i, j+1)
    dfs(grid, i, j-1)",174
29193108691,num_to_roman,"def num_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syb = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syb[i]
            num -= val[i]
        i += 1
    return roman_num",174
72219099016,convert_to_roman,"def convert_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",174
6376835847,edit_distance,"def edit_distance(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0 for x in range(n + 1)] for x in range(m + 1)]
    
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])
    
    return dp[m][n]",174
4065866742,integer_to_roman,"def integer_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syb = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syb[i]
            num -= val[i]
        i += 1
    return roman_num",174
23626355702,num_to_roman,"def num_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",174
10665045031,decimal_to_roman,"def decimal_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",174
73387992756,dec_to_roman,"def dec_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syb = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syb[i]
            num -= val[i]
        i += 1
    return roman_num",174
39266406667,num_to_roman,"def num_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syb = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syb[i]
            num -= val[i]
        i += 1
    return roman_num",174
7595444579,decimal_to_roman,"def decimal_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",174
70597319476,count_distinct_subsequences,"def count_distinct_subsequences(s: str) -> int:
    MOD = 10**9 + 7
    dp = [0] * (len(s) + 1)
    dp[0] = 1
    last = [-1] * 26
    for i in range(1, len(s) + 1):
        dp[i] = (2 * dp[i-1]) % MOD
        if last[ord(s[i-1]) - ord('a')] != -1:
            dp[i] = (dp[i] - dp[last[ord(s[i-1]) - ord('a')]] + MOD) % MOD
        last[ord(s[i-1]) - ord('a')] = i - 1
    return (dp[-1] - 1) % MOD",174
73856974507,num_to_roman,"def num_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syb = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syb[i]
            num -= val[i]
        i += 1
    return roman_num",174
2214522282,decimal_to_roman,"def decimal_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syb = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syb[i]
            num -= val[i]
        i += 1
    return roman_num",174
4582709140,integer_to_roman,"def integer_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",174
75058015448,int_to_roman,"def int_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syb = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syb[i]
            num -= val[i]
        i += 1
    return roman_num",174
72817446677,num_to_roman,"def num_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",174
28706067181,decimal_to_roman,"def decimal_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",174
6453254271,longest_palindromic_substring,"def longest_palindromic_substring(s: str) -> str:
    def expand_around_center(left: int, right: int) -> str:
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]

    longest = """"
    for i in range(len(s)):
        # Odd length palindrome
        palindrome1 = expand_around_center(i, i)
        # Even length palindrome
        palindrome2 = expand_around_center(i, i + 1)

        # Update the longest palindrome found
        if len(palindrome1) > len(longest):
            longest = palindrome1
        if len(palindrome2) > len(longest):
            longest = palindrome2

    return longest",173
22874472345,kth_smallest,"def partition(arr,low,high):
    i = ( low-1 )
    pivot = arr[high]
  
    for j in range(low , high):
        if   arr[j] <= pivot:
            i = i+1
            arr[i],arr[j] = arr[j],arr[i]
  
    arr[i+1],arr[high] = arr[high],arr[i+1]
    return ( i+1 )
  
def quickSort(arr,low,high):
    if low < high:
        pi = partition(arr,low,high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)

def kth_smallest(arr, k):
    n = len(arr)
    quickSort(arr, 0, n-1)
    return arr[k-1]",173
10969632632,decode_message,"def decode_message(s: str) -> int:
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if 10 <= int(s[i-2:i]) <= 26 and s[i-1] != '0':
            dp[i] = dp[i-1] + dp[i-2]
        elif int(s[i-2:i]) == 10 or int(s[i-2:i]) == 20:
            dp[i] = dp[i-2]
        else:
            dp[i] = dp[i-1]
    return dp[n]",173
5981499019,int_to_roman,"def int_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
    ]
    roman_num = ''
    i = 0
    while num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",173
28475631821,int_to_roman,"def int_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
    ]
    roman_num = ''
    i = 0
    while num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",173
4511140980,quicksort,"def quicksort(arr):
    def swap(arr, i, j):
        arr[i], arr[j] = arr[j], arr[i]

    def partition(arr, low, high):
        pivot = arr[high]
        i = low - 1
        for j in range(low, high):
            if arr[j] < pivot:
                i += 1
                swap(arr, i, j)
        swap(arr, i + 1, high)
        return i + 1

    def quicksort_recursive(arr, low, high):
        if low < high:
            pi = partition(arr, low, high)
            quicksort_recursive(arr, low, pi - 1)
            quicksort_recursive(arr, pi + 1, high)

    quicksort_recursive(arr, 0, len(arr) - 1)
    return arr",173
21292581877,count_distinct_subsequences,"def count_distinct_subsequences(s: str) -> int:
    MOD = 10**9 + 7
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    last = [-1] * 26
    for i in range(1, n + 1):
        dp[i] = (dp[i - 1] * 2) % MOD
        if last[ord(s[i - 1]) - ord('a')] != -1:
            dp[i] -= dp[last[ord(s[i - 1]) - ord('a')]]
        dp[i] %= MOD
        last[ord(s[i - 1]) - ord('a')] = i - 1
    return dp[n] - 1",173
30688856055,roman_numerals,"def roman_numerals(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
        ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
        ]
    roman_num = ''
    i = 0
    while  num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",173
33072620737,int_to_roman,"def int_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
    ]
    roman_num = ''
    i = 0
    while num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",173
14838519952,int_to_roman,"def int_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
    ]
    roman_num = ''
    i = 0
    while num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",173
36061027505,catalan,"def catalan(n):
    if n <= 1: 
        return 1
    # Table to store results of subproblems
    catalan = [0 for i in range(n + 1)]
    # Initialize first two values in table
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n + 1):
        catalan[i] = 0
        for j in range(i):
            catalan[i] = catalan[i] + catalan[j] * catalan[i-j-1]
    return catalan[n]

# Driver Code
if __name__ == '__main__':
    n = 10
    print(""Catalan number for n = %d is %d"" % (n, catalan(n)))",173
33099865612,decimal_to_roman,"def decimal_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
    ]
    roman_num = ''
    i = 0
    while num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",173
40317149144,binary_search_count,"def binary_search_count(arr, target):
    def binary_search(arr, target, find_first):
        low, high = 0, len(arr) - 1
        result = -1
        while low <= high:
            mid = (low + high) // 2
            if arr[mid] == target:
                result = mid
                if find_first:
                    high = mid - 1
                else:
                    low = mid + 1
            elif arr[mid] < target:
                low = mid + 1
            else:
                high = mid - 1
        return result
    first = binary_search(arr, target, True)
    last = binary_search(arr, target, False)
    if first == -1 or last == -1:
        return 0
    return last - first + 1",173
8919963740,number_to_roman,"def number_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    syb = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
    ]
    roman_num = ''
    i = 0
    while num > 0:
        for _ in range(num // val[i]):
            roman_num += syb[i]
            num -= val[i]
        i += 1
    return roman_num",173
23726190961,boyer_moore_search,"def create_bad_character_shift(pattern):
    bad_char_shift = {}
    m = len(pattern)
    for i in range(m-1):
        bad_char_shift[pattern[i]] = m - i - 1
    return bad_char_shift

def boyer_moore_search(text, pattern):
    m = len(pattern)
    n = len(text)
    if m > n:
        return -1

    bad_char_shift = create_bad_character_shift(pattern)

    s = 0
    while s <= n - m:
        j = m - 1
        while j >= 0 and pattern[j] == text[s + j]:
            j -= 1

        if j < 0:
            return s
        else:
            s += bad_char_shift.get(text[s + m - 1], m)

    return -1",173
40774650153,len,"def generate_n_queens(n):
    results = []
    col_queens, pos_queens, neg_queens = set(), set(), set()

    def nQueens(r, board):
        if r == n:
            results.append(board.copy())
            return

        for c in range(n):
            if c in col_queens or (r + c) in pos_queens or (r - c) in neg_queens:
                continue

            col_queens.add(c)
            pos_queens.add(r + c)
            neg_queens.add(r - c)
            board.append(c)
            nQueens(r + 1, board)
            board.pop()
            col_queens.remove(c)
            pos_queens.remove(r + c)
            neg_queens.remove(r - c)

    nQueens(0, [])
    return results",173
74654312464,int_to_roman,"def int_to_roman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
    ]
    roman_num = ''
    i = 0
    while num > 0:
        for _ in range(num // val[i]):
            roman_num += syms[i]
            num -= val[i]
        i += 1
    return roman_num",173
2706095557,threeSum,"def threeSum(nums):
    res = []
    nums.sort()
    for i in range(len(nums)-2):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        l, r = i+1, len(nums)-1
        while l < r:
            s = nums[i] + nums[l] + nums[r]
            if s < 0:
                l +=1 
            elif s > 0:
                r -= 1
            else:
                res.append((nums[i], nums[l], nums[r]))
                while l < r and nums[l] == nums[l+1]:
                    l += 1
                while l < r and nums[r] == nums[r-1]:
                    r -= 1
                l += 1; r -= 1
    return res",173
13093630912,is_symmetric,"from collections import deque

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_symmetric(root: TreeNode) -> bool:
    if not root:
        return True

    queue = deque([root.left, root.right])

    while queue:
        left_node, right_node = queue.popleft(), queue.pop()

        if not left_node and not right_node:
            continue
        if not left_node or not right_node:
            return False
        if left_node.val != right_node.val:
            return False

        queue.append(left_node.left)
        queue.append(right_node.right)
        queue.append(left_node.right)
        queue.append(right_node.left)

    return True",172
33273289436,longestPalindrome,"def longestPalindrome(s):
    if len(s) < 2:
        return s

    def expandAroundCenter(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left+1:right]

    longest = """"
    for i in range(len(s)):
        # odd length palindromes
        palindrome1 = expandAroundCenter(i, i)
        # even length palindromes
        palindrome2 = expandAroundCenter(i, i+1)

        # update the longest palindrome found so far
        if len(palindrome1) > len(longest):
            longest = palindrome1
        if len(palindrome2) > len(longest):
            longest = palindrome2

    return longest",172
31280359990,count_unique_subsequences,"def count_unique_subsequences(s):
    n = len(s)
    dp = [0] * (n+1)
    dp[0] = 1
    last_occurrence = [-1] * 26
    for i in range(1, n + 1):
        dp[i] = 2 * dp[i - 1]
        if last_occurrence[ord(s[i-1]) - ord('a')] != -1:
            dp[i] -= dp[last_occurrence[ord(s[i-1]) - ord('a')]]
        last_occurrence[ord(s[i-1]) - ord('a')] = i - 1
    return dp[n] - 1

print(count_unique_subsequences(""abc""))
print(count_unique_subsequences(""aba""))
print(count_unique_subsequences(""aaa""))",172
16158823021,countComponents,"from collections import defaultdict

def countComponents(n, edges):
    class Solution:
        def __init__(self):
            self.adjList = defaultdict(list)

        def dfs(self, node, visited):
            visited.add(node)
            for point in self.adjList[node]:
                if point not in visited:
                    self.dfs(point, visited)

        def getAdjList(self, edges):
            for i in range(len(edges)):
                self.adjList[edges[i][0]].append(edges[i][1])
                self.adjList[edges[i][1]].append(edges[i][0])

    solution = Solution()
    solution.getAdjList(edges)
    visited = set()
    components = 0

    for i in range(n):
        if i not in visited:
            components += 1
            solution.dfs(i, visited)

    return components",172
42018104899,valid_parentheses_string,"def valid_parentheses_string(s: str) -> bool:
    left_count = 0
    right_count = 0

    # Check from left to right
    for char in s:
        if char == '(':
            left_count += 1
        else:
            if left_count > 0:
                left_count -= 1
            else:
                right_count += 1

    if left_count > 1 or right_count > 1:
        return False

    # Check from right to left
    left_count = 0
    for char in reversed(s):
        if char == ')':
            right_count -= 1
        else:
            if right_count < 0:
                return False
            left_count += 1

        if left_count > 1:
            return False

    return True",172
23205680962,smallest_distinct_window,"from collections import Counter

def smallest_distinct_window(s):
    distinct_chars = len(set(s))
    char_count = Counter()
    start = 0
    min_len = float('inf')
    min_start = 0
    distinct_count = 0

    for end in range(len(s)):
        char_count[s[end]] += 1
        if char_count[s[end]] == 1:
            distinct_count += 1

        while distinct_count == distinct_chars:
            if end - start + 1 < min_len:
                min_len = end - start + 1
                min_start = start

            char_count[s[start]] -= 1
            if char_count[s[start]] == 0:
                distinct_count -= 1
            start += 1

    return s[min_start:min_start + min_len]",172
592675463,longest_string_chain,"from collections import defaultdict

def longest_string_chain(words):
    def is_predecessor(shorter, longer):
        if len(longer) - len(shorter) != 1:
            return False
        for i in range(len(longer)):
            if shorter == longer[:i] + longer[i+1:]:
                return True
        return False

    words.sort(key=len)
    predecessors = defaultdict(int)
    max_chain = 1
    for word in words:
        current_max = 1
        for i in range(len(word)):
            predecessor = word[:i] + word[i+1:]
            if predecessor in predecessors:
                current_max = max(current_max, predecessors[predecessor] + 1)
        predecessors[word] = current_max
        max_chain = max(max_chain, current_max)
    return max_chain",172
31733720604,max_string_length,"from typing import List

def max_string_length(strs: List[str]) -> int:
    def has_overlap(s1, s2):
        return any(s1.count(c) > 0 for c in s2)

    memo = {}
    def dfs(index: int, current: str) -> int:
        if index >= len(strs):
            return len(current)
        
        if (index, current) in memo:
            return memo[(index, current)]
        
        length_with_current = dfs(index + 1, current + strs[index]) if not has_overlap(current, strs[index]) else len(current)
        length_without_current = dfs(index + 1, current)
        
        memo[(index, current)] = max(length_with_current, length_without_current)
        return memo[(index, current)]
    
    return dfs(0, """")",172
26654911998,edit_distance,"def edit_distance(str1, str2):
    m = len(str1)
    n = len(str2)
    
    dp = [[0 for x in range(n+1)] for x in range(m+1)]
    
    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])
    
    return dp[m][n]",172
28989812733,min_operations,"def min_operations(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif s[i-1] == t[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    return dp[m][n]",172
2279303676,longest_palindrome_subsequence,"def longest_palindrome_subsequence(s):
    n = len(s)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        dp[i][i] = 1

    for start in range(n-1, -1, -1):
        for end in range(start+1, n):
            if s[start] == s[end]:
                dp[start][end] = 2 + dp[start+1][end-1]
            else:
                dp[start][end] = max(dp[start+1][end], dp[start][end-1])

    return dp[0][n-1]

print(longest_palindrome_subsequence(""abdbca""))
print(longest_palindrome_subsequence(""cddpd""))
print(longest_palindrome_subsequence(""pqr""))",172
11800522446,longestPalindromeSubseq,"def longestPalindromeSubseq(s, k):
    n = len(s)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = 2 + dp[i+1][j-1]
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    for i in range(n):
        if dp[0][n-1] - dp[i][n-i-1] <= k:
            return dp[0][n-1]
    return dp[0][n-1] - k",172
72569038140,min_Operations,"def min_Operations(s1, s2): 
    m = len(s1)
    n = len(s2)
    dp = [[0 for x in range(n+1)] for x in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])
    return dp[m][n]",172
2988487000,smallest_number_with_n_divisors,"import math

def smallest_number_with_n_divisors(n):
    if n == 1:
        return 1
    count = 0
    num = 1
    while True:
        for i in range(1, int(math.sqrt(num)) + 1):
            if num % i == 0:
                if num // i == i:
                    count += 1
                else:
                    count += 2
        if count == n:
            return num
        count = 0
        num += 1

def check():
    assert smallest_number_with_n_divisors(4) == 6
    assert smallest_number_with_n_divisors(5) == 16
    assert smallest_number_with_n_divisors(6) == 12
    print(""All test cases passed"")

check()",171
30836779802,is_possible,"from collections import defaultdict

def is_possible(nums):
    if len(nums) < 3:
        return False

    count = defaultdict(int)
    tails = defaultdict(int)

    for num in nums:
        count[num] += 1

    for num in nums:
        if count[num] == 0:
            continue
        elif tails[num - 1] > 0:
            tails[num - 1] -= 1  
            tails[num] += 1  
        elif count[num + 1] > 0 and count[num + 2] > 0:
            count[num + 1] -= 1  
            count[num + 2] -= 1  
            tails[num + 2] += 1  
        else:
            return False

        count[num] -= 1

    return True",171
15952179658,string_to_int,"def string_to_int(str):
    str = str.strip()
    if not str: return 0
    sign = 1
    if str[0] == '-':
        sign = -1
        str = str[1:]
    elif str[0] == '+':
        str = str[1:]
    num = 0
    for char in str:
        if not '0' <= char <= '9':
            break
        if num > (2**31 - 1) // 10 or (num == (2**31 - 1) // 10 and char > '7'):
            return 2**31 - 1 if sign > 0 else -2**31
        num = num * 10 + int(char)
    return num * sign",171
13192162480,days_in_months_leap_year,"def days_in_months_leap_year(year):
    # Define the number of days in each month
    days_in_months = {'January': 31, 'February': 28, 'March': 31, 'April': 30, 'May': 31, 'June': 30,
                      'July': 31, 'August': 31, 'September': 30, 'October': 31, 'November': 30, 'December': 31}
    
    # Check if the year is a leap year
    if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:
        days_in_months['February'] = 29
    return days_in_months",171
10985694011,find_min_operations,"def find_min_operations(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
    
    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    
    return dp[m][n]",171
18954897836,waysToSum,"def waysToSum(n):
    if n == 0:
        return 1
    if n < 0:
        return 0
    return waysToSum(n-1) + waysToSum(n-3) + waysToSum(n-4)

# Optimized solution using dynamic programming
def waysToSum_dp(n):
    dp = [0] * (n+1)
    dp[0] = 1
    for i in range(1, n+1):
        dp[i] += dp[i-1] if i-1 >= 0 else 0
        dp[i] += dp[i-3] if i-3 >= 0 else 0
        dp[i] += dp[i-4] if i-4 >= 0 else 0
    return dp[n]",171
31505057884,min_steps,"def min_steps(target: int) -> int:
    target = abs(target)  # As the line is infinite in both directions, we can consider only positive direction by taking absolute value of target
    steps = 0  # To store the minimum number of steps required
    sum_of_steps = 0  # To store the sum of all steps taken
    while True:
        if sum_of_steps >= target and (sum_of_steps - target) % 2 == 0:  # Check if the current sum of steps is greater than or equal to target and the difference between sum and target is even
            return steps  # Return the number of steps required
        else:
            steps += 1  # Increment the number of steps
            sum_of_steps += steps  # Add the current step to the sum of steps",171
19388947098,min_jumps,"def min_jumps(arr):
    n = len(arr)
    if n <= 1:
        return 0
    if arr[0] == 0:
        return -1

    max_reach = arr[0]
    step = arr[0]
    jump = 1

    if n == 1:
        return 0

    for i in range(1, n):
        if i == n - 1:
            return jump

        max_reach = max(max_reach, i + arr[i])

        step -= 1

        if step == 0:
            jump += 1

            if i >= max_reach:
                return -1

            if max_reach >= n - 1:
                return jump

            step = max_reach - i

    return -1",171
43356981667,last_element_of_longest_palindrome,"def last_element_of_longest_palindrome(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    last_element = s[0]
    for i in range(n):
        for j in range(n):
            if dp[i][j] > dp[0][0] - 1:
                last_element = s[j]
    return last_element",171
1784586844,max_subarray_length,"def max_subarray_length(arr, target_sum):
    sum_indices = {0: -1}
    max_length = 0
    current_sum = 0
    
    for i, num in enumerate(arr):
        current_sum += num
        
        if current_sum not in sum_indices:
            sum_indices[current_sum] = i
        
        if current_sum - target_sum in sum_indices:
            max_length = max(max_length, i - sum_indices[current_sum - target_sum])
    
    return max_length

print(max_subarray_length([1,2,3], 3))  # Output: 2
print(max_subarray_length([1,2,3], 6))  # Output: 3
print(max_subarray_length([1,2,3,4,5], 9))  # Output: 3",171
32857610626,comb_sum,"class Solution:
    def __init__(self):
        self.res = []
    
    def comb_sum(self, array, target, output = []):
        if target == 0:
            self.res.append(output)
            return
        elif len(array) == 0:
            return
        if array[0] > target:
            self.comb_sum(array[1:], target, output)
            return
        else:
            op1 = output[:]
            output.append(array[0])
            op2 = output[:]
            self.comb_sum(array, target - array[0], op2)
            array = array[1:]
            self.comb_sum(array, target, op1)
            return

def comb_sum(array, target):
    arr1 = Solution()
    arr1.comb_sum(array, target)
    return arr1.res",171
3009808667,max_histogram_area,"def max_histogram_area(heights):
    stack = []
    max_area = 0
    index = 0
    while index < len(heights):
        if (not stack) or (heights[stack[-1]] <= heights[index]):
            stack.append(index)
            index += 1
        else:
            top_of_stack = stack.pop()
            area = (heights[top_of_stack] * 
                   ((index - stack[-1] - 1) 
                    if stack else index))
            max_area = max(max_area, area)
    while stack:
        top_of_stack = stack.pop()
        area = (heights[top_of_stack] * 
               ((index - stack[-1] - 1) 
                if stack else index))
        max_area = max(max_area, area)
    return max_area",171
42425619120,int_to_roman,"def int_to_roman(num):
    value = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    symbols = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
    ]
    roman_num = ''
    i = 0
    while num > 0:
        for _ in range(num // value[i]):
            roman_num += symbols[i]
            num -= value[i]
        i += 1
    return roman_num",171
20064606702,cocktail_shaker_sort,"def cocktail_shaker_sort(arr):
    n = len(arr)
    swapped = True
    start = 0
    end = n-1
    while (swapped==True):
        swapped = False
        for i in range (start, end):
            if (arr[i] > arr[i+1]) :
                arr[i], arr[i+1]= arr[i+1], arr[i]
                swapped=True
        if (swapped==False):
            break
        swapped = False
        end = end-1
        for i in range(end-1, start-1,-1):
            if (arr[i] > arr[i+1]):
                arr[i], arr[i+1] = arr[i+1], arr[i]
                swapped = True
        start = start+1
    return arr",171
42259094498,longest_palindrome_substring,"def longest_palindrome_substring(s: str) -> str:
    def expand_around_center(left: int, right: int) -> str:
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]

    longest = """"
    for i in range(len(s)):
        # Odd length palindrome
        palindrome1 = expand_around_center(i, i)
        # Even length palindrome
        palindrome2 = expand_around_center(i, i + 1)

        # Update the longest palindrome found
        if len(palindrome1) > len(longest):
            longest = palindrome1
        if len(palindrome2) > len(longest):
            longest = palindrome2

    return longest",171
26836581580,island_counter,"from typing import List

def island_counter(grid: List[List[str]]) -> int:
    if not grid:
        return 0

    rows, cols = len(grid), len(grid[0])
    count = 0

    def dfs(r, c):
        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0':
            return
        grid[r][c] = '0'
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                dfs(r, c)
                count += 1

    return count",171
42319048540,longest_palindrome,"def longest_palindrome(s):
    if len(s) < 2:
        return s

    def expand_around_center(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]

    longest = """"
    for i in range(len(s)):
        # Odd length palindrome
        palindrome1 = expand_around_center(i, i)
        # Even length palindrome
        palindrome2 = expand_around_center(i, i + 1)

        # Update the longest palindrome if necessary
        if len(palindrome1) > len(longest):
            longest = palindrome1
        if len(palindrome2) > len(longest):
            longest = palindrome2
    return longest",171
37383505085,find_target_count,"def find_target_count(nums, target):
    def binSearch(nums,target,leftBiase):
        lp = 0
        rp = len(nums)-1
        mid = 0
        index = -1
        while lp<=rp:
            mid = (lp+rp)//2
            if(nums[mid] == target):
                index=mid
                if(leftBiase):
                    rp = mid-1
                else:
                    lp=mid+1
            elif(nums[mid]>target):
                rp=mid-1
            elif(nums[mid]<target):
                lp=mid+1
        return index
    
    left = binSearch(nums,target,True)
    right = binSearch(nums,target,False)
    
    if left == -1:
        return 0
    else:
        return right - left + 1",170
17870670921,find_largest_palindrome,"def find_largest_palindrome(s: str) -> str:
    if len(s) == 0:
        return """"
    max_length = 1
    start = 0
    for i in range(len(s)):
        if i - max_length >= 1 and s[i - max_length - 1: i + 1] == s[i - max_length - 1: i + 1][::-1]:
            start = i - max_length - 1
            max_length += 2
            continue
        if i - max_length >= 0 and s[i - max_length: i + 1] == s[i - max_length: i + 1][::-1]:
            start = i - max_length
            max_length += 1
    return s[start: start + max_length]",170
12599547815,shortest_subarray,"from collections import deque

def shortest_subarray(nums, k):
    n = len(nums)
    min_length = n + 1
    prefix_sum = [0] * (n + 1)
    
    for i in range(1, n + 1):
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]

    dq = deque()
    
    for i in range(n + 1):
        while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k:
            min_length = min(min_length, i - dq[0])
            dq.popleft()
        
        while dq and prefix_sum[i] <= prefix_sum[dq[-1]]:
            dq.pop()
        
        dq.append(i)
    
    return min_length if min_length <= n else 0",170
19129024393,find_first_last,"def find_first_last(arr, target):
    def binary_search(arr, target, find_first):
        left, right = 0, len(arr) - 1
        result = -1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == target:
                result = mid
                if find_first:
                    right = mid - 1
                else:
                    left = mid + 1
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return result

    first = binary_search(arr, target, True)
    if first == -1:
        return (-1, -1)
    last = binary_search(arr, target, False)
    return (first, last)",170
12321145695,find_target_positions,"def find_target_positions(nums, target):
    def binary_search(nums, target, findFirst):
        low, high = 0, len(nums) - 1
        ans = -1
        while low <= high:
            mid = (low + high) // 2
            if nums[mid] > target:
                high = mid - 1
            elif nums[mid] < target:
                low = mid + 1
            else:
                ans = mid
                if findFirst:
                    high = mid - 1
                else:
                    low = mid + 1
        return ans

    first = binary_search(nums, target, True)
    if first == -1:
        return [-1, -1]
    last = binary_search(nums, target, False)
    return [first, last]",170
29878892400,closest_value_in_bst,"class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def closest_value_in_bst(node, target):
    closest = node.value
    while node:
        if abs(target - closest) > abs(target - node.value):
            closest = node.value
        if target < node.value:
            node = node.left
        elif target > node.value:
            node = node.right
        else:
            break
    return closest

# Construct the binary search tree
tree = Node(11)
tree.left = Node(5)
tree.right = Node(17)
tree.left.left = Node(2)
tree.left.left.left = Node(1)
tree.right.left = Node(14)
tree.right.right = Node(20)",170
7345540027,min_ops_to_convert,"def min_ops_to_convert(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    return dp[m][n]",170
74729778207,ways_To_Reach_End,"def ways_To_Reach_End(grid):
    m, n = len(grid), len(grid[0])
    if grid[0][0] == 1 or grid[m-1][n-1] == 1:
        return 0
    dp = [[0 for _ in range(n)] for _ in range(m)]
    dp[0][0] = 1
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                dp[i][j] = 0
            else:
                if i > 0:
                    dp[i][j] += dp[i-1][j]
                if j > 0:
                    dp[i][j] += dp[i][j-1]
    return dp[m-1][n-1]",170
43383106232,longest_common_substring,"def longest_common_substring(s1, s2):
    m = [[0] * (1 + len(s2)) for i in range(1 + len(s1))]
    longest, x_longest = 0, 0
    for x in range(1, 1 + len(s1)):
        for y in range(1, 1 + len(s2)):
            if s1[x - 1] == s2[y - 1]:
                m[x][y] = m[x - 1][y - 1] + 1
                if m[x][y] > longest:
                    longest = m[x][y]
                    x_longest = x
            else:
                m[x][y] = 0
    return s1[x_longest - longest: x_longest]",170
2170728329,longest_common_substring,"def longest_common_substring(s1, s2):
    m = [[0] * (1 + len(s2)) for i in range(1 + len(s1))]
    longest, x_longest = 0, 0
    for x in range(1, 1 + len(s1)):
        for y in range(1, 1 + len(s2)):
            if s1[x - 1] == s2[y - 1]:
                m[x][y] = m[x - 1][y - 1] + 1
                if m[x][y] > longest:
                    longest = m[x][y]
                    x_longest = x
            else:
                m[x][y] = 0
    return s1[x_longest - longest: x_longest]",170
27620632990,max_square_area,"def max_square_area(matrix):
    m = len(matrix)
    if m == 0:
        return 0
    n = len(matrix[0])
    if n == 0:
        return 0
    max_side = 0
    dp = [[0] * n for _ in range(m)]
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                max_side = max(max_side, dp[i][j])
    return max_side ** 2",170
70848187258,next_permutation,"def next_permutation(nums):
    n = len(nums)
    if n < 2:
        return nums

    l, r = n - 2, n - 1
    while l >= 0:
        if nums[l] < nums[r]:
            break
        l -= 1
        r -= 1

    if l < 0:
        nums.reverse()
        return nums

    k = n - 1
    while nums[l] >= nums[k]:
        k -= 1
    nums[l], nums[k] = nums[k], nums[l]

    start = r
    end = n - 1
    while start < end:
        nums[start], nums[end] = nums[end], nums[start]
        start += 1
        end -= 1
    return nums",169
535138333,minJumps,"def minJumps(arr): 
    n = len(arr) 
    if n <= 1: 
        return 0
    if arr[0] == 0: 
        return -1
    maxReach = arr[0] 
    step = arr[0] 
    jump = 1
    for i in range(1, n): 
        if i == n-1: 
            return jump 
        maxReach = max(maxReach, i + arr[i]) 
        step -= 1
        if step == 0: 
            jump += 1
            if i >= maxReach: 
                return -1
            if i == maxReach: 
                step = maxReach - i 
            else: 
                step = maxReach - i 
    return -1",169
12235885770,is_magic_square,"def is_magic_square(matrix):
    n = len(matrix)
    if n == 0:
        return False

    # Calculate the sum of the first row to use as a reference
    magic_sum = sum(matrix[0])

    # Check sums of rows
    for row in matrix:
        if sum(row) != magic_sum:
            return False

    # Check sums of columns
    for col in zip(*matrix):
        if sum(col) != magic_sum:
            return False

    # Check sum of the main diagonal
    if sum(matrix[i][i] for i in range(n)) != magic_sum:
        return False

    # Check sum of the secondary diagonal
    if sum(matrix[i][n-1-i] for i in range(n)) != magic_sum:
        return False

    return True",169
36160267377,is_valid_url,"import re

def is_valid_url(url: str) -> bool:
    pattern = r'^(https?://)?((?!-)[a-zA-Z\d-]{1,63}(?<!-)\.)*((?!-)[a-zA-Z\d-]{1,63}(?<!-))(/[a-zA-Z0-9_.,@?^=%&amp;:~\+#-]*;[a-zA-Z0-9_.,@?^=%&amp;:~\+#-]*)?(\?[a-zA-Z0-9_.,@?^=%&amp;:~\+#-]*)?#?([a-zA-Z0-9_.,@?^=%&amp;:~\+#-]*)?$'
    return bool(re.match(pattern, url))",169
31676060360,check_straight_line,"from typing import List

def check_straight_line(coordinates: List[List[int]]) -> bool:
    base = coordinates[0]
    base2 = coordinates[1]

    try:
        inclination = (base[1] - base2[1]) / (base[0] - base2[0])
    except ZeroDivisionError:
        return True if all(coord[0] == coordinates[0][0] for coord in coordinates) else False

    for i in range(2, len(coordinates)):
        other_base = coordinates[i]
        try:
            other_inclination = (base[1] - other_base[1]) / (base[0] - other_base[0])
        except ZeroDivisionError:
            return False
        if other_inclination != inclination:
            return False
    return True",169
14130997416,min_cost_path,"def min_cost_path(cost):
    m, n = len(cost), len(cost[0])
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = cost[0][0]
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + cost[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + cost[0][j]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j]
    return dp[m-1][n-1]",169
32615158087,countIslands,"from typing import List

def countIslands(grid: List[List[int]]) -> int:
    if not grid:
        return 0

    def dfs(i, j):
        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != 1:
            return
        grid[i][j] = 0
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                dfs(i, j)
                count += 1
    return count",169
16860439077,findCheapestPrice,"from collections import defaultdict

def findCheapestPrice(n, flights, src, dest, k):
    dp = defaultdict(list)
    for x,y,z in flights:
        dp[x].append((y,z))
        
    cityCost = {src:0}
        
    queue = []
        
    queue.append((src,0,0))
        
    while queue:
        city, cost, distance = queue.pop(0)
        for nextTrip,nextTripCost in dp[city]:
            if nextTrip not in cityCost or cost + nextTripCost < cityCost[nextTrip]:
                cityCost[nextTrip] = cost + nextTripCost
                if distance < k:
                    queue.append((nextTrip,cityCost[nextTrip],distance+1))
        
    return cityCost[dest] if dest in cityCost else -1",169
74329656728,edit_distance,"def edit_distance(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
    
    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])
    return dp[m][n]",169
40810550587,num_buses_to_destination,"from collections import defaultdict

def num_buses_to_destination(routes, source, target):
    if source == target: return 0
    if source not in {stop for route in routes for stop in route}: return -1

    graph = defaultdict(set)
    for i, route in enumerate(routes):
        for stop in route:
            graph[stop].add(i)

    queue = [(x, 1) for x in graph[source]]
    visited = set([x for x,_ in queue])

    while queue:
        rid, b = queue.pop(0)

        for stop in routes[rid]:
            if stop == target:
                return b
            for i in graph[stop]:
                if i not in visited:
                    queue.append((i, b+1))
                    visited.add(i)
    return -1",169
25042261626,longestPalindrome,"def longestPalindrome(s: str) -> str:
    if len(s) == 0:
        return 0
    maxLen = 1
    start = 0
    for i in range(len(s)):
        if i - maxLen >= 1 and s[i - maxLen - 1: i + 1] == s[i - maxLen - 1: i + 1][::-1]:
            start = i - maxLen - 1
            maxLen += 2
            continue
        if i - maxLen >= 0 and s[i - maxLen: i + 1] == s[i - maxLen: i + 1][::-1]:
            start = i - maxLen
            maxLen += 1
    return s[start: start + maxLen]",169
1658442422,longest_Palindrome,"def longest_Palindrome(s: str) -> str:
    if len(s) == 0:
        return """"
    max_len = 1
    start = 0
    for i in range(len(s)):
        if i - max_len >= 1 and s[i - max_len - 1 : i + 1] == s[i - max_len - 1 : i + 1][::-1]:
            start = i - max_len - 1
            max_len += 2
            continue
        if i - max_len >= 0 and s[i - max_len : i + 1] == s[i - max_len : i + 1][::-1]:
            start = i - max_len
            max_len += 1
    return s[start : start + max_len]",169
43120133503,minEditDistance,"def minEditDistance(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]

    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    return dp[m][n]",169
38796738792,isLongPressedName,"def isLongPressedName(name: str, typed: str) -> bool:
    name = list(name)
    typed = list(typed)
    n, m = len(name), len(typed)
    i, x, jicun = 0, 0, ''
    while i < n:
        if x < m and name[i] == typed[x]:
            jicun = name[i]
            i += 1
            x += 1
            continue
        while x < m and typed[x] == jicun:
            x += 1
        if x >= m or typed[x] != name[i]:
            return False
    while x < m and typed[x] == jicun:
        x += 1
    if x != m:
        return False
    return True",169
1183814242,reverse_parentheses,"def reverse_parentheses(s: str) -> str:
    stack = []
    for char in s:
        if char != "")"":
            stack.append(char)
        else:
            temp = """"
            while stack and stack[-1] != ""("":
                temp += stack.pop()
            stack.pop()  # Remove the '('
            stack.extend(temp)
    return """".join(stack)

print(reverse_parentheses(""(abcd)""))  # Should print ""dcba""
print(reverse_parentheses(""(u(love)i)""))  # Should print ""iloveu""
print(reverse_parentheses(""(ed(et(oc))el)""))  # Should print ""leetcode""
print(reverse_parentheses(""a(bcdefghijkl(mno)p)q""))  # Should print ""apmnolkjihgfedcbq""",169
42073195852,find_longest_consecutive_subsequence,"def find_longest_consecutive_subsequence(arr, N):
    arr = list(map(int, arr))
    arr.sort()
    longest_length = 1
    current_length = 1
    start = arr[0]
    for i in range(1, N):
        if (arr[i] == arr[i - 1] + 1):
            current_length+=1
        elif (arr[i] != arr[i - 1]):
            if (longest_length < current_length):
                longest_length = current_length
                start = arr[i - current_length]
            current_length = 1
    if (longest_length < current_length):
        start = arr[N - current_length]
        longest_length = current_length
    return ' '.join(map(str, list(range(start, start + longest_length))))",168
24463670326,is_consecutive_sequence,"def is_consecutive_sequence(s: str) -> bool:
    n = len(s)
    if n < 2:
        return False
    
    def check_sequence(start, length):
        if length > n:
            return False
        
        number = int(s[start:start+length])
        next_start = start + length
        
        while next_start < n:
            next_number = number + 1
            next_length = len(str(next_number))
            if next_start + next_length > n or s[next_start:next_start+next_length] != str(next_number):
                return False
            
            number = next_number
            next_start += next_length
        
        return True
    
    for length in range(1, n // 2 + 1):
        if check_sequence(0, length):
            return True
    
    return False",168
36752155414,grid_paths,"def grid_paths(grid):
    m = len(grid)
    n = len(grid[0])
    if grid[0][0] == 1 or grid[m-1][n-1] == 1:
        return 0
    dp = [[0 for _ in range(n)] for _ in range(m)]
    dp[0][0] = 1
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                dp[i][j] = 0
            else:
                if i > 0:
                    dp[i][j] += dp[i-1][j]
                if j > 0:
                    dp[i][j] += dp[i][j-1]
    return dp[m-1][n-1]",168
14431057383,integer_break,"def integer_break(n):
    """"""
    Finds the maximum product after breaking an integer into the sum of at least two positive integers.

    :param n: Integer to be broken into sum of at least two positive integers.
    :return: Maximum product of those integers.
    """"""
    cache = [1] * (n+1)
    for i in range(2, n+1):
        for j in range(1, i):
            cache[i] = max(cache[i], j*(i-j), j*cache[i-j])
    return cache[-1]

if __name__ == '__main__':
    assert integer_break(2) == 1
    assert integer_break(10) == 36
    assert integer_break(8) == 18
    print(""All test cases passed."")",168
39091600241,edit_distance,"def edit_distance(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    return dp[m][n]",168
41560232552,edit_distance,"def edit_distance(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    return dp[m][n]",168
36160313107,edit_distance,"def edit_distance(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])
    return dp[m][n]",168
22851795846,search_range,"def search_range(nums, target):
	""""""
	:type nums: List[int]
	:type target: int
	:rtype: List[int]
	""""""
	left = binsearch(nums, target, True)
	right = binsearch(nums, target, False)
	return [left, right]

def binsearch(nums, target, direction):
	start = 0
	end = len(nums) - 1
	index = -1		
	while start <= end:
		mid = (start + end) // 2
		if nums[mid] < target:
			start = mid + 1
		elif nums[mid] > target:
			end = mid - 1
		else:
			index = mid
			if direction:
				end = mid - 1
			else:
				start = mid + 1

	return index",168
9795870048,closed_island,"from typing import List

def closed_island(grid: List[List[int]]) -> int:
    def dfs(i, j):
        if not (0 <= i < m and 0 <= j < n) or grid[i][j] == 1:
            return True
        if not (0 < i < m-1 and 0 < j < n-1):
            return False
        grid[i][j] = 1
        return dfs(i-1, j) and dfs(i+1, j) and dfs(i, j-1) and dfs(i, j+1)

    m, n = len(grid), len(grid[0])
    return sum(dfs(i, j) for i in range(m) for j in range(n) if grid[i][j] == 0)",168
17739291146,find_lower_bound,"def find_lower_bound(array, target):
    lo = 0
    hi = len(array)
    while lo < hi:
        mid = lo + (hi - lo) // 2
        if array[mid] < target:
            lo = mid + 1
        else:
            hi = mid
    return lo


# Test the function
assert find_lower_bound([1, 2, 4, 4, 5, 6, 8], 4) == 2
assert find_lower_bound([1, 2, 4, 4, 5, 6, 8], 3) == 2
assert find_lower_bound([1, 2, 4, 4, 5, 6, 8], 8) == 6",168
34940924811,countWays,"def countWays(grid):
    rows = len(grid)
    cols = len(grid[0])
    
    if grid[0][0] == 1 or grid[rows-1][cols-1] == 1:
        return 0
    
    dp = [[0]*cols for _ in range(rows)]
    dp[0][0] = 1
    
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 1:
                dp[i][j] = 0
            else:
                if i > 0:
                    dp[i][j] += dp[i-1][j]
                if j > 0:
                    dp[i][j] += dp[i][j-1]
    return dp[rows-1][cols-1]",168
15733289648,find_path,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def find_path(root, value):
    path = []
    def dfs(node, path):
        if not node:
            return False
        path.append(node.val)
        if node.val == value:
            return True
        if dfs(node.left, path) or dfs(node.right, path):
            return True
        path.pop()
        return False
    dfs(root, path)
    return path

assert find_path(None, 1) == []
assert find_path(TreeNode(1), 1) == [1]
assert find_path(TreeNode(1, TreeNode(2), TreeNode(3)), 3) == [1, 3]",168
5361442578,reverse_string_with_stack,"class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return not bool(self.items)

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()

    def peek(self):
        return self.items[-1]

    def size(self):
        return len(self.items)


def reverse_string_with_stack(input_string):
    stack = Stack()
    reversed_string = """"
    for char in input_string:
        stack.push(char)
    while not stack.is_empty():
        reversed_string += stack.pop()
    return reversed_string


# Test cases
assert reverse_string_with_stack(""hello"") == ""olleh""
assert reverse_string_with_stack(""world"") == ""dlrow""
assert reverse_string_with_stack(""python"") == ""nohtyp""",168
14132417736,median_sorted_arrays,"def median_sorted_arrays(nums1, nums2):
    nums = []
    i, j = 0, 0
    while i < len(nums1) and j < len(nums2):
        if nums1[i] < nums2[j]:
            nums.append(nums1[i])
            i += 1
        else:
            nums.append(nums2[j])
            j += 1
    while i < len(nums1):
        nums.append(nums1[i])
        i += 1
    while j < len(nums2):
        nums.append(nums2[j])
        j += 1
    if len(nums) % 2 == 0:
        return (nums[len(nums)//2 - 1] + nums[len(nums)//2]) / 2
    else:
        return nums[len(nums)//2]",168
70150662170,uniquePaths,"def uniquePaths(obstacleGrid):
    m, n = len(obstacleGrid), len(obstacleGrid[0])
    dp = [[0]*n for _ in range(m)]
    for i in range(m):
        if obstacleGrid[i][0] == 1:
            break
        dp[i][0] = 1
    for j in range(n):
        if obstacleGrid[0][j] == 1:
            break
        dp[0][j] = 1
    for i in range(1, m):
        for j in range(1, n):
            if obstacleGrid[i][j] == 0:
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[m-1][n-1]",168
39853851266,find_middle_node,"class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def find_middle_node(head: ListNode) -> int:
    slow, fast = head, head
    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next
    return slow.val

if __name__ == ""__main__"":
    node1 = ListNode(1)
    node2 = ListNode(2)
    node3 = ListNode(3)
    node4 = ListNode(4)
    node5 = ListNode(5)
    
    node1.next = node2
    node2.next = node3
    node3.next = node4
    node4.next = node5
    
    assert find_middle_node(node1) == 3",167
42386542269,repeatedSubstringPattern,"def repeatedSubstringPattern(s: str) -> bool:

	slen = len(s)

	if slen == 1:
		return False

	if slen == 2:
		return s[0] == s[1]

	mid = 1
	while mid <= slen//2:
		midx = mid
		while midx < slen:
			if s[0:mid] == s[midx:midx+len(s[0:mid])]:
				if (midx + len(s[0:mid])) > slen:
					return True
				else:
					midx += len(s[0:mid])
			else:
				mid += 1
				break

		if midx >= slen:
			return True

	if mid >= slen//2:
		return False",167
24504348249,count_islands,"def count_islands(grid):
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    count = 0
    
    def dfs(r, c):
        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0:
            return
        grid[r][c] = 0
        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            dfs(r + dr, c + dc)
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 1:
                dfs(r, c)
                count += 1
                
    return count",167
31906336841,find_longest_palindrome,"def find_longest_palindrome(s):
    if len(s) == 0:
        return 0
    maxLen = 1
    start = 0
    for i in range(len(s)):
        if i - maxLen >= 1 and s[i - maxLen - 1 : i + 1] == s[i - maxLen - 1 : i + 1][::-1]:
            start = i - maxLen - 1
            maxLen += 2
            continue
        if i - maxLen >= 0 and s[i - maxLen : i + 1] == s[i - maxLen : i + 1][::-1]:
            start = i - maxLen
            maxLen += 1
    return s[start : start + maxLen]",167
3238436166,is_dag,"def is_dag(edges):
    graph = {}
    for u, v in edges:
        if u not in graph:
            graph[u] = []
        if v not in graph:
            graph[v] = []
        graph[u].append(v)
    indegree = {}
    for u, v in edges:
        if v not in indegree:
            indegree[v] = 0
        indegree[v] += 1
    queue = [u for u in graph if u not in indegree]
    while queue:
        u = queue.pop(0)
        for v in graph[u]:
            indegree[v] -= 1
            if indegree[v] == 0:
                queue.append(v)
    if sum(indegree.values()) > 0:
        return False
    return True",167
42899817638,numIslands,"def numIslands(grid):
    def dfs(grid, i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':
            return
        grid[i][j] = '#'  # mark as visited
        dfs(grid, i+1, j)
        dfs(grid, i-1, j)
        dfs(grid, i, j+1)
        dfs(grid, i, j-1)

    if not grid:
        return 0

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(grid, i, j)
                count += 1
    return count",167
4729240487,largest_rectangle,"def largest_rectangle(matrix):
    if not matrix:
        return 0
    
    max_area = 0
    n = len(matrix)
    m = len(matrix[0])
    height = [0] * m
    
    for i in range(n):
        for j in range(m):
            height[j] = height[j] + 1 if matrix[i][j] == 1 else 0
        
        stack = [-1]
        for j in range(m + 1):
            while stack[-1] != -1 and (j == m or height[stack[-1]] >= height[j]):
                h = height[stack.pop()]
                w = j - stack[-1] - 1
                max_area = max(max_area, h * w)
            stack.append(j)
    
    return max_area",167
19929095224,split_array,"def split_array(arr):
    if len(arr) < 6:
        return 0

    from collections import defaultdict
    import operator
    from itertools import accumulate as acc

    d = defaultdict(int)
    d[arr[0]] = 1
    rightsum = list(acc(arr[::-1], operator.add))[::-1]
    leftsum = list(acc(arr, operator.add))
    result = 0

    for j in range(1, len(arr) - 1):
        temp = leftsum[j]
        if temp % 3:
            d[leftsum[j]] += 1
            continue
        third = temp / 3
        if third == rightsum[j + 1]:
            result += d[third]
        d[leftsum[j]] += 1

    return result",167
17706609629,find_longest_palindrome,"def find_longest_palindrome(s):
    if len(s) == 0:
        return 0
    maxLen = 1
    start = 0
    for i in range(len(s)):
        if i - maxLen >= 1 and s[i - maxLen - 1 : i + 1] == s[i - maxLen - 1 : i + 1][::-1]:
            start = i - maxLen - 1
            maxLen += 2
            continue
        if i - maxLen >= 0 and s[i - maxLen : i + 1] == s[i - maxLen : i + 1][::-1]:
            start = i - maxLen
            maxLen += 1
    return s[start : start + maxLen]",167
33760095378,circular_array_loop,"def circular_array_loop(nums):
    N = len(nums)
    def nxt(x):
        return (x + nums[x]) % N
    for i in range(N):  
        if nums[i] == 0: continue  
        slow, fast = i, nxt(i)
        while nums[slow] * nums[fast] > 0 and nums[fast] * nums[nxt(fast)] > 0:
            if slow == fast:
                if slow == nxt(fast):
                    break  
                else:
                    return True
            slow = nxt(slow)
            fast = nxt(nxt(fast))

        val = nums[i]  
        while val * nums[i] > 0:
            tmp = nxt(i)
            nums[i] = 0
            i = tmp
    return False",167
74885817087,find_unique_common_elements,"def find_unique_common_elements(list1, list2):
    # creating a dictionary to hold count of elements in list2
    count_dict = {}
    for item in list2:
        count_dict[item] = count_dict.get(item, 0) + 1

    # creating a list to hold the common unique elements
    common_list = []
    for item in list1:
        if item in count_dict and count_dict[item] == 1:
            common_list.append(item)
            # ensuring that the item is unique in list1 as well
            if list1.count(item) > 1:
                common_list.pop()
            else:
                # to ensure that the item is not included in result more than once even if it is common
                count_dict[item] = 0

    return common_list",167
5258407291,longest_palindrome_substring,"def longest_palindrome_substring(s):
    if len(s) == 0:
        return 0
    max_len = 1
    start = 0
    for i in range(len(s)):
        if i - max_len >= 1 and s[i - max_len - 1 : i + 1] == s[i - max_len - 1 : i + 1][::-1]:
            start = i - max_len - 1
            max_len += 2
            continue
        if i - max_len >= 0 and s[i - max_len : i + 1] == s[i - max_len : i + 1][::-1]:
            start = i - max_len
            max_len += 1
    return s[start : start + max_len]",167
4128467756,count_subsequences,"def count_subsequences(main_str: str, target_str: str) -> int:
    m, n = len(main_str), len(target_str)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][0] = 1

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if main_str[i - 1] == target_str[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[m][n]",167
21105342013,largest_Rectangle_Area,"def largest_Rectangle_Area(heights):
    stack = []
    max_area = 0
    index = 0
    while index < len(heights):
        if (not stack) or (heights[stack[-1]] <= heights[index]):
            stack.append(index)
            index += 1
        else:
            top_of_stack = stack.pop()
            area = (heights[top_of_stack] *
                    ((index - stack[-1] - 1) if stack else index))
            max_area = max(max_area, area)
    while stack:
        top_of_stack = stack.pop()
        area = (heights[top_of_stack] *
                ((index - stack[-1] - 1) if stack else index))
        max_area = max(max_area, area)
    return max_area",167
23422842074,lengthOfLIS,"def lengthOfLIS(nums):
    n = len(nums)
    if n==0:
        return 0

    dp = [1]*n
    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

print(lengthOfLIS([10,9,2,5,3,7,101,18]))
print(lengthOfLIS([-1,-2,-3,-4,-5,-6]))
print(lengthOfLIS([2,1,3,1,4]))
print(lengthOfLIS([3,2,1,2]))
print(lengthOfLIS([3, 2, 1]))",167
73976383472,find_integer_and_sqrt,"import math

def find_integer_and_sqrt(lst):
    res = [(i, round(math.sqrt(i))) for i in lst]
    return res

assert find_integer_and_sqrt([1, 4, 9, 16]) == [(1, 1), (4, 2), (9, 3), (16, 4)]
assert find_integer_and_sqrt([2, 3, 5, 6]) == [(2, 1), (3, 2), (5, 2), (6, 2)]
assert find_integer_and_sqrt([25, 36, 49, 64]) == [(25, 5), (36, 6), (49, 7), (64, 8)]",166
36036283961,days_in_month,"def is_leap_year(year):
    if year % 4 == 0:
        if year % 100 == 0:
            if year % 400 == 0:
                return True
            else:
                return False
        else:
            return True
    else:
        return False

def days_in_month(month, year):
    if month in [1, 3, 5, 7, 8, 10, 12]:
        return 31
    elif month in [4, 6, 9, 11]:
        return 30
    elif month == 2:
        if is_leap_year(year):
            return 29
        else:
            return 28
    else:
        return None",166
12405167322,longest_Palindrome,"def longest_Palindrome(s):
    if len(s) == 0:
        return 0
    maxLen = 1
    start = 0
    for i in range(len(s)):
        if i - maxLen >= 1 and s[i - maxLen - 1: i + 1] == s[i - maxLen - 1: i + 1][::-1]:
            start = i - maxLen - 1
            maxLen += 2
            continue
        if i - maxLen >= 0 and s[i - maxLen: i + 1] == s[i - maxLen: i + 1][::-1]:
            start = i - maxLen
            maxLen += 1
    return s[start: start + maxLen]",166
17771162495,count_target_value,"def count_target_value(nums, target):
    left = 0
    right = len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1
        elif nums[mid] > target:
            right = mid - 1
        else:
            count = 1
            left_count = mid - 1
            while left_count >= 0 and nums[left_count] == target:
                count += 1
                left_count -= 1
            right_count = mid + 1
            while right_count < len(nums) and nums[right_count] == target:
                count += 1
                right_count += 1
            return count
    return 0",166
29375577653,decode_variations,"def decode_variations(s: str) -> int:
    if not s or s[0] == '0':
        return 0

    # dp[i] represents the number of ways to decode the string s[:i]
    dp = [0] * (len(s) + 1)
    dp[0], dp[1] = 1, 1

    for i in range(2, len(s) + 1):
        # Single digit decode
        if s[i-1] != '0':
            dp[i] += dp[i-1]

        # Two digit decode
        two_digit = int(s[i-2:i])
        if 10 <= two_digit <= 26:
            dp[i] += dp[i-2]

    return dp[len(s)]",166
32866580356,find_count,"def find_count(arr, x):
    left = binary_search(arr, x, True)
    if left == -1:
        return 0
    right = binary_search(arr, x, False)
    return right - left + 1

def binary_search(arr, x, is_left):
    low, high = 0, len(arr) - 1
    result = -1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == x:
            result = mid
            if is_left:
                high = mid - 1
            else:
                low = mid + 1
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1
    return result",166
41155328916,longestCommonSubstring,"def longestCommonSubstring(s1, s2):
    len1, len2 = len(s1), len(s2)
    grid = [[0 for _ in range(len2+1)] for _ in range(len1+1)]
    result = """"
    max_length = 0
    for r in range(1, len1+1):
        for c in range(1, len2+1):
            if s1[r-1] == s2[c-1]:
                grid[r][c] = grid[r-1][c-1] + 1
                if grid[r][c] > max_length:
                    max_length = grid[r][c]
                    result = s1[r-max_length:r]
            else:
                grid[r][c] = 0
    return result",166
24434954005,longest_Palindrome,"def longest_Palindrome(s):
    if len(s) == 0:
        return 0
    maxLen = 1
    start = 0
    for i in range(len(s)):
        if i - maxLen >= 1 and s[i - maxLen - 1 : i + 1] == s[i - maxLen - 1 : i + 1][::-1]:
            start = i - maxLen - 1
            maxLen += 2
            continue
        if i - maxLen >= 0 and s[i - maxLen : i + 1] == s[i - maxLen : i + 1][::-1]:
            start = i - maxLen
            maxLen += 1
    return s[start : start + maxLen]",166
32648531115,largest_rectangle_area,"def largest_rectangle_area(heights):
    stack = []
    max_area = 0
    index = 0
    while index < len(heights):
        if (not stack) or (heights[stack[-1]] <= heights[index]):
            stack.append(index)
            index += 1
        else:
            top_of_stack = stack.pop()
            area = (heights[top_of_stack] *
                    ((index - stack[-1] - 1) if stack else index))
            max_area = max(max_area, area)
    while stack:
        top_of_stack = stack.pop()
        area = (heights[top_of_stack] *
                ((index - stack[-1] - 1) if stack else index))
        max_area = max(max_area, area)
    return max_area",165
25906057442,max_length_subarray,"def max_length_subarray(nums):
    ctr = 0
    d = {0:0}
    maxlen = 0
    for i, val in enumerate(nums, 1):
        if val==0:
            ctr-=1
        else:
            ctr+=1

        if ctr in d:
            maxlen = max(maxlen, i-d[ctr])
        else:
            d[ctr] = i
    return maxlen

# Testing
print(max_length_subarray([0, 1])) # Expected output: 2
print(max_length_subarray([0, 1, 0])) # Expected output: 2
print(max_length_subarray([0, 1, 0, 1, 0, 1, 1])) # Expected output: 6",165
40710153704,find_longest_palindrome,"def find_longest_palindrome(s):
    if len(s) == 0:
        return """"
    max_length = 1
    start = 0
    for i in range(len(s)):
        if i - max_length >= 1 and s[i - max_length - 1: i + 1] == s[i - max_length - 1: i + 1][::-1]:
            start = i - max_length - 1
            max_length += 2
            continue
        if i - max_length >= 0 and s[i - max_length: i + 1] == s[i - max_length: i + 1][::-1]:
            start = i - max_length
            max_length += 1
    return s[start: start + max_length]",165
15324774142,count_palindrome_substrings,"def count_palindrome_substrings(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    count = 0
    for i in range(n):
        dp[i][i] = 1
        count += 1
    for i in range(n-1):
        if s[i] == s[i+1]:
            dp[i][i+1] = 1
            count += 1
    for k in range(3, n+1):
        for i in range(n-k+1):
            j = i + k - 1
            if s[i] == s[j] and dp[i+1][j-1]:
                dp[i][j] = 1
                count += 1
    return count",165
43495003666,longest_palindrome,"def longest_palindrome(s):
    if len(s) == 0:
        return 0
    maxLen = 1
    start = 0
    for i in range(len(s)):
        if i - maxLen >= 1 and s[i - maxLen - 1 : i + 1] == s[i - maxLen - 1 : i + 1][::-1]:
            start = i - maxLen - 1
            maxLen += 2
            continue
        if i - maxLen >= 0 and s[i - maxLen : i + 1] == s[i - maxLen : i + 1][::-1]:
            start = i - maxLen
            maxLen += 1
    return s[start : start + maxLen]",165
10931331321,is_valid_number,"def is_valid_number(s):
    try:
        if s.count('.') > 1 or s.count('e') > 1 or s.count('-') > 1:
            return False
        if 'e' in s:
            s = s.split('e')
            if len(s[0]) == 0 or len(s[1]) == 0:
                return False
            if s[1].count('-') > 0:
                return False
        if '.' in s:
            s = s.split('.')
            if len(s[0]) == 0 or len(s[1]) == 0:
                return False
        if '-' in s and s.index('-') != 0:
            return False
        float(s)
        return True
    except ValueError:
        return False",165
11072731853,find_longest_palindrome,"def find_longest_palindrome(s):
    if len(s) == 0:
        return """"
    max_length = 1
    start = 0
    for i in range(len(s)):
        if i - max_length >= 1 and s[i - max_length - 1: i + 1] == s[i - max_length - 1: i + 1][::-1]:
            start = i - max_length - 1
            max_length += 2
            continue
        if i - max_length >= 0 and s[i - max_length: i + 1] == s[i - max_length: i + 1][::-1]:
            start = i - max_length
            max_length += 1
    return s[start: start + max_length]",165
1452565952,find_longest_palindrome,"def find_longest_palindrome(s):
    if len(s) == 0:
        return """"
    max_length = 1
    start = 0
    for i in range(len(s)):
        if i - max_length >= 1 and s[i - max_length - 1: i + 1] == s[i - max_length - 1: i + 1][::-1]:
            start = i - max_length - 1
            max_length += 2
            continue
        if i - max_length >= 0 and s[i - max_length: i + 1] == s[i - max_length: i + 1][::-1]:
            start = i - max_length
            max_length += 1
    return s[start: start + max_length]",165
36093584541,has_cycle,"from typing import List

def has_cycle(num_nodes: int, edges: List[List[int]]) -> bool:
    graph = {i: [] for i in range(num_nodes)}
    for u, v in edges:
        graph[u].append(v)

    visited = [False] * num_nodes
    rec_stack = [False] * num_nodes

    def dfs(node):
        visited[node] = True
        rec_stack[node] = True

        for neighbor in graph[node]:
            if not visited[neighbor]:
                if dfs(neighbor):
                    return True
            elif rec_stack[neighbor]:
                return True

        rec_stack[node] = False
        return False

    for node in range(num_nodes):
        if not visited[node]:
            if dfs(node):
                return True
    return False",165
30636164265,longest_palindrome_substring,"def longest_palindrome_substring(s):
    if len(s) == 0:
        return """"
    max_length = 1
    start = 0
    for i in range(len(s)):
        if i - max_length >= 1 and s[i - max_length - 1: i + 1] == s[i - max_length - 1: i + 1][::-1]:
            start = i - max_length - 1
            max_length += 2
            continue
        if i - max_length >= 0 and s[i - max_length: i + 1] == s[i - max_length: i + 1][::-1]:
            start = i - max_length
            max_length += 1
    return s[start: start + max_length]",165
17669273210,min_swaps,"from typing import List

def min_swaps(nums: List[int]) -> int:
    n = len(nums)
    arr_pos, pos_arr = [], list(enumerate(nums))
    
    pos_arr.sort(key=lambda it: it[1])
    for i in range(n):
        arr_pos.append(pos_arr[i][0])
    
    vis = [False] * n 
    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",165
23944068745,longestPalindrome,"from typing import List
from collections import Counter

def longestPalindrome(words: List[str]) -> int:
    word_count = Counter(words)
    max_len = 0
    flag = True
    for word in set(words):
        rev_word = word[-1::-1]
        if word != rev_word and rev_word in word_count:
            max_len += 2 * min(word_count[word], word_count[rev_word])
        elif word == rev_word:
            if word_count[word] % 2 == 0:
                max_len += 2 * word_count[word]
            else:
                if flag:
                    max_len += 2 * word_count[word]
                    flag = False
                else:
                    max_len += 2 * (word_count[word] - 1)

    return max_len",165
7586609936,max_hist_area,"def max_hist_area(heights):
    stack = []
    max_area = 0
    index = 0
    while index < len(heights):
        if (not stack) or (heights[stack[-1]] <= heights[index]):
            stack.append(index)
            index += 1
        else:
            top_of_stack = stack.pop()
            area = (heights[top_of_stack] *
                    ((index - stack[-1] - 1) if stack else index))
            max_area = max(max_area, area)
    while stack:
        top_of_stack = stack.pop()
        area = (heights[top_of_stack] *
                ((index - stack[-1] - 1) if stack else index))
        max_area = max(max_area, area)
    return max_area",165
12783934007,find_longest_subarray,"def find_longest_subarray(arr):
    max_len = 0
    sum = 0
    sum_dict = {0: -1}
    for i in range(len(arr)):
        if arr[i] == 0:
            sum -= 1
        else:
            sum += 1
        if sum in sum_dict:
            max_len = max(max_len, i - sum_dict[sum])
        else:
            sum_dict[sum] = i
    return max_len

# Test cases
assert find_longest_subarray([0,1]) == 2
assert find_longest_subarray([0,1,0]) == 2
assert find_longest_subarray([0, 0, 1, 0, 1, 1]) == 6",165
40969029863,longest_palindrome_subseq,"def longest_palindrome_subseq(s):
    n = len(s)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][n-1]

print(longest_palindrome_subseq(""bbbab""))
print(longest_palindrome_subseq(""cbbd""))
print(longest_palindrome_subseq(""abac""))",165
25039937268,lps,"def lps(s):
    n = len(s)
    L = [[0 for x in range(n)] for x in range(n)]
    for i in range(n):
        L[i][i] = 1
    for cl in range(2, n+1):
        for i in range(n-cl+1):
            j = i+cl-1
            if s[i] == s[j] and cl == 2:
                L[i][j] = 2
            elif s[i] == s[j]:
                L[i][j] = L[i+1][j-1] + 2
            else:
                L[i][j] = max(L[i][j-1], L[i+1][j]);
    return L[0][n-1]",165
70572520530,digit_operation,"def digit_operation(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True

    def product_of_digits(num):
        product = 1
        while num > 0:
            product *= num % 10
            num //= 10
        return product

    def sum_of_digits(num):
        total_sum = 0
        while num > 0:
            total_sum += num % 10
            num //= 10
        return total_sum

    if is_prime(n):
        return sum_of_digits(n)
    else:
        return product_of_digits(n)",165
38726693481,leads_to_destination,"from typing import List

def leads_to_destination(n: int, edges: List[List[int]], source: int, destination: int) -> bool:
    def dfs_loop_check(graph, node, dest, states):
        if states[node] != None:
            return not states[node]

        if len(graph[node]) == 0:
            return node == dest
        
        states[node] = True
        for next_node in graph[node]:
            if not dfs_loop_check(graph, next_node, dest, states):
                return False
        
        states[node] = False
        return True

    graph = [[] for i in range(n)]
    for edge in edges:
        i, j = edge
        graph[i].append(j)
    return dfs_loop_check(graph, source, destination, states=[None]*n)",165
16458827331,longest_palindrome,"def longest_palindrome(s):
    if len(s) == 0:
        return 0
    maxLen = 1
    start = 0
    for i in range(len(s)):
        if i - maxLen >= 1 and s[i - maxLen - 1 : i + 1] == s[i - maxLen - 1 : i + 1][::-1]:
            start = i - maxLen - 1
            maxLen += 2
            continue
        if i - maxLen >= 0 and s[i - maxLen : i + 1] == s[i - maxLen : i + 1][::-1]:
            start = i - maxLen
            maxLen += 1
    return s[start : start + maxLen]",165
12469226715,max_subarray,"def max_subarray(lst):
    if not lst:
        return []
    res = lst[0]
    curr= lst[0]
    l=0
    r=0
    curr_l=0 if lst[0]>=0 else 1
    for i in range(1,len(lst)):
        if lst[i]>=0:
            curr=max(0,curr)
            curr+=lst[i]
            if res <=curr:
                if res == curr:
                    if(r-l)<(i-curr_l):
                        l=curr_l
                        r=i
                else:
                    res=curr
                    l=curr_l
                    r=i
        else:
            curr=lst[i]
            curr_l=i+1
    return lst[l:r+1] if res>=0 else []",165
932089056,sieve_of_eratosthenes,"def sieve_of_eratosthenes(limit):
    """"""
    Implements the Sieve of Eratosthenes algorithm to find all prime numbers up to a given limit.

    Parameters:
    limit (int): The upper limit (inclusive) for finding prime numbers.

    Returns:
    list: A list of prime numbers up to the given limit.
    """"""
    primes = []
    sieve = [True] * (limit + 1)
    for p in range(2, int(limit**0.5) + 1):
        if sieve[p] == True:
            for i in range(p*p, limit + 1, p):
                sieve[i] = False
    for p in range(2, limit + 1):
        if sieve[p]:
            primes.append(p)
    return primes",165
29868212239,roman_to_int,"def roman_to_int(s):
    roman = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000,'IV':4,'IX':9,'XL':40,'XC':90,'CD':400,'CM':900}
    i = 0
    num = 0
    while i < len(s):
        if i+1<len(s) and s[i:i+2] in roman:
            num+=roman[s[i:i+2]]
            i+=2
        else:
            #i+1<len(s) is required to avoid out of range error
            num+=roman[s[i]]
            i+=1
    return num",164
12891089988,beautifulArrangement,"def beautifulArrangement(N: int) -> int:
    def backtrack(index):
        if index > N:
            return 1
        count = 0
        for i in range(1, N + 1):
            if not visited[i] and (index % i == 0 or i % index == 0):
                visited[i] = True
                count += backtrack(index + 1)
                visited[i] = False
        return count
    visited = [False] * (N + 1)
    return backtrack(1)

def main():
    print('2 ===', beautifulArrangement(2))
    print('1 ===', beautifulArrangement(1))
    print('3 ===', beautifulArrangement(3))

if __name__ == '__main__':
    main()",164
32658753155,lcs,"def lcs(X , Y): 
    m = len(X) 
    n = len(Y) 
  
    # declaring the array for storing the dp values 
    L = [[None]*(n+1) for i in range(m+1)] 
  
    for i in range(m + 1): 
        for j in range(n + 1): 
            if i == 0 or j == 0 : 
                L[i][j] = 0
            elif X[i-1] == Y[j-1]: 
                L[i][j] = L[i-1][j-1]+1
            else: 
                L[i][j] = max(L[i-1][j] , L[i][j-1]) 
  
    return L[m][n]",164
12213514763,letter_combinations,"from typing import List

def letter_combinations(digits: str) -> List[str]:
    if not digits:
        return []
    
    digit_to_letters = {
        ""2"": ""abc"", ""3"": ""def"", ""4"": ""ghi"", ""5"": ""jkl"",
        ""6"": ""mno"", ""7"": ""pqrs"", ""8"": ""tuv"", ""9"": ""wxyz"",
        ""0"": "" "", ""1"": """"
    }
    
    def backtrack(index: int, path: str):
        if len(path) == len(digits):
            combinations.append(path)
            return
        
        for letter in digit_to_letters[digits[index]]:
            backtrack(index + 1, path + letter)
    
    combinations = []
    backtrack(0, """")
    return combinations",164
19784101224,smallest_window,"def smallest_window(s: str, t: str) -> str:
    from collections import defaultdict
    hs, ht = defaultdict(int), defaultdict(int)
    for a in t:
        ht[a] += 1
    cnt = 0
    res = """"
    j = 0
    for i in range(len(s)):
        hs[s[i]] += 1
        if hs[s[i]] <= ht[s[i]]:
            cnt += 1
        while j < len(s) and hs[s[j]] > ht[s[j]]:
            hs[s[j]] -= 1
            j += 1
        if cnt == len(t):
            if len(res) == 0 or len(res) > i-j+1:
                res = s[j:i+1]
    return res",164
5813556471,num_islands,"def num_islands(grid):
    if not grid:
        return 0

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == ""1"":
                dfs(grid, i, j)
                count += 1
    return count

def dfs(grid, i, j):
    if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != ""1"":
        return
    grid[i][j] = ""#""
    dfs(grid, i+1, j)
    dfs(grid, i-1, j)
    dfs(grid, i, j+1)
    dfs(grid, i, j-1)",164
1974006996,longestPalindrome,"def longestPalindrome(s):
    if len(s) == 0:
        return 0
    maxLen = 1
    start = 0
    for i in range(len(s)):
        if i - maxLen >= 1 and s[i - maxLen - 1: i + 1] == s[i - maxLen - 1: i + 1][::-1]:
            start = i - maxLen - 1
            maxLen += 2
            continue
        if i - maxLen >= 0 and s[i - maxLen: i + 1] == s[i - maxLen: i + 1][::-1]:
            start = i - maxLen
            maxLen += 1
    return s[start: start + maxLen]",164
8024896299,prime_factors_count,"def prime_factors_count(n):
    count = 0
    # Count the number of 2s that divide n
    while n % 2 == 0:
        count += 1
        n = n / 2
    # n must be odd at this point, so a skip of 2 (i = i + 2) can be used
    for i in range(3, int(n**0.5) + 1, 2):
        # While i divides n, count i and divide n
        while n % i == 0:
            count += 1
            n = n / i
    # Condition if n is a prime number greater than 2
    if n > 2:
        count += 1
    return count",164
5688227695,longest_Palindrome,"def longest_Palindrome(s):
    if len(s) == 0:
        return """"
    max_length = 1
    start = 0
    for i in range(len(s)):
        if i - max_length >= 1 and s[i - max_length - 1 : i + 1] == s[i - max_length - 1 : i + 1][::-1]:
            start = i - max_length - 1
            max_length += 2
            continue
        if i - max_length >= 0 and s[i - max_length : i + 1] == s[i - max_length : i + 1][::-1]:
            start = i - max_length
            max_length += 1
    return s[start : start + max_length]",164
74952601097,find_longest_increasing_subsequence,"def find_longest_increasing_subsequence(nums):
    n = len(nums)
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)


print(find_longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]))
print(find_longest_increasing_subsequence([0, 1, 0, 3, 2, 3]))
print(find_longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]))",163
15024933203,max_subarray,"from collections import deque

def max_subarray(arr, k):
    n = len(arr)
    if n < k:
        raise ValueError(""Array length should be greater than or equal to k"")
    
    max_in_subarray = []
    q = deque()
    
    for i in range(k):
        while q and arr[i] >= arr[q[-1]]:
            q.pop()
        q.append(i)
        
    for i in range(k, n):
        max_in_subarray.append(arr[q[0]])
        
        while q and q[0] <= i-k:
            q.popleft()
            
        while q and arr[i] >= arr[q[-1]]:
            q.pop()
        q.append(i)
    
    max_in_subarray.append(arr[q[0]])
    return max_in_subarray",163
17333873928,ways_to_express,"def ways_to_express(n):
    if n == 0 or n == 1:
        return 1
    elif n == 2:
        return 1
    elif n == 3:
        return 2
    else:
        a, b, c, d = 1, 1, 2, 3
        for i in range(4, n+1):
            d, c, b, a = a + b + c, d, c, b
        return d

print(ways_to_express(1))
print(ways_to_express(2))
print(ways_to_express(3))
print(ways_to_express(4))
print(ways_to_express(5))
print(ways_to_express(6))",163
33345482920,longest_palindromic_substring,"def longest_palindromic_substring(s):
    if len(s) < 2:
        return s

    start = 0
    max_length = 1

    for i in range(len(s)):
        if i - max_length >= 1 and s[i - max_length - 1:i + 1] == s[i - max_length - 1:i + 1][::-1]:
            start = i - max_length - 1
            max_length += 2
            continue

        if i - max_length >= 0 and s[i - max_length:i + 1] == s[i - max_length:i + 1][::-1]:
            start = i - max_length
            max_length += 1

    return s[start:start + max_length]",163
71417407071,next_greater_permutation,"def next_greater_permutation(arr):
    if arr == sorted(arr, reverse=True):
        arr.sort()
        return arr
    else:
        i, j = 0, 0
        for i in range(len(arr)-1, 0, -1):
            if arr[i-1] < arr[i]:
                i -= 1
                break
        for j in range(len(arr)-1, i, -1):
            if arr[j] > arr[i]:
                break
        arr[i], arr[j] = arr[j], arr[i]
        temp = arr[i+1:]
        temp.reverse()

        j = 0
        for k in range(i+1, len(arr)):
            arr[k] = temp[j]
            j += 1
    return arr",163
29744601050,longest_palindrome_subseq,"def longest_palindrome_subseq(s):
    length = len(s)
    dp = [[0]*length for _ in range(length)]

    for i in range(length):
        dp[i][i] = 1

    for l in range(2, length+1):
        for i in range(length-l+1):
            j = i + l - 1
            if s[i] == s[j] and l == 2:
                dp[i][j] = 2
            elif s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][-1]",163
23840898717,count_paths,"def count_paths(grid):
    m, n = len(grid), len(grid[0])
    if grid[0][0] == 1 or grid[m-1][n-1] == 1:
        return 0
    dp = [[0]*n for _ in range(m)]
    dp[0][0] = 1
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                dp[i][j] = 0
            else:
                if i > 0:
                    dp[i][j] += dp[i-1][j]
                if j > 0:
                    dp[i][j] += dp[i][j-1]
    return dp[m-1][n-1]",163
29343952752,count_islands,"def count_islands(grid):
    if not grid:
        return 0
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                dfs(grid, i, j)
                count += 1
    return count

def dfs(grid, i, j):
    if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != 1:
        return
    grid[i][j] = -1
    dfs(grid, i+1, j)
    dfs(grid, i-1, j)
    dfs(grid, i, j+1)
    dfs(grid, i, j-1)",163
23266299003,largest_rectangle,"def largest_rectangle(matrix):
    if not matrix:
        return 0

    m, n = len(matrix), len(matrix[0])
    heights = [0] * (n + 1)
    max_area = 0

    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                heights[j] += 1
            else:
                heights[j] = 0
        
        stack = [-1]
        for j in range(n + 1):
            while heights[j] < heights[stack[-1]]:
                h = heights[stack.pop()]
                w = j - stack[-1] - 1
                max_area = max(max_area, h * w)
            stack.append(j)
    
    return max_area",163
36577031219,longest_palindrome,"def longest_palindrome(s):
    if len(s) == 0:
        return """"
    max_length = 1
    start = 0
    for i in range(len(s)):
        if i - max_length >= 1 and s[i - max_length - 1: i + 1] == s[i - max_length - 1: i + 1][::-1]:
            start = i - max_length - 1
            max_length += 2
            continue
        if i - max_length >= 0 and s[i - max_length: i + 1] == s[i - max_length: i + 1][::-1]:
            start = i - max_length
            max_length += 1
    return s[start: start + max_length]",163
10242220617,max_circular_subarray_sum,"def max_subarray_sum(arr):
    max_sum = float('-inf')
    current_sum = 0
    for num in arr:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum

def min_subarray_sum(arr):
    min_sum = float('inf')
    current_sum = 0
    for num in arr:
        current_sum = min(num, current_sum + num)
        min_sum = min(min_sum, current_sum)
    return min_sum

def max_circular_subarray_sum(arr):
    max_normal = max_subarray_sum(arr)
    max_wrap = sum(arr) - min_subarray_sum(arr)
    return max(max_normal, max_wrap) if max_wrap > 0 else max_normal",163
1693771306,smallestWindow,"def smallestWindow(s):
    dist_count_char = len(set(s))
    count = {}
    start = 0
    min_length = float('inf')
    distinct_counter = 0

    for j in range(len(s)):
        count[s[j]] = count.get(s[j], 0) + 1
        if count[s[j]] == 1:
            distinct_counter += 1

        if distinct_counter == dist_count_char:
            while count[s[start]] > 1:
                if count[s[start]] > 1:
                    count[s[start]] -= 1
                start += 1

            current_length = j - start + 1
            min_length = min(min_length, current_length)

    return min_length if min_length != float('inf') else 0",163
36171168852,longest_palindrome,"def longest_palindrome(s):
    if len(s) == 0:
        return """"
    max_length = 1
    start = 0
    for i in range(len(s)):
        if i - max_length >= 1 and s[i - max_length - 1 : i + 1] == s[i - max_length - 1 : i + 1][::-1]:
            start = i - max_length - 1
            max_length += 2
            continue
        if i - max_length >= 0 and s[i - max_length : i + 1] == s[i - max_length : i + 1][::-1]:
            start = i - max_length
            max_length += 1
    return s[start : start + max_length]",163
39659174710,find_min_operations,"def find_min_operations(source, target):
    m, n = len(source), len(target)
    dp = [[0] * (n+1) for _ in range(m+1)]

    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif source[i-1] == target[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])

    return dp[m][n]",162
14218645838,find_element_details,"def find_element_details(arr, x):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == x:
            first = mid
            while first > 0 and arr[first - 1] == x:
                first -= 1

            last = mid
            while last < len(arr) - 1 and arr[last + 1] == x:
                last += 1

            count = last - first + 1
            return count, first, last

        elif arr[mid] < x:
            left = mid + 1
        else:
            right = mid - 1

    return 0, -1, -1",162
71118695544,union_sorted_lists,"def union_sorted_lists(list1, list2):
    i, j = 0, 0
    union_list = []

    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            union_list.append(list1[i])
            i += 1
        elif list1[i] > list2[j]:
            union_list.append(list2[j])
            j += 1
        else:
            union_list.append(list1[i])
            i += 1
            j += 1

    while i < len(list1):
        union_list.append(list1[i])
        i += 1

    while j < len(list2):
        union_list.append(list2[j])
        j += 1

    return union_list",162
3233375107,largest_time_from_digits,"from itertools import permutations

def largest_time_from_digits(arr):
    max_time = -1
    for h1, h2, m1, m2 in permutations(arr):
        hour = h1 * 10 + h2
        minute = m1 * 10 + m2
        if hour < 24 and minute < 60:
            time = hour * 60 + minute
            if time > max_time:
                max_time, max_h1, max_h2, max_m1, max_m2 = time, h1, h2, m1, m2
    if max_time == -1:
        return """"
    else:
        return f""{max_h1}{max_h2}:{max_m1}{max_m2}""",162
31351315483,is_subsequence,"def is_subsequence(s: str, t: str) -> bool:
    len_s = len(s)
    len_t = len(t)
    dp = [[False] * (len_t + 1) for _ in range(len_s + 1)]
    for j in range(len_t + 1):
        dp[0][j] = True
    for i in range(1, len_s + 1):
        for j in range(1, len_t + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = dp[i][j - 1]
    return dp[len_s][len_t]",162
11907452276,diameter_of_binary_tree,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def diameter_of_binary_tree(root):
    (diameter, height) = diameter_of_binary_tree_recursive(root)
    return diameter

def diameter_of_binary_tree_recursive(root):
    if root == None:
        return (0, 0)

    (left_diameter, left_height) = diameter_of_binary_tree_recursive(root.left)
    (right_diameter, right_height) = diameter_of_binary_tree_recursive(root.right)
    diameter = max(left_diameter, right_diameter, left_height + right_height)
    height = max(left_height, right_height) + 1
    return (diameter, height)",162
12235608700,numDistinct,"def numDistinct(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(m + 1):
        dp[i][0] = 1
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]
    
    return dp[m][n]",162
19606125235,max_uncrossed_lines,"def max_uncrossed_lines(A, B):
    len_A = len(A)
    len_B = len(B)
    
    dp = [[0] * (len_B + 1) for _ in range(len_A + 1)]
    
    for i in range(1, len_A + 1):
        for j in range(1, len_B + 1):
            if A[i - 1] == B[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])
    
    return dp[-1][-1]",162
36678777833,search,"from typing import List

def search(nums: List[int], target: int) -> int:
    def find_target(first: int, last: int) -> int:
        if last < first:
            return -1
        mid = (first + last) // 2
        if nums[mid] == target:
            return mid
        if nums[first] <= nums[mid]:
            if nums[first] <= target and target < nums[mid]:
                return find_target(first, mid - 1)
            return find_target(mid + 1, last)
        if nums[mid] < target and target <= nums[last]:
            return find_target(mid + 1, last)
        return find_target(first, mid - 1)
    return find_target(0, len(nums) - 1)",162
13296991393,month_days,"def is_leap_year(year):
    if year % 4 != 0:
        return False
    elif year % 100 != 0:
        return True
    elif year % 400 != 0:
        return False
    else:
        return True

def month_days(year, month):
    if month in [1, 3, 5, 7, 8, 10, 12]:
        return 31
    elif month in [4, 6, 9, 11]:
        return 30
    elif month == 2:
        if is_leap_year(year):
            return 29
        else:
            return 28
    else:
        return ""Invalid month""",162
70725979950,maxSubarraysLessThanK,"def maxSubarraysLessThanK(nums, k):
    n = len(nums)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]

    def check(m):
        for i in range(m, n + 1):
            if prefix_sum[i] - prefix_sum[i - m] <= k:
                return True
        return False

    left, right = 1, n
    result = 0
    while left <= right:
        mid = (left + right) // 2
        if check(mid):
            result = mid
            left = mid + 1
        else:
            right = mid - 1
    return result",162
22951360521,can_form_word,"def can_form_word(s, wordDict):
    dp = [False] * (len(s) + 1)
    dp[0] = True
    
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break
                
    return dp[len(s)]

# Test cases
assert can_form_word(""applepenapple"", [""apple"", ""pen""]) == True
assert can_form_word(""catsandog"", [""cats"", ""dog"", ""sand"", ""and"", ""cat""]) == False
assert can_form_word(""pineapplepenapple"", [""apple"", ""pen"", ""applepen"", ""pine"", ""pineapple""]) == True",162
4128551146,num_ways_decode,"def num_ways_decode(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1

    for i in range(2, n + 1):
        # Check if successful single digit decode is possible.
        if s[i - 1:i] != '0':
            dp[i] = dp[i - 1]
        # Check if successful two digit decode is possible.
        if s[i - 2:i] >= '10' and s[i - 2:i] <= '26':
            dp[i] += dp[i - 2]
    return dp[n]",162
34504743830,generate_combinations,"def generate_combinations(digits):
    if len(digits) == 0:
        return []
    d = {1:"""", 2:""abc"", 3:""def"", 4:""ghi"",5:""jkl"", 6:""mno"", 7:""pqrs"", 8:""tuv"", 9:""wxyz"", 0:"" ""}
    def dfs(digits, index, path , res , d):
        if index == len(digits):
            res.append("""".join(path))
            return
        digit = int(digits[index])
        for c in d.get(digit, []):
            path.append(c)
            dfs(digits, index+1, path, res, d)
            path.pop()
    res=[]
    dfs(digits, 0, [], res, d)
    return res",162
59207366,longest_palindrome_substring,"def longest_palindrome_substring(s):
    if not s:
        return """"
    n = len(s)
    start = 0
    max_len = 1
    for i in range(n):
        if i - max_len >= 1 and s[i - max_len - 1:i + 1] == s[i - max_len - 1:i + 1][::-1]:
            start = i - max_len - 1
            max_len += 2
            continue
        if i - max_len >= 0 and s[i - max_len:i + 1] == s[i - max_len:i + 1][::-1]:
            start = i - max_len
            max_len += 1
    return s[start:start + max_len]",161
2723351738,length_Of_Longest_Substring,"def length_Of_Longest_Substring(s: str) -> int:
    seen = {}
    l = 0
    output = 0
    
    for r in range(len(s)):

        #s[r]がseenの中に入っていないならば、output更新
        if s[r] not in seen:
            output = max(output, r-l+1)

        #s[r]がseenの中に入っている。
        else:
            #それが、lよりも左側になるならば、output更新
            if seen[s[r]] < l:
                output = max(output, r-l+1)
            #lと同じか右側ならば、lを更新する。
            else:
                l = seen[s[r]] + 1
        seen[s[r]] = r 
    
    return output",161
27481934584,check_ip_address,"import re
def check_ip_address(ip):
    regex_ipv4 = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    regex_ipv6 = r'^([0-9a-fA-F]{1,4}:){7}([0-9a-fA-F]{1,4})$'
    if re.match(regex_ipv4, ip):
        return ""IPv4""
    elif re.match(regex_ipv6, ip):
        return ""IPv6""
    else:
        return ""Neither""",161
3458649691,pascals_triangle_row,"def pascals_triangle_row(n):
    row = [1] * (n + 1)
    for i in range(1, n + 1):
        row[i] = row[i - 1] * (n - i + 1) // i
    return row

print(pascals_triangle_row(0))  # [1]
print(pascals_triangle_row(1))  # [1, 1]
print(pascals_triangle_row(2))  # [1, 2, 1]
print(pascals_triangle_row(3))  # [1, 3, 3, 1]
print(pascals_triangle_row(4))  # [1, 4, 6, 4, 1]",161
72288104666,count_connected_components,"from typing import List

def count_connected_components(n: int, edges: List[List[int]]) -> int:
    ids = [0] * n
    for i in range(n):
        ids[i] = i
    for edge in edges:
        union(edge[0], edge[1], ids)
    comp_set = set()
    for i in range(n):
        comp_set.add(find(i, ids))
    return len(comp_set)

def union(edge1, edge2, ids):
    parent1 = find(edge1, ids)
    parent2 = find(edge2, ids)
    ids[parent1] = parent2

def find(edge, ids):
    if ids[edge] != edge: 
        ids[edge] = find(ids[edge], ids)
    return ids[edge]",161
32320964079,next_number_with_same_bit_count,"def next_number_with_same_bit_count(n):
    c = n
    c0 = 0
    c1 = 0
    while ((c & 1) == 0) and (c != 0):
        c0 += 1
        c >>= 1
    while (c & 1) == 1:
        c1 += 1
        c >>= 1
    if c0 + c1 == 31 or c0 + c1 == 0:
        return -1
    p = c0 + c1
    n |= (1 << p)
    n &= ~((1 << p) - 1)
    n |= (1 << (c1 - 1)) - 1
    return n",161
10931912361,unique_paths,"def unique_paths(obstacleGrid):
    m = len(obstacleGrid[0])
    n = len(obstacleGrid)
    arr = [[1]*m for i in range(n)]
    for i in range(0, n):
        for j in range(0, m):
            if obstacleGrid[i][j] == 1:
                arr[i][j] = 0
            else:
                if i == 0:
                    arr[i][j] = arr[i][j-1]
                elif j == 0:
                    arr[i][j] = arr[i-1][j]
                else:
                    arr[i][j] = arr[i-1][j] + arr[i][j-1]
    return arr[n-1][m-1]",161
20736593415,distinct_subsequences,"def distinct_subsequences(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][0] = 1
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[m][n]",161
71501025325,isAnagram,"def isAnagram(s: str, t: str) -> bool:
    s_map = {}
    t_map = {}
    for s_char in s:
        if s_char not in s_map.keys():
            s_map[s_char] = 1
        else:
            s_map[s_char] += 1

    for t_char in t:
        if t_char not in t_map.keys():
            t_map[t_char] = 1
        else:
            t_map[t_char] += 1

    if len(s_map.keys()) != len(t_map.keys()):
        return False

    for key, num in s_map.items():
        if key not in t_map.keys():
            return False
        if t_map[key] != num:
            return False

    return True",161
12283052658,num_distinct,"def num_distinct(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][0] = 1
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[m][n]",161
10167300233,find_LCS,"def find_LCS(s1, s2):
    m = len(s1)
    n = len(s2)
    L = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif s1[i - 1] == s2[j - 1]:
                L[i][j] = L[i - 1][j - 1] + 1
            else:
                L[i][j] = max(L[i - 1][j], L[i][j - 1])

    return L[m][n]",161
19230927347,shortest_substring,"from collections import Counter

def shortest_substring(s: str) -> str:
    unique_chars = len(set(s))
    start, end = 0, 0
    min_len = float('inf')
    min_substring = """"
    char_count = Counter()

    while end < len(s):
        char_count[s[end]] += 1

        while len(char_count) == unique_chars:
            if end - start + 1 < min_len:
                min_len = end - start + 1
                min_substring = s[start:end+1]

            char_count[s[start]] -= 1
            if char_count[s[start]] == 0:
                del char_count[s[start]]
            start += 1

        end += 1

    return min_substring",161
39180477698,max_circular_subarray_sum,"def max_subarray_sum(arr):
    max_ending_here = max_so_far = arr[0]
    for x in arr[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far

def max_circular_subarray_sum(arr):
    max_kadane = max_subarray_sum(arr)
    max_wrap = 0
    for i in range(len(arr)):
        max_wrap += arr[i]
        arr[i] = -arr[i]
    max_wrap = max_wrap + max_subarray_sum(arr)
    if max_wrap > max_kadane and max_wrap != 0:
        return max_wrap
    else:
        return max_kadane",161
13756198565,find_median,"import heapq
def find_median(nums):
    left = []
    right = []
    for num in nums:
        if not right or num < right[0]:
            heapq.heappush(left, -num)
        else:
            heapq.heappush(right, num)
        
        if len(left) - len(right) > 1:
            heapq.heappush(right, -heapq.heappop(left))
        elif len(right) - len(left) > 1:
            heapq.heappush(left, -heapq.heappop(right))

    if len(left) > len(right):
        return -left[0]
    elif len(right) > len(left):
        return right[0]
    else:
        return (-left[0] + right[0]) / 2",161
37808771264,num_islands,"def num_islands(grid):
    def dfs(grid, i, j):
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == ""0"":
            return
        grid[i][j] = ""0""
        dfs(grid, i-1, j)
        dfs(grid, i+1, j)
        dfs(grid, i, j-1)
        dfs(grid, i, j+1)

    num_islands = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == ""1"":
                dfs(grid, i, j)
                num_islands += 1
    return num_islands",161
69996918904,caesar_cipher,"def caesar_cipher(text, shift):
    result = """"
    for char in text:
        if char.isalpha():
            stay_in_alphabet = ord(char) + shift
            if char.isupper():
                if stay_in_alphabet > ord('Z'):
                    stay_in_alphabet -= 26
                elif stay_in_alphabet < ord('A'):
                    stay_in_alphabet += 26
            elif char.islower():
                if stay_in_alphabet > ord('z'):
                    stay_in_alphabet -= 26
                elif stay_in_alphabet < ord('a'):
                    stay_in_alphabet += 26
            final_letter = chr(stay_in_alphabet)
            result += final_letter
        else:
            result += char
    return result",160
21819570892,find_max_submatrix,"def find_max_submatrix(matrix):
    max_sum = float('-inf')
    rows = len(matrix)
    cols = len(matrix[0])
    
    for left in range(cols):
        temp = [0]*rows
        for right in range(left, cols):
            for i in range(rows):
                temp[i] += matrix[i][right]
            max_sum = max(max_sum, maxSubArraySum(temp))
    return max_sum


def maxSubArraySum(arr):
    max_so_far = max_ending_here = arr[0]
    for i in range(1, len(arr)):
        max_ending_here = max(arr[i], max_ending_here + arr[i])
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far",160
70572486930,int_to_roman,"def int_to_roman(nums):
    romans = [""M"", ""CM"", ""D"", ""CD"", ""C"", ""XC"", ""L"", ""XL"", ""X"", ""IX"", ""V"", ""IV"", ""I""]
    numbers = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    
    result = []
    
    for num in nums:
        temp = """"
        
        for n, r in zip(numbers, romans):
            temp += r * (num // n)
            num %= n
            
        result.append(temp)
        
    return result",160
2360468678,closest_pair,"import math

def distance(p1, p2):
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def closest_pair(points):
    points.sort()
    best_pair = (points[0], points[1])
    min_dist = distance(points[0], points[1])
    for i in range(len(points) - 1):
        for j in range(i+1, len(points)):
            if points[j][0] - points[i][0] >= min_dist:
                break
            dist = distance(points[i], points[j])
            if dist < min_dist:
                min_dist = dist
                best_pair = (points[i], points[j])
    return best_pair",160
8926377206,find_longest_palindromic_substring,"def find_longest_palindromic_substring(s: str) -> str:
    if len(s) < 2:
        return s

    start, max_len = 0, 1

    def expand_around_center(left, right):
        nonlocal start, max_len
        while left >= 0 and right < len(s) and s[left] == s[right]:
            if (right - left + 1) > max_len:
                start = left
                max_len = right - left + 1
            left -= 1
            right += 1

    for i in range(len(s)):
        expand_around_center(i, i)
        expand_around_center(i, i + 1)

    return s[start:start + max_len]",160
34385647219,smallest_window,"from collections import Counter

def smallest_window(s):
    distinct_count = len(set(s))
    min_len = float('inf')
    min_str = """"
    counter = Counter()
    start = 0
    distinct_counter = 0
    for end in range(len(s)):
        if counter[s[end]] == 0:
            distinct_counter += 1
        counter[s[end]] += 1
        while distinct_counter == distinct_count:
            if end - start + 1 < min_len:
                min_len = end - start + 1
                min_str = s[start:end+1]
            counter[s[start]] -= 1
            if counter[s[start]] == 0:
                distinct_counter -= 1
            start += 1
    return min_str",160
71373076847,min_palindrome_ops,"def min_palindrome_ops(s: str) -> int:
    if s == s[::-1]:
        return 0
    dp = [[0 for _ in range(len(s))] for _ in range(len(s))]
    for i in range(len(s) - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return len(s) - dp[0][len(s) - 1]",160
35159184228,numDistinct,"def numDistinct(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][0] = 1
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[m][n]",160
30574552201,find_largest_product,"def find_largest_product(arr):
    arr.sort()
    return max(arr[0] * arr[1] * arr[-1], arr[-1] * arr[-2] * arr[-3])

if __name__ == ""__main__"":
    test_cases = [
        ([1, 2, 3], 6),
        ([10, 3, 5, 6, 20], 1200),
        ([-10, -3, -5, -6, -20], -90),
        ([1, -4, 3, -6, 7, 0], 168)
    ]

    for arr, expected in test_cases:
        assert find_largest_product(arr) == expected",160
70084641239,largest_square,"def largest_square(matrix):
    if not matrix:
        return 0

    rows = len(matrix)
    cols = len(matrix[0])
    dp = [[0] * (cols + 1) for _ in range(rows + 1)]
    max_side = 0

    for i in range(1, rows + 1):
        for j in range(1, cols + 1):
            if matrix[i - 1][j - 1] == 1:
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                max_side = max(max_side, dp[i][j])

    return max_side ** 2",160
20352419017,numDistinct,"def numDistinct(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][0] = 1
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[m][n]",160
5875957775,count_pairs,"def count_pairs(arr, k):
    arr.sort()
    i, j = 0, 1
    count = 0
    while j < len(arr) and i < j:
        diff = arr[j] - arr[i]
        if diff < k:
            j += 1
        elif diff > k:
            i += 1
            if i == j:
                j += 1
        else:
            count += 1
            i += 1
            j += 1
            while i < len(arr) and arr[i] == arr[i-1]:
                i += 1
            while j < len(arr) and j > i and arr[j] == arr[j-1]:
                j += 1
    return count",160
22072087286,max_circular_subarray_sum,"def max_circular_subarray_sum(nums):
    def kadane_algorithm(arr):
        max_ending_here = max_so_far = arr[0]
        for x in arr[1:]:
            max_ending_here = max(x, max_ending_here + x)
            max_so_far = max(max_so_far, max_ending_here)
        return max_so_far

    max_kadane = kadane_algorithm(nums)
    max_wrap = 0
    for i in range(len(nums)):
        max_wrap += nums[i]
        nums[i] = -nums[i]
    max_wrap = max_wrap + kadane_algorithm(nums)
    
    if max_wrap > max_kadane and max_wrap != 0:
        return max_wrap
    else:
        return max_kadane",160
9590696565,find_LCS,"def find_LCS(str1,str2):
    m = len(str1)
    n = len(str2)
    L = [[0] * (n+1) for _ in range(m+1)]

    # Build the matrix in bottom-up manner
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif str1[i-1] == str2[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])
    return L[m][n]",160
71293524866,isAlienSorted,"from typing import List

def isAlienSorted(words: List[str], order: str) -> bool:
    pos = [0] * 26
    for i, ch in enumerate(order):
        pos[ord(ch) - ord('a')] = i
    for i in range(1, len(words)):
        pre = words[i - 1]
        curr = words[i]
            
        for j in range(max(len(pre), len(curr))):
            if j >= len(pre): break
            if j >= len(curr): return False
            if pre[j] != curr[j]:
                    if pos[ord(pre[j]) - ord('a')] > pos[ord(curr[j]) - ord('a')]:
                        return False
                    break
                    
            
    return True",160
20128711785,int_to_roman,"def int_to_roman(num):
    values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ]
    numerals = [ ""M"", ""CM"", ""D"", ""CD"", ""C"", ""XC"", ""L"", ""XL"", ""X"", ""IX"", ""V"", ""IV"", ""I"" ]
    roman = ''
    i = 0
    while  num > 0:
        for _ in range(num // values[i]):
            roman += numerals[i]
            num -= values[i]
        i += 1
    return roman",160
33182024161,sum_of_tree,"class Node:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

def sum_of_tree(root):
    if root is None:
        return 0
    return root.value + sum_of_tree(root.left) + sum_of_tree(root.right)

# Test cases
assert sum_of_tree(Node(1, Node(2), Node(3))) == 6
assert sum_of_tree(Node(1, Node(2, Node(4), Node(5)), Node(3))) == 15
assert sum_of_tree(Node(1, Node(2, Node(4, Node(7), Node(8)), Node(5)), Node(3))) == 30",160
42713317226,find_Steps,"def find_Steps(arr):
    if len(arr) == 1:
        return 0
    if arr[0] == 0:
        return -1
    max_reach = arr[0]
    steps = arr[0]
    jump = 1
    for i in range(1, len(arr)):
        if i == len(arr) - 1:
            return jump
        max_reach = max(max_reach, i + arr[i])
        steps -= 1
        if steps == 0:
            jump += 1
            if i >= max_reach:
                return -1
            if max_reach >= len(arr) - 1:
                return jump
            steps = max_reach - i
    return -1",160
44918975711,nth_fibonacci,"def nth_fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b

# Test cases
assert nth_fibonacci(0) == 0
assert nth_fibonacci(1) == 1
assert nth_fibonacci(2) == 1
assert nth_fibonacci(3) == 2
assert nth_fibonacci(4) == 3
assert nth_fibonacci(5) == 5
assert nth_fibonacci(6) == 8",160
2851325657,is_valid_url,"import re

def is_valid_url(url):
    pattern = r""^(http|https)://[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)+(/[a-zA-Z0-9-._~:/?#@[\\\]!$&'()*+,;=]*)?$""
    return bool(re.match(pattern, url))

if __name__ == '__main__':
    print(is_valid_url(""http://www.example.com""))
    print(is_valid_url(""https://sub-domain.example.com/path?query=string#fragment""))
    print(is_valid_url(""invalid://url""))
    print(is_valid_url(""http://127.0.0.1:8000""))
    print(is_valid_url(""ftp://example.com""))",160
39787971289,num_distinct_bst,"def num_distinct_bst(n):
    """"""
    Calculate the number of distinct binary search trees (BSTs) that can be created with n nodes.
    """"""
    
    # Base case for 0 and 1 nodes
    if n == 0 or n == 1:
        return 1
    
    # Initialize an array to store the sub-problem results
    dp = [0] * (n+1)
    dp[0], dp[1] = 1, 1
    
    for nodes in range(2, n+1):
        for i in range(nodes):
            dp[nodes] += dp[i] * dp[nodes - i - 1]
    
    return dp[n] % 1000000007",160
34565782587,three_closest,"from typing import List

def three_closest(nums: List[int], target: int) -> int:
    nums.sort()
    closest_diff = float('inf')
    closest_sum = None
    
    for i in range(len(nums) - 2):
        l, r = i + 1, len(nums) - 1
        
        while l < r:
            current_sum = nums[i] + nums[l] + nums[r]
            current_diff = abs(target - current_sum)
            
            if current_diff < closest_diff:
                closest_diff = current_diff
                closest_sum = current_sum
            
            if current_sum < target:
                l += 1
            elif current_sum > target:
                r -= 1
            else:
                return current_sum

    return closest_sum",160
23181750694,Smallest_Window,"def Smallest_Window(str): 
    n = len(str) 
    dist_count_char = len(set([x for x in str])) 
      
    count = {}
    start = 0
    min_len = float('inf')
    for i in range(n):
        count[str[i]] = count.get(str[i], 0) + 1
        if len(count) == dist_count_char:
            while count[str[start]] > 1:
                if count[str[start]] > 1:
                    count[str[start]] -= 1
                start += 1
            window_len = i - start + 1
            if window_len < min_len:
                min_len = window_len
                min_window = str[start : i + 1]
    return min_window",160
10711059168,find_ways,"def find_ways(num_dice, num_faces, target):
    if num_dice == 0 or target <= 0:
        return 0
    dp = [[0 for _ in range(target+1)] for _ in range(num_dice+1)]
    
    for i in range(1, min(num_faces, target)+1):
        dp[1][i] = 1
        
    for dice in range(2, num_dice+1):
        for sum_val in range(1, target+1):
            for face_val in range(1, num_faces+1):
                if sum_val - face_val >= 0:
                    dp[dice][sum_val] += dp[dice-1][sum_val-face_val]
                    
    return dp[num_dice][target]",160
15950865161,find_max_dominant,"def find_max_dominant(nums):
    if len(nums) <= 1:
        return 0
    max1, max2 = nums[0], nums[1]
    max1Idx = 0
    if max1 < max2:
        max1, max2 = max2, max1
        max1Idx = 1
    for i, n in enumerate(nums):
        if i < 2:
            continue
        if max1 < n:
            max2 = max1
            max1 = n
            max1Idx = i
        elif max2 < n:
            max2 = n
    if max2 == 0 or max2 * 2 <= max1:
        return max1Idx
    return -1",160
70744620009,is_balanced_parentheses,"def is_balanced_parentheses(s):
    stack = []
    opening = [""("", ""["", ""{""]
    closing = ["")"", ""]"", ""}""]
    length = len(s)
    if length % 2 == 1:
        return False
    for i in range(length):
        if s[i] in opening:
            stack.append(s[i])
        elif s[i] in closing:
            if not stack:
                return False
            elif s[i] == "")"" and stack[-1] == ""("":
                stack.pop()
            elif s[i] == ""]"" and stack[-1] == ""["":
                stack.pop()
            elif s[i] == ""}"" and stack[-1] == ""{"":
                stack.pop()
            else:
                return False
    return not stack",159
42864460719,numIslands,"def numIslands(grid):
    def dfs(i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':
            return 
        grid[i][j] = '#' 
        dfs(i+1, j)
        dfs(i-1, j) 
        dfs(i, j+1)
        dfs(i, j-1)
        
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                # increment counter when dfs finishes as it indicates a new island has been found
                count += 1
    return count",159
15212541089,max_subarray,"from collections import deque

def max_subarray(nums, k):
    if not nums or k <= 0 or k > len(nums):
        return None

    max_values = []
    window = deque()

    for i, num in enumerate(nums):
        # Remove elements that are out of the current window
        while window and window[0] < i - k + 1:
            window.popleft()

        # Remove elements that are smaller than the current element
        while window and nums[window[-1]] < num:
            window.pop()

        window.append(i)

        # Add the maximum value for the window starting from the kth element
        if i >= k - 1:
            max_values.append(nums[window[0]])

    return max(max_values)",159
73832662876,circular_shift,"def circular_shift(nums, k):
    shortest_k = k % len(nums)
    if shortest_k != 0:
        # when use the function itself, ""self"" is unnecessary
        reverse(nums, 0, len(nums) - 1)
        reverse(nums, 0, shortest_k - 1)
        reverse(nums, shortest_k, len(nums) - 1)
    return nums

def reverse(nums, start, end):
    while start < end:
        temp = nums[start]
        nums[start] = nums[end]
        nums[end] = temp
        start = start + 1
        end = end - 1


def circular_shift_with_return(nums, k):
    result = nums.copy()
    circular_shift(result, k)
    return result",159
30472475861,buddy_strings,"from collections import defaultdict
def buddy_strings(s, goal):
    if len(s) != len(goal):
        return False
    duplicate = False
    diff_cnt = 0
    s_letter = defaultdict(int)
    goal_letter = defaultdict(int)
    for i in range(len(s)):
        s_letter[s[i]] += 1
        goal_letter[goal[i]] += 1
        if s[i] != goal[i]:
            diff_cnt += 1
    for l in s_letter:
        if s_letter[l] != goal_letter[l]:
            return False
        if s_letter[l] > 1:
            duplicate = True
    if (diff_cnt == 0 and duplicate) or diff_cnt == 2:
        return True
    return False",158
41899240139,can_form_square,"def can_form_square(nums):
    if not nums: return False
        
    total = sum(nums)
    if total%4 != 0: return False
        
    nums.sort(reverse=True)
    sums = [0]*4
        
    return dfs(len(nums), sums, nums, total//4, 0)

def dfs(l, sums, nums, tgt, idx):
    if l == idx:
        return sums[1] == sums[2] == sums[3] == tgt
        
    for i in range(4):
        if sums[i] + nums[idx] <= tgt:
            sums[i]+=nums[idx]
            if dfs(l,sums, nums, tgt, idx+1):
                return True         
            sums[i]-=nums[idx]
                
    return False",158
70726663801,longest_palindrome,"def longest_palindrome(s):
    if len(s) == 0:
        return """"
    max_length = 1
    start = 0
    for i in range(len(s)):
        if i - max_length >= 1 and s[i - max_length - 1:i + 1] == s[i - max_length - 1:i + 1][::-1]:
            start = i - max_length - 1
            max_length += 2
            continue
        if i - max_length >= 0 and s[i - max_length:i + 1] == s[i - max_length:i + 1][::-1]:
            start = i - max_length
            max_length += 1
    return s[start:start + max_length]",158
72925853436,distribute_candies,"def distribute_candies(candies):
    candies_map = dict()
    n_candies = len(candies)
    for candi in candies:
        if candi not in candies_map:
            candies_map[candi] = 1
        else:
            candies_map[candi] += 1
    candies_list = sorted(candies_map, key=candies_map.get)
    n_candies_kinds = len(candies_list)
    i = 0
    res = 0
    while i < n_candies / 2:
        if i < n_candies_kinds:
            res += 1
        else:
            return n_candies_kinds
        i += 1
    return res",158
10108321489,has_cycle,"def has_cycle(edges):
    graph = {}
    for edge in edges:
        if edge[0] not in graph:
            graph[edge[0]] = []
        if edge[1] not in graph:
            graph[edge[1]] = []
        graph[edge[0]].append(edge[1])
        graph[edge[1]].append(edge[0])
    
    visited = set()
    def dfs(node, parent):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                if dfs(neighbor, node):
                    return True
            elif neighbor != parent:
                return True
        return False
    
    for node in graph:
        if node not in visited:
            if dfs(node, None):
                return True
    return False",158
14180719835,is_match,"def is_match(s: str, p: str) -> bool:
    memo = {}

    def dp(i, j):
        if (i, j) in memo:
            return memo[(i, j)]
        if j == len(p):
            return i == len(s)

        first_match = i < len(s) and p[j] in {s[i], "".""}
        if len(p) - j >= 2 and p[j+1] == ""*"":
            ans = dp(i, j+2) or first_match and dp(i+1, j)
        else:
            ans = first_match and dp(i+1, j+1)
        memo[(i, j)] = ans
        return ans

    return dp(0, 0)",158
34546929240,Add_Binary_Nums,"def Add_Binary_Nums(x,y):
    maxlen = max(len(x),len(y))

    x = x.zfill(maxlen)
    y = y.zfill(maxlen)
    result = ''
    carry = 0

    for i in range(maxlen-1,-1,-1):
        a = carry
        a += 1 if x[i] == '1' else 0
        a += 1 if y[i] == '1' else 0
        result = ('1' if a % 2 == 1 else '0' ) + result
        carry = 0 if a<2 else 1

    if carry !=0:
        result = '1' +result
    return result.zfill(maxlen)",158
6693023811,max_square,"def max_square(matrix):
    if not matrix:
        return 0

    m, n = len(matrix), len(matrix[0])
    dp = [[0] * n for _ in range(m)]
    max_side = 0

    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                max_side = max(max_side, dp[i][j])

    return max_side * max_side",158
12213463653,maxRectangleArea,"def maxRectangleArea(matrix):
    if not matrix or not matrix[0]:
        return 0

    m, n = len(matrix), len(matrix[0])
    heights = [0] * (n + 1)
    maxArea = 0

    for row in matrix:
        for i in range(n):
            heights[i] = heights[i] + 1 if row[i] == 1 else 0

        stack = [-1]
        for i in range(n + 1):
            while heights[i] < heights[stack[-1]]:
                h = heights[stack.pop()]
                w = i - 1 - stack[-1]
                maxArea = max(maxArea, h * w)
            stack.append(i)

    return maxArea",158
7294146800,distinct_substring,"def distinct_substring(str):
    distinct_chars = len(set(str))
    start, start_index, min_len = 0, -1, float('inf')
    count = {}
    for end in range(len(str)):
        count[str[end]] = count.get(str[end], 0) + 1
        if len(count) == distinct_chars:
            while count[str[start]] > 1:
                if count[str[start]] > 1:
                    count[str[start]] -= 1
                start += 1
            len_window = end - start + 1
            if min_len > len_window:
                min_len = len_window
                start_index = start
    return """" if start_index == -1 else str[start_index:start_index + min_len]",158
72050615606,lcs,"def lcs( X , Y ): 
    m = len(X) 
    n = len(Y) 
  
    L = [[None]*(n + 1) for i in range(m + 1)] 
  
    for i in range(m + 1): 
        for j in range(n + 1): 
            if i == 0 or j == 0 : 
                L[i][j] = 0
            elif X[i-1] == Y[j-1]: 
                L[i][j] = L[i-1][j-1] + 1
            else: 
                L[i][j] = max(L[i-1][j] , L[i][j-1]) 
  
    return L[m][n]",158
4983263671,min_swaps,"def min_swaps(A, B):
    n1 = 0
    s1 = 1
    for i in range(1, len(A)):
        n2 = s2 = float(""inf"")
        if A[i] > A[i-1] and B[i] > B[i-1]:
            n2 = min(n2, n1)
            s2 = min(s2, s1 + 1)
        if A[i] > B[i-1] and B[i] > A[i-1]:
            n2 = min(s1, n2)
            s2 = min(n1+1, s2)
        n1 = n2
        s1 = s2
    return min(n1, s1)",158
71036658903,largest_square,"def largest_square(matrix):
    if not matrix:
        return 0
    rows, cols = len(matrix), len(matrix[0])
    dp = [[0] * cols for _ in range(rows)]
    max_side = 0
    for i in range(rows):
        for j in range(cols):
            if matrix[i][j] == 1:
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                max_side = max(max_side, dp[i][j])
    return max_side ** 2",158
5820816354,find_longest_substring,"def find_longest_substring(s, k):
    if not s or k <= 0:
        return """"

    char_map = {}
    left = 0
    max_len = 0
    max_substring = """"

    for right in range(len(s)):
        char_map[s[right]] = char_map.get(s[right], 0) + 1

        while len(char_map) > k:
            char_map[s[left]] -= 1
            if char_map[s[left]] == 0:
                del char_map[s[left]]
            left += 1

        if right - left + 1 > max_len:
            max_len = right - left + 1
            max_substring = s[left:right+1]

    return max_substring",157
14593438187,largestRectangle,"def largestRectangle(matrix):
    if not matrix:
        return 0

    max_area = 0
    dp = [0] * len(matrix[0])
    for row in matrix:
        for i in range(len(row)):
            dp[i] = dp[i] + 1 if row[i] == 1 else 0

        stack = [-1]
        for i in range(len(dp) + 1):
            while stack[-1] != -1 and (i == len(dp) or dp[stack[-1]] >= dp[i]):
                height = dp[stack.pop()]
                width = i - stack[-1] - 1
                max_area = max(max_area, height * width)
            stack.append(i)

    return max_area",157
4416562042,largest_rectangle,"def largest_rectangle(matrix):
    if not matrix:
        return 0

    n = len(matrix)
    m = len(matrix[0])
    height = [0] * (m + 1)
    max_area = 0

    for i in range(n):
        for j in range(m):
            height[j] = height[j] + 1 if matrix[i][j] == 1 else 0

        stack = [-1]
        for j in range(m + 1):
            while height[j] < height[stack[-1]]:
                h = height[stack.pop()]
                w = j - stack[-1] - 1
                max_area = max(max_area, h * w)
            stack.append(j)

    return max_area",157
23558112812,find_order,"from collections import defaultdict

def find_order(numCourses, prerequisites):
    graph = defaultdict(list)
    indegrees = [0]*numCourses
    for course, pre in prerequisites:
        graph[pre].append(course)
        indegrees[course] += 1
    queue = [i for i in range(numCourses) if indegrees[i] == 0]
    order = []
    while queue:
        course = queue.pop(0)
        order.append(course)
        for next_course in graph[course]:
            indegrees[next_course] -= 1
            if indegrees[next_course] == 0:
                queue.append(next_course)
    if len(order) == numCourses:
        return order
    else:
        return []",157
73155097304,num_to_roman,"def num_to_roman(num):
    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    symbols = [""M"", ""CM"", ""D"", ""CD"", ""C"", ""XC"", ""L"", ""XL"", ""X"", ""IX"", ""V"", ""IV"", ""I""]
    roman_num = ''
    i = 0
    while num > 0:
        for _ in range(num // values[i]):
            roman_num += symbols[i]
            num -= values[i]
        i += 1
    return roman_num",157
8993606365,containsNearbyAlmostDuplicate,"def containsNearbyAlmostDuplicate(nums, k, t):
    if t < 0: return False
    n = len(nums)
    buckets = {}
    w = t + 1
    for i in range(n):
        bucket_num = nums[i] // w
        if bucket_num in buckets:
            return True
        if bucket_num - 1 in buckets and abs(nums[i] - buckets[bucket_num - 1]) < w:
            return True
        if bucket_num + 1 in buckets and abs(nums[i] - buckets[bucket_num + 1]) < w:
            return True
        buckets[bucket_num] = nums[i]
        if i >= k: del buckets[nums[i-k]//w]
    return False",157
19209393272,has_cycle,"def has_cycle(edges):
    graph = {}
    for edge in edges:
        if edge[0] not in graph:
            graph[edge[0]] = []
        graph[edge[0]].append(edge[1])
    
    visited = set()
    rec_stack = set()

    def is_cyclic_util(v):
        visited.add(v)
        rec_stack.add(v)

        if v in graph:
            for neighbor in graph[v]:
                if neighbor not in visited:
                    if is_cyclic_util(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True

        rec_stack.remove(v)
        return False

    for vertex in graph:
        if vertex not in visited:
            if is_cyclic_util(vertex):
                return True
    return False",157
1941182841,count_connected_components,"from collections import deque

def count_connected_components(n, edges):
    def bfs(node):
        queue = deque([node])
        visited.add(node)
        while queue:
            current = queue.popleft()
            for neighbor in adj_list[current]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)

    adj_list = {i: [] for i in range(1, n + 1)}
    for edge in edges:
        adj_list[edge[0]].append(edge[1])
        adj_list[edge[1]].append(edge[0])
    
    visited = set()
    components = 0
    for node in adj_list:
        if node not in visited:
            bfs(node)
            components += 1
    return components",157
8436091851,calculate_days,"from collections import Counter

def calculate_days(tasks, n):
    if not n:
        return len(tasks)
    clock = 0
    left = Counter(tasks)
    requeue = dict() # index -> (task, count)
    
    while left or requeue:
        if clock in requeue:
            t, c = requeue[clock]
            left[t] = c
            del requeue[clock]
        if not left:
            clock += 1
            continue
        task, freq = left.most_common(1)[0]
        if freq > 1:
            requeue[clock + n + 1] = (task, freq - 1)
        del left[task]
        clock += 1
        
    return clock",157
24148601302,num_unique_bsts,"def num_unique_bsts(n):
    """"""
    :type n: int
    :rtype: int
    """"""
    
    arr = [0 for i in range(n+1)]
    arr[0] = 1
    arr[1] = 1
    for i in range(2,n+1):
        max_val = 0

        for j in range(1,i+1):
            left_node = j-1
            right_node = i-j
            tree_num = arr[left_node] *arr[right_node]
            max_val +=tree_num
        arr[i] = max_val

    return arr[n]

print(num_unique_bsts(3))
print(num_unique_bsts(4))
print(num_unique_bsts(5))",157
69896486436,length_longest_path,"def length_longest_path(input: str) -> int:
    input = input.split('\n')
    if not input: return 0

    def isFile(s: str):
        return s.find('.') != -1

    def countDepth(s: str):
        return s.count('\t')

    maxLength = 0
    stack = []
    for item in input:
        if isFile(item):
            dirName = '/'.join(stack)
            if dirName != '': dirName += '/'
            maxLength = max(maxLength, len(dirName + item.replace('\t', '')))
            continue

        depth = countDepth(item)
        while len(stack) > depth:
            stack.pop()
        stack.append(item.replace('\t', ''))
    return maxLength",156
40162975920,longest_consecutive,"def longest_consecutive(nums):
    """"""
    Finds the length of the longest consecutive elements sequence in an unsorted list of integers.

    Args:
        nums (List[int]): The list of integers.

    Returns:
        int: The length of the longest consecutive elements sequence.
    """"""
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",156
36305249209,topological_sort,"from collections import defaultdict

def topological_sort(numCourses, prerequisites):
    graph = defaultdict(list)
    indegree = [0] * numCourses
    for course, prereq in prerequisites:
        graph[prereq].append(course)
        indegree[course] += 1

    queue = [i for i in range(numCourses) if indegree[i] == 0]
    result = []
    while queue:
        node = queue.pop(0)
        result.append(node)
        for neighbor in graph[node]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                queue.append(neighbor)
    
    if len(result) == numCourses:
        return result
    else:
        return []",156
31391869176,max_rectangle,"def max_rectangle(matrix):
    if not matrix:
        return 0
    m, n = len(matrix), len(matrix[0])
    height = [0] * (n + 1)
    max_area = 0
    for i in range(m):
        for j in range(n):
            height[j] = height[j] + 1 if matrix[i][j] == 1 else 0
        stack = [-1]
        for k in range(n + 1):
            while height[k] < height[stack[-1]]:
                h = height[stack.pop()]
                w = k - stack[-1] - 1
                max_area = max(max_area, h * w)
            stack.append(k)
    return max_area",156
19643789618,longest_cycle,"def longest_cycle(d):
    """"""
    Returns the length of the longest repeating cycle in the decimal representation of 1/d.
    """"""
    remainders = {}
    remainder = 1
    position = 0
    while remainder not in remainders and remainder != 0:
        remainders[remainder] = position
        remainder = (remainder * 10) % d
        position += 1
    if remainder == 0:
        return 0
    return position - remainders[remainder]

def solution(N=1000):
    return max(range(2, N), key=longest_cycle)


print(solution())  # Prints the value of d < 1000 for which 1/d contains the longest recurring cycle",156
28485784738,largest_rectangle,"def largest_rectangle(matrix):
    if not matrix:
        return 0

    m, n = len(matrix), len(matrix[0])
    heights = [0] * (n + 1)
    max_area = 0

    for i in range(m):
        for j in range(n):
            heights[j] = heights[j] + 1 if matrix[i][j] == 1 else 0

        stack = [-1]
        for k in range(n + 1):
            while heights[k] < heights[stack[-1]]:
                h = heights[stack.pop()]
                w = k - stack[-1] - 1
                max_area = max(max_area, h * w)
            stack.append(k)

    return max_area",156
30089463734,min_squares,"import math

def min_squares(n):
    # Generate a list of square numbers less than or equal to n.
    squares = [i * i for i in range(1, int(math.sqrt(n)) + 1)]
    # The dp array will store the minimum number of squares for each number up to n.
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    # Fill in the dp array using a bottom-up dynamic programming approach.
    for i in range(1, n + 1):
        for square in squares:
            if i < square:
                break
            dp[i] = min(dp[i], dp[i - square] + 1)
    return dp[n]",156
35627292493,count_islands,"def count_islands(matrix):
    if not matrix:
        return 0

    def dfs(i, j):
        if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or matrix[i][j] != 1:
            return
        matrix[i][j] = 0
        dfs(i-1, j)
        dfs(i+1, j)
        dfs(i, j-1)
        dfs(i, j+1)

    island_count = 0
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            if matrix[i][j] == 1:
                dfs(i, j)
                island_count += 1
                
    return island_count",156
73903696948,kth_smallest,"import heapq

def kth_smallest(nums, k):
    heapq.heapify(nums)
    for _ in range(k-1):
        heapq.heappop(nums)
    return heapq.heappop(nums)

print(kth_smallest([3, 2, 1, 5, 6, 4], 2))  # 2
print(kth_smallest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4))  # 3
print(kth_smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 8))  # 8",156
11392429659,find_second_max,"def find_second_max(numbers):
  if len(numbers) < 2:
    return None
  max1 = max2 = float('-inf')
  for num in numbers:
    if num > max1:
      max2 = max1
      max1 = num
    elif num > max2 and num != max1:
      max2 = num
  return max2

print(find_second_max([9, 2, 7, 4, 11, 6]))
print(find_second_max([15, 22, 3, 8, 11, 22]))
print(find_second_max([34, 12, 34, 45, 56, 78]))",156
32750707850,is_bipartite,"from collections import defaultdict, deque

def is_bipartite(edges):
    graph = defaultdict(list)
    for edge in edges:
        graph[edge[0]].append(edge[1])
        graph[edge[1]].append(edge[0])
    color = [0] * len(graph)
    for i in range(len(graph)):
        if color[i] != 0: continue
        q = deque()
        q.append(i)
        color[i] = 1
        while q:
            cur = q.popleft()
            for e in graph[cur]:
                if color[e] != 0:
                    if color[cur] == color[e]:
                        return False
                else:
                    color[e] = -color[cur]
                    q.append(e)
    return True",156
40697727209,subarrays_with_k_distinct,"from typing import List
from collections import Counter

def subarrays_with_k_distinct(A: List[int], K: int) -> int:
    def atmostk(A, K):
        c = Counter()
        res = i = 0
        for j in range(len(A)):
            if c[A[j]] == 0:
                K -= 1
            c[A[j]] += 1

            while K < 0:
                c[A[i]] -= 1
                if c[A[i]] == 0:
                    K += 1
                i += 1
            res += j - i + 1
        return res

    return atmostk(A, K) - atmostk(A, K - 1)",156
40709231034,num_islands,"def num_islands(grid):
    def dfs(x, y):
        if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != '1':
            return
        grid[x][y] = '#'
        dfs(x + 1, y)
        dfs(x - 1, y)
        dfs(x, y + 1)
        dfs(x, y - 1)

    if not grid:
        return 0

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1
    return count",156
33623938379,check_word_transform,"def check_word_transform(target_word, word_list):
    for word in word_list:
        if len(word) == len(target_word):
            differences = 0
            for i in range(len(target_word)):
                if word[i] != target_word[i]:
                    differences += 1
            if differences == 1:
                return True
        elif len(word) == len(target_word) - 1:
            for i in range(len(target_word)):
                if word == target_word[:i] + target_word[i+1:]:
                    return True
        elif len(word) == len(target_word) + 1:
            for i in range(len(word)):
                if target_word == word[:i] + word[i+1:]:
                    return True
    return False",156
13978408560,count_islands,"def count_islands(grid):
    def dfs(grid, i, j):
        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0:
            return
        grid[i][j] = 0
        dfs(grid, i+1, j)
        dfs(grid, i-1, j)
        dfs(grid, i, j+1)
        dfs(grid, i, j-1)
    
    islands = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                islands += 1
                dfs(grid, i, j)
    return islands",156
18139870568,distinct_subsequences,"def distinct_subsequences(s, t):
    dp = [[0 for _ in range(len(t) + 1)] for _ in range(len(s) + 1)]
    for i in range(len(s) + 1):
        dp[i][0] = 1
    for i in range(1, len(s) + 1):
        for j in range(1, len(t) + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[len(s)][len(t)]",156
69947776749,largest_rectangle,"def largest_rectangle(matrix):
    if not matrix:
        return 0

    n = len(matrix)
    m = len(matrix[0])
    max_area = 0
    height = [0] * (m + 1)
    for i in range(n):
        for j in range(m):
            height[j] = height[j] + 1 if matrix[i][j] == 1 else 0
        stack = [-1]
        for j in range(m + 1):
            while height[j] < height[stack[-1]]:
                h = height[stack.pop()]
                w = j - 1 - stack[-1]
                max_area = max(max_area, h * w)
            stack.append(j)
    return max_area",156
24294774216,max_circular_subarray_sum,"def max_circular_subarray_sum(A):
    def kadane(arr):
        cur = ans = float(""-inf"")
        for val in arr:
            cur = val + max(cur, 0)
            ans = max(ans, cur)
        return ans
    
    def min_kadane(arr):
        cur = ans = float(""inf"")
        for val in arr:
            cur = val + min(cur, 0)
            ans = min(ans, cur)
        return ans
    
    arr_sum = sum(A)
    ans1 = kadane(A)
    ans2 = arr_sum - min_kadane(A[1:])
    ans3 = arr_sum - min_kadane(A[:-1])
    return max(ans1, ans2, ans3)",156
17453452660,fibonacci_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def fibonacci_prime(n):
    count = 0
    a, b = 0, 1
    while True:
        a, b = b, a + b
        if is_prime(b):
            count += 1
            if count == n:
                return b",156
4129280136,search_target,"from typing import List

def search_target(nums: List[int], target: int) -> List[int]:
    left = 0
    right = len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            left = right = mid
            while left >= 0 and nums[left] == target:
                left -= 1
            while right < len(nums) and nums[right] == target:
                right += 1
            return [left + 1, right - 1]
        if target < nums[mid]:
            right = mid - 1
        else:
            left = mid + 1
    return [-1, -1]",156
40251405975,distinct_subsequences,"def distinct_subsequences(s, t):
    dp = [[0] * (len(s) + 1) for _ in range(len(t) + 1)]
    for j in range(len(s) + 1):
        dp[0][j] = 1
    for i in range(1, len(t) + 1):
        for j in range(1, len(s) + 1):
            if t[i - 1] == s[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]
            else:
                dp[i][j] = dp[i][j - 1]
    return dp[-1][-1]",155
13707349499,min_window,"import collections

def min_window(s: str, t: str) -> str:
    need = collections.Counter(t)
    missing = len(t)
    left = start = end = 0
    
    for right, char in enumerate(s, 1):
        missing -= need[char] > 0
        need[char] -= 1
            
        if missing == 0:
            while left < right and need[s[left]] < 0:
                need[s[left]] += 1
                left += 1
            if not end or right - left <= end - start:
                start, end = left, right
            need[s[left]] += 1
            missing += 1
            left += 1
    return s[start:end]",155
10931342081,find_largest_unique,"def find_largest_unique(nums):
    unique_numbers = set()
    duplicates = set()
    for num in nums:
        if num in unique_numbers:
            duplicates.add(num)
            unique_numbers.remove(num)
        else:
            unique_numbers.add(num)
    if len(unique_numbers) == 0:
        return -1
    else:
        return max(unique_numbers)

assert find_largest_unique([3, 4, 4, 3, 6, 6, 7]) == 7
assert find_largest_unique([2, 2, 3, 3, 4, 4]) == -1
assert find_largest_unique([1, 2, 3, 4, 5]) == 5",155
10877026221,find_largest_square,"def find_largest_square(matrix):
    if not matrix:
        return 0
    m, n = len(matrix), len(matrix[0])
    dp = [[0]*n for _ in range(m)]
    max_side = 0
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                max_side = max(max_side, dp[i][j])
    return max_side * max_side",155
12306441715,largest_rectangle,"def largest_rectangle(matrix):
    if not matrix:
        return 0
    m, n = len(matrix), len(matrix[0])
    heights = [0] * (n + 1)
    max_area = 0
    for i in range(m):
        for j in range(n):
            heights[j] = heights[j] + 1 if matrix[i][j] == 1 else 0
        stack = [-1]
        for j in range(n + 1):
            while heights[j] < heights[stack[-1]]:
                h = heights[stack.pop()]
                w = j - 1 - stack[-1]
                max_area = max(max_area, h * w)
            stack.append(j)
    return max_area",155
30843427086,minSubArrayLen,"from typing import List

def minSubArrayLen(target: int, nums: List[int]) -> int:
    left = 0
    current_sum = 0
    min_length = float('inf')  # Initialize as infinity

    for right in range(len(nums)):
        current_sum += nums[right]  # Add current number to the running sum

        # Shrink the window from the left if the current sum >= target
        while current_sum >= target:
            min_length = min(min_length, right - left + 1)
            current_sum -= nums[left]
            left += 1

    # If min_length is still infinity, no such subarray exists
    return 0 if min_length == float('inf') else min_length",155
12287324851,is_tree,"from typing import List

def is_tree(edges: List[List[int]]) -> bool:
    if not edges: return False
    n = max(max(edges)) + 1
    indegree = [0] * n
    for edge in edges:
        indegree[edge[1]] += 1
    if max(indegree) > 1: return False
    visited = [False] * n
    def dfs(node):
        if visited[node]: return True
        visited[node] = True
        for edge in edges:
            if edge[0] == node:
                if dfs(edge[1]): return True
        return False
    if dfs(edges[0][0]):
        return False
    return sum(visited) == n",155
29606462686,count_islands,"from typing import List

def count_islands(grid: List[List[int]]) -> int:
    def dfs(r, c):
        if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] == 0:
            return
        grid[r][c] = 0
        dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)

    count = 0
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == 1:
                dfs(r, c)
                count += 1
    return count",155
34587679255,largest_square,"def largest_square(matrix):
    if not matrix:
        return 0

    rows, cols = len(matrix), len(matrix[0])
    dp = [[0] * cols for _ in range(rows)]
    max_size = 0

    for i in range(rows):
        for j in range(cols):
            if matrix[i][j] == 1:
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                max_size = max(max_size, dp[i][j])
    
    return max_size ** 2",155
1831233890,dec_to_bin_stack,"class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def peek(self):
        return self.items[len(self.items)-1]

    def size(self):
        return len(self.items)

def dec_to_bin_stack(dec_number):
    rem_stack = Stack()
    while dec_number > 0:
        rem = dec_number % 2
        rem_stack.push(rem)
        dec_number = dec_number // 2

    bin_string = """"
    while not rem_stack.is_empty():
        bin_string = bin_string + str(rem_stack.pop())

    return bin_string",155
37541868076,largestRectangleArea,"def largestRectangleArea(heights):
    stack = []
    max_area = 0
    index = 0
    while index < len(heights):
        if (not stack) or (heights[stack[-1]] <= heights[index]):
            stack.append(index)
            index += 1
        else:
            top = stack.pop()
            area = (heights[top] * ((index - stack[-1] - 1) if stack else index))
            max_area = max(max_area, area)
    while stack:
        top = stack.pop()
        area = (heights[top] * ((index - stack[-1] - 1) if stack else index))
        max_area = max(max_area, area)
    return max_area",155
3346017587,unique_common_elements,"def unique_common_elements(list1, list2):
    """"""
    Returns unique common elements present in both lists.
    """"""
    # Create a dictionary to count occurrences of each element in the first list
    count_dict = {}
    for item in list1:
        count_dict[item] = count_dict.get(item, 0) + 1
    
    # Create a set of unique elements in the second list
    unique_set = set(list2)
    
    # Find common elements that appear only once in both lists
    result = []
    for item in list1:
        if item in unique_set and count_dict[item] == 1 and list2.count(item) == 1:
            result.append(item)
            unique_set.remove(item)
    
    return result",155
41342463546,valid_tree,"from collections import defaultdict

def valid_tree(n, edges):
    graph = defaultdict(list)
    for edge in edges:
        u, v = edge[0], edge[1]
        graph[u].append(v)
        graph[v].append(u)
    visited = set([])
    
    if not dfs(0, -1, graph, visited):
        return False
    if len(visited) != n:
        return False
    return True

def dfs(node, parent, graph, visited):
    visited.add(node)
    for nbr in graph[node]:
        if nbr not in visited:
            if not dfs(nbr, node, graph, visited):
                return False
        elif nbr in visited and nbr != parent:
            return False
    return True",155
70592595835,decimal_to_roman,"def decimal_to_roman(decimal):
    roman_numerals = {
        1000: 'M',
        900: 'CM',
        500: 'D',
        400: 'CD',
        100: 'C',
        90: 'XC',
        50: 'L',
        40: 'XL',
        10: 'X',
        9: 'IX',
        5: 'V',
        4: 'IV',
        1: 'I'
    }
    result = ''
    for value, numeral in roman_numerals.items():
        while decimal >= value:
            result += numeral
            decimal -= value
    return result",155
43825345333,count_pattern_subsequence,"def count_pattern_subsequence(text, pattern):
    m, n = len(text), len(pattern)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][0] = 1
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text[i - 1] == pattern[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[m][n]",155
2479758973,max_points,"from collections import defaultdict

def max_points(points):
    d = defaultdict(int)
    max_points = 0
    for i in range(len(points)):
        d.clear()
        slope_max = 0
        for j in range(i + 1, len(points)):
            dx = points[j][0] - points[i][0]
            dy = points[j][1] - points[i][1]
            if dx == 0:
                slope = 1000000001
            else:
                slope = dy / dx
            d[slope] += 1
            slope_max = max(slope_max, d[slope])
        max_points = max(max_points, slope_max)
    return max_points + 1",155
12234223350,island_counter,"def island_counter(grid):
    if not grid:
        return 0

    rows, cols = len(grid), len(grid[0])
    count = 0

    def dfs(i, j):
        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == 0:
            return
        grid[i][j] = 0
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)

    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 1:
                dfs(i, j)
                count += 1

    return count",155
21075456746,lcs,"def lcs(X, Y): 
    m = len(X) 
    n = len(Y) 
  
    L = [[0 for x in range(n+1)] for x in range(m+1)] 
  
    for i in range(m+1): 
        for j in range(n+1): 
            if i == 0 or j == 0: 
                L[i][j] = 0
            elif X[i-1] == Y[j-1]: 
                L[i][j] = L[i-1][j-1] + 1
            else: 
                L[i][j] = max(L[i-1][j], L[i][j-1]) 
  
    return L[m][n]",155
19161837001,largest_square,"def largest_square(matrix):
    if not matrix:
        return 0
    rows, cols = len(matrix), len(matrix[0])
    dp = [[0] * cols for _ in range(rows)]
    max_side = 0
    for i in range(rows):
        for j in range(cols):
            if matrix[i][j] == 1:
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                max_side = max(max_side, dp[i][j])
    return max_side ** 2",154
180168631,is_Happy_Number,"def is_Happy_Number(n):
    d_sqr = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
    res = {}
    sumnum = n
    while res.get(sumnum, 0) != 2:
        sumnum = sum(d_sqr[int(d)] for d in str(sumnum))
        if sumnum == 1:
            return True
        res[sumnum] = res.setdefault(sumnum, 0) + 1
    return False",154
19620860556,add_large_numbers,"def add_large_numbers(num1: str, num2: str) -> str:
    carry = 0
    result = []
    i, j = len(num1) - 1, len(num2) - 1
    while i >= 0 or j >= 0 or carry > 0:
        n1 = int(num1[i]) if i >= 0 else 0
        n2 = int(num2[j]) if j >= 0 else 0
        total = n1 + n2 + carry
        carry = total // 10
        result.append(str(total % 10))
        i, j = i - 1, j - 1
    return """".join(result[::-1])",154
28760430347,is_number_palindrome,"def is_number_palindrome(number):
    numString = str(number)
    reverseNumber = """"
    newArr = []
    i = 0
    length = len(numString)
    while(i<length):
        newArr.append(numString[i])
        i = i + 1
    reversedArr = reversed(newArr)
    finalArr = list(reversedArr)

    # Final Reversed Array
    # print(finalArr)
    for num in finalArr:
        reverseNumber = reverseNumber + num
    # print(number)
    # print(reverseNumber)
    if (str(reverseNumber) == str(number)):
        # print(""Number is Palindrome"")
        return True
    else:
        # print(""Number is not Palindrome"")
        return False",154
6051322307,countIslands,"def countIslands(grid):
    def dfs(grid, i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != 1:
            return
        grid[i][j] = 0
        dfs(grid, i+1, j)
        dfs(grid, i-1, j)
        dfs(grid, i, j+1)
        dfs(grid, i, j-1)
    
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                dfs(grid, i, j)
                count += 1
    return count",154
46948182062,decimal_to_roman,"def decimal_to_roman(num):
    decimal = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    roman = [""M"", ""CM"", ""D"", ""CD"", ""C"", ""XC"", ""L"", ""XL"", ""X"", ""IX"", ""V"", ""IV"", ""I""]
    result = """"
    i = 0
    while num > 0:
        for _ in range(num // decimal[i]):
            result += roman[i]
            num -= decimal[i]
        i += 1
    return result",154
4938542411,power_set,"from copy import deepcopy

def power_set(nums):
    """"""
    :type nums: List[int]
    :rtype: List[List[int]]
    """"""
    res = []
    sub = []
    for size in range(len(nums) + 1):
        _backtrack(size, 0, sub, res, nums)
    return res


def _backtrack(subset_size, start_index, temp_subset, result, nums):
    if len(temp_subset) == subset_size:
        result.append(deepcopy(temp_subset))
        return
    for i in range(start_index, len(nums)):
        temp_subset.append(nums[i])
        _backtrack(subset_size, i + 1, temp_subset, result, nums)
        temp_subset.pop(-1)",154
15378402579,largestRectangle,"def largestRectangle(matrix):
    if not matrix: return 0
    m, n = len(matrix), len(matrix[0])
    height = [0] * (n + 1)
    max_area = 0
    for i in range(m):
        for j in range(n):
            height[j] = height[j] + 1 if matrix[i][j] == 1 else 0
        stack = [-1]
        for j in range(n + 1):
            while height[j] < height[stack[-1]]:
                h = height[stack.pop()]
                w = j - 1 - stack[-1]
                max_area = max(max_area, h * w)
            stack.append(j)
    return max_area",154
27329389145,num_distinct,"def num_distinct(s, t):
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][0] = 1
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[m][n]",154
15025043493,is_possible_partition,"from collections import Counter

def is_possible_partition(nums):
    if len(nums) < 3:
        return False
    freq = Counter(nums)
    need = Counter()
    for num in nums:
        if freq[num] == 0:
            continue
        if need[num] > 0:
            need[num] -= 1
            need[num + 1] += 1
        elif freq[num + 1] > 0 and freq[num + 2] > 0:
            freq[num + 1] -= 1
            freq[num + 2] -= 1
            need[num + 3] += 1
        else:
            return False
        freq[num] -= 1
    return True",154
4124616310,smallest_window,"def smallest_window(s):
    dist_count = len(set(s))
    count = {}
    min_len = float('inf')
    start = 0
    distinct = 0

    for end in range(len(s)):
        count[s[end]] = count.get(s[end], 0) + 1
        if count[s[end]] == 1:
            distinct += 1

        while distinct == dist_count:
            if min_len > end - start + 1:
                min_len = end - start + 1
                min_str = s[start:end+1]

            count[s[start]] -= 1
            if count[s[start]] == 0:
                distinct -= 1
            start += 1

    return min_str",154
11920873407,longest_unique_sub,"def longest_unique_sub(s):
    max_len = 0
    max_sub = """"
    i = 0
    j = 0
    char_dict = {}
    while j < len(s):
        if s[j] in char_dict:
            i = max(i, char_dict[s[j]]+1)
        char_dict[s[j]] = j
        if j-i+1 > max_len:
            max_len = j-i+1
            max_sub = s[i:j+1]
        j += 1
    return max_sub

assert longest_unique_sub(""abcabcbb"") == ""abc""
assert longest_unique_sub(""bbbbb"") == ""b""
assert longest_unique_sub(""pwwkew"") == ""wke""",154
18728905663,num_ways_to_sum,"def num_ways_to_sum(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    if n == 2:
        return 1
    if n == 3:
        return 2
    if n == 4:
        return 4
    ways = [0] * (n + 1)
    ways[1], ways[2], ways[3], ways[4] = 1, 1, 2, 4
    for i in range(5, n + 1):
        ways[i] = ways[i - 1] + ways[i - 3] + ways[i - 4]
    return ways[n]",154
25811169760,unique_letter_strings,"import string

def unique_letter_strings(s: str) -> int:
    index = {c: [-1, -1] for c in string.ascii_uppercase}
    res = 0

    for i, c in enumerate(s):
        k, j = index[c]
        res += (i - j) * (j - k)
        index[c] = [j, i]

    for c in index:
        k, j = index[c]
        res += (len(s) - j) * (j - k)

    return res

print(unique_letter_strings(""ABC""))  # 10
print(unique_letter_strings(""ABA""))  # 8
print(unique_letter_strings(""LEETCODE""))  # 92",154
72916119384,lcs,"def lcs(X, Y):
    m = len(X)
    n = len(Y)
    L = [[0] * (n + 1) for i in range(m + 1)]

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif X[i - 1] == Y[j - 1]:
                L[i][j] = L[i - 1][j - 1] + 1
            else:
                L[i][j] = max(L[i - 1][j], L[i][j - 1])
    return L[m][n]",154
7345747157,minPathSum,"def minPathSum(triangle):
    """"""
    Finds the minimum path sum from top to bottom in a triangle.

    Args:
    - triangle (List[List[int]]): A list of lists representing the triangle.

    Returns:
    - int: The minimum path sum from top to bottom.
    """"""
    if not triangle:
        return 0

    for row in range(len(triangle) - 2, -1, -1):
        for col in range(len(triangle[row])):
            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])

    return triangle[0][0]

# Test cases
if __name__ == ""__main__"":
    test_minimum_path_sum()",154
34146335601,largest_square,"def largest_square(matrix):
    if not matrix:
        return 0
    m, n = len(matrix), len(matrix[0])
    dp = [[0]*n for _ in range(m)]
    max_side = 0
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                max_side = max(max_side, dp[i][j])
    return max_side ** 2",153
148498333,grid_ways,"def grid_ways(rows, cols):
    if rows == 1 or cols == 1:
        return 1
    return grid_ways(rows-1, cols) + grid_ways(rows, cols-1)

# Better optimized solution using dynamic programming
def grid_ways_dp(rows, cols):
    dp = [[0 for _ in range(cols)] for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            if i == 0 or j == 0:
                dp[i][j] = 1
            else:
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[rows-1][cols-1]",153
30329796287,decode_Ways,"def decode_Ways(s):
    if not s or s[0] == '0':
        return 0
    prev, curr = 1, 1
    for i in range(1, len(s)):
        if 10 <= int(s[i-1:i+1]) <= 26 and s[i] != '0':
            curr, prev = prev + curr, curr
        elif int(s[i-1:i+1]) == 10 or int(s[i-1:i+1]) == 20:
            curr, prev = prev, 0
        elif s[i] != '0':
            curr, prev = curr, curr
        else:
            return 0
    return curr",153
31943559230,find_first_non_repeating_char,"from collections import OrderedDict

def find_first_non_repeating_char(s: str) -> str:
    char_order = OrderedDict()
    char_count = {}
    
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
            char_order[char] = None
    
    for char in char_order.keys():
        if char_count[char] == 1:
            return char
    return None

if __name__ == ""__main__"":
    print(find_first_non_repeating_char(""level""))
    print(find_first_non_repeating_char(""google""))
    print(find_first_non_repeating_char(""success""))
    print(find_first_non_repeating_char(""aabbcc""))",153
17798295114,unique_permutation_count,"from collections import Counter
from math import factorial

def unique_permutation_count(string):
    # Calculate the factorial of the length of the string
    total_permutations = factorial(len(string))
    
    # Calculate the product of the factorials of the counts of each character
    duplicate_factorials = 1
    for count in Counter(string).values():
        duplicate_factorials *= factorial(count)
    
    # The number of unique permutations is the total permutations divided by the duplicate factorials
    return total_permutations // duplicate_factorials

print(unique_permutation_count(""aab""))  # Output: 3
print(unique_permutation_count(""aaa""))  # Output: 1
print(unique_permutation_count(""abc""))  # Output: 6",153
13098084645,decodeWays,"def decodeWays(s):
    if not s or s[0] == '0': 
        return 0
    if len(s) == 1: 
        return 1
    dp = [0 for _ in range(len(s)+1)]
    dp[0], dp[1] = 1, 1
    for i in range(2, len(s)+1):
        if s[i-1] != '0': 
            dp[i] = dp[i-1]
        if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] <= '6'):
            dp[i] += dp[i-2]
    return dp[-1]",153
18988157406,sort_by_length_and_alphabetically,"def sort_by_length_and_alphabetically(strings):
    return sorted(strings, key=lambda x: (len(x), x))

# Test the function
assert sort_by_length_and_alphabetically([""apple"", ""banana"", ""pear"", ""kiwi"", ""orange""]) == [""kiwi"", ""pear"", ""apple"", ""banana"", ""orange""]
assert sort_by_length_and_alphabetically([""cat"", ""dog"", ""elephant"", ""tiger"", ""lion""]) == [""cat"", ""dog"", ""lion"", ""tiger"", ""elephant""]
assert sort_by_length_and_alphabetically([""hello"", ""world"", ""python"", ""programming"", ""code""]) == [""code"", ""hello"", ""world"", ""python"", ""programming""]",153
10460574001,longest_subarray,"def longest_subarray(arr, k):
    left, right, distinct_count, max_length = 0, 0, 0, 0
    element_count = {}

    while right < len(arr):
        if arr[right] not in element_count:
            distinct_count += 1
            element_count[arr[right]] = 0
        element_count[arr[right]] += 1

        while distinct_count > k:
            element_count[arr[left]] -= 1
            if element_count[arr[left]] == 0:
                distinct_count -= 1
                del element_count[arr[left]]
            left += 1

        max_length = max(max_length, right - left + 1)
        right += 1

    return max_length",153
72925851516,largest_rectangle,"def largest_rectangle(matrix):
    if not matrix:
        return 0
    m, n = len(matrix), len(matrix[0])
    height = [0] * (n+1)
    max_area = 0
    for i in range(m):
        for j in range(n):
            height[j] = height[j] + 1 if matrix[i][j] == 1 else 0
        stack = [-1]
        for j in range(n+1):
            while height[j] < height[stack[-1]]:
                h = height[stack.pop()]
                w = j - 1 - stack[-1]
                max_area = max(max_area, h * w)
            stack.append(j)
    return max_area",153
70082183625,largest_square,"def largest_square(matrix):
    if not matrix:
        return 0
    rows, cols = len(matrix), len(matrix[0])
    dp = [[0]*cols for _ in range(rows)]
    max_side = 0
    for i in range(rows):
        for j in range(cols):
            if matrix[i][j] == 1:
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                max_side = max(max_side, dp[i][j])
    return max_side * max_side",153
17479939471,sort_colors,"def sort_colors(colors, k):
    if not colors or k is None:
        return
    i = 0
    for color in range(1, k + 1):
        i = one_color(colors, i, color)
    return colors

def one_color(nums, index, color):
    left = index
    right = len(nums) - 1
    while left < right:
        while left < right and nums[left] == color:
            left += 1
        while left < right and nums[right] > color:
            right -= 1
        if left < right:
            nums[left], nums[right] = nums[right], nums[left]
    return left if nums[left] != color else left + 1",153
19224248149,largest_square,"def largest_square(matrix):
    if not matrix:
        return 0
    m, n = len(matrix), len(matrix[0])
    dp = [[0]*n for _ in range(m)]
    maxSide = 0
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                maxSide = max(maxSide, dp[i][j])
    return maxSide * maxSide",153
36206455764,can_rearrange_to_palindrome,"from collections import Counter

def can_rearrange_to_palindrome(s):
    if len(s) % 2 == 1:
        odd_count = 0
        for count in Counter(s).values():
            if count % 2 == 1:
                odd_count += 1
            if odd_count > 1:
                return False
        return True
    else:
        for count in Counter(s).values():
            if count % 2 == 1:
                return False
        return True

print(can_rearrange_to_palindrome(""aabb""))
print(can_rearrange_to_palindrome(""car""))
print(can_rearrange_to_palindrome(""aaabbbb""))
print(can_rearrange_to_palindrome(""code""))",153
1644728033,valid_parentheses,"from typing import List


def valid_parentheses(n: int) -> List[str]:
    def generate_parentheses(n: int, open_count: int, close_count: int, current: str, result: List[str]):
        if open_count == n and close_count == n:
            result.append(current)
            return
        if open_count < n:
            generate_parentheses(n, open_count + 1, close_count, current + ""("", result)
        if close_count < open_count:
            generate_parentheses(n, open_count, close_count + 1, current + "")"", result)

    result: List[str] = []
    generate_parentheses(n, 0, 0, """", result)
    return result",153
4368165547,longest_common_subsequence,"def longest_common_subsequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [['' for _ in range(n + 1)] for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + str1[i - 1]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len)
    return dp[m][n]",153
19093273664,count_islands,"def count_islands(grid):
    if not grid:
        return 0

    def dfs(x, y):
        if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != 1:
            return
        grid[x][y] = 0
        dfs(x+1, y)
        dfs(x-1, y)
        dfs(x, y+1)
        dfs(x, y-1)

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                dfs(i, j)
                count += 1
    return count",153
38218376659,longest_palindromic_substring,"def longest_palindromic_substring(s):
    if len(s) < 2:
        return s
    start = 0
    max_length = 1
    for i in range(len(s)):
        if i - max_length >= 1 and s[i-max_length-1:i+1] == s[i-max_length-1:i+1][::-1]:
            start = i - max_length - 1
            max_length += 2
            continue
        if i - max_length >= 0 and s[i-max_length:i+1] == s[i-max_length:i+1][::-1]:
            start = i - max_length
            max_length += 1
    return s[start:start + max_length]",153
30974761704,longest_common_subsequence,"def longest_common_subsequence(str1, str2):
    dp = [['' for _ in range(len(str2) + 1)] for _ in range(len(str1) + 1)]
    for i in range(1, len(str1) + 1):
        for j in range(1, len(str2) + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + str1[i - 1]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len)
    return dp[-1][-1]",153
73268813691,min_jumps,"def min_jumps(arr): 
    n = len(arr) 
    if (n <= 1): 
        return 0
    if (arr[0] == 0): 
        return -1
    maxReach = arr[0]; step = arr[0]; jump = 1; 
    for i in range(1, n): 
        if (i == n - 1): 
            return jump 
        maxReach = max(maxReach, i + arr[i]); 
        step -= 1; 
        if (step == 0): 
            jump += 1
            if (i >= maxReach): 
                return -1
            step = maxReach - i 
    return -1",153
6423408125,longest_common_subsequence,"def longest_common_subsequence(s1: str, s2: str) -> int:
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]",152
753609596,find_largest_rectangle,"def find_largest_rectangle(heights):
    stack = []
    max_area = 0
    index = 0
    while index < len(heights):
        if not stack or heights[stack[-1]] <= heights[index]:
            stack.append(index)
            index += 1
        else:
            top = stack.pop()
            area = (heights[top] * ((index - stack[-1] - 1) if stack else index))
            max_area = max(max_area, area)
    while stack:
        top = stack.pop()
        area = (heights[top] * ((index - stack[-1] - 1) if stack else index))
        max_area = max(max_area, area)
    return max_area",152
70559467927,islands_number,"def islands_number(grid):
    def dfs(grid, i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != 1:
            return
        grid[i][j] = 0
        dfs(grid, i+1, j)
        dfs(grid, i-1, j)
        dfs(grid, i, j+1)
        dfs(grid, i, j-1)

    islands = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                dfs(grid, i, j)
                islands += 1
    return islands",152
12305069567,largest_square,"def largest_square(matrix):
    if not matrix: return 0
    m, n = len(matrix), len(matrix[0])
    dp = [[0] * n for _ in range(m)]
    max_side = 0
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                max_side = max(max_side, dp[i][j])
    return max_side**2",152
69912359196,top_k_frequent,"def top_k_frequent(nums, k):
    counts = {}
    max_count = 0

    for num in nums:
        if num in counts:
            counts[num] = counts[num] + 1
        else:
            counts[num] = 1

        max_count = max(max_count, counts[num])

    buckets = [[] for _ in range(max_count + 1)]
    for num, count in counts.items():
        buckets[count].append(num)
    
    ans = []
    for i in range(max_count, -1, -1):
        for num in buckets[i]:
            ans.append(num)
            if len(ans) == k:
                break
        if len(ans) == k:
            break

    return ans",152
4527884762,min_deletions,"def min_deletions(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return m + n - 2 * dp[m][n]",152
20136626442,confusing_number,"def confusing_number(N):
    rules = {
        ""0"": ""0"",
        ""1"": ""1"",
        ""6"": ""9"",
        ""8"": ""8"",
        ""9"": ""6""
    }
    n_str = str(N)
    left, right = 0, len(n_str) - 1
    diff = False
    while left <= right:
        if n_str[left] not in rules or n_str[right] not in rules:
            return False
        else:
            if rules[n_str[left]] != n_str[right] or rules[n_str[right]] != n_str[left]:
                diff = True
            left += 1
            right -= 1
    return diff if diff else False",152
37163662480,alien_order,"import collections

def alien_order(words):
    pre, suc = collections.defaultdict(set), collections.defaultdict(set)
    for pair in zip(words, words[1:]):
        for a, b in zip(pair[0], pair[1]):
            if a != b:
                suc[a].add(b)
                pre[b].add(a)
                break

    ans = ''
    chars = set("""".join(words))
    cands = chars - set(pre.keys())
    while cands:
        ch = cands.pop()
        ans += ch
        for item in suc[ch]:
            pre[item].discard(ch)
            if not pre[item]:
                cands.add(item)

    return ans if len(chars) == len(ans) else """"",152
22526122687,diameter_of_graph,"from collections import deque

def diameter_of_graph(adj_matrix):
    def bfs(start):
        distances = [float('inf')] * len(adj_matrix)
        distances[start] = 0
        queue = deque([start])
        while queue:
            node = queue.popleft()
            for neighbor in range(len(adj_matrix[node])):
                if adj_matrix[node][neighbor] == 1 and distances[neighbor] == float('inf'):
                    distances[neighbor] = distances[node] + 1
                    queue.append(neighbor)
        return distances

    max_diameter = 0
    for start in range(len(adj_matrix)):
        distances = bfs(start)
        max_diameter = max(max_diameter, max(distances))

    return max_diameter",152
72331225688,count_islands,"def dfs(grid, i, j):
    if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != 1:
        return
    grid[i][j] = 0
    dfs(grid, i+1, j)
    dfs(grid, i-1, j)
    dfs(grid, i, j+1)
    dfs(grid, i, j-1)

def count_islands(grid):
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                dfs(grid, i, j)
                count += 1
    return count",152
6991276338,can_rearrange_to_palindrome,"def can_rearrange_to_palindrome(s: str) -> bool:
    def is_palindrome(s):
        return s == s[::-1]

    if is_palindrome(s):
        char_count = [0] * 256
        for char in s:
            char_count[ord(char)] += 1
        odd_counts = sum(count % 2 for count in char_count)
        return odd_counts <= 1

    for i in range(len(s) // 2):
        s = s[:i] + s[i+1:] + s[i] + s[i+2:]
        if is_palindrome(s):
            return True
        s = s[:i] + s[i+1:]
    return False",152
30443763029,longest_substring_with_k_distinct,"def longest_substring_with_k_distinct(s, k):
    window_start = 0
    max_length = 0
    char_frequency = {}

    for window_end in range(len(s)):
        right_char = s[window_end]
        if right_char not in char_frequency:
            char_frequency[right_char] = 0
        char_frequency[right_char] += 1

        while len(char_frequency) > k:
            left_char = s[window_start]
            char_frequency[left_char] -= 1
            if char_frequency[left_char] == 0:
                del char_frequency[left_char]
            window_start += 1

        max_length = max(max_length, window_end - window_start + 1)
    return max_length",152
36523609567,minDeletions,"def minDeletions(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return m + n - 2 * dp[m][n]",152
4025485412,longest_substring_with_k_distinct,"def longest_substring_with_k_distinct(s, k):
    window_start = 0
    max_length = 0
    char_frequency = {}

    for window_end in range(len(s)):
        right_char = s[window_end]
        if right_char not in char_frequency:
            char_frequency[right_char] = 0
        char_frequency[right_char] += 1

        while len(char_frequency) > k:
            left_char = s[window_start]
            char_frequency[left_char] -= 1
            if char_frequency[left_char] == 0:
                del char_frequency[left_char]
            window_start += 1

        max_length = max(max_length, window_end - window_start + 1)
    return max_length",152
6270353563,next_prime,"def next_prime(num):
    def is_prime(n):
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    if num <= 1:
        return 2
    prime = num
    found = False
    while not found:
        prime += 1
        if is_prime(prime):
            found = True
    return prime",152
40810110803,checkPermutation,"from collections import Counter

def checkPermutation(s1, s2):
    key_hole = Counter(s1)
    key = Counter([])
    n = len(s1)
    pins = left = 0

    for right, ch_right in enumerate(s2):
        if n < right - left + 1:
            ch_left = s2[left]
            if key[ch_left] == key_hole[ch_left]:
                pins -= 1
            key[ch_left] -= 1
            left += 1

        key[ch_right] += 1
        if key[ch_right] == key_hole[ch_right]:
            pins += 1

        if pins == len(key_hole):
            return True
    return False",152
39657805500,max_product_subarray,"def max_product_subarray(nums):
    if len(nums) == 1:
        return nums[0]

    res = -float('inf')
    pos, neg = 0, 0
    for n in nums:
        if n >= 0:
            pos, neg = max(pos*n, n), neg * n
        else:
            pos, neg = neg * n, min(pos*n, n)
        res = max(res, pos)
    return res

assert max_product_subarray([2, 3, -2, 4]) == 6
assert max_product_subarray([-2, 0, -1]) == 0
assert max_product_subarray([0, 2]) == 2",152
5809157891,has_cycle,"def has_cycle(edges):
    graph = {}
    for edge in edges:
        if edge[0] not in graph:
            graph[edge[0]] = []
        graph[edge[0]].append(edge[1])
    
    def visit(node, visited, stack):
        if node in stack:
            return True
        if node in visited:
            return False

        visited.add(node)
        stack.add(node)
        if node in graph:
            for neighbour in graph[node]:
                if visit(neighbour, visited, stack):
                    return True
        stack.remove(node)
        return False

    visited = set()
    stack = set()
    for node in graph:
        if visit(node, visited, stack):
            return True
    return False",152
36518476102,nth_look_and_say,"def nth_look_and_say(n):
    """"""
    Generates the nth term of the ""look-and-say"" sequence.
    """"""
    if n == 1:
        return ""1""
    
    previous_term = nth_look_and_say(n - 1)  # Recursively build the sequence
    result = """"
    count = 1
    for i in range(1, len(previous_term)):
        if previous_term[i] == previous_term[i - 1]:
            count += 1
        else:
            result += str(count) + previous_term[i - 1]
            count = 1
    result += str(count) + previous_term[-1]  # Add the last digit and its count
    return result",152
38484306208,longest_Common_Subsequence,"def longest_Common_Subsequence(text1: str, text2: str) -> int:
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]",152
25108959561,longestCommonSubsequence,"def longestCommonSubsequence(text1: str, text2: str) -> int:
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = 1 + dp[i - 1][j - 1]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]",152
21159138076,find_interval_intersection,"def find_interval_intersection(A, B):
    combined = sorted(A + B, key=lambda x: x[0])
    intersection = []
    currentEnd = -1

    for start, end in combined:
        if start <= currentEnd:
            intersection.append([start, min(currentEnd, end)])
        currentEnd = max(currentEnd, end)        

    # Remove duplicates and sort by start time for the final result
    final_intersection = []
    for interval in intersection:
        if not final_intersection or final_intersection[-1][1] < interval[0]:
            final_intersection.append(interval)
        else:
            final_intersection[-1][1] = max(final_intersection[-1][1], interval[1])
            
    return final_intersection",151
34173157572,romanToInt,"def romanToInt(s: str) -> int:
    roman = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000,'IV':4,'IX':9,'XL':40,'XC':90,'CD':400,'CM':900}
    i = 0
    num = 0
    while i < len(s):
        if i+1<len(s) and s[i:i+2] in roman:
            num+=roman[s[i:i+2]]
            i+=2
        else:
            num+=roman[s[i]]
            i+=1
    return num",151
14171758238,find_largest_number_in_binary_tree,"class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

def insert(node, key):
    if node is None:
        return Node(key)
    else:
        if node.val < key:
            node.right = insert(node.right, key)
        else:
            node.left = insert(node.left, key)
    return node

def find_largest_number_in_binary_tree(tree_list):
    root = None
    for num in tree_list:
        root = insert(root, num)
    max_number = root.val
    while root:
        while root.right:
            root = root.right
            max_number = root.val
        break
    return max_number",151
18303003991,rearrange_string,"import heapq
from collections import Counter

def rearrange_string(S: str) -> str:
    counts = Counter(S)
    heap = []
    for key in counts.keys():
        heapq.heappush(heap, [-counts[key], key])

    result = []
    while heap:
        item = heapq.heappop(heap)
        if result and item[1] == result[-1]:
            if not heap:
                return """"
            nxt = heapq.heappop(heap)
            heapq.heappush(heap, item)
            item = nxt
        result.append(item[1])
        if item[0] < -1:
            heapq.heappush(heap, [item[0]+1, item[1]])

    return """".join(result)",151
1447533584,min_avg_slice,"from math import inf

def min_avg_slice(A):
    # write your code in Python 3.6
    min_avg = inf
    min_index = 0
    for i in range(len(A) - 1):
        current_avg = (A[i] + A[i + 1]) / 2
        if current_avg < min_avg:
            min_avg = current_avg
            min_index = i
    for i in range(len(A) - 2):
        current_avg = (A[i] + A[i + 1] + A[i + 2]) / 3
        if current_avg < min_avg:
            min_avg = current_avg
            min_index = i
    return min_index",151
23963899450,min_additional_questions,"def min_additional_questions(questions, n):
    questions.sort()
    add = 0
    for i in range(n - 1):
        if questions[i + 1] - questions[i] <= 10:
            continue
        if questions[i + 1] - questions[i] <= 20 and questions[i + 1] - questions[i] > 10:
            add += 1
            continue
        if questions[i + 1] - questions[i] > 20:
            add += 2
            continue

    ad = (n + add) % 3
    if ad == 0:
        return add
    else:
        return add + (3 - ad)",151
3015426882,shortest_path_dijkstra,"import heapq

def shortest_path_dijkstra(graph, start, end):
    queue = [(0, start, [])]
    seen = set()
    min_dist = float(""inf"")
    path = []

    while queue:
        (cost, node, route) = heapq.heappop(queue)

        if node not in seen:
            seen.add(node)
            route = route + [node]

            if node == end:
                if cost < min_dist:
                    min_dist = cost
                    path = route

            for neighbor, edge_cost in graph[node].items():
                if neighbor not in seen:
                    edge_cost = cost + edge_cost
                    heapq.heappush(queue, (edge_cost, neighbor, route))
    
    return path",151
31147523398,check_connected_graph,"from collections import defaultdict

def dfs(graph, visited, v):
    visited[v]=True

    for adj in graph[v]:
        if(visited[adj]==False):
            dfs(graph,visited,adj)

def check_connected_graph(edges):
    # graph :: tree
    graph=defaultdict(list)
    visited={key:False for key in range(1,len(edges)+1)}
    
    for edge in edges:
        graph[edge[0]].append(edge[1])
        graph[edge[1]].append(edge[0])

    # for key,val in graph.items():
    #     print(key,val)

    dfs(graph,visited,1)

    for v in visited.values():
        if v==False:
            return False
    return True",151
38099436302,largestRectangleArea,"def largestRectangleArea(heights):
    stack = []
    maxArea = 0
    i = 0
    while i < len(heights):
        if not stack or heights[i] >= heights[stack[-1]]:
            stack.append(i)
            i += 1
        else:
            top = stack.pop()
            area = (heights[top] * ((i - stack[-1] - 1) if stack else i))
            maxArea = max(maxArea, area)
    while stack:
        top = stack.pop()
        area = (heights[top] * ((i - stack[-1] - 1) if stack else i))
        maxArea = max(maxArea, area)
    return maxArea",151
42013517421,longest_substring_with_k_distinct,"def longest_substring_with_k_distinct(s, k):
    window_start, max_length = 0, 0
    char_frequency = {}

    for window_end in range(len(s)):
        right_char = s[window_end]
        if right_char not in char_frequency:
            char_frequency[right_char] = 0
        char_frequency[right_char] += 1

        while len(char_frequency) > k:
            left_char = s[window_start]
            char_frequency[left_char] -= 1
            if char_frequency[left_char] == 0:
                del char_frequency[left_char]
            window_start += 1

        max_length = max(max_length, window_end - window_start + 1)
    return max_length",151
35220579014,next_permutation,"def next_permutation(n):
    num_list = list(str(n))
    i = len(num_list) - 2
    while i >= 0:
        if num_list[i] < num_list[i + 1]:
            break
        i -= 1
    if i >= 0:
        j = len(num_list) - 1
        while j > i:
            if num_list[j] > num_list[i]:
                break
            j -= 1
        num_list[i], num_list[j] = num_list[j], num_list[i]
        num_list[i + 1:] = reversed(num_list[i + 1:])
    else:
        num_list.reverse()
    return int("""".join(num_list))",151
28346430076,max_rect_area,"def max_rect_area(heights):
    stack = []
    max_area = 0
    index = 0
    while index < len(heights):
        if not stack or heights[stack[-1]] <= heights[index]:
            stack.append(index)
            index += 1
        else:
            top = stack.pop()
            area = (heights[top] * ((index - stack[-1] - 1) if stack else index))
            max_area = max(max_area, area)
    while stack:
        top = stack.pop()
        area = (heights[top] * ((index - stack[-1] - 1) if stack else index))
        max_area = max(max_area, area)
    return max_area",151
39249874106,unique_paths_with_obstacles,"def unique_paths_with_obstacles(obstacleGrid):
    m, n = len(obstacleGrid), len(obstacleGrid[0])
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = 1 - obstacleGrid[0][0]
    for i in range(m):
        for j in range(n):
            if obstacleGrid[i][j] == 1:
                dp[i][j] = 0
            else:
                if i > 0:
                    dp[i][j] += dp[i-1][j]
                if j > 0:
                    dp[i][j] += dp[i][j-1]
    return dp[m-1][n-1]",151
2968795205,max_histogram_area,"def max_histogram_area(heights):
    stack = []
    max_area = 0
    i = 0
    while i < len(heights):
        if not stack or heights[stack[-1]] <= heights[i]:
            stack.append(i)
            i += 1
        else:
            top = stack.pop()
            area = (heights[top] * ((i - stack[-1] - 1) if stack else i))
            max_area = max(max_area, area)
    while stack:
        top = stack.pop()
        area = (heights[top] * ((i - stack[-1] - 1) if stack else i))
        max_area = max(max_area, area)
    return max_area",151
36197629990,max_area_histogram,"def max_area_histogram(histogram):
    stack = []
    max_area = 0
    i = 0
    while i < len(histogram):
        if not stack or histogram[i] >= histogram[stack[-1]]:
            stack.append(i)
            i += 1
        else:
            top = stack.pop()
            area = (histogram[top] * ((i - stack[-1] - 1) if stack else i))
            max_area = max(max_area, area)
    while stack:
        top = stack.pop()
        area = (histogram[top] * ((i - stack[-1] - 1) if stack else i))
        max_area = max(max_area, area)
    return max_area",151
74612510971,max_histogram_area,"def max_histogram_area(heights):
    stack = []
    max_area = 0
    index = 0
    while index < len(heights):
        if not stack or heights[stack[-1]] <= heights[index]:
            stack.append(index)
            index += 1
        else:
            top = stack.pop()
            area = (heights[top] * ((index - stack[-1] - 1) if stack else index))
            max_area = max(max_area, area)
    while stack:
        top = stack.pop()
        area = (heights[top] * ((index - stack[-1] - 1) if stack else index))
        max_area = max(max_area, area)
    return max_area",151
74449130744,max_histogram_area,"def max_histogram_area(heights):
    stack = []
    max_area = 0
    i = 0
    while i < len(heights):
        if not stack or heights[i] >= heights[stack[-1]]:
            stack.append(i)
            i += 1
        else:
            top = stack.pop()
            area = (heights[top] * ((i - stack[-1] - 1) if stack else i))
            max_area = max(max_area, area)
    while stack:
        top = stack.pop()
        area = (heights[top] * ((i - stack[-1] - 1) if stack else i))
        max_area = max(max_area, area)
    return max_area",151
17233219996,find_k_smallest_pairs,"import heapq

def find_k_smallest_pairs(nums1, nums2, k):
    if not nums1 or not nums2:
        return []
    
    heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))
    
    result = []
    while heap and len(result) < k:
        _, i, j = heapq.heappop(heap)
        result.append([nums1[i], nums2[j]])
        if j + 1 < len(nums2):
            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
    
    return result",151
41660230162,longest_subarray_with_k_distinct,"def longest_subarray_with_k_distinct(arr, k):
    window_start, max_length = 0, 0
    char_frequency = {}

    for window_end in range(len(arr)):
        right_char = arr[window_end]
        if right_char not in char_frequency:
            char_frequency[right_char] = 0
        char_frequency[right_char] += 1

        while len(char_frequency) > k:
            left_char = arr[window_start]
            char_frequency[left_char] -= 1
            if char_frequency[left_char] == 0:
                del char_frequency[left_char]
            window_start += 1

        max_length = max(max_length, window_end - window_start + 1)

    return max_length",151
41674680461,max_operations,"from collections import defaultdict

def max_operations(nums, k):
    operations = 0
    count = defaultdict(int)
    for num in nums:
        count[num] += 1
    for i in range (len(nums)):
        half = k - nums[i]
        if count[nums[i]] != 0 and count[half] != 0 and nums[i] != half:
            count[nums[i]] -= 1
            count[half] -= 1
            operations += 1
        if nums[i] == half:
            if count[nums[i]] >1:
                count[nums[i]] -= 1
                count[half] -= 1
                operations += 1                 
    return operations",151
1234912807,largest_fib_divisor,"def gen_fib_sequence(n):
    fib_sequence = [0, 1]
    while fib_sequence[-1] < n:
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
    return fib_sequence

def largest_fib_divisor(n):
    fib_sequence = gen_fib_sequence(n)
    for i in range(len(fib_sequence)-1, 0, -1):
        if n % fib_sequence[i] == 0:
            return fib_sequence[i]
    return 1

assert largest_fib_divisor(10) == 5
assert largest_fib_divisor(34) == 34
assert largest_fib_divisor(21) == 21",150
23656752833,num_ways_to_decode,"def num_ways_to_decode(s: str) -> int:
    if s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1

    for i in range(2, n + 1):
        if s[i - 1] > '0':
            dp[i] = dp[i - 1]
        if s[i - 2] == '1' or (s[i - 2] == '2' and s[i - 1] < '7'):
            dp[i] += dp[i - 2]
    return dp[n]",150
29663806291,num_islands,"def num_islands(grid):
    if not grid:
        return 0

    def dfs(i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':
            return
        grid[i][j] = '#'
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1
    return count",150
26208606746,distinct_subsequences,"def distinct_subsequences(s):
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    last_occurrence = [-1] * 26
    for i in range(1, n + 1):
        dp[i] = 2 * dp[i - 1]
        if last_occurrence[ord(s[i - 1]) - ord('a')] != -1:
            dp[i] -= dp[last_occurrence[ord(s[i - 1]) - ord('a')]]
        last_occurrence[ord(s[i - 1]) - ord('a')] = i - 1
    return dp[n] - 1",150
69811585425,num_islands,"def num_islands(grid):
    if not grid:
        return 0

    def dfs(i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':
            return
        grid[i][j] = '#'
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1
    return count",150
17567668501,count_palindrome_substrings,"def count_palindrome_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # Count odd length palindromes (center is at s[i])
        total_count += expand_around_center(i, i)
        # Count even length palindromes (center is between s[i] and s[i+1])
        total_count += expand_around_center(i, i + 1)

    return total_count",150
18688157142,shortest_subarray_length,"def shortest_subarray_length(k, nums):
    if len(nums) == 0:
        return 0
    
    min_length, length = len(nums) + 1, len(nums)
    start, end = 0, 0
    current_sum = 0
    
    while end < length:
        
        while end < length and current_sum < k:
            current_sum += nums[end]
            end += 1
        
        while start < length and current_sum >= k:
            if end - start < min_length:
                min_length = end - start
            
            current_sum -= nums[start]
            start += 1
    
    if min_length == len(nums) + 1:
        return 0
    
    return min_length",150
71127126227,shortest_subarray,"from collections import deque

def shortest_subarray(nums, k):
    n = len(nums)
    prefix = [0] * (n+1)
    for i in range(n):
        prefix[i+1] = prefix[i] + nums[i]
    
    dq = deque()
    min_len = float('inf')
    for i in range(n+1):
        while dq and prefix[i] - prefix[dq[0]] >= k:
            min_len = min(min_len, i - dq[0])
            dq.popleft()
        while dq and prefix[i] <= prefix[dq[-1]]:
            dq.pop()
        dq.append(i)
    
    return min_len if min_len != float('inf') else 0",150
71527834309,decode_message,"def decode_message(s):
    if not s or s[0] == '0':
        return 0
    if len(s) == 1:
        return 1
    ways = [1, 1]
    for i in range(1, len(s)):
        if s[i] == '0':
            if s[i-1] > '2':
                return 0
            ways.append(ways[-2])
        elif s[i-1] == '1' or (s[i-1] == '2' and s[i] < '7'):
            ways.append(ways[-1] + ways[-2])
        else:
            ways.append(ways[-1])
    return ways[-1]",150
534412033,numDecodings,"def numDecodings(s: str) -> int:
    dp = [0] * (len(s) + 1)
    dp[len(s)] = 1

    for i in range(len(s) - 1, -1, -1):
        if s[i] == '0':
            dp[i] = 0
        else:
            dp[i] = dp[i + 1]
        if (i + 1 < len(s) and 
            (s[i] == '1' or (s[i] == '2' and s[i + 1] in '0123456'))):
            dp[i] += dp[i + 2]
    return dp[0]",150
71439409910,connected_components,"from collections import defaultdict, deque

def connected_components(edges):
    if not edges:
        return 0

    # Create adjacency list
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    def bfs(node):
        queue = deque([node])
        while queue:
            current = queue.popleft()
            if current in visited:
                continue
            visited.add(current)
            for neighbor in graph[current]:
                if neighbor not in visited:
                    queue.append(neighbor)

    visited = set()
    components = 0

    for node in graph:
        if node not in visited:
            bfs(node)
            components += 1

    return components",150
71631957750,num_distinct_subsequences,"def num_distinct_subsequences(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = 1
    for i in range(1, m + 1):
        dp[i][0] = 1
        for j in range(1, n + 1):
            dp[i][j] = dp[i - 1][j] + (dp[i - 1][j - 1] if s[i - 1] == t[j - 1] else 0)
    return dp[m][n]",150
34621281126,nth_ugly_number,"def nth_ugly_number(n):
    ugly = [1]
    i2 = i3 = i5 = 0
    while len(ugly) < n:
        next_ugly = min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5)
        ugly.append(next_ugly)
        if next_ugly == ugly[i2] * 2:
            i2 += 1
        if next_ugly == ugly[i3] * 3:
            i3 += 1
        if next_ugly == ugly[i5] * 5:
            i5 += 1
    return ugly[-1]",150
74931334425,is_bipartite,"from collections import deque
def is_bipartite(graph):
    n = len(graph)
    visited = {} # not visited
    for node in range(n):
        if node not in visited:
            dq = deque([node])
            visited[node] = 0 # set group to arbitary 0 or 1
            while dq:
                cur_node = dq.pop()
                for nei in graph[cur_node]:
                    if nei not in visited:
                        dq.append(nei)
                        visited[nei] = visited[cur_node] ^ 1  # 0^1, 1^1 => xor
                    elif visited[nei] == visited[cur_node]: # check group
                        return False
    return True",150
31587748263,merge_intervals,"def merge_intervals(intervals):
    if len(intervals) < 2:
        return intervals

    # Sort intervals based on the start time
    intervals.sort(key=lambda x: x[0])

    merged = []
    # Initialize with the first interval
    current = intervals[0]

    for interval in intervals[1:]:
        if interval[0] <= current[1]:
            # Overlapping intervals, merge them
            current[1] = max(current[1], interval[1])
        else:
            # Non-overlapping interval, add the current to merged and start a new interval
            merged.append(current)
            current = interval

    # Add the last merged interval
    merged.append(current)
    return merged",150
7665605472,valid_parentheses_string,"def valid_parentheses_string(s):
    while '()' in s or '[]' in s or '{}' in s:
        s = s.replace('()', '').replace('[]', '').replace('{}', '')
    return s == ''

print(valid_parentheses_string(""()"")) # True
print(valid_parentheses_string(""()[]{}"")) # True
print(valid_parentheses_string(""(]"")) # False
print(valid_parentheses_string(""([)]"")) # False
print(valid_parentheses_string(""{[]}"")) # True
print(valid_parentheses_string(""((()))"")) # True
print(valid_parentheses_string(""([{}])"")) # True
print(valid_parentheses_string(""([{])"")) # False",149
29326219057,find_connected_components,"def find_connected_components(edges):
    parent = {}
    
    def find(x):
        if x not in parent:
            parent[x] = x
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(a, b):
        ra, rb = find(a), find(b)
        if ra == rb:
            return
        parent[ra] = rb
    
    for edge in edges:
        union(edge[0], edge[1])
    
    components = {}
    for node in parent:
        root = find(node)
        if root not in components:
            components[root] = set()
        components[root].add(node)
    
    return list(components.values())",149
8159031356,word_ladder_length,"from collections import deque

def word_ladder_length(beginWord, endWord, wordList):
    if endWord not in wordList: return 0
    L = len(beginWord)
    wordList = set(wordList)
    queue = deque([(beginWord, 1)])
    while queue:
        currentWord, level = queue.popleft()
        for i in range(L):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                nextWord = currentWord[:i] + c + currentWord[i+1:]
                if nextWord == endWord: return level + 1
                if nextWord in wordList:
                    wordList.remove(nextWord)
                    queue.append((nextWord, level + 1))
    return 0",149
14611015129,convert_number_string,"def convert_number_string(s):
    number_dict = {
        'zero': '0',
        'one': '1',
        'two': '2',
        'three': '3',
        'four': '4',
        'five': '5',
        'six': '6',
        'seven': '7',
        'eight': '8',
        'nine': '9',
    }

    answer = ''
    word = ''

    for char in s:
        if char == ' ':
            if word in number_dict:
                answer += number_dict[word]
                word = ''
        else:
            word += char

    if word in number_dict:
        answer += number_dict[word]

    return int(answer)",149
32616199117,max_substring_length,"def max_substring_length(s, k):
    if k == 0: return 0
    left, right, max_len = 0, 0, 0
    char_dict = {}
    while right < len(s):
        if s[right] in char_dict:
            char_dict[s[right]] += 1
        else:
            char_dict[s[right]] = 1

        while len(char_dict) > k:
            char_dict[s[left]] -= 1
            if char_dict[s[left]] == 0:
                del char_dict[s[left]]
            left += 1

        max_len = max(max_len, right - left + 1)
        right += 1

    return max_len",149
28313751096,num_ways,"def num_ways(s: str) -> int:
    dp = [0] * (len(s) + 1)
    dp[0] = 1
    if s[0] == '0':
        dp[1] = 0
    else:
        dp[1] = 1
    for i in range(2, len(s) + 1):
        temp1 = int(s[i-1])
        temp2 = int(s[i-2:i])
        if(temp1 >= 1):
            dp[i] += dp[i-1]
        if 10 <= temp2 <= 26:
            dp[i] += dp[i-2]
    return dp[len(s)]",149
27301422958,largestRectangleArea,"def largestRectangleArea(heights):
    stack = []
    max_area = 0
    index = 0
    while index < len(heights):
        if not stack or heights[stack[-1]] <= heights[index]:
            stack.append(index)
            index += 1
        else:
            top = stack.pop()
            area = (heights[top] * ((index - stack[-1] - 1) if stack else index))
            max_area = max(max_area, area)
    while stack:
        top = stack.pop()
        area = heights[top] * ((index - stack[-1] - 1) if stack else index)
        max_area = max(max_area, area)
    return max_area",149
39391299413,longest_substring_with_k_distinct,"def longest_substring_with_k_distinct(s: str, k: int) -> int:
    charMap = {} # char:frequency
    max_length = 0
    left = 0
    
    for right in range(len(s)):
        charMap[s[right]] = charMap.get(s[right], 0) + 1
        
        # If there are more than k distinct characters, slide the left edge
        while len(charMap) > k:
            charMap[s[left]] -= 1
            if charMap[s[left]] == 0:
                del charMap[s[left]]
            left += 1
            
        max_length = max(max_length, right - left + 1)
        
    return max_length",149
10060081342,numDecodings,"def numDecodings(s: str) -> int:
    if not s:
        return 0
    dp = [0] * (len(s) + 1)
    dp[0] = 1
    dp[1] = 0 if s[0] == ""0"" else 1

    for i in range(2, len(s) + 1):
        single = int(s[i-1:i])
        double = int(s[i-2:i])

        if 1 <= single <= 9:
            dp[i] += dp[i-1]
        if 10 <= double <= 26:
            dp[i] += dp[i-2]

    return dp[len(s)]",149
37000683098,max_nested_lists,"def max_nested_lists(lst):
    max_depth = 1
    depth = 1
    for i in lst:
        if isinstance(i, list):
            depth += max_nested_lists(i)
            max_depth = max(max_depth, depth)
            depth -= 1
    return max_depth

print(max_nested_lists([1, [2, [3, 4], 5], [6]])) # Expected output: 3
print(max_nested_lists([1, 2, 3])) # Expected output: 1
print(max_nested_lists([1, [2, [3, [4, 5], 6], 7], [8, 9]])) # Expected output: 4",149
21533055638,least_operations,"def least_operations(str1, str2):
    len1, len2 = len(str1), len(str2)
    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]

    for i in range(len1):
        for j in range(len2):
            if str1[i] == str2[j]:
                dp[i + 1][j + 1] = dp[i][j] + 1
            else:
                dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])
    
    return len1 + len2 - 2 * dp[len1][len2]",149
21747061584,has_cycle,"def has_cycle(matrix):
    def dfs(v, visited, rec_stack):
        visited[v] = True
        rec_stack[v] = True
        for i, x in enumerate(matrix[v]):
            if x == 1:
                if not visited[i]:
                    if dfs(i, visited, rec_stack):
                        return True
                elif rec_stack[i]:
                    return True
        rec_stack[v] = False
        return False

    num_vertex = len(matrix)
    visited = [False] * num_vertex
    rec_stack = [False] * num_vertex
    for v in range(num_vertex):
        if not visited[v]:
            if dfs(v, visited, rec_stack):
                return True
    return False",148
2614837238,find_triplets,"def find_triplets(nums):
    nums.sort()
    n = len(nums)
    triplets = 0
    for i in range(n):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        l, r = i+1, n-1
        while l < r:
            s = nums[i] + nums[l] + nums[r]
            if s < 0:
                l +=1 
            elif s > 0:
                r -= 1
            else:
                triplets += 1
                l += 1
                while l < r and nums[l] == nums[l-1]:
                    l += 1
    return triplets",148
25002915976,decode_ways,"def decode_ways(s: str) -> int:
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        single_digit = int(s[i-1:i])
        double_digit = int(s[i-2:i])
        if 1 <= single_digit <= 9:
            dp[i] += dp[i-1]
        if 10 <= double_digit <= 26:
            dp[i] += dp[i-2]
    return dp[n]",148
22634895591,decode_ways,"def decode_ways(s: str) -> int:
    if s == """" or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] > '0':
            dp[i] = dp[i - 1]
        if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] < '7'):
            dp[i] += dp[i - 2]
    return dp[n]",148
38988571596,word_ladder_length,"from collections import deque

def word_ladder_length(beginWord, endWord, wordList):
    if endWord not in wordList:
        return 0
    q = deque()
    q.append([beginWord, 1])
    
    while q:
        x, count = q.popleft()
        if x == endWord:
            return count
        
        for i in range(len(wordList)):
            diff = 0
            word = wordList[i]
            for j in range(len(word)):
                if x[j] != word[j]:
                    diff += 1
            if diff == 1:
                q.append([word, count + 1])
                wordList[i] = """"
        
    return 0",148
4744379390,decode_Ways,"def decode_Ways(s: str) -> int:
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        one_digit = int(s[i-1:i])
        two_digit = int(s[i-2:i])
        if 1 <= one_digit <= 9:
            dp[i] += dp[i-1]
        if 10 <= two_digit <= 26:
            dp[i] += dp[i-2]
    return dp[n]",148
33529897145,grid_paths,"def grid_paths(grid):
    m = len(grid)
    n = len(grid[0])
    dp = [[0 for _ in range(n)] for _ in range(m)]
    dp[0][0] = 1 - grid[0][0]
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                dp[i][j] = 0
            else:
                if i > 0:
                    dp[i][j] += dp[i - 1][j]
                if j > 0:
                    dp[i][j] += dp[i][j - 1]
    return dp[m - 1][n - 1]",148
20855922230,coin_change,"def coin_change(amount, coins):
    dp = [[0 for _ in range(amount + 1)] for _ in range(len(coins) + 1)]
    for i in range(len(coins) + 1):
        dp[i][0] = 1
    for i in range(1, len(coins) + 1):
        for j in range(1, amount + 1):
            if j >= coins[i - 1]:
                dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[-1][-1]",148
23726331439,tree_height,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def tree_height(root):
    if root is None:
        return -1  # A tree with no nodes has height -1
    else:
        left_height = tree_height(root.left)
        right_height = tree_height(root.right)
        return max(left_height, right_height) + 1

# Test the function
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

assert tree_height(root) == 2",148
12221572662,rearrange,"def rearrange(nums):
    positives, negatives, ans = [], [], []
    
    for i in nums:
        if i < 0:
            negatives.append(i)
        else:
            positives.append(i)
            
    i, j = 0, 0
    while i < len(positives) and j < len(negatives):
        ans.append(positives[i])
        ans.append(negatives[j])
        i += 1
        j += 1
        
    while i < len(positives):
        ans.append(positives[i])
        i += 1
        
    while j < len(negatives):
        ans.append(negatives[j])
        j += 1
        
    return ans",148
73466362556,find_missing_and_repeating,"def find_missing_and_repeating(A):
    n = len(A)
    
    sumac = (n*(n+1))//2
    sumsqac = ((n*(n+1))*(2*n+1))//6
    
    summ = 0
    sumsq = 0
    
    for i in range(n):
        sumsq += A[i]**2
        summ += A[i]
        
    diff = sumac - summ
    diffsq = sumsqac - sumsq
    
    xpy = diffsq//diff
    xpyd = (xpy+diff)//2
    xpydd = xpy-xpyd
    
    return [xpydd, xpyd]",148
29141621065,decode_count,"def decode_count(s: str) -> int:
    if len(s) == 0 or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] > '0':
            dp[i] = dp[i-1]
        if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] < '7'):
            dp[i] += dp[i-2]
    return dp[n]",148
28601607207,find_single_non_duplicate,"def find_single_non_duplicate(nums):
    lo = 0
    hi = len(nums) - 1   
    while lo < hi:
        mid = lo + (hi - lo) // 2
        halves_are_even = (hi - mid) % 2 == 0
        if nums[mid + 1] == nums[mid]:
            if halves_are_even:
                lo = mid + 2
            else:
                hi = mid - 1
        elif nums[mid - 1] == nums[mid]:
            if halves_are_even:
                hi = mid - 2
            else:
                lo = mid + 1
        else:
            return nums[mid]
    return nums[lo]",148
27046837642,longest_common_subsequence,"def longest_common_subsequence(X, Y):
    m = len(X)
    n = len(Y)
    L = [[0 for x in range(n+1)] for x in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif X[i-1] == Y[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])
    return L[m][n]",147
28188827197,largestRectangleArea,"def largestRectangleArea(heights):
    stack = []
    max_area = 0
    i = 0
    while i < len(heights):
        if not stack or heights[i] >= heights[stack[-1]]:
            stack.append(i)
            i += 1
        else:
            top = stack.pop()
            area = heights[top] * ((i - stack[-1] - 1) if stack else i)
            max_area = max(max_area, area)
    while stack:
        top = stack.pop()
        area = heights[top] * ((i - stack[-1] - 1) if stack else i)
        max_area = max(max_area, area)
    return max_area",147
16779578104,decimal_to_roman,"def decimal_to_roman(decimal):
    roman_numerals = [
        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),
        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),
        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')
    ]
    result = []
    for value, symbol in roman_numerals:
        while decimal >= value:
            decimal -= value
            result.append(symbol)
    return ''.join(result)",147
26187952479,longest_common_subsequence,"def longest_common_subsequence(x, y):
    m = len(x)
    n = len(y)

    L = [[0 for i in range(n+1)] for j in range(m+1)]

    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif x[i-1] == y[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])

    return L[m][n]",147
18633521759,wordBreak,"from typing import List

def wordBreak(s: str, wordDict: List[str]) -> bool:
    wset = set(wordDict)
    dp = [True] + [False]*len(s)
    for i in range(1,len(s)+1):
        for j in range(i):
            dp[i] |= (dp[j] and (s[j:i] in wset))
    return dp[len(s)]


if __name__ == ""__main__"":
    print(wordBreak(""leetcode"",[""leet"", ""code""]))
    print(wordBreak(""applepenapple"",[""apple"", ""pen""]))
    print(wordBreak(""catsandog"",[""cats"", ""dog"", ""sand"", ""and"", ""cat""]))",147
40366034380,largestRectangleArea,"def largestRectangleArea(heights):
    stack = []
    max_area = 0
    i = 0
    while i < len(heights):
        if not stack or heights[i] >= heights[stack[-1]]:
            stack.append(i)
            i += 1
        else:
            top = stack.pop()
            area = heights[top] * ((i - stack[-1] - 1) if stack else i)
            max_area = max(max_area, area)
    while stack:
        top = stack.pop()
        area = heights[top] * ((i - stack[-1] - 1) if stack else i)
        max_area = max(max_area, area)
    return max_area",147
15853395628,is_valid_arithmetic_expression,"def is_valid_arithmetic_expression(s: str) -> bool:
    stack = []
    prev_char = None

    for char in s:
        if char == ""("":
            stack.append(char)
        elif char == "")"":
            if not stack:
                return False
            stack.pop()
        elif char not in [""+"", ""-"", "" "", ""0"", ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""]:
            return False
        elif char in [""+"", ""-""] and (prev_char is None or prev_char in [""+"", ""-"", ""("", "" ""]):
            return False
        prev_char = char

    return len(stack) == 0",147
13128973294,num_Decodings,"def num_Decodings(s):
    if len(s) == 0 or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        oneDigit = int(s[i-1:i])
        twoDigits = int(s[i-2:i])
        if oneDigit >= 1:
            dp[i] += dp[i-1]
        if twoDigits >= 10 and twoDigits <= 26:
            dp[i] += dp[i-2]
    return dp[n]",147
6007294794,findSmallestGreater,"def findSmallestGreater(nums, target):
    low = 0 
    high = len(nums) - 1
    while low <= high:
        mid = (low + high) // 2
        if nums[mid] == target:
            if mid == len(nums)-1 and nums[mid] != nums[0]:
                return nums[0]
            elif nums[mid] != nums[mid+1]:
                return nums[mid+1]
            else:
                low = mid + 1
        elif nums[mid] > target:
            high = mid - 1
        else:
            low = mid + 1
                
    return nums[0] if low >= len(nums) else nums[low]",147
30554828186,myAtoi,"def myAtoi(s):
    ans = ''
    sig = """"
    for cher in s:
        if cher in ('-', '+', "" ""):
            if len(sig + ans) == 0:
                sig = cher if cher != ' ' else sig
            else: break
        elif cher.isnumeric():
            ans += cher
        else: break
    ans = 0 if len(ans) == 0 else int(ans)
    if ans > 2147483647:
        return -2147483648 if ""-"" in sig else 2147483647
    return -ans if ""-"" in sig else ans",147
38626057259,find_longest_common_subsequence,"def find_longest_common_subsequence(s1, s2):
    m = len(s1)
    n = len(s2)
    dp = [["""" for _ in range(n+1)] for _ in range(m+1)]
    
    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + s1[i-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)
                
    return dp[m][n]",147
8868820480,find_max_pairable,"from collections import Counter

def find_max_pairable(nums):
    c = Counter(nums)
    maxVal = -1
    for key, cnt in c.items():
        tempVal = -key
        if tempVal in c.keys():
            maxVal = max(maxVal, abs(key))
    return maxVal

if __name__ == ""__main__"":
    assert find_max_pairable([-3, 1, 2, 3, 4]) == 3
    assert find_max_pairable([1, 2, 3, -1, -2, -3]) == 3
    assert find_max_pairable([5, 6, -7, 8]) == -1",147
32916971194,count_subsets,"def count_subsets(arr, target):
    n = len(arr)
    dp = [[0] * (target + 1) for _ in range(n + 1)]
    for i in range(n + 1):
        dp[i][0] = 1
    for i in range(1, n + 1):
        for j in range(1, target + 1):
            if j < arr[i - 1]:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - arr[i - 1]]
    return dp[n][target]",147
13093660502,num_islands,"def num_islands(grid):
    def dfs(x, y):
        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != '1':
            return
        grid[x][y] = '#'  # mark as visited
        dfs(x+1, y)
        dfs(x-1, y)
        dfs(x, y+1)
        dfs(x, y-1)

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1
    return count",147
69884540478,longest_substring_with_2_unique_chars,"def longest_substring_with_2_unique_chars(s):
    if len(s) == 0:
        return 0
    left = 0
    right = 0
    max_len = 0
    char_index = {}
    while right < len(s):
        if s[right] in char_index:
            char_index[s[right]] = right
        else:
            if len(char_index) == 2:
                min_index = min(char_index.values())
                left = min_index + 1
                del char_index[s[min_index]]
            char_index[s[right]] = right
        max_len = max(max_len, right - left + 1)
        right += 1
    return max_len",147
26972627376,shortestSubarray,"from collections import deque
def shortestSubarray(A, K):
    queue, n, prefixSum, minLength = deque(), len(A), [0]*(len(A)+1), float('inf')
    for i in range(n):
        prefixSum[i+1] = prefixSum[i] + A[i]
    for i in range(n+1):
        while queue and prefixSum[i] - prefixSum[queue[0]] >= K:
            minLength = min(minLength, i - queue[0])
            queue.popleft()
        while queue and prefixSum[i] <= prefixSum[queue[-1]]:
            queue.pop()
        queue.append(i)
    return minLength if minLength != float('inf') else -1",147
14353834408,largest_rectangle_area,"def largest_rectangle_area(heights):
    stack = [-1]
    res = 0
    for i, h in enumerate(heights):
        while stack[-1] != -1 and h < heights[stack[-1]]:
            prev_i = stack.pop()
            prev_h = heights[prev_i]
            width = i - 1 - stack[-1]
            res = max(res, width * prev_h)
        stack.append(i)
    while stack[-1] != -1:
        prev_i = stack.pop()
        prev_h = heights[prev_i]
        width = len(heights) - stack[-1] - 1
        res = max(res, width * prev_h)
    return res",147
18973274847,convert,"def convert(s, numRows):
	l = len(s)
	times = 2*numRows - 2
	if times == 0:
		return s
	ansL = [''] * numRows
	
	for row in range(numRows):
		if row == 0 or row == numRows-1:
			for i in range(row, l, times):
				ansL[row] += s[i]
		else:
			for i in range(row, l, times):
				j = ((i//times)*2+1)*times-i
				if j < l:
					ansL[row] += s[i] + s[j]
				else:
					ansL[row] += s[i]
		
	return ''.join(ansL)",147
38901376060,kth_smallest_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i*i <= n:
        if n % i == 0 or n % (i+2) == 0:
            return False
        i += 6
    return True

def kth_smallest_prime(arr, k):
    primes = [i for i in arr if is_prime(i)]
    primes.sort()
    if k <= len(primes):
        return primes[k-1]
    else:
        return -1",146
33961336618,longest_equal_subsequence,"def longest_equal_subsequence(arr):
    max_length = 0
    max_subsequence = []
    current_length = 1
    current_subsequence = [arr[0]]
    for i in range(1, len(arr)):
        if arr[i] == arr[i-1]:
            current_length += 1
            current_subsequence.append(arr[i])
            if current_length > max_length:
                max_length = current_length
                max_subsequence = current_subsequence
        else:
            current_length = 1
            current_subsequence = [arr[i]]
            if current_length > max_length:
                max_length = current_length
                max_subsequence = current_subsequence
    return max_subsequence",146
25354152646,smallest_window_distinct_chars,"def smallest_window_distinct_chars(s):
    dist_count = len(set(s))
    start, start_index, min_len = 0, -1, float('inf')
    count = {}

    for j in range(len(s)):
        count[s[j]] = count.get(s[j], 0) + 1

        while len(count) == dist_count:
            if min_len > j - start + 1:
                min_len = j - start + 1
                start_index = start

            count[s[start]] -= 1
            if count[s[start]] == 0:
                del count[s[start]]
            start += 1
    return s[start_index : start_index + min_len]",146
4877651549,largest_rectangle,"def largest_rectangle(matrix):
    if not matrix: return 0
    n = len(matrix[0])
    height = [0] * (n + 1)
    max_area = 0
    for row in matrix:
        for i in range(n):
            height[i] = height[i] + 1 if row[i] == 1 else 0
        stack = [-1]
        for i in range(n + 1):
            while height[i] < height[stack[-1]]:
                h = height[stack.pop()]
                w = i - 1 - stack[-1]
                max_area = max(max_area, h * w)
            stack.append(i)
    return max_area",146
20063361232,convert_base,"def convert_base(num: str, from_base: int, to_base: int) -> str:
    # Convert from the from_base to base 10
    decimal = int(num, from_base)
    
    # Convert from base 10 to the to_base
    if to_base == 10:
        return str(decimal)
    else:
        result = """"
        while decimal > 0:
            remainder = decimal % to_base
            if remainder < 10:
                result = str(remainder) + result
            else:
                result = chr(remainder - 10 + ord('A')) + result
            decimal //= to_base
        return result if result else ""0""",146
25608491419,largest_rectangle,"def largest_rectangle(matrix):
    if not matrix: return 0
    n = len(matrix[0])
    height = [0] * (n + 1)
    max_area = 0
    for row in matrix:
        for i in range(n):
            height[i] = height[i] + 1 if row[i] == 1 else 0
        stack = [-1]
        for i in range(n + 1):
            while height[i] < height[stack[-1]]:
                h = height[stack.pop()]
                w = i - 1 - stack[-1]
                max_area = max(max_area, h * w)
            stack.append(i)
    return max_area",146
75093130686,find_lcs,"def find_lcs(s1, s2):
    m = len(s1)
    n = len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    return dp[m][n]",146
23461949876,word_segment,"def word_segment(s, wordDict):
    """"""
    :type s: str
    :type wordDict: List[str]
    :rtype: bool
    dpi 前i个元素为结尾的子串是否能拆分
    """"""
    if not wordDict:
        return False
    dp = [False for _ in range(len(s) + 1)]
    dp[0] = True
    wordDict = set(wordDict)
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break
    return dp[-1]",146
32661211759,topKFrequent,"from collections import Counter

def topKFrequent(nums, k):
    # nums에 등장하는 숫자 빈도수 중, 상위 k개까지 리스트에 담아 리턴한다
    result = []
    set_nums = Counter(nums)
    # 등장 빈도수 별로 내림차순 정렬(가장 많이 등장하는 상위 갯수부터 세므로)
    sorted_nums = sorted(set_nums.items(), reverse=True, key = lambda item : item[1])
    # 상위 k개까지 result 리스트에 담을 수 있도록한다 
    for s in range(k) :
        result.append(sorted_nums[s][0])
    return result",146
20789335131,reverse_integer,"def reverse_integer(x):
    reversed_x = 0
    while x != 0:
        digit = x % 10
        x = (x - digit) // 10
        if reversed_x > (2**31-1) // 10 or (reversed_x == (2**31-1) // 10 and digit > 7):
            return 0
        if reversed_x < (-2**31) // 10 or (reversed_x == (-2**31) // 10 and digit < -8):
            return 0
        reversed_x = reversed_x * 10 + digit
    return reversed_x",146
23264932676,count_rotations,"def count_rotations(arr):
    low = 0
    high = len(arr) - 1
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next = (mid + 1) % len(arr)
        prev = (mid - 1 + len(arr)) % len(arr)
        if arr[mid] <= arr[next] and arr[mid] <= arr[prev]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        elif arr[mid] >= arr[low]:
            low = mid + 1
    return 0",146
30991826757,word_ladder_length,"from collections import deque

def word_ladder_length(beginWord, endWord, wordList):
    wordList = set(wordList)
    if endWord not in wordList:
        return 0

    queue = deque([(beginWord, 1)])
    while queue:
        current_word, length = queue.popleft()
        for i in range(len(current_word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                next_word = current_word[:i] + c + current_word[i+1:]
                if next_word == endWord:
                    return length + 1
                if next_word in wordList:
                    queue.append((next_word, length + 1))
                    wordList.remove(next_word)
    return 0",146
22334642425,reformat_string,"def reformat_string(s: str) -> str:
    result = """"
    digits = []
    alpha = []
    for i in s:
        if i.isdigit():
            digits.append(i)
        else:
            alpha.append(i)
    if abs(len(alpha)-len(digits))<2:
        while digits and alpha:
            result += alpha.pop(0)
            result += digits.pop(0)
        if digits:
            result = digits[0] + result + digits[1:]
        elif alpha:
            result = alpha[0] + result + alpha[1:]
    elif len(alpha) > len(digits):
        result = """".join(alpha)
    else:
        result = """".join(digits)
    return result",146
13825865698,romanToInt,"def romanToInt(s):
    roman = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000,'IV':4,'IX':9,'XL':40,'XC':90,'CD':400,'CM':900}
    i = 0
    num = 0
    while i < len(s):
        if i+1<len(s) and s[i:i+2] in roman:
            num+=roman[s[i:i+2]]
            i+=2
        else:
            num+=roman[s[i]]
            i+=1
    return num",146
71596044791,max_visited_nodes,"from typing import List

def max_visited_nodes(edges: List[List[int]]) -> int:

    def dfs(u):
        stack = [u]
        vis = set()

        while stack:
            u = stack.pop()
            if u in vis:
                continue
            vis.add(u)
            for v in graph[u]:
                stack.append(v)
        
        return len(vis)

    n = len(edges) + 1
    graph = {i:[] for i in range(n)}

    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    ans = float('-inf')
    for node in graph:
        ans = max(ans, dfs(node))

    return ans",146
30529133807,max_xor,"class Solution(object):
    def findMaximumXOR(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        res, mask = 0, 0
        for i in range(31, -1, -1):
            mask |= (1 << i)
            tmpSet = set()
            for n in nums:
                tmpSet.add(n & mask)
            tmpRes = res | (1 << i)
            for pre in tmpSet:
                if tmpRes ^ pre in tmpSet:
                    res = tmpRes
                    break
        return res

def max_xor(nums):
    solution = Solution()
    return solution.findMaximumXOR(nums)",146
38286526036,max_overlapping_intervals,"def max_overlapping_intervals(intervals):
    start_times = []
    end_times = []
    for interval in intervals:
        start_times.append(interval[0])
        end_times.append(interval[1])
    start_times.sort()
    end_times.sort()
    max_overlaps = current_overlaps = 0
    start_index = end_index = 0
    while start_index < len(intervals):
        if start_times[start_index] < end_times[end_index]:
            current_overlaps += 1
            max_overlaps = max(max_overlaps, current_overlaps)
            start_index += 1
        else:
            current_overlaps -= 1
            end_index += 1
    return max_overlaps",146
7677031296,num_ways,"def num_ways(obstacleGrid):
    m = len(obstacleGrid)
    n = len(obstacleGrid[0])
    dp = [[0]*n for _ in range(m)]
    dp[0][0] = 1 - obstacleGrid[0][0]
    for i in range(m):
        for j in range(n):
            if obstacleGrid[i][j] == 1:
                dp[i][j] = 0
            else:
                if i > 0:
                    dp[i][j] += dp[i-1][j]
                if j > 0:
                    dp[i][j] += dp[i][j-1]
    return dp[-1][-1]",146
10457345913,num_ways,"def num_ways(s: str) -> int:
    if not s or (s[0] == '0'):
        return 0

    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1

    for i in range(2, n + 1):
        if s[i-1] > '0':
            dp[i] = dp[i-1]
        if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] < '7'):
            dp[i] += dp[i-2]

    return dp[n]",146
3553273623,is_symmetric,"# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_symmetric(root: TreeNode) -> bool:
    if root is None:
        return True
    return is_mirror(root.left, root.right)

def is_mirror(left: TreeNode, right: TreeNode) -> bool:
    if left is None and right is None:
        return True
    if left is None or right is None:
        return False
    return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left)",146
73333149582,find_lonely_pixel,"from collections import defaultdict

def find_lonely_pixel(picture):
    row_map, col_map, blacks = defaultdict(int), defaultdict(int), []
    for i in range(len(picture)):
        for j in range(len(picture[0])):
            if picture[i][j] == ""B"":
                row_map[i] += 1
                col_map[j] += 1
                if row_map[i] == 1 and col_map[j] == 1:
                    blacks.append((i, j))
    
    count = 0
    for i, j in blacks:
        if row_map[i] == 1 and col_map[j] == 1:
            count += 1
    return count",146
37049098989,reverse_vowels,"def reverse_vowels(s: str) -> str:
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    left = 0 
    right = len(s) - 1
    listStr = list(s)

    while left <right:
        if listStr[left] in vowels and listStr[right] in vowels:
            listStr[left], listStr[right] = listStr[right], listStr[left]
            left+=1
            right-=1
        elif listStr[left] in vowels and listStr[right] not in vowels:
            right -=1
        else:
            left+=1
        
    return ''.join(listStr)",146
3853117090,find_median,"from heapq import heappop, heappush

def find_median(nums):
    low, high = [], []
    for num in nums:
        if len(low) == 0 or num < -low[0]:
            heappush(low, -num)
        else:
            heappush(high, num)

        if len(low) > len(high) + 1:
            heappush(high, -heappop(low))
        elif len(high) > len(low):
            heappush(low, -heappop(high))

    if len(low) == len(high):
        return (-low[0] + high[0]) / 2
    else:
        return -low[0]",146
12234511180,lcs,"def lcs(X, Y):
    m = len(X)
    n = len(Y)
    L = [[0 for x in range(n+1)] for x in range(m+1)]
 
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif X[i-1] == Y[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])
    return L[m][n]",146
21808325132,missing_element,"def missing_element(nums, k):
    if not nums or k == 0:
        return 0
    diff = nums[-1] - nums[0] + 1
    missing = diff - len(nums)
    if missing < k:
        return nums[-1] + k - missing
    l, r = 0, len(nums) - 1
    while l + 1 < r:
        mid = (l + r) // 2
        missing = nums[mid] - nums[l] - (mid - l)
        if missing < k:
            l = mid
            k -= missing
        else:
            r = mid
    return nums[l] + k",146
19022844655,longest_common_subseq,"def longest_common_subseq(s1, s2):
    m = len(s1)
    n = len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]",146
15945142837,longest_palindrome_length,"from collections import Counter

def longest_palindrome_length(s):
    # Count the frequency of each character in the string
    char_count = Counter(s)

    # Keep track of the total length of the palindrome
    length = 0

    # Loop through the character counts
    for count in char_count.values():
        # Add the maximum even number less than or equal to the count to the length
        length += (count // 2) * 2

        # If the count is odd and we haven't added the center character yet, add it to the length
        if count % 2 == 1 and length % 2 == 0:
            length += 1

    return length",146
9217975392,can_reach_end,"def can_reach_end(nums):
    # 状态定义:dp[i]为当前位置可以跳到的最远点
    dp = [0] * len(nums)
    # 初始化
    dp[0] = nums[0]
    # 状态转移
    for i in range(1, len(nums)):
        if dp[i - 1] >= i:
            dp[i] = max(
                dp[i - 1]
                , i + nums[i]
            )
        else:
            dp[i] = dp[i - 1]

        if dp[i] >= len(nums) - 1:
            return True

    return dp[-1] >= len(nums) - 1",145
6963310468,decode_variations,"def decode_variations(s):
    if not s or s[0] == '0':
        return 0
    dp = [0] * (len(s) + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, len(s) + 1):
        if s[i - 1] > '0':
            dp[i] = dp[i - 1]
        if s[i - 2] == '1' or (s[i - 2] == '2' and s[i - 1] < '7'):
            dp[i] += dp[i - 2]
    return dp[len(s)]",145
71779493321,find_largest_in_window,"from collections import deque

def find_largest_in_window(nums, k):
    if not nums:
        return None

    ans = []
    max_queue = deque()
    for i in range(k):
        while max_queue and nums[i] >= nums[max_queue[-1]]:
            max_queue.pop()
        max_queue.append(i)

    ans.append(nums[max_queue[0]])

    for i in range(k, len(nums)):
        while max_queue and max_queue[0] <= i - k:
            max_queue.popleft()
        while max_queue and nums[i] >= nums[max_queue[-1]]:
            max_queue.pop()
        max_queue.append(i)
        ans.append(nums[max_queue[0]])

    return ans",145
16544687357,champernowne_digit,"def champernowne_digit(n):
    if n < 10:
        return n
    digit_length = 1
    while 9 * (10**(digit_length-1)) * digit_length < n:
        n -= 9 * (10**(digit_length-1)) * digit_length
        digit_length += 1
    quotient, remainder = divmod(n-1, digit_length)
    return int(str(10**digit_length + quotient)[remainder])

print(champernowne_digit(1)) # 1
print(champernowne_digit(11)) # 0
print(champernowne_digit(12)) # 1",145
36198057700,matrix_sum,"from collections import defaultdict

def matrix_sum(matrix, target):
    M, N = len(matrix), len(matrix[0])
    ans = 0
    for top in range(M):
        rowSums = [0] * N
        for bottom in range(top, M):
            for j in range(N):
                rowSums[j] += matrix[bottom][j]

            prefixSums = defaultdict(int)
            prefixSums[0] = 1
            currSum = 0
            for sum_j in rowSums:
                currSum += sum_j
                ans += prefixSums[currSum - target]
                prefixSums[currSum] += 1
    return ans",145
11922322953,min_jumps_to_end,"def min_jumps_to_end(arr):
    if len(arr) == 1:
        return 0
    if arr[0] == 0:
        return -1
    max_reach = arr[0]
    step = arr[0]
    jump = 1
    for i in range(1, len(arr)):
        if i == len(arr) - 1:
            return jump
        max_reach = max(max_reach, i + arr[i])
        step -= 1
        if step == 0:
            jump += 1
            step = max_reach - i
        if step + i >= len(arr):
            return jump
    return -1",145
6268570342,multi_str,"def multi_str(num1, num2):
    n1, n2 = len(num1), len(num2)
    res = [0] * (n1 + n2)

    for i in range(n1-1, -1, -1):
        for j in range(n2-1, -1, -1):
            mult = (ord(num1[i])-ord('0')) * (ord(num2[j])-ord('0')) + res[i+j+1]
            res[i+j+1] = mult % 10
            res[i+j] += mult // 10

    res_str = ''.join(map(str, res))
    return str(int(res_str))",145
16937861342,count_decodings,"def count_decodings(message):
    if not message or message[0] == '0':
        return 0
    
    n = len(message)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    
    for i in range(2, n + 1):
        one_digit = int(message[i-1:i])
        two_digits = int(message[i-2:i])
        
        if one_digit >= 1:
            dp[i] += dp[i-1]
        if two_digits >= 10 and two_digits <= 26:
            dp[i] += dp[i-2]
    
    return dp[n]",145
1832001889,lcs,"def lcs(X,Y):
    m = len(X)
    n = len(Y)
    L = [[0 for x in range(n+1)] for x in range(m+1)]
 
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif X[i-1] == Y[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])
    return L[m][n]",145
13661174671,ternary_search,"def ternary_search(arr, key):
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3

        if key == arr[mid1]:
            return mid1
        if key == arr[mid2]:
            return mid2

        if key < arr[mid1]:
            right = mid1 - 1
        elif key > arr[mid2]:
            left = mid2 + 1
        else:
            left = mid1 + 1
            right = mid2 - 1

    return -1",145
874150184,longest_palindrome_subsequence,"def longest_palindrome_subsequence(str1):
    str2 = str1[::-1]
    m = len(str1)
    n = len(str2)
    dp = [[0 for x in range(n+1)] for x in range(m+1)]
    
    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]",145
24361122491,jumps,"def jumps(nums):
    if len(nums) == 1:
        return 0
    if nums[0] == 0:
        return -1

    max_reach = nums[0]
    step = nums[0]
    jump = 1
    for i in range(1, len(nums)):
        if i == len(nums) - 1:
            return jump
        max_reach = max(max_reach, i + nums[i])
        step -= 1
        if step == 0:
            jump += 1
            step = max_reach - i
            if step + i > len(nums) - 1:
                return jump
    return -1",145
13436387109,findKthSmallestPrime,"from collections import Counter

def findKthSmallestPrime(arr, k):
    primes = []
    prime_count = Counter()
    is_prime = [True] * (max(arr) + 1)
    is_prime[0], is_prime[1] = False, False

    for i in range(2, len(is_prime)):
        if is_prime[i]:
            primes.append(i)
            for j in range(i*i, len(is_prime), i):
                is_prime[j] = False

    for num in arr:
        if is_prime[num]:
            prime_count[num] += 1

    primes_in_array = sorted(list(prime_count.keys()))

    return primes_in_array[k-1]",145
12502981218,find_longest_substring,"from collections import defaultdict

def find_longest_substring(s: str, k: int) -> int:
    window_start = 0
    max_length = 0
    char_frequency = defaultdict(int)

    for window_end in range(len(s)):
        right_char = s[window_end]
        char_frequency[right_char] += 1

        while len(char_frequency) > k:
            left_char = s[window_start]
            char_frequency[left_char] -= 1
            if char_frequency[left_char] == 0:
                del char_frequency[left_char]
            window_start += 1

        max_length = max(max_length, window_end - window_start + 1)
    return max_length",145
16571131040,count_subarrays,"def at_most_k_distinct(arr, k):
    count = {}
    i = 0
    res = 0
    for j in range(len(arr)):
        if arr[j] not in count:
            count[arr[j]] = 0
        count[arr[j]] += 1
        while len(count) > k:
            count[arr[i]] -= 1
            if count[arr[i]] == 0:
                del count[arr[i]]
            i += 1
        res += j - i + 1
    return res

def count_subarrays(arr, k):
    return at_most_k_distinct(arr, k) - at_most_k_distinct(arr, k-1)",145
15519742559,max_path_sum,"def max_path_sum(root):
    res = [-float('inf')]
    max_path(root, res)

    return res[0]


def max_path(node, res):
    if not node:
        return -float('inf')
    left_sum = max(max_path(node.left, res), 0)
    right_sum = max(max_path(node.right, res), 0)

    res[0] = max(res[0], node.val + left_sum + right_sum)

    return node.val + max(left_sum, right_sum)
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right",145
33753504458,min_score,"from collections import deque

def min_score(n, roads):
    res = int(1e9)
    graph = [[] for _ in range(n+1)]
    visited = [False] * (n + 1)

    for a, b, dist in roads:
        graph[a].append((b, dist))
        graph[b].append((a, dist))

    q = deque([1])
    visited[1] = True

    while q:
        v = q.popleft()

        for neigh, dist in graph[v]:
            res = min(res, dist)
            if not visited[neigh]:
                q.append(neigh)
                visited[neigh] = True
                
    return res",145
4128793246,is_valid_number,"def is_valid_number(s):
    try:
        float(s)
        return True
    except ValueError:
        try:
            if s[-1] in ['e', 'E']:
                return False
            int(s.split('.')[0])
            float(s.split('.')[1])
            if s[-2] in ['e', 'E']:
                int(s.split('e')[-1])
                return True
            elif s[-3] in ['e', 'E']:
                if s[-2] in ['+', '-']:
                    int(s.split('e')[-1])
                    return True
                else:
                    return False
            else:
                return False
        except (ValueError, IndexError):
            return False",145
22564899073,decode_ways,"def decode_ways(s):
    if not s:
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 0 if s[0] == '0' else 1

    for i in range(2, n + 1):
        single = int(s[i-1:i])
        double = int(s[i-2:i])
        if 1 <= single <= 9:
            dp[i] += dp[i-1]
        if 10 <= double <= 26:
            dp[i] += dp[i-2]

    return dp[n]",145
7435965246,longestCommonSubsequence,"def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]",145
12233537400,number_to_square,"def number_to_square(numbers):
    return {num: num * num for num in numbers}

# Test the function
assert number_to_square([1, 2, 3, 4]) == {1: 1, 2: 4, 3: 9, 4: 16}
assert number_to_square([5, 3, 9]) == {5: 25, 3: 9, 9: 81}
assert number_to_square([7, 0, 12]) == {7: 49, 0: 0, 12: 144}
print(""All test cases passed"")",144
13049197359,count_palindromic_substrings,"def count_palindromic_substrings(s):
    def count_palindromes_center(s, left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        total_count += count_palindromes_center(s, i, i)  # Odd length palindromes
        total_count += count_palindromes_center(s, i, i + 1)  # Even length palindromes
    return total_count",144
16989564758,find_median_sorted_arrays,"def find_median_sorted_arrays(nums1, nums2):
    nums = []
    i, j = 0, 0
    while i < len(nums1) and j < len(nums2):
        if nums1[i] < nums2[j]:
            nums.append(nums1[i])
            i += 1
        else:
            nums.append(nums2[j])
            j += 1
    nums += nums1[i:]
    nums += nums2[j:]
    n = len(nums)
    if n % 2 == 0:
        return (nums[n//2 - 1] + nums[n//2]) / 2.0
    else:
        return nums[n//2]",144
17270250668,count_prime_factors,"def count_prime_factors(num: int) -> int:
    if num < 2:
        return 0
    factors = set()
    # Check for 2 as a factor
    while num % 2 == 0:
        factors.add(2)
        num = num // 2
    # Check for odd factors
    for i in range(3, int(num**0.5) + 1, 2):
        while num % i == 0:
            factors.add(i)
            num = num // i
    # Check if num is a prime number greater than 2
    if num > 2:
        factors.add(num)
    return len(factors)",144
6085659807,total_trapped_water,"def total_trapped_water(height):
    if len(height) <= 2:
        return 0

    left, right = 0, len(height) - 1
    left_max, right_max = height[left], height[right]
    water = 0

    while left < right:
        if height[left] < height[right]:
            if height[left] >= left_max:
                left_max = height[left]
            else:
                water += left_max - height[left]
            left += 1
        else:
            if height[right] >= right_max:
                right_max = height[right]
            else:
                water += right_max - height[right]
            right -= 1

    return water",144
30138179195,findLongestCommonSubsequence,"def findLongestCommonSubsequence(X, Y):
    m = len(X)
    n = len(Y)
    L = [[None]*(n+1) for i in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif X[i-1] == Y[j-1]:
                L[i][j] = L[i-1][j-1]+1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])
    return L[m][n]",144
13296952745,ways_to_change,"def ways_to_change(n: int) -> int:
    if n == 0:
        return 0
    l = [[1 for _ in range(n+1)] for i in range(4)]
    c = [1,5,10,25]
    for i in range(1,4):
        for j in range(1,n+1):
            if j < c[i]:
                l[i][j] = l[i-1][j]
            else:
                l[i][j] = l[i-1][j] + l[i][j-c[i]]
    return l[-1][-1] % 1000000007",144
40498869834,count_islands,"def count_islands(grid):
    def dfs(i, j):
        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != 1:
            return
        grid[i][j] = 0
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
    
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                dfs(i, j)
                count += 1
    return count",144
3683458858,str_to_float_list,"def str_to_float_list(test_str):
    return list(map(float, test_str[1:-1].split("", "")))

if __name__ == ""__main__"":
    assert str_to_float_list(""[1.1, 2.2, 3.3]"") == [1.1, 2.2, 3.3]
    assert str_to_float_list(""[4.4, 5.5, 6.6]"") == [4.4, 5.5, 6.6]
    assert str_to_float_list(""[7.7, 8.8, 9.9]"") == [7.7, 8.8, 9.9]",144
38099473962,count_palindromes,"def count_palindromes(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_palindromes = 0
    for i in range(len(s)):
        # Count odd length palindromes
        total_palindromes += expand_around_center(i, i)
        # Count even length palindromes
        total_palindromes += expand_around_center(i, i + 1)

    return total_palindromes",144
34031367827,numIslands,"def numIslands(grid):
    def dfs(i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':
            return
        grid[i][j] = '#' # Mark as visited
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1
    return count",144
10078926727,count_palindromic_substrings,"def count_palindromic_substrings(s: str) -> int:
    def expand_around_center(left: int, right: int) -> int:
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        total_count += expand_around_center(i, i)  # Odd length palindromes
        total_count += expand_around_center(i, i + 1)  # Even length palindromes
    return total_count",144
15185713117,lcs_length,"def lcs_length(X, Y): 
    m = len(X)
    n = len(Y)
    L = [[None]*(n+1) for i in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0 :
                L[i][j] = 0
            elif X[i-1] == Y[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])
    return L[m][n]",144
10288682996,sort_even,"def sort_even(lst):
    return sorted([i for i in lst if i % 2 == 0])

# Test cases
assert sort_even([9, 2, 7, 4, 5, 6]) == [2, 4, 6]
assert sort_even([1, 3, 5, 7, 9]) == []
assert sort_even([8, 6, 4, 2, 0, -2, -4, -6, -8, -10]) == [-10, -8, -6, -4, -2, 0, 2, 4, 6, 8]",144
2593989530,longest_common_subsequence,"def longest_common_subsequence(X, Y):
    m = len(X)
    n = len(Y)
    L = [[None]*(n+1) for i in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif X[i-1] == Y[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])
    return L[m][n]",144
70100896940,find_longest_unique_substring,"def find_longest_unique_substring(s):
    start, max_len, start_index, visited = 0, 0, 0, [False for _ in range(256)]
    for i in range(len(s)):
        if visited[ord(s[i])] == True:
            while s[i] != s[start]:
                visited[ord(s[start])] = False
                start += 1
            start += 1
        else:
            visited[ord(s[i])] = True
        if max_len < i - start + 1:
            max_len = i - start + 1
            start_index = start
    return s[start_index:start_index + max_len]",143
7835005270,min_jumps,"def min_jumps(arr):
    if len(arr) <= 1:
        return 0
    if arr[0] == 0:
        return -1
    max_reach = arr[0]
    step = arr[0]
    jump = 1
    for i in range(1, len(arr)):
        if i == len(arr) - 1:
            return jump
        max_reach = max(max_reach, i + arr[i])
        step -= 1
        if step == 0:
            jump += 1
            if i >= max_reach:
                return -1
            step = max_reach - i
    return -1",143
20001254544,count_arithmetic_slices,"from collections import defaultdict

def count_arithmetic_slices(arr):
    """"""
    Counts the total number of arithmetic subsequences in the given list.

    Parameters:
    arr (list): A list of integers.

    Returns:
    int: The total count of arithmetic subsequences.
    """"""
    dp = [defaultdict(int) for _ in range(len(arr))]
    total = 0
    for i in range(len(arr)):
        for j in range(i):
            diff = arr[i] - arr[j]
            dp[i][diff] += 1
            if diff in dp[j]:
                dp[i][diff] += dp[j][diff]
                total += dp[j][diff]
    return total",143
22369499981,num_islands,"def num_islands(grid):
    def dfs(i, j):
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':
            return
        grid[i][j] = '0'
        dfs(i-1, j)
        dfs(i+1, j)
        dfs(i, j-1)
        dfs(i, j+1)
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1
    return count",143
26331593518,max_vowels,"def max_vowels(s: str, k: int) -> int:
    vowels = ['a', 'e', 'i', 'o', 'u']
    count, max_vowels = 0, 0
    for i in range(k):
        if s[i] in vowels:
            count += 1
    max_vowels = max(max_vowels, count)
    for i in range(k, len(s)):
        if s[i] in vowels:
            count += 1
        if s[i - k] in vowels:
            count -= 1
        max_vowels = max(max_vowels, count)
    return max_vowels",143
13959485487,quick_sort,"def quick_sort(array):
    def quick_fn(left, right):
        if left >= right:
            return
        pivot_idx = partition(left, right)
        quick_fn(left, pivot_idx - 1)
        quick_fn(pivot_idx + 1, right)

    def partition(left, right):
        pivot = array[right]
        idx = left
        for i in range(left, right):
            if array[i] < pivot:
                array[idx], array[i] = array[i], array[idx]
                idx += 1
        array[idx], array[right] = array[right], array[idx]
        return idx

    quick_fn(0, len(array) - 1)
    return array",143
14012927225,generate_pascal_triangle,"class Solution:
    res = []

    def search(self, row, all_rows):
        if row == all_rows:
            return
        arr = [1] * (row + 1)
        for i in range(1, row):
            arr[i] = self.res[row - 1][i - 1] + self.res[row - 1][i]
        self.res.append(arr)
        self.search(row + 1, all_rows)

    def generate_pascal_triangle(self, numRows):
        self.res.clear()

        self.search(0, numRows)

        return self.res
sol = Solution()
def generate_pascal_triangle(numRows):
	return sol.generate_pascal_triangle(numRows)",143
12190193540,local_maxima_count,"from typing import List

def local_maxima_count(list: List[int]) -> int:
  count = 0
  for i in range(1, len(list) - 1):
    if list[i] > list[i - 1] and list[i] > list[i + 1]:
      count += 1

  return count

print(local_maxima_count([1, 2, 3, 2, 1])) # 1
print(local_maxima_count([1, 3, 2, 4, 3])) # 2
print(local_maxima_count([1, 1, 1, 1, 1])) # 0",143
29046592551,num_decodings,"def num_decodings(s: str) -> int:
    if not s or s[0] == '0':
        return 0
    dp = [0] * (len(s) + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, len(s) + 1):
        single = int(s[i-1:i])
        double = int(s[i-2:i])
        if 1 <= single <= 9:
            dp[i] += dp[i-1]
        if 10 <= double <= 26:
            dp[i] += dp[i-2]
    return dp[-1]",143
1300439188,number_of_islands,"def number_of_islands(grid):
    def dfs(i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != 1:
            return
        grid[i][j] = 0
        dfs(i-1, j)
        dfs(i+1, j)
        dfs(i, j-1)
        dfs(i, j+1)
    
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                dfs(i, j)
                count += 1
    return count",143
41925597723,min_jumps,"def min_jumps(arr):
    if len(arr) <= 1:
        return 0
    if arr[0] == 0:
        return -1

    max_reach = arr[0]
    step = arr[0]
    jump = 1

    for i in range(1, len(arr)):
        if i == len(arr) - 1:
            return jump

        max_reach = max(max_reach, i + arr[i])
        step -= 1

        if step == 0:
            jump += 1
            if i >= max_reach:
                return -1
            step = max_reach - i

    return -1",143
36845242418,substring_k_distinct,"def substring_k_distinct(s, k):
    if not s or k <= 0:
        return 0
    start = 0
    end = 0
    max_length = 0
    char_map = {}
    while end < len(s):
        char_map[s[end]] = char_map.get(s[end], 0) + 1
        while len(char_map) > k:
            char_map[s[start]] -= 1
            if char_map[s[start]] == 0:
                del char_map[s[start]]
            start += 1
        max_length = max(max_length, end - start + 1)
        end += 1
    return max_length",143
35354271769,longest_common_subsequence,"def longest_common_subsequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [["""" for _ in range(n+1)] for _ in range(m+1)]

    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + str1[i-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)
    
    return dp[m][n]",143
29266882156,repeat_elements,"def repeat_elements(input_list, n):
    return [item for item in input_list for _ in range(n)]

print(repeat_elements([1, 2, 3], 2))  # [1, 1, 2, 2, 3, 3]
print(repeat_elements([0, 1], 4))  # [0, 0, 0, 0, 1, 1, 1, 1]
print(repeat_elements(['a', 'b', 'c'], 3))  # ['a', 'a', 'a', 'b', 'b', 'b', 'c', 'c', 'c']",143
13975203704,max_subarray_product,"def max_subarray_product(nums):
    # dp
    # maintain max and min of substring
    # if zero set max and min to 1
    # return max
        
    res = max(nums)
    currMax, currMin = 1, 1
        
    for num in nums:
        if num == 0:
            currMax = 1
            currMin = 1
        else:
            temp = max((num * currMin), (num * currMax), num)
            currMin = min((num * currMin), (num * currMax), num)
            currMax = temp
            res = max(res, currMax)
            
    return res",142
39766147836,longest_palindromic_subseq,"def longest_palindromic_subseq(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][n - 1]",142
786025828,find_LCS,"def find_LCS(s1, s2):
    m, n = len(s1), len(s2)
    dp = [["""" for _ in range(n+1)] for _ in range(m+1)]
    
    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + s1[i-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)
    return dp[m][n]",142
72463105908,next_permutation,"def next_permutation(nums):
    n = len(nums)
    i = n - 2
    while i >= 0 and nums[i] >= nums[i + 1]:
        i -= 1
    if i >= 0:
        j = n - 1
        while j >= 0 and nums[j] <= nums[i]:
            j -= 1
        nums[i], nums[j] = nums[j], nums[i]
    left, right = i + 1, n - 1
    while left < right:
        nums[left], nums[right] = nums[right], nums[left]
        left += 1
        right -= 1
    return nums",142
20064571732,split_ip,"def split_ip(s):
    def backtrack(start, tmp_res, k):
        if k < 0: return
        if start == len(s) and k == 0:
            res.append(tmp_res[:-1])
            return
        for i in range(start, min(start + 3, len(s))):
            if (i > start and s[start] == '0') or (i >= start + 1 and int(s[start:i+1]) > 255):
                continue
            backtrack(i + 1, tmp_res + s[start:i+1] + '.', k - 1)

    res = []
    backtrack(0, """", 4)
    return res",142
71439443830,lcs,"def lcs(X, Y):
    m = len(X)
    n = len(Y)
 
    L = [[None]*(n+1) for i in range(m+1)]
 
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0 :
                L[i][j] = 0
            elif X[i-1] == Y[j-1]:
                L[i][j] = L[i-1][j-1]+1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])
    return L[m][n]",142
33838075572,jump,"def jump(nums: list[int]) -> int:
    n, ans, i = len(nums), 0, 0
    if len(nums) < 2:
        return 0
    max_reach, step, jump = nums[0], nums[0], 1
    for i in range(1, n):
        if i == n - 1:
            return jump
        max_reach = max(max_reach, i + nums[i])
        step -= 1
        if step == 0:
            jump += 1
            if i >= max_reach:
                return -1
            step = max_reach - i
    return jump",142
27471313417,longest_common_subsequence,"def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [["""" for _ in range(n+1)] for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + s1[i-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)
    return dp[m][n]",142
4494104744,longestCommonSubsequence,"def longestCommonSubsequence(text1: str, text2: str) -> int:
    m, n = len(text1), len(text2)
    dp = [[0] * (n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]",142
71105901011,combinationSum2,"def combinationSum2(arr, target):
    def f(ind, sum, temp, target, n, arr, ans):
        if sum == target:
            ans.append(temp[:])
            return
        if ind == n or sum > target:
            return
        for i in range(ind, n):
            if i > ind and arr[i] == arr[i - 1]:
                continue
            temp.append(arr[i])
            f(i + 1, sum + arr[i], temp, target, n, arr, ans)
            temp.pop()

    arr.sort()
    ans = []
    f(0, 0, [], target, len(arr), arr, ans)
    return ans",142
71050013166,find_kth_number,"def find_kth_number(n: int, k: int) -> int:
    def get_steps(cur, n):
        steps, first, last = 0, cur, cur
        while first <= n:
            steps += min(last, n) - first + 1
            first *= 10
            last = last * 10 + 9
        return steps
    
    curr = 1
    k -= 1
    while k:
        steps = get_steps(curr, n)
        if steps <= k:
            k -= steps
            curr += 1
        else:
            curr *= 10
            k -= 1
    return curr",142
28452852125,longest_palindromic_subsequence,"def longest_palindromic_subsequence(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][n - 1]",142
3458894481,reverse_vowels,"def reverse_vowels(s):
    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
    s_list = list(s)
    start = 0
    end = len(s_list) - 1
    while start < end:
        if s_list[start] not in vowels:
            start += 1
        elif s_list[end] not in vowels:
            end -= 1
        else:
            s_list[start], s_list[end] = s_list[end], s_list[start]
            start += 1
            end -= 1
    return ''.join(s_list)",142
20272105664,max_diff,"def max_diff(arr):
    # Initialize max_diff and min_element
    max_diff = arr[1] - arr[0]
    min_element = arr[0]
    # Loop over the array from index 1 to the end
    for i in range(1, len(arr)):
        # If the current element minus the min_element is greater than max_diff,
        # update max_diff
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        # If the current element is less than the min_element, update min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",142
22525939767,shortestSubarray,"import heapq

def shortestSubarray(A: [int], K: int) -> int:
    heap = [(0,-1)] # (runSum, index)
    runSum = 0 # running sum
    shortest = float('inf')
    for i in range(len(A)):
        n = A[i]
        runSum += n
        while heap and runSum-heap[0][0] >= K:
            mostRecentIdx = heapq.heappop(heap)[1]
            shortest = min(shortest, i-mostRecentIdx)
        heapq.heappush(heap, (runSum, i))
            
    if shortest == float('inf'):
        return -1
        
    return shortest",142
5361493688,is_stack_sequence,"def is_stack_sequence(pushed, popped):
    """"""
    Check if the popped sequence can be obtained from the pushed sequence
    by performing push and pop operations on a stack.
    
    :param pushed: List[int]. The sequence of elements pushed into the stack.
    :param popped: List[int]. The sequence of elements popped from the stack.
    :return: bool. True if the popped sequence can be obtained, False otherwise.
    """"""
    stack = []
    j = 0
    for x in pushed:
        stack.append(x)
        while stack and stack[-1] == popped[j]:
            stack.pop()
            j += 1
    return len(stack) == 0",142
34425219398,shortest_string,"from itertools import permutations

def shortest_string(arr):
    def merge(s1, s2):
        if s1 in s2:
            return s2
        for i in range(len(s2)):
            if s1.startswith(s2[i:]):
                return s2[:i] + s1
        return s2 + s1
    
    res = ""a"" * 999
    for perm in permutations(arr):
        s = merge(perm[0], merge(perm[1], perm[2]))
        if len(s) < len(res):
            res = s
        elif len(s) == len(res):
            res = min(s, res)
    return res",142
72484826104,num_ways_to_reach_last_cell,"def num_ways_to_reach_last_cell(m: int, n: int) -> int:
    if m == 1 or n == 1:
        return 1
    dp = [[0 for _ in range(n)] for _ in range(m)]
    for i in range(m):
        dp[i][0] = 1
    for j in range(n):
        dp[0][j] = 1
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[m-1][n-1]",142
32013904146,lcs,"def lcs(s1, s2):
    m, n = len(s1), len(s2)
    dp = [["""" for _ in range(n+1)] for _ in range(m+1)]
    
    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + s1[i-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)
    
    return dp[m][n]",142
34574563315,find_min_jumps,"def find_min_jumps(arr):
    n = len(arr)
    if n <= 1:
        return 0
    if arr[0] == 0:
        return float('inf')
    max_reach = arr[0]
    step = arr[0]
    jump = 1
    for i in range(1, n):
        if i == n - 1:
            return jump
        max_reach = max(max_reach, i + arr[i])
        step -= 1
        if step == 0:
            jump += 1
            if i >= max_reach:
                return float('inf')
            step = max_reach - i",142
74653887153,next_permutation,"def next_permutation(nums):
    n = len(nums)
    i = n - 2
    while i >= 0 and nums[i] >= nums[i + 1]:
        i -= 1

    if i >= 0:
        j = n - 1
        while j >= 0 and nums[j] <= nums[i]:
            j -= 1
        nums[i], nums[j] = nums[j], nums[i]

    left, right = i + 1, n - 1
    while left < right:
        nums[left], nums[right] = nums[right], nums[left]
        left += 1
        right -= 1

    return nums",142
4309337783,longest_palindromic_substring,"def longest_palindromic_substring(s: str) -> str:
    def expand_around_center(left: int, right: int) -> str:
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]

    if len(s) < 2 or s == s[::-1]:
        return s

    result = """"
    for i in range(len(s) - 1):
        result = max(result, expand_around_center(i, i + 1), expand_around_center(i, i + 2), key=len)

    return result",142
73965270520,min_remove_to_make_valid,"from collections import defaultdict
from collections import deque

def min_remove_to_make_valid(s: str) -> str:
    char_map = defaultdict(str)
    stack = deque()
    for i, char in enumerate(s):
        char_map[i] = char
    for i, char in enumerate(s):
        if char == '(': stack.append(i)
        if char == ')':
            if stack:
                last_index = stack.pop()
                if char_map[last_index] != '(':
                    char_map[i] = ''
            else:
                char_map[i] = ''
    while stack:
        last_index = stack.pop()
        char_map[last_index] = ''
    return ''.join(char_map.values())",142
17739105536,longest_palindromic_subsequence,"def longest_palindromic_subsequence(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][n - 1]",142
35117726618,longest_palindrome_subseq,"def longest_palindrome_subseq(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
                
    return dp[0][n - 1]",142
43460371126,max_envelopes,"def max_envelopes(envs):
    envs = sorted(envs, key=lambda x:(x[0], -x[1]))
    h = [env[1] for env in envs]

    def lis(h):
        res = 0
        len_h = len(h)
        if len_h == 0:
            return 0
        dp = [1] * len_h
        for i in range(len_h):
            for j in range(i):
                if h[j] < h[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
            res = max(res, dp[i])
        return res

    return lis(h)",142
18588192131,longest_palindromic_subsequence,"def longest_palindromic_subsequence(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]

    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][n - 1]",142
2498656601,longest_palindromic_subsequence,"def longest_palindromic_subsequence(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]

    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    return dp[0][n - 1]",142
13333026117,next_permutation,"def next_permutation(nums):
    n = len(nums)
    i = n - 2
    while i >= 0 and nums[i] >= nums[i + 1]:
        i -= 1
    if i >= 0:
        j = n - 1
        while j >= 0 and nums[j] <= nums[i]:
            j -= 1
        nums[i], nums[j] = nums[j], nums[i]
    left, right = i + 1, n - 1
    while left < right:
        nums[left], nums[right] = nums[right], nums[left]
        left += 1
        right -= 1
    return nums",142
73725809752,longest_subarray_equal_zeros_ones,"def longest_subarray_equal_zeros_ones(arr):
    diff, max_len, sum_val, hash_map = -1, 0, 0, {}
    for i in range(len(arr)):
        sum_val += 1 if arr[i] == 1 else -1
        if sum_val == 0:
            max_len = i + 1
        if sum_val not in hash_map:
            hash_map[sum_val] = i
        elif diff == sum_val - hash_map[sum_val]:
            continue
        else:
            max_len = max(max_len, i-hash_map[sum_val])
            diff = sum_val-hash_map[sum_val]
    return max_len",142
10665938111,findBestValue,"def findBestValue(arr: list[int], target: int) -> int:
    low = 0
    high = max(arr)
    
    closest_diff = target
    best_value = 0
    
    while low <= high:
        mid = (low + high) // 2
        total = sum([min(x, mid) for x in arr])
        
        diff = abs(total - target)
        if diff < closest_diff or diff == closest_diff and mid < best_value:
            closest_diff = diff
            best_value = mid
            
        if total < target:
            low = mid + 1
        else:
            high = mid - 1
    
    return best_value",142
14790258599,num_islands,"def num_islands(grid):
    def dfs(i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':
            return
        grid[i][j] = '0'
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
        
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1
    return count",142
14558278949,count_unique_pairs,"def count_unique_pairs(arr,target):
    arr.sort()
    left, right = 0, len(arr) - 1
    count = 0
    while left < right:
        if arr[left] + arr[right] == target:
            count += 1
            left += 1
            right -= 1
            while left < right and arr[left] == arr[left - 1]:
                left += 1
            while left < right and arr[right] == arr[right + 1]:
                right -= 1
        elif arr[left] + arr[right] < target:
            left += 1
        else:
            right -= 1
    return count",142
71963255153,third_max,"def third_max(nums):
    # remove duplicates by converting to a set and back to a list
    nums = list(set(nums))
    # if less than 3 items, return max
    if len(nums) < 3:
        return max(nums)
    # iterate through the list and remove the maximum 2 times
    for _ in range(2):
        max_num = nums[0]
        max_idx = 0
        for i in range(1, len(nums)):
            if nums[i] > max_num:
                max_num = nums[i]
                max_idx = i
        nums.pop(max_idx)
    # return the third max
    return max(nums)",141
35732553684,calculate_hcf,"def calculate_hcf(x, y):
    if x > y:
        smaller = y
    else:
        smaller = x
    for i in range(1, smaller+1):
        if((x % i == 0) and (y % i == 0)):
            hcf = i
    return hcf

# Test the function with the given test cases
print(calculate_hcf(3, 5))  # Expected output: 1
print(calculate_hcf(25, 15))  # Expected output: 5
print(calculate_hcf(100, 75))  # Expected output: 25",141
73195119670,findNextGreatest,"def findNextGreatest(elements, target):
    l, r = 0, len(elements) - 1
    while l <= r:
        mid = (l + r) // 2
        if elements[mid] == target:
            while mid < len(elements) and elements[mid] == target:
                mid += 1
            if mid < len(elements):
                return elements[mid]
            else:
                return elements[0]
        elif elements[mid] > target:
            r = mid - 1
        else:
            l = mid + 1
    if elements[-1] > target:
        return elements[l]
    else:
        return elements[0]",141
43021273314,find_lcs,"def find_lcs(s1, s2):
  m, n = len(s1), len(s2)
  dp = [["""" for _ in range(n+1)] for _ in range(m+1)]
  for i in range(1, m+1):
    for j in range(1, n+1):
      if s1[i-1] == s2[j-1]:
        dp[i][j] = dp[i-1][j-1] + s1[i-1]
      else:
        dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)
  return dp[m][n]",141
37284460745,count_palindrome_substrings,"def count_palindrome_substrings(s):
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    count = 0

    for length in range(n):
        for start in range(n - length):
            end = start + length
            if length == 0:
                dp[start][end] = True
            elif length == 1:
                dp[start][end] = (s[start] == s[end])
            else:
                dp[start][end] = (s[start] == s[end]) and dp[start + 1][end - 1]

            if dp[start][end]:
                count += 1

    return count",141
20352693397,largest_divisible_subset,"def largest_divisible_subset(nums):
    n = len(nums)
    nums.sort()
    dp = [1]*n
    hash = [i for i in range(n)]
    for i in range(1, n):
        for j in range(i):
            if nums[i]%nums[j] == 0 and dp[i] < dp[j]+1:
                dp[i] = dp[j]+1
                hash[i] = j
    maxLen = max(dp)
    index = dp.index(maxLen)
    res = []
    while index != hash[index]:
        res.append(nums[index])
        index = hash[index]
    res.append(nums[index])
    return res[::-1]",141
70205784994,max_value_with_swaps,"def max_value_with_swaps(arr, k):
    n = len(arr)
    if n == 1 or k == 0:
        return arr[0]
    
    max_val = [arr[0]] * n
    for i in range(1, n):
        max_val[i] = max(arr[i], max_val[i-1])
    
    result = arr[0]
    for i in range(1, n):
        if k > 0:
            result = max(result, max_val[min(i+k, n-1)])
            max_val[i] = max(max_val[i], result)
        else:
            result = max_val[i]
    
    return result",141
11603446841,numWays,"def numWays(m, n):
    MOD = 10**9 + 7
    dp = [[0 for _ in range(n)] for _ in range(m)]
    dp[0][0] = 1
    for i in range(m):
        for j in range(n):
            if i == 0 and j == 0:
                continue
            up = dp[i-1][j] if i > 0 else 0
            left = dp[i][j-1] if j > 0 else 0
            dp[i][j] = (up + left) % MOD
    return dp[m-1][n-1]",141
36043898171,decode_message,"def decode_message(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n+1):
        single_digit = int(s[i-1:i])
        double_digit = int(s[i-2:i])
        if 1 <= single_digit <= 9:
            dp[i] += dp[i-1]
        if 10 <= double_digit <= 26:
            dp[i] += dp[i-2]
    return dp[n]",141
42321107256,find_longest_palindromic_subsequence,"def find_longest_palindromic_subsequence(text):
    n = len(text)
    dp = [[0 for _ in range(n)] for _ in range(n)]

    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if text[i] == text[j]:
                dp[i][j] = 2 + dp[i + 1][j - 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    return dp[0][n - 1]",141
38359856707,decode_message,"def decode_message(s: str) -> int:
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i - 1] != '0':
            dp[i] += dp[i - 1]
        two_digit = int(s[i - 2: i])
        if 10 <= two_digit <= 26:
            dp[i] += dp[i - 2]
    return dp[n]",141
72101338987,count_decodings,"def count_decodings(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2, n + 1):
        single = int(s[i-1:i])
        double = int(s[i-2:i])
        if 1 <= single <= 9:
            dp[i] += dp[i-1]
        if 10 <= double <= 26:
            dp[i] += dp[i-2]
    return dp[n]",141
22957952853,combinations,"def combinations(n_list, k):
    def find_combinations(start, k):
        if k == 0:
            return [[]]
        combinations = []
        for i in range(start, len(n_list)):
            current_combinations = find_combinations(i + 1, k - 1)
            for combination in current_combinations:
                combinations.append([n_list[i]] + combination)
        return combinations

    return find_combinations(0, k)

print(combinations([1,2,3,4],2))
print(combinations([1,2,3,4,5],3))
print(combinations([1,2,3,4,5,6],4))",141
108685579,calculate_ways,"def calculate_ways(m, n):
    # Initialize a 2D array with zeros
    dp = [[0 for _ in range(n)] for _ in range(m)]

    # Set the first cell to 1
    dp[0][0] = 1

    # Fill the dp array
    for i in range(m):
        for j in range(n):
            if i > 0:
                dp[i][j] += dp[i-1][j]
            if j > 0:
                dp[i][j] += dp[i][j-1]

    # Return the value in the last cell
    return dp[m-1][n-1]",141
38914950440,count_palindromes,"def count_palindromes(s):
    n = len(s)
    count = 0
    for i in range(n):
        # odd length palindromes
        l, r = i, i
        while l >= 0 and r < n and s[l] == s[r]:
            count += 1
            l -= 1
            r += 1
        # even length palindromes
        l, r = i, i + 1
        while l >= 0 and r < n and s[l] == s[r]:
            count += 1
            l -= 1
            r += 1
    return count",141
24532683192,max_divisible_subset,"from collections import deque

def max_divisible_subset(nums):
    nums.sort()
    
    q=deque()
    for i in range(len(nums)):
        q.append([[nums[i]],i])
    
    visited=[0]*len(nums)
    
    ans=-1
    ret=[]
    while q:
        path,idx=q.pop()
        if len(path)>ans:
            ans=len(path)
            ret=path
        
        if visited[idx]>=len(path):
            continue
                
        visited[idx]=len(path)
        
        for next in range(idx+1,len(nums)):
            if nums[next]%path[-1]==0:
                q.append([path+[nums[next]],next])
    
    return len(ret)",141
23462248466,can_split,"def can_split(nums):
    total = sum(nums)
    if total % 2 == 1:
        return False
    target = total // 2
    nums.sort(reverse=True)
    pre_lookup = set([0])
    for i in range(len(nums)):
        if nums[i] == target:
            return True
        if nums[i] > target:
            continue
        now_lookup = set()
        now_lookup.update(pre_lookup)
        for item in pre_lookup:
            if item + nums[i] == target:
                return True
            if item + nums[i] < target:
                now_lookup.add(item + nums[i])
        pre_lookup = now_lookup
    return False",141
17489990833,longest_non_repeating_substring,"def longest_non_repeating_substring(s):
    """"""
    Find the longest substring without repeating characters in a given string.
    """"""
    if not s:
        return """"

    char_index = {}
    start = 0
    longest = 0
    longest_start = 0

    for i, char in enumerate(s):
        if char in char_index and char_index[char] >= start:
            start = char_index[char] + 1
        char_index[char] = i

        if i - start + 1 > longest:
            longest = i - start + 1
            longest_start = start

    return s[longest_start:longest_start + longest]",141
35186697731,decode_Ways,"def decode_Ways(s):
    if not s or s[0] == '0': return 0
    dp = [0] * (len(s) + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, len(s) + 1):
        one_digit = int(s[i-1:i])
        two_digit = int(s[i-2:i])
        if one_digit >= 1:
            dp[i] += dp[i-1]
        if two_digit >= 10 and two_digit <= 26:
            dp[i] += dp[i-2]
    return dp[len(s)]",141
8821140529,count_palindromes,"def count_palindromes(s):
    n = len(s)
    count = 0
    for i in range(n):
        # odd length palindromes
        l, r = i, i
        while l >= 0 and r < n and s[l] == s[r]:
            count += 1
            l -= 1
            r += 1
        # even length palindromes
        l, r = i, i + 1
        while l >= 0 and r < n and s[l] == s[r]:
            count += 1
            l -= 1
            r += 1
    return count",141
35113997199,binary_multiply,"def binary_multiply(bin1: str, bin2: str) -> str:
    d = {'0': 0, '1': 1}
    l1, l2 = [], []
    for i in bin1:
        l1.append(d[i])
    for j in bin2:
        l2.append(d[j])
    res1, res2 = 0, 0
    for i in l1:
        res1 = res1 * 2 + i
    for j in l2:
        res2 = res2 * 2 + j
    result = res1 * res2
    bin_result = bin(result)[2:]
    return bin_result",141
5815119637,can_partition,"def can_partition(nums):
    total = sum(nums)
    if total % 2 != 0:
        return False

    target = total // 2
    seen = [0] * len(nums)
    nums.sort(reverse=True)

    def dfs(index, current_sum):
        if current_sum == target:
            return True
        
        for i in range(index, len(nums)):
            if not seen[i] and current_sum + nums[i] <= target:
                seen[i] = 1
                if dfs(i + 1, current_sum + nums[i]):
                    return True
                seen[i] = 0
        return False

    return dfs(0, 0)",141
41957284051,find_unique_pairs,"def find_unique_pairs(nums, target):
    """"""
    Finds the number of unique pairs of numbers in a list that add up to a given target sum.
    
    :param nums: List of integers.
    :param target: Target sum.
    :return: Number of unique pairs that add up to the target sum.
    """"""
    seen = {}
    pairs = set()
    
    for num in nums:
        diff = target - num
        if diff in seen and (num, diff) not in pairs and (diff, num) not in pairs:
            pairs.add((min(num, diff), max(num, diff)))
        seen[num] = True
        
    return len(pairs)",141
36423823783,longest_substring_with_k_distinct,"from collections import defaultdict

def longest_substring_with_k_distinct(s, k):
    begin, end = 0, 0
    m = 0
    counter = 0
    s_set = defaultdict(int)

    while end < len(s):
        if s_set[s[end]] == 0:
            counter += 1
        s_set[s[end]] += 1
        end += 1
        while counter > k:
            if s_set[s[begin]] == 1:
                counter -= 1
            s_set[s[begin]] -= 1
            begin += 1
        m = max(m, end - begin)
    return m",141
71015832355,longestCommonSubsequence,"def longestCommonSubsequence(text1: str, text2: str) -> int:
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m):
        for j in range(n):
            if text1[i] == text2[j]:
                dp[i + 1][j + 1] = dp[i][j] + 1
            else:
                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])
    return dp[-1][-1]",141
2545940902,numDecodings,"def numDecodings(s):
    if not s:
        return 0
    dp = [0 for _ in range(len(s) + 1)]
    dp[0] = 1
    dp[1] = 0 if s[0] == ""0"" else 1
    
    for i in range(2, len(s) + 1):
        if s[i-1] != ""0"":
            dp[i] += dp[i-1]
        two_digit = int(s[i-2:i])
        if two_digit >= 10 and two_digit <= 26:
            dp[i] += dp[i-2]
    return dp[len(s)]",141
4207215303,find_lcs,"def find_lcs(s1, s2):
    m, n = len(s1), len(s2)
    dp = [["""" for j in range(n+1)] for i in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + s1[i-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)
    return dp[m][n]",141
39032214968,numIslands,"def numIslands(grid):
    def dfs(i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != 1:
            return
        grid[i][j] = 0
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                dfs(i, j)
                count += 1
    return count",141
73388018996,dec_to_hex,"def dec_to_hex(num):
    if num == 0:
        return ""0""
    mp = ""0123456789abcdef""
    rs = """"
    if num < 0:
        num = -num
        sign = ""-""
    else:
        sign = """"
    for i in range(8):
        rs = mp[num % 16] + rs
        num = num // 16
    return sign + rs.lstrip('0')

assert dec_to_hex(26) == ""1a""
assert dec_to_hex(0) == ""0""
assert dec_to_hex(-305) == ""-131""",141
9625681557,min_swaps_to_sort,"def min_swaps_to_sort(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",140
3142021574,min_swaps_to_sort,"def min_swaps_to_sort(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}

    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",140
785544318,find_longest_harmonious_subarray,"from collections import Counter

def find_longest_harmonious_subarray(nums):
    ans = 0
    tracking = Counter(nums)
    for i in tracking:
        if tracking[i+1] != 0:
            ans = max(ans,tracking[i]+tracking[i+1])
    return ans

assert find_longest_harmonious_subarray([1,3,2,2,5,2,3,7]) == 5
assert find_longest_harmonious_subarray([1,2,3,4]) == 2
assert find_longest_harmonious_subarray([1,1,1,1]) == 0",140
8636867295,decodeWays,"def decodeWays(s: str) -> int:
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] != '0':
            dp[i] += dp[i-1]
        two_digit = int(s[i-2:i])
        if two_digit >= 10 and two_digit <= 26:
            dp[i] += dp[i-2]
    return dp[n]",140
16631919279,min_swaps_to_sort,"def min_swaps_to_sort(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0

    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",140
16832433402,minJumps,"def minJumps(arr):
    n = len(arr)
    if n <= 1:
        return 0
    if arr[0] == 0:
        return float('inf')
    maxReach = arr[0]
    step = arr[0]
    jump = 1
    for i in range(1, n):
        if i == n - 1:
            return jump
        maxReach = max(maxReach, i + arr[i])
        step -= 1
        if step == 0:
            jump += 1
            if i >= maxReach:
                return float('inf')
            step = maxReach - i
    return jump",140
19766029001,min_jumps,"def min_jumps(arr):
  n = len(arr)
  if n <= 1:
    return 0
  if arr[0] == 0:
    return float('inf')
  maxReach = arr[0]
  step = arr[0]
  jump = 1
  for i in range(1, n):
    if i == n - 1:
      return jump
    maxReach = max(maxReach, i + arr[i])
    step -= 1
    if step == 0:
      jump += 1
      if i >= maxReach:
        return float('inf')
      step = maxReach - i
  return jump",140
24073829347,largest_square,"def largest_square(matrix):
    if not matrix:
        return 0
    n = len(matrix)
    m = len(matrix[0])
    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
    max_side = 0
    for i in range(n):
        for j in range(m):
            if matrix[i][j] == 1:
                dp[i+1][j+1] = min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1
                max_side = max(max_side, dp[i+1][j+1])
    return max_side**2",140
6773353665,max_score,"from collections import Counter

def max_score(words, letters, score):
    supplies = Counter(letters)

    def dfs(i, supplies):
        if i >= len(words):
            return 0
        word = words[i]
        word_count = Counter(word)
        if any(word_count[ch] > supplies[ch] for ch in word_count):
            return dfs(i + 1, supplies)
        pick = dfs(i + 1, supplies - word_count) + sum(score[ord(ch) - ord('a')] for ch in word)
        no_pick = dfs(i + 1, supplies)
        return max(pick, no_pick)

    return dfs(0, supplies)",140
11216362780,sort_colors,"def sort_colors(nums):
    """"""
    Sorts an array with n objects colored red, white, or blue, so that objects of the same color are adjacent,
    with the colors in the order red, white, and blue.
    Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
    """"""
    count = [0] * 3
    for i in nums:
        count[i] += 1
    index = 0
    for i in range(3):
        for j in range(count[i]):
            nums[index] = i
            index += 1
    return nums",140
6391232756,min_swaps_to_sort,"def min_swaps_to_sort(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",140
38657681813,numIslands,"def numIslands(grid):
    def dfs(i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':
            return
        grid[i][j] = '#'
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1
    return count",140
32618938862,longest_Palindromic_Subsequence,"def longest_Palindromic_Subsequence(arr):
    n = len(arr)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if arr[i] == arr[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
                
    return dp[0][n - 1]",140
20606536620,largest_divisible_subset,"def largest_divisible_subset(nums):
    if not nums:
        return []
    nums.sort()
    n = len(nums)
    dp = [1]*n
    prev = [-1]*n
    for i in range(1, n):
        for j in range(i):
            if nums[i]%nums[j] == 0 and dp[j]+1 > dp[i]:
                dp[i] = dp[j] + 1
                prev[i] = j
    max_idx = dp.index(max(dp))
    subset = []
    while max_idx != -1:
        subset.append(nums[max_idx])
        max_idx = prev[max_idx]
    subset.reverse()
    return subset",140
26972509016,is_anagram,"def is_anagram(str1, str2):
    str1 = str1.replace(' ','').lower()
    str2 = str2.replace(' ','').lower()
    
    if len(str1) != len(str2):
        return False
    
    count = {}
    
    for letter in str1:
        if letter in count:
            count[letter] += 1
        else:
            count[letter] = 1
    
    for letter in str2:
        if letter in count:
            count[letter] -= 1
        else:
            return False
    
    for k in count:
        if count[k] != 0:
            return False
    return True",140
6234598764,numIslands,"def numIslands(grid):
    def dfs(i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':
            return
        grid[i][j] = '#'
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1
    return count",140
74400000246,longest_subarray_with_zero_sum,"def longest_subarray_with_zero_sum(arr):
    sum_index = {0: -1}
    max_len = -1
    start = -1
    sum = 0
    for i in range(len(arr)):
        sum += arr[i]
        if sum not in sum_index:
            sum_index[sum] = i
        else:
            if i - sum_index[sum] > max_len:
                max_len = i - sum_index[sum]
                start = sum_index[sum] + 1
    if max_len == -1:
        return (-1, -1)
    else:
        return (start, start + max_len - 1)",140
38901587691,shortest_path_dijkstra,"import heapq


def shortest_path_dijkstra(graph, source, destination):
    n = len(graph)
    dist = [float('inf')] * n
    dist[source] = 0
    pq = [(0, source)]
    while pq:
        d, u = heapq.heappop(pq)
        if d > dist[u]:
            continue
        for v in range(n):
            if graph[u][v] > 0:
                if dist[v] > dist[u] + graph[u][v]:
                    dist[v] = dist[u] + graph[u][v]
                    heapq.heappush(pq, (dist[v], v))
    return dist[destination]",140
70392685109,decode_ways,"def decode_ways(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] != '0':
            dp[i] = dp[i-1]
        if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] < '7'):
            dp[i] += dp[i-2]
    return dp[n]",140
18888818157,min_swaps_to_sort,"def min_swaps_to_sort(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",140
19231252011,max_prime_diff,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def max_prime_diff(arr):
    prime_nums = [num for num in arr if is_prime(num)]
    if not prime_nums:
        return 0
    prime_nums.sort()
    max_diff = prime_nums[-1] - prime_nums[0]
    for i in range(1, len(prime_nums)):
        max_diff = max(max_diff, prime_nums[i] - prime_nums[i-1])
    return max_diff",140
44911643638,min_swaps_to_sort,"def min_swaps_to_sort(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}

    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue

        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",140
14851492854,find_modes,"from collections import Counter

def find_modes(nums):
    count = Counter(nums)
    max_count = max(count.values())
    modes = [num for num, freq in count.items() if freq == max_count]
    return sorted(modes)

# Test cases
assert find_modes([1, 2, 2, 3]) == [2]
assert find_modes([1, 1, 2, 2, 3, 3]) == [1, 2, 3]
assert find_modes([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) == [4]",140
21820717859,longest_palindromic_subsequence,"def longest_palindromic_subsequence(s: str) -> int:
    n = len(s)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
                
    return dp[0][n-1]",140
38666501069,minimum_edit_distance,"def minimum_edit_distance(s1, s2):
    if len(s1) > len(s2):
        s1, s2 = s2, s1

    distances = range(len(s1) + 1)
    for index2, char2 in enumerate(s2):
        new_distances = [index2 + 1]
        for index1, char1 in enumerate(s1):
            if char1 == char2:
                new_distances.append(distances[index1])
            else:
                new_distances.append(1 + min((distances[index1],
                                               distances[index1+1],
                                               new_distances[-1])))
        distances = new_distances
    return distances[-1]",140
28293902874,is_lexico_sorted,"from collections import defaultdict

def is_lexico_sorted(words, order):
    orderMap = defaultdict(int)
    for index, char in enumerate(order, start = 1):
        orderMap[char] = index
    for i in range(len(words) - 1):
        word1 = words[i]
        word2 = words[i + 1]
        for j in range(min(len(word1), len(word2))):
            if word1[j] != word2[j]:
                if orderMap[word1[j]] > orderMap[word2[j]]:
                    return False
                break
        else:
            if len(word1) > len(word2):
                return False
    return True",140
70047031155,smallest_prime_palindrome,"def isPrime(x):
    if x < 2 or x%2 == 0:
        return x == 2
    
    for i in range(3, int(x**0.5) + 1):
        if x%i == 0:
            return False
        
    return True

def smallest_prime_palindrome(N):
    if 8 <= N <= 11:
        return 11

    for x in range(10**(len(str(N))//2), 10**8):
        x = str(x)
        palindrome = int(x + x[-2::-1])
        if palindrome >= N and isPrime(palindrome):
            return palindrome",140
70954472948,look_and_say,"def look_and_say(n):
    if n == 1:
        return ""1""
    s = look_and_say(n-1)
    count = 1
    res = """"
    for i in range(len(s)):
        if i == 0:
            count = 1
        elif s[i] == s[i-1]:
            count += 1
        elif s[i] != s[i-1]:
            ss = f""{count}{s[i-1]}""
            res += ss
            count = 1
        if i == len(s)-1:
            ss = f""{count}{s[i]}"" 
            res += ss
    return res",140
17493324474,num_islands,"def num_islands(grid):
    def dfs(i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':
            return
        grid[i][j] = '#'
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1
    return count",140
43144992290,minimum_swaps_to_sort,"def minimum_swaps_to_sort(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",140
22036092865,longest_palindrome_subsequence,"def longest_palindrome_subsequence(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][n - 1]",140
10707417040,calculate_catalan,"def calculate_catalan(n):
    if n <= 1:
        return 1

    catalan = [0 for _ in range(n + 1)]
    catalan[0] = 1
    catalan[1] = 1

    for i in range(2, n + 1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i - j - 1]

    return catalan[n]

# Test cases
assert calculate_catalan(0) == 1
assert calculate_catalan(3) == 5
assert calculate_catalan(5) == 42",140
72070875687,min_swaps_to_sort,"def min_swaps_to_sort(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {i: False for i in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",140
37000143235,min_eating_speed,"from typing import List

def min_eating_speed(piles: List[int], H: int) -> int:
    def can_finish(piles, mid, H):
        hours_needed = 0
        for n in piles:
            hours_needed += (n + mid - 1) // mid
            if hours_needed > H:
                return False
        return True

    l, r = 1, max(piles)
    while l < r:
        mid = l + (r - l) // 2
        if can_finish(piles, mid, H):
            r = mid
        else:
            l = mid + 1
    return l",139
44152281676,areAlmostEqual,"def areAlmostEqual(s1: str, s2: str) -> bool:
    if s1 == s2:
        return True
    c = 0
    l = list()
    for i in range(len(s1)):
        if s1[i] != s2[i]:
            l.append(i)
            c += 1

    if c != 2:
        return False
                
    s1 = list(s1)
    s1[l[0]], s1[l[1]] = s1[l[1]], s1[l[0]]
    s1 = ''.join(s1)
    if s1 == s2:
        return True
    return False",139
6855068381,longest_substring_with_k_distinct,"def longest_substring_with_k_distinct(s: str, k: int) -> int:
    max_len = 0
    char_count = {}
    left = 0

    for right in range(len(s)):
        if s[right] in char_count:
            char_count[s[right]] += 1
        else:
            char_count[s[right]] = 1

        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]
            left += 1

        max_len = max(max_len, right - left + 1)

    return max_len",139
30688631332,min_swaps,"def min_swaps(nums):
    n = len(nums)
    arr_pos = [*enumerate(nums)]
    arr_pos.sort(key=lambda it: it[1])
    ans = 0
    vis = {i: False for i in range(n)}
 
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
 
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
 
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",139
14227900377,is_tree,"from collections import defaultdict

def is_tree(edges):
    def dfs(node, parent, visited):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor == parent:
                continue
            if neighbor in visited:
                return False
            if not dfs(neighbor, node, visited):
                return False
        return True

    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    visited = set()
    if not dfs(edges[0][0], None, visited):
        return False
    return len(visited) == len(set(node for edge in edges for node in edge))",139
75136420745,is_possible_consecutive_split,"from collections import Counter

def is_possible_consecutive_split(nums):
    left = Counter(nums)
    end = Counter()
    for num in nums:
        if left[num] == 0:
            continue
        left[num] -= 1
        if end[num - 1] > 0:
            end[num - 1] -= 1
            end[num] += 1
        elif left[num + 1] and left[num + 2]:
            left[num + 1] -= 1
            left[num + 2] -= 1
            end[num + 2] += 1
        else:
            return False
    return True",139
12190521720,phone_combinations,"mapping = {
  '2':'abc',
  '3':'def',
  '4':'ghi',
  '5':'jkl',
  '6':'mno',
  '7':'pqrs',
  '8':'tuv',
  '9':'wxyz'
}

def combinations(str, i, pref, all):
  if i == len(str):
    all.append("""".join(pref))
    return
  options = mapping[str[i]]
  for j in range(len(options)):
    combinations(str, i+1, [*pref, options[j]], all)

def phone_combinations(str):
  all = []
  combinations(str, 0, [], all)
  return all",139
71050044206,decode_variations,"def decode_variations(s):
    if not s or s[0] == '0': return 0
    dp = [0 for _ in range(len(s) + 1)]
    dp[0], dp[1] = 1, 1
    for i in range(2, len(s) + 1):
        if s[i-1] > '0':
            dp[i] = dp[i-1]
        if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] < '7'):
            dp[i] += dp[i-2]
    return dp[len(s)]",139
26695249471,LCS,"def LCS(X, Y):
    m = len(X)
    n = len(Y)
    L = [[None]*(n+1) for i in range(m+1)]
    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0 :
                L[i][j] = 0
            elif X[i-1] == Y[j-1]:
                L[i][j] = L[i-1][j-1]+1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])
    return L[m][n]",139
71631975990,longest_palindrome_subseq,"def longest_palindrome_subseq(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = 2 + dp[i + 1][j - 1]
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][n - 1]",139
72565395394,decode_variations,"def decode_variations(s):
    if not s or s[0] == '0':
        return 0

    dp = [0] * (len(s) + 1)
    dp[0], dp[1] = 1, 1

    for i in range(2, len(s) + 1):
        if s[i-1] > '0':
            dp[i] = dp[i-1]
        if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] < '7'):
            dp[i] += dp[i-2]
    return dp[len(s)]",139
27726077850,decode_variations,"def decode_variations(s):
    if not s or s[0] == ""0"":
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        one = int(s[i-1:i])
        two = int(s[i-2:i])
        if 1 <= one <= 9:
            dp[i] += dp[i-1]
        if 10 <= two <= 26:
            dp[i] += dp[i-2]
    return dp[n]",139
30089501394,can_arrange_pairs,"from collections import defaultdict

def can_arrange_pairs(arr, K):
    d = defaultdict(int)
    for a in arr:
        remainder = (-a) % K
        d[remainder] += 1

    for n in d.keys():
        if n == 0:
            continue
        if n not in d and (K - n) not in d:
            continue
        if n not in d or (K - n) not in d:
            return False
        if d[n] != d[K - n]:
            return False
        if n == (K - n) and d[n] % 2:
            return False
    return True",139
18450953713,count_rotations,"def count_rotations(arr):
    low = 0
    high = len(arr) - 1
    while low <= high:
        if arr[low] <= arr[high]:
            return low
        mid = (low + high) // 2
        next = (mid + 1) % len(arr)
        prev = (mid - 1 + len(arr)) % len(arr)
        if arr[mid] <= arr[next] and arr[mid] <= arr[prev]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0",139
11867307830,checkCamelCase,"def checkCamelCase(s: str) -> bool:
    if not s:
        return False
    if s[0].islower():
        return False
    if ' ' in s or '_' in s:
        return False
    words = [s[0]]
    for i in range(1, len(s)):
        if s[i].isupper():
            if len(words[-1]) == 1 and words[-1].isupper():
                return False
            words.append(s[i])
        else:
            words[-1] += s[i]
    return all(word[0].isupper() and word[1:].islower() for word in words)",139
12174098791,prime_sum,"def prime_sum(n):
    check = [0] * (n + 1)
    check[0] = check[1] = 1  # 1: not prime

    # marking non-prime numbers
    for i in range(2, n + 1):
        if check[i] == 0:
            j = i + i
            while j <= n:
                check[j] = 1
                j += i

    # summing up prime numbers
    sum = 0
    for i in range(2, n + 1):
        if check[i] == 0:
            sum += i
    return sum",139
71965103747,minJumps,"def minJumps(arr):
    n = len(arr)
    if n <= 1:
        return 0
    if arr[0] == 0:
        return -1
    maxReach = arr[0]
    step = arr[0]
    jump = 1
    for i in range(1, n):
        if i == n - 1:
            return jump
        maxReach = max(maxReach, i + arr[i])
        step -= 1
        if step == 0:
            jump += 1
            if i >= maxReach:
                return -1
            step = maxReach - i
    return -1",139
8283244313,longest_non_repeating_substring,"def longest_non_repeating_substring(s: str) -> str:
    if len(s) <= 1:
        return s
    start = 0
    end = 0
    char_set = set()
    max_len = 0
    max_start = 0
    while end < len(s):
        if s[end] not in char_set:
            char_set.add(s[end])
            end += 1
            if end - start > max_len:
                max_len = end - start
                max_start = start
        else:
            char_set.remove(s[start])
            start += 1
    return s[max_start:max_start + max_len]",139
18027111481,decodeWays,"def decodeWays(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        single = int(s[i-1:i])
        double = int(s[i-2:i])
        if 1 <= single <= 9:
            dp[i] += dp[i-1]
        if 10 <= double <= 26:
            dp[i] += dp[i-2]
    return dp[n]",139
21149601264,decode_ways,"def decode_ways(s: str) -> int:
    if not s or s[0] == '0':
        return 0

    dp = [0] * (len(s) + 1)
    dp[0], dp[1] = 1, 1

    for i in range(2, len(s) + 1):
        if s[i-1] > '0':
            dp[i] = dp[i-1]

        two_digit = int(s[i-2:i])
        if two_digit >= 10 and two_digit <= 26:
            dp[i] += dp[i-2]

    return dp[len(s)]",139
347394523,minimum_Swaps,"def minimum_Swaps(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",139
21275229762,longest_alphabetical_substring,"def longest_alphabetical_substring(s: str) -> str:
    if not s:
        return """"
    max_len = 1
    max_substring = s[0]
    current_len = 1
    current_substring = s[0]
    for i in range(1, len(s)):
        if s[i] >= s[i - 1]:
            current_len += 1
            current_substring += s[i]
            if current_len > max_len:
                max_len = current_len
                max_substring = current_substring
        else:
            current_len = 1
            current_substring = s[i]
    return max_substring",139
24460453303,decode_variations,"def decode_variations(s):
    if not s or s[0] == '0':
        return 0
    dp = [1, 1]
    if len(s) <= 1:
        return dp[0]
    dp.extend([0] * (len(s)-1))
    for i in range(1, len(s)):
        if s[i] != '0':
            dp[i+1] = dp[i]
        if s[i-1] != '0' and 10 <= int(s[i-1:i+1]) <= 26:
            dp[i+1] += dp[i-1]
    return dp[-1]",139
9550238563,mobile_keypad,"def mobile_keypad(num):
    keypad = {""2"": ""abc"", ""3"": ""def"", ""4"": ""ghi"", ""5"": ""jkl"", ""6"": ""mno"", ""7"": ""pqrs"", ""8"": ""tuv"", ""9"": ""wxyz""}
    if len(num) == 0:
        return [""""]
    first_digit = num[0]
    rest_digits = num[1:]
    next_combinations = mobile_keypad(rest_digits)
    current_combinations = []
    for char in keypad[first_digit]:
        for combination in next_combinations:
            current_combinations.append(char + combination)
    return current_combinations",139
4973976816,find_min_jumps,"def find_min_jumps(nums):
    if len(nums) <= 1:
        return 0
    if nums[0] == 0:
        return -1
    maxReach = nums[0]
    step = nums[0]
    jump = 1
    for i in range(1, len(nums)):
        if i == len(nums) - 1:
            return jump
        maxReach = max(maxReach, i + nums[i])
        step -= 1
        if step == 0:
            jump += 1
            if i >= maxReach:
                return -1
            step = maxReach - i
    return -1",139
71726426584,count_palindrome_substrings,"def count_palindrome_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # Odd length palindromes (single character center)
        total_count += expand_around_center(i, i)
        # Even length palindromes (adjacent character center)
        total_count += expand_around_center(i, i + 1)

    return total_count",139
21911461725,check_anagrams,"def check_anagrams(str1, str2):
    str1 = str1.replace(' ', '').lower()
    str2 = str2.replace(' ', '').lower()
    
    if len(str1) != len(str2):
        return False
    
    char_count = {}
    
    for char in str1:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    
    for char in str2:
        if char not in char_count:
            return False
        else:
            char_count[char] -= 1
            if char_count[char] < 0:
                return False
    
    return True",139
25191348400,next_permutation,"def next_permutation(nums):
    n = len(nums)
    i = n - 2
    while i >= 0 and nums[i] >= nums[i + 1]:
        i -= 1

    if i >= 0:
        j = n - 1
        while nums[j] <= nums[i]:
            j -= 1
        nums[i], nums[j] = nums[j], nums[i]

    left = i + 1
    right = n - 1
    while left < right:
        nums[left], nums[right] = nums[right], nums[left]
        left += 1
        right -= 1
    return nums",138
39391409703,is_rotation_of_palindrome,"def is_rotation_of_palindrome(s: str) -> bool:
    # Concatenate the string with itself to handle the rotation
    doubled_s = s + s

    # Check for a palindrome substring of the length of the original string
    for i in range(len(s)):
        if is_palindrome(doubled_s[i:i+len(s)]):
            return True
    return False

def is_palindrome(s: str) -> bool:
    # Convert to lower case and remove non-alphanumeric characters
    s = ''.join(filter(str.isalnum, s.lower()))
    
    # Check if the string is equal to its reverse
    return s == s[::-1]",138
15520721719,min_swaps,"def min_swaps(arr):
    n = len(arr)
    arr_pos =[*enumerate(arr)]
    arr_pos.sort(key = lambda it:it[1])
    vis = {k:False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans+= (cycle_size-1)
    return ans",138
71024067032,longest_RepeatingSubsequence,"def longest_RepeatingSubsequence(str): 
    n = len(str) 
    dp = [[0 for _ in range(n+1)] for _ in range(n+1)] 
    for i in range(1, n+1): 
        for j in range(1, n+1): 
            if (str[i-1] == str[j-1] and i != j): 
                dp[i][j] = 1 + dp[i-1][j-1] 
            else: 
                dp[i][j] = max(dp[i][j-1], dp[i-1][j]); 
    return dp[n][n];",138
11800492856,min_swaps,"def min_swaps(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}

    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",138
13695141352,minSwaps,"def minSwaps(nums):
    n = len(nums)
    arrpos = [*enumerate(nums)]
    arrpos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arrpos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arrpos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",138
45781890267,decode_message,"def decode_message(s):
    if not s or s[0] == '0':
        return 0
    dp = [0] * (len(s) + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, len(s) + 1):
        if s[i-1] > '0':
            dp[i] = dp[i-1]
        if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] < '7'):
            dp[i] += dp[i-2]
    return dp[len(s)]",138
29042446272,minimum_swaps,"def minimum_swaps(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",138
71766501575,closest_value,"def closest_value(nums, target):
    left = 0
    right = len(nums) - 1
    closest = float('inf')
    closest_val = nums[0]
    
    while left <= right:
        mid = (left + right) // 2
        if abs(target - nums[mid]) < closest:
            closest = abs(target - nums[mid])
            closest_val = nums[mid]
        elif abs(target - nums[mid]) == closest:
            closest_val = min(closest_val, nums[mid])
            
        if target < nums[mid]:
            right = mid - 1
        else:
            left = mid + 1
            
    return closest_val",138
30384872078,longest_non_repeating_substring,"def longest_non_repeating_substring(s: str) -> int:
    """"""
    Finds the length of the longest substring without repeating characters.

    :param s: The input string.
    :return: The length of the longest substring without repeating characters.
    """"""
    start = 0
    max_len = 0
    used_char = {}

    for i in range(len(s)):
        if s[i] in used_char and start <= used_char[s[i]]:
            start = used_char[s[i]] + 1
        else:
            max_len = max(max_len, i - start + 1)

        used_char[s[i]] = i

    return max_len",138
22647324264,isAnagram,"def isAnagram(str1, str2):
    str1 = str1.replace("" "", """").lower()
    str2 = str2.replace("" "", """").lower()
    if len(str1) != len(str2):
        return False
    count = {}
    for letter in str1:
        if letter in count:
            count[letter] += 1
        else:
            count[letter] = 1
    for letter in str2:
        if letter in count:
            count[letter] -= 1
        else:
            return False
    for k in count:
        if count[k] != 0:
            return False
    return True",138
1876571322,are_anagrams,"def are_anagrams(word1, word2):
    word1 = word1.replace(' ', '').lower()
    word2 = word2.replace(' ', '').lower()

    if len(word1) != len(word2):
        return False

    count = {}

    for letter in word1:
        if letter in count:
            count[letter] += 1
        else:
            count[letter] = 1

    for letter in word2:
        if letter in count:
            count[letter] -= 1
        else:
            return False

    for k in count:
        if count[k] != 0:
            return False

    return True",138
6391165506,check_anagram,"def check_anagram(str1, str2):
    str1 = str1.replace("" "", """").lower()
    str2 = str2.replace("" "", """").lower()
    if len(str1) != len(str2):
        return False
    count = {}
    for letter in str1:
        if letter in count:
            count[letter] += 1
        else:
            count[letter] = 1
    for letter in str2:
        if letter in count:
            count[letter] -= 1
        else:
            return False
    for k in count:
        if count[k] != 0:
            return False
    return True",138
31937239621,minJumps,"def minJumps(arr):
    n = len(arr)
    if n <= 1:
        return 0
    if arr[0] == 0:
        return -1
    maxReach = arr[0]
    step = arr[0]
    jump = 1
    for i in range(1, n):
        if i == n-1:
            return jump
        maxReach = max(maxReach, i + arr[i])
        step -= 1
        if step == 0:
            jump += 1
            if i >= maxReach:
                return -1
            step = maxReach - i
    return -1",138
34424813208,minSwaps,"def minSwaps(nums):
    n = len(nums)
    arrPos = [*enumerate(nums)]
    arrPos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arrPos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arrPos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",138
73699423767,can_form_palindrome,"def can_form_palindrome(s):
    """"""
    Checks if the given string can form a palindrome by rearranging its letters.
    
    :param s: The input string.
    :return: True if the string can form a palindrome, False otherwise.
    """"""
    counter = {}
    for char in s:
        char = char.lower()
        if char.isalpha():
            if char in counter:
                counter[char] += 1
            else:
                counter[char] = 1
    
    odd_counts = 0
    for count in counter.values():
        if count % 2 != 0:
            odd_counts += 1
    
    return odd_counts <= 1",138
799526239,valid_abbreviation,"def valid_abbreviation(word, abbr):
    i = 0
    j = 0
    while i < len(word) and j < len(abbr):
        if word[i] == abbr[j]:
            i += 1
            j += 1
        elif abbr[j].isdigit():
            if abbr[j] == '0':
                return False
            num = """"
            while j < len(abbr) and abbr[j].isdigit():
                num += abbr[j]
                j += 1
            i += int(num)
        else:
            return False
    return i == len(word) and j == len(abbr)",138
17771320886,min_swap_sort,"def min_swap_sort(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0

    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",138
38901286411,min_swaps,"def min_swaps(nums):
    n = len(nums)
    arrpos = [*enumerate(nums)]
    arrpos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}

    ans = 0
    for i in range(n):
        if vis[i] or arrpos[i][0] == i:
            continue

        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arrpos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",138
13412520122,nearest_palindrome,"def nearest_palindrome(n):
    l = len(n)
    if l == 1:
        return str(int(n) - 1)

    candidates = set(( ( ""1""+""0""*(l-1)+""1"" ), ""9""*(l-1) ))
    prefix = int( n[:int((l+1)/2)] )

    for i in map(str, (prefix -1, prefix, prefix + 1)):
        candidates.add(i+[i,i[:-1]][l & 1][::-1])
    candidates.discard(n)

    return min(candidates, key=lambda x: (abs(int(x) - int(n)), int(x)))",138
9524833722,lucas,"def lucas(n: int) -> int:
    if n == 0:
        return 2
    if n == 1:
        return 1

    a, b = 2, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

def check_lucas():
    assert lucas(0) == 2
    assert lucas(1) == 1
    assert lucas(7) == 29
    assert lucas(10) == 123
    print(""All test cases passed."")

check_lucas()",138
72484879224,min_swaps,"def min_swaps(nums):
    n = len(nums)
    arrpos = [*enumerate(nums)]
    arrpos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arrpos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arrpos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",138
40509217888,twoSum_sort,"def twoSum_sort(nums, target):
    """"""
    Sort the list first, then use two pointers to find the pair of numbers that add up to the target.
    """"""
    sorted_nums = sorted((e, i) for i, e in enumerate(nums))
    left, right = 0, len(nums) - 1
    while left < right:
        current_sum = sorted_nums[left][0] + sorted_nums[right][0]
        if current_sum < target:
            left += 1
        elif current_sum > target:
            right -= 1
        else:
            return [sorted_nums[left][1], sorted_nums[right][1]]
    return []",138
33021421562,min_operations_to_palindrome,"def min_operations_to_palindrome(s):
    n = len(s)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 0
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1]
            else:
                dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1
    return dp[0][n - 1]",138
28087599451,count_distinct_subsequences,"def count_distinct_subsequences(s: str, target: str) -> int:
    MOD = 10**9 + 7
    target_len = len(target)
    dp = [0] * (target_len + 1)
    dp[0] = 1
    s_len = len(s)
    for i in range(s_len):
        for j in range(target_len - 1, -1, -1):
            if s[i] == target[j]:
                dp[j + 1] += dp[j]
        for j in range(1, target_len + 1):
            dp[j] %= MOD
    return dp[target_len]",138
20606915910,min_swaps,"def min_swaps(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}

    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue

        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1

        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",138
22935206380,minimumSwaps,"def minimumSwaps(arr):
    n = len(arr)
    arr_pos = [*enumerate(arr)]
    arr_pos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arr_pos[j][0]
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",138
24036127372,frequent_elements,"from typing import List
from collections import Counter

def frequent_elements(nums: List[int], k: int) -> List[int]:
    """"""
    Finds the k most frequent elements in the given list of integers.
    Elements are returned in descending order of frequency.
    If two elements have the same frequency, the smaller one comes first.
    """"""
    # Count the frequency of each element in the list
    freq = Counter(nums)
    
    # Find the k most common elements, sorted by frequency and then by value
    result = [num for num, _ in freq.most_common(k)]
    result.sort(key=lambda x: (-freq[x], x))
    
    return result",138
23726101371,max_sub_array_of_size_k,"def max_sub_array_of_size_k(k, arr):
    max_sum = 0
    window_sum = 0
    window_start = 0

    for window_end in range(len(arr)):
        window_sum += arr[window_end]  # add the next element
        # slide the window, we don't need to slide if we've not hit the required window size of 'k'
        if window_end >= k - 1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]  # subtract the element going out
            window_start += 1  # slide the window ahead

    return max_sum",137
32791625168,single_number,"def single_number(nums):
    """"""
    Returns the single number in the list that appears only once where every other number appears exactly twice.

    Complexity:
        Time: O(n)
        Space: O(1)

    Args:
        nums (list): List of integers where every element appears twice except for one.

    Examples:
        >>> single_number([4,1,2,1,2])
        4
        >>> single_number([2,2,1])
        1
        >>> single_number([0,1,0])
        1
    """"""
    xor = 0
    for num in nums:
        xor ^= num
    return xor",137
73466381436,min_operations_to_palindrome,"def min_operations_to_palindrome(s: str) -> int:
    n = len(s)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = 2 + dp[i+1][j-1]
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return n - dp[0][n-1]",137
46454210484,max_rectangle_area,"def max_rectangle_area(heights):
    stack = [-1]
    max_area = 0
    for i, h in enumerate(heights):
        while stack[-1] != -1 and heights[stack[-1]] >= h:
            height = heights[stack.pop()]
            width = i - stack[-1] - 1
            max_area = max(max_area, height * width)
        stack.append(i)
    while stack[-1] != -1:
        height = heights[stack.pop()]
        width = len(heights) - stack[-1] - 1
        max_area = max(max_area, height * width)
    return max_area",137
7153650773,max_product_pair,"def max_product_pair(nums):
    if len(nums) < 2:
        return None
    nums.sort()
    return max(nums[0] * nums[1], nums[-1] * nums[-2])

if __name__ == '__main__':
    assert max_product_pair([1, 2, 3, 4]) == 12
    assert max_product_pair([-1, -2, -3, -4]) == 12
    assert max_product_pair([0, 0, 0, 0]) == 0
    assert max_product_pair([1]) == None
    assert max_product_pair([]) == None",137
36588384836,longest_zero_sum_subarray,"def longest_zero_sum_subarray(arr):
    max_length = 0
    sum_dict = {0: -1}
    max_start = -1
    max_end = -1
    current_sum = 0
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum in sum_dict:
            start = sum_dict[current_sum] + 1
            end = i
            if end - start > max_length:
                max_length = end - start
                max_start = start
                max_end = end
        else:
            sum_dict[current_sum] = i
    return arr[max_start:max_end+1]",137
70260860250,next_permutation,"def next_permutation(nums):
    n = len(nums)
    i = n - 2
    while i >= 0 and nums[i] >= nums[i + 1]:
        i -= 1
    if i >= 0:
        j = n - 1
        while nums[j] <= nums[i]:
            j -= 1
        nums[i], nums[j] = nums[j], nums[i]
    left, right = i + 1, n - 1
    while left < right:
        nums[left], nums[right] = nums[right], nums[left]
        left += 1
        right -= 1
    return nums",137
3196457143,primes_in_range,"def primes_in_range(start, end):
    def is_prime(n):
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    primes = []
    for num in range(start, end + 1):
        if is_prime(num):
            primes.append(num)
    return primes",137
40045477161,min_subarray_length,"def min_subarray_length(target, nums):
    left = 0  # index
    right = 0  # index
    cum_sum = 0  # initialize sliding window sum
    min_length = len(nums) + 1000  # to satisfy the min function condition

    while right < len(nums):
        cum_sum += nums[right]

        while cum_sum >= target:
            min_length = min(min_length, right - left + 1)
            cum_sum -= nums[left]
            left += 1

        right += 1

    return min_length if min_length != len(nums) + 1000 else 0",137
74011745526,max_vowels,"def max_vowels(s, k):
    vowels = 'aeiou'
    max_vowels = 0
    current_vowels = 0
    for i in range(k):
        if s[i] in vowels:
            current_vowels += 1
    max_vowels = current_vowels
    for i in range(k, len(s)):
        if s[i] in vowels:
            current_vowels += 1
        if s[i-k] in vowels:
            current_vowels -= 1
        max_vowels = max(max_vowels, current_vowels)
    return max_vowels",137
21457495048,find_largest_range,"def find_largest_range(lst):
    nums = set(lst)
    best = []
    longest_length = 0
    while nums:
        num = nums.pop()
        current_len = 1
        left = num - 1
        while left in nums:
            nums.remove(left)
            left -= 1
            current_len += 1

        right = num + 1
        while right in nums:
            nums.remove(right)
            right += 1
            current_len += 1

        if current_len > longest_length:
            longest_length = current_len
            best = [left + 1, right - 1]
    return best",137
11852912976,partition,"def partition(s):
    def dfs(start):
        if start >= len(s): return [[]]
        result = []
        for i in range(start, len(s)):
            if s[start:i + 1] == s[start:i + 1][::-1]:
                ret = dfs(i + 1)
                for l in ret:
                    result.append([s[start:i + 1]] + l)
        return result

    return dfs(0)

assert partition(""aab"") == [[""a"", ""a"", ""b""], [""aa"", ""b""]]
assert partition(""a"") == [[""a""]]
assert partition(""aa"") == [[""a"", ""a""], [""aa""]]",137
40123094100,longest_common_subsequence,"def longest_common_subsequence(str1, str2):
    m = len(str1)
    n = len(str2)
    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]",137
22110184292,find_longest_common_subsequence,"def find_longest_common_subsequence(a, b):
    m, n = len(a), len(b)
    dp = [["""" for _ in range(n+1)] for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if a[i-1] == b[j-1]:
                dp[i][j] = dp[i-1][j-1] + a[i-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)
    return dp[m][n]",137
9459040747,maxDistToClosest,"def maxDistToClosest(seats):
    first = seats.index(1)
    last = 0
    for i in range(len(seats) - 1, -1, -1):
        if seats[i]: 
            last = i
            break
    res = 0
    temp = 0
    for i in range(first, last + 1):
        if seats[i] == 1:
            res = max(temp, res)
            temp = 0
        else:
            temp += 1
    return max(first, len(seats) - last - 1, (res + 1) // 2)",137
15212777809,max_distinct_subarray_sum,"from collections import Counter

def max_distinct_subarray_sum(nums, k):
    ans = 0
    cnt = Counter(nums[: k - 1])
    s = sum(nums[: k - 1])
    for in_, out in zip(nums[k - 1 :], nums):
        cnt[in_] += 1  # Move in element
        s += in_
        if len(cnt) == k:
            ans = max(ans, s)
        cnt[out] -= 1  # Move out element
        if cnt[out] == 0:
            del cnt[out]  # Remove element with count 0
        s -= out
    return ans",137
17535969603,jump,"def jump(arr):
    n = len(arr)
    if n <= 1:
        return 0
    if arr[0] == 0:
        return -1
    maxReach = arr[0]
    step = arr[0]
    jump = 1
    for i in range(1, n):
        if i == n - 1:
            return jump
        maxReach = max(maxReach, i + arr[i])
        step -= 1
        if step == 0:
            jump += 1
            if i >= maxReach:
                return -1
            step = maxReach - i
    return -1",137
29740932024,longest_substring_with_k_replacements,"from collections import defaultdict


def longest_substring_with_k_replacements(s, k):
    count_character = defaultdict(int)
    start = 0
    max_count = 0
    result = 0
    for end in range(len(s)):
        cur_char = s[end]
        count_character[cur_char] += 1
        max_count = max(max_count, count_character[cur_char])
        cur_length = end - start + 1
        if cur_length - max_count > k:
            count_character[s[start]] -= 1
            start += 1
            cur_length -= 1
        result = max(result, cur_length)
    return result",137
3912067070,balanced_parentheses,"def balanced_parentheses(n):
    """"""
    Generate all combinations of n pairs of balanced parentheses.
    
    :param n: Number of pairs of parentheses.
    :return: List of strings representing all possible combinations of balanced parentheses.
    """"""
    result = []
    def generate_parentheses(s='', left=0, right=0):
        if len(s) == 2 * n:
            result.append(s)
            return
        if left < n:
            generate_parentheses(s+'(', left+1, right)
        if right < left:
            generate_parentheses(s+')', left, right+1)
    generate_parentheses()
    return result",137
70944408440,num_decodings,"def num_decodings(s):
    if not s:
        return 0
    dp = [0] * (len(s) + 1)
    dp[0], dp[1] = 1, 1 if 0 < int(s[0]) <= 9 else 0
    for i in range(2, len(s) + 1):
        if 0 < int(s[i-1:i]) <= 9:
            dp[i] += dp[i-1]
        if 10 <= int(s[i-2:i]) <= 26:
            dp[i] += dp[i-2]
    return dp[len(s)]",137
28683753506,merge_k_sorted_lists,"import heapq
from typing import List

def merge_k_sorted_lists(arrays: List[List[int]]) -> List[int]:
    pq = []
    for i, array in enumerate(arrays):
        heapq.heappush(pq, (array[0], i, 0))
    result = []
    while pq:
        val, array_idx, element_idx = heapq.heappop(pq)
        result.append(val)
        if element_idx + 1 < len(arrays[array_idx]):
            next_tuple = (arrays[array_idx][element_idx + 1], array_idx, element_idx + 1)
            heapq.heappush(pq, next_tuple)
    return result",137
20538802356,count_Palindromic_substrings,"def count_Palindromic_substrings(s: str) -> int:
    def expandAroundCenter(left: int, right: int) -> int:
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
            count += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # odd length palindrome
        total_count += expandAroundCenter(i, i)
        # even length palindrome
        total_count += expandAroundCenter(i, i + 1)
    
    return total_count",137
72287096984,count_decode_ways,"def count_decode_ways(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i - 1] != '0':
            dp[i] += dp[i - 1]
        two_digit = int(s[i - 2:i])
        if 10 <= two_digit <= 26:
            dp[i] += dp[i - 2]
    return dp[n]",137
11675136224,is_valid_html_tag,"import re

def is_valid_html_tag(tag: str) -> bool:
    pattern = r""^<[a-zA-Z0-9-]*>$""
    return bool(re.match(pattern, tag))

print(is_valid_html_tag(""<div>""))  # True
print(is_valid_html_tag(""<div class='main'>""))  # False
print(is_valid_html_tag(""<div1>""))  # True
print(is_valid_html_tag(""<-div>""))  # False
print(is_valid_html_tag(""<1div>""))  # False
print(is_valid_html_tag(""<div-1>""))  # True
print(is_valid_html_tag(""<>""))  # False",137
20564143224,climbStairs,"def climbStairs(n: int) -> int:
    """"""
    Using dynamic programming, we can solve this problem by storing the number of ways
    to reach each step. The number of ways to reach a step is the sum of the number of ways
    to reach the previous step and the step before the previous step.
    time complexity: O(n), space complexity: O(1)
    """"""
    if n <= 2:
        return n
    first, second = 1, 2
    for _ in range(3, n + 1):
        third = first + second
        first, second = second, third
    return second",137
17190932481,max_overlapping_intervals,"def max_overlapping_intervals(intervals):
    starts = []
    ends = []
    for interval in intervals:
        starts.append(interval[0])
        ends.append(interval[1])
    starts.sort()
    ends.sort()
    active_intervals = 0
    max_intervals = 0
    i, j = 0, 0
    while i < len(starts) and j < len(ends):
        if starts[i] < ends[j]:
            active_intervals += 1
            max_intervals = max(max_intervals, active_intervals)
            i += 1
        else:
            active_intervals -= 1
            j += 1
    return max_intervals",137
11316474772,merge_sort,"def merge_sort(lst):
    if len(lst) <= 1:
        return lst
    
    mid = len(lst) // 2
    left = merge_sort(lst[:mid])
    right = merge_sort(lst[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result",136
6997223471,find_max_sum_subarray,"def find_max_sum_subarray(arr, k):
    max_sum = float('-inf')
    window_sum = 0
    window_start = 0

    for window_end in range(len(arr)):
        window_sum += arr[window_end]  # add the next element
        # slide the window, we don't need to slide if we've not hit the required window size of 'k'
        if window_end >= k-1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]  # subtract the element going out
            window_start += 1  # slide the window ahead

    return max_sum",136
27482768484,unique_path_with_obstacles,"def unique_path_with_obstacles(obstacleGrid):
    m, n = len(obstacleGrid), len(obstacleGrid[0])
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = 1 - obstacleGrid[0][0]
    for i in range(m):
        for j in range(n):
            if obstacleGrid[i][j] == 0:
                if i > 0: dp[i][j] += dp[i-1][j]
                if j > 0: dp[i][j] += dp[i][j-1]
    return dp[m-1][n-1]",136
22534056232,single_number,"def single_number(nums):
    ones, twos, threes = 0, 0, 0
    for num in nums:
        twos |= ones & num
        ones ^= num
        threes = ones & twos
        ones &= ~threes
        twos &= ~threes
    return ones

if __name__ == '__main__':
    print(single_number([2, 2, 3, 2]))
    print(single_number([0, 1, 0, 1, 0, 1, 99]))
    print(single_number([-2, -2, -3, -2]))",136
34815479513,countWays,"def countWays(coins, n):
    m = len(coins)
    dp = [[0 for x in range(m)] for x in range(n+1)]
    
    for i in range(m):
        dp[0][i] = 1

    for i in range(1, n+1):
        for j in range(m):
            x = dp[i - coins[j]][j] if i-coins[j] >= 0 else 0 
            y = dp[i][j-1] if j >= 1 else 0 
            dp[i][j] = x + y
    return dp[n][m-1]",136
39204486,filter_palindromes,"def filter_palindromes(strings):
    return [s for s in strings if s == s[::-1]]

# Test cases
print(filter_palindromes([""racecar"", ""level"", ""python"", ""madam""]))  # Should return [""racecar"", ""level"", ""madam""]
print(filter_palindromes([""deified"", ""civic"", ""hello"", ""world""]))  # Should return [""deified"", ""civic""]
print(filter_palindromes([""radar"", ""refer"", ""step on no pets"", ""noon""]))  # Should return [""radar"", ""refer"", ""step on no pets"", ""noon""]",136
25869496826,is_valid_parentheses,"def is_valid_parentheses(s: str) -> bool:
    # Initialize a counter for tracking the balance of parentheses
    balance = 0
    # Iterate through the string
    for char in s:
        # If an opening parenthesis is found, increment the balance
        if char == '(':
            balance += 1
        # If a closing parenthesis is found, decrement the balance
        elif char == ')':
            balance -= 1
        # If the balance goes negative, parentheses are not valid
        if balance < 0:
            return False
    # If the balance is zero, parentheses are valid
    return balance == 0",136
6303393660,find_largest_second_element,"def find_largest_second_element(tuples_list):
    # Check if the list is empty
    if not tuples_list:
        return None

    # Initialize the largest second element as the second element of the first tuple
    largest_second_element = tuples_list[0][1]

    # Iterate through the list of tuples
    for tup in tuples_list:
        # Check if the current tuple has at least two elements
        if len(tup) >= 2:
            # Update the largest second element if the current second element is larger
            if tup[1] > largest_second_element:
                largest_second_element = tup[1]

    return largest_second_element",136
3345253627,max_sliding_window,"from collections import deque
def max_sliding_window(nums, k):
    n = len(nums)
    if n == 0:
        return []
    q = deque()
    res = []
    for i in range(k):
        while q and nums[i] >= nums[q[-1]]:
            q.pop()
        q.append(i)
    for i in range(k, n):
        res.append(nums[q[0]])
        while q and q[0] <= i - k:
            q.popleft()
        while q and nums[i] >= nums[q[-1]]:
            q.pop()
        q.append(i)
    res.append(nums[q[0]])
    return res",136
38532984558,find_shortest_subarray,"def find_shortest_subarray(nums):
    counter = {}
    left = {}
    right = {}

    max_frequency = 0

    for i, v in enumerate(nums):
        if v not in counter:
            counter[v] = 1
            left[v] = i
            right[v] = i
        else:
            right[v] = i
            counter[v] += 1

        max_frequency = max(max_frequency, counter[v])

    result = float('inf')

    for c in counter:
        if counter[c] == max_frequency:
            result = min(result, right[c] - left[c] + 1)

    return result",136
37686040758,findMaxLength,"def findMaxLength(nums):
    if len(nums) <= 3:
        return 2

    maxSofar = 2
    map01 = {0: 0, 1: 0}
    for i in range(len(nums)):
        map01[nums[i]] += 1
        if map01[0] == map01[1]:
            maxSofar = map01[0] + map01[1]
        else:
            maxSofar = max(maxSofar, 2 * min(map01[0], map01[1]))

    return maxSofar",136
72617941825,num_squares,"from collections import deque

def num_squares(n):
    square_nums = [i * i for i in range(1, int(n**0.5) + 1)]
    lvl = 0

    # Use `set` to eliminate the redundancy of remainders within the same level.
    que = {n}
    while que:
        next_que = set()
        lvl += 1
        for remain in que:
            for sq in square_nums:
                if remain == sq:
                    return lvl
                elif remain >= sq:
                    next_que.add(remain - sq)
                else:
                    break
        que = next_que
    assert False",136
72461246388,nth_prime,"def nth_prime(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    prime_list = []
    i = 2
    while len(prime_list) < n:
        if is_prime(i):
            prime_list.append(i)
        i += 1
    return prime_list[-1]

assert nth_prime(1) == 2
assert nth_prime(5) == 11
assert nth_prime(10) == 29",136
37680554661,common_chars,"from collections import Counter

def common_chars(words):
    count = []
    first_word_count = Counter(words[0]) 
    ans = [0]*26

    for key,value in  first_word_count.items():
        ans[ord(key) % ord('a')] = value

    for i in range(len(words)):
        count = Counter(words[i])
        for j in range(len(ans)):
            letter = chr(j + ord('a'))
            ans[j] = min(ans[j], count[letter])

    result = []
    for i in range(len(ans)):
        result += [chr(i + ord('a'))]*ans[i]
            
    return result",136
7583892630,dijkstra_shortest_path,"import heapq

def dijkstra_shortest_path(graph, source):
    distances = {node: float('inf') for node in graph}
    distances[source] = 0
    priority_queue = [(0, source)]
    heapq.heapify(priority_queue)

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)

        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances",136
72862285814,can_split,"from collections import Counter

def can_split(nums):
    count = Counter(nums)
    tails = Counter()

    for n in nums:
        if count[n] == 0:
            continue
        elif tails[n-1] > 0:
            tails[n-1] -= 1
            tails[n] += 1
        elif count[n+1] > 0 and count[n+2] > 0:
            count[n+1] -= 1
            count[n+2] -= 1
            tails[n+2] += 1
        else:
            return False
        count[n] -= 1
    return True",136
37168716721,is_valid_bst,"from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_valid_bst(root: Optional[TreeNode]) -> bool:
    def helper(node, min_val, max_val):
        if not node:
            return True
        if not (node.val > min_val and node.val < max_val):
            return False
        return (helper(node.left, min_val, node.val) and
                helper(node.right, node.val, max_val))
    return helper(root, float('-inf'), float('inf'))",136
72324629508,find_minimum,"def find_minimum(nums):
    if len(nums) == 1:
        return nums[0]
    left, right = 0, len(nums) - 1
    if nums[right] > nums[0]:
        return nums[0]
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] > nums[mid + 1]:
            return nums[mid + 1]
        if nums[mid - 1] > nums[mid]:
            return nums[mid]
        if nums[mid] > nums[0]:
            left = mid + 1
        else:
            right = mid - 1",136
18302743061,find_longest_conseq_subseq,"def find_longest_conseq_subseq(arr, n):
    if n == 0:
        return 0
    arr = list(set(arr))
    arr.sort()
    longest_streak = 1
    current_streak = 1
    for i in range(1, len(arr)):
        if arr[i] != arr[i - 1]:
            if arr[i] == arr[i - 1] + 1:
                current_streak += 1
            else:
                longest_streak = max(longest_streak, current_streak)
                current_streak = 1
    return max(longest_streak, current_streak)",136
14624836832,num_ways,"def num_ways(s):
    if s[0] == '0':
        return 0
    dp = [0] * (len(s) + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, len(s) + 1):
        if s[i-1] != '0':
            dp[i] += dp[i-1]
        if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] <= '6'):
            dp[i] += dp[i-2]
    return dp[len(s)]",136
11667151793,binary_search_index,"def binary_search_index(lis, target):
    if type(lis) is not list:
        raise TypeError(""binary search only accepts lists, not {}"".format(str(type(lis))))
    left = 0
    right = len(lis) - 1
    while left <= right:
        mid = (left + right) // 2
        if target == lis[mid]:
            if mid == 0 or lis[mid-1] != target:
                return mid
            right = mid - 1
        elif target < lis[mid]:
            right = mid - 1
        else:
            left = mid + 1
    return -1",136
72459847348,min_operations_to_palindrome,"def min_operations_to_palindrome(s: str) -> int:
    n = len(s)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 0
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1]
            else:
                dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1
    return dp[0][n-1]",136
36392606386,max_meetings,"from typing import List

def max_meetings(meetings: List[List[int]]) -> int:
    # Sort meetings based on end time
    meetings.sort(key=lambda x: x[1])
    
    # Initialize the end time of the first meeting and count
    last_meeting_end = meetings[0][1]
    count = 1
    
    # Iterate through the sorted meetings
    for start, end in meetings[1:]:
        # If the current meeting starts after the last meeting ends, it can be accommodated
        if start >= last_meeting_end:
            count += 1
            last_meeting_end = end
            
    return count",136
16429334597,longest_palindromic_subsequence,"def longest_palindromic_subsequence(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][n-1]",135
24202530716,min_steps,"def min_steps(arr):
    if len(arr) == 1:
        return 0
    queue = [(0, 0)]
    visited = [False] * len(arr)
    while queue:
        pos, step = queue.pop(0)
        if pos == len(arr) - 1:
            return step
        left, right = pos - arr[pos], pos + arr[pos]
        for next_pos in range(max(0, left), min(len(arr), right) + 1):
            if not visited[next_pos]:
                visited[next_pos] = True
                queue.append((next_pos, step + 1))
    return -1",135
30974683694,shortestDistance,"def shortestDistance(words, word1, word2):
    ShortestDistance = float('inf')
    Word1Indices = [i for i, x in enumerate(words) if x == word1 ]
    Word2Indices = [i for i, x in enumerate(words) if x == word2 ]
    
    for i in range(0,len(Word1Indices)) :
        for j in range(0,len(Word2Indices)) :
            if abs(Word1Indices[i] - Word2Indices[j]) < ShortestDistance :
                ShortestDistance = abs(Word1Indices[i] - Word2Indices[j])
    
    return ShortestDistance",135
25200548377,find_max_product,"def find_max_product(nums):
    if not nums:
        return 0
    n = len(nums)
    max_dp = [0] * n
    min_dp = [0] * n
    max_dp[0] = min_dp[0] = nums[0]
    for i in range(1, n):
        max_dp[i] = max(nums[i], max_dp[i-1] * nums[i], min_dp[i-1] * nums[i])
        min_dp[i] = min(nums[i], max_dp[i-1] * nums[i], min_dp[i-1] * nums[i])
    return max(max_dp)",135
22020377190,longest_palindrome_subsequence,"def longest_palindrome_subsequence(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][n - 1]",135
15906947588,longest_palindrome_subseq,"def longest_palindrome_subseq(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][n - 1]",135
32120947049,count_primes,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def count_primes(n):
    count = 0
    for i in range(2, n):
        if is_prime(i):
            count += 1
    return count",135
32499708330,palindromic_substrings,"def palindromic_substrings(s):
    def count_palindromes(s, left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total = 0
    for i in range(len(s)):
        total += count_palindromes(s, i, i)  # odd length palindromes
        total += count_palindromes(s, i, i+1)  # even length palindromes
    return total",135
70452287252,maxProfitWithKTransactions,"def maxProfitWithKTransactions(prices, k):
    if not len(prices):
        return 0

    buildDP = [[0 for _ in prices] for i in range(k + 1)]

    for row in range(1, k + 1):

        maxSeen = float('-inf')

        for col in range(1, len(prices)):

            maxSeen = max(maxSeen, -prices[col-1] + buildDP[row-1][col-1])
            buildDP[row][col] = max(buildDP[row][col-1], prices[col] + maxSeen)

    return buildDP[-1][-1]",135
71439507510,find_min_subarray,"def find_min_subarray(arr):
    n = len(arr)
    max_seen = -float('inf')
    right = -1
    for i in range(n):
        max_seen = max(max_seen, arr[i])
        if arr[i] < max_seen:
            right = i

    min_seen = float('inf')
    left = -1
    for i in range(n-1, -1, -1):
        min_seen = min(min_seen, arr[i])
        if arr[i] > min_seen:
            left = i

    return right - left + 1 if right != -1 and left != -1 else 0",135
72543226265,longestCommonSubsequence,"def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]",135
40928353852,is_circular_sentence,"def is_circular_sentence(sentence: str) -> bool:
    n = len(sentence)

    #check whether the first and the last character of the whole string are the same or not
    words = sentence.split()
    m = len(words)
    if sentence[0] != sentence[n - 1]:
        return False
    else:
        #iterating through the list and checking the fist chx and last chx are a  match
        for i in range(m-1):
            j = len(words[i]) - 1
            if words[i + 1][0] != words[i][j]:
                return False

    return True",135
13387769111,minPathCost,"def minPathCost(grid,m,n) :
    for i in range(m-1,-1,-1):
        for j in range(n-1,-1,-1):
            if i == m-1 and j != n-1:
                grid[i][j] += grid[i][j+1]
            elif i != m-1 and j == n-1:
                grid[i][j] += grid[i+1][j]
            elif i != m-1 and j != n-1:
                grid[i][j] += min(grid[i+1][j], grid[i][j+1])
    return grid[0][0]",135
31147547608,find_h_index,"def find_h_index(citations):
    answer = 0
    
    citations.sort(reverse=True)
    
    len_citations=len(citations)
    # print(len_citations)
    # print(citations)
    for cand_h in range(citations[0],0,-1):
        # print('if h is',cand_h, end=', ')
        satisfied=0
        for item in citations:
            # print(item, end=' ')
            if(item>=cand_h):
                satisfied+=1
            
        if satisfied>=cand_h:
            answer=cand_h
            break
                
        # print('cnt_satisfied',satisfied)
    
    return answer",135
72611726699,decode_message,"def decode_message(s: str) -> int:
    if not s or s[0] == '0':
        return 0
    if len(s) == 1:
        return 1
    one_back, two_back = 1, 1
    for i in range(1, len(s)):
        cur = 0
        if s[i] != '0':
            cur = one_back
        if s[i-1] != '0' and int(s[i-1:i+1]) <= 26:
            cur += two_back
        two_back, one_back = one_back, cur
    return one_back",135
40714492674,count_unique_bsts,"def count_unique_bsts(n):
    # Initialize the dynamic programming table
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1

    # Fill the dp table
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]

    return dp[n]

# Test the function
print(count_unique_bsts(3)) # 5
print(count_unique_bsts(4)) # 14
print(count_unique_bsts(5)) # 42",135
71527873029,is_valid_preorder,"def is_valid_preorder(preorder):
    stack = []
    lower_bound = float('-inf')
    for value in preorder:
        if value < lower_bound:
            return False
        while stack and stack[-1] < value:
            lower_bound = stack.pop()
        stack.append(value)
    return True

if __name__ == ""__main__"":
    assert is_valid_preorder([8,5,1,7,10,12]) == True
    assert is_valid_preorder([5,2,1,3,6]) == True
    assert is_valid_preorder([5,6,1,2,3]) == False",135
17035217841,find_kth_largest,"import heapq

def find_kth_largest(nums, k):
    min_heap = []
    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    return min_heap[0]

assert find_kth_largest([3,2,1,5,6,4], 2) == 5
assert find_kth_largest([3,2,3,1,2,4,5,5,6], 4) == 4
assert find_kth_largest([3,2,1], 2) == 2",135
12121060153,transpose,"def transpose(matrix):
    # Get the number of rows and columns in the matrix
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Initialize an empty list to store the transposed matrix
    transposed = []
    
    # Create a list of lists with the appropriate dimensions for the transposed matrix
    for i in range(cols):
        transposed.append([0] * rows)
    
    # Fill in the transposed matrix with the appropriate values from the original matrix
    for i in range(rows):
        for j in range(cols):
            transposed[j][i] = matrix[i][j]
    
    return transposed",135
11945579291,closest_points,"import math

def euclidean_distance(point1, point2):
    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)

def closest_points(points):
    points.sort()
    min_distance = float('inf')
    closest_pair = None
    for i in range(len(points)-1):
        for j in range(i+1, min(i+8, len(points))):
            distance = euclidean_distance(points[i], points[j])
            if distance < min_distance:
                min_distance = distance
                closest_pair = (points[i], points[j])
    return closest_pair",135
33985939708,longest_palindrome_subseq,"def longest_palindrome_subseq(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][n - 1]",135
1823380207,longest_palindrome_subseq,"def longest_palindrome_subseq(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][n - 1]",135
71456102964,minCostPath,"from typing import List

def minCostPath(cost: List[List[int]]) -> int:
    m = len(cost)
    n = len(cost[0])
    for i in range(1, n):
        cost[0][i] += cost[0][i-1]
    for i in range(1, m):
        cost[i][0] += cost[i-1][0]
    for i in range(1, m):
        for j in range(1, n):
            cost[i][j] += min(cost[i-1][j], cost[i][j-1])
    return cost[m-1][n-1]",135
28644565078,sum_of_primes_below,"def sum_of_primes_below(n):
    if not isinstance(n, int):
        return ""Input is not an integer!""
    if n < 1:
        return ""Input must be bigger than 0!""
    if n == 1:
        return 0
    primes = []
    for possiblePrime in range(2, n):
        isPrime = True
        for num in range(2, int(possiblePrime ** 0.5) + 1):
            if possiblePrime % num == 0:
                isPrime = False
                break
        if isPrime:
            primes.append(possiblePrime)
    return sum(primes)",135
10294528637,longest_palindromic_subsequence,"def longest_palindromic_subsequence(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][n-1]",135
8868848286,len_longest_substring,"def len_longest_substring(s):
    """"""
    Finds the length of the longest substring without repeating characters.
    :param s: input string
    :return: length of the longest substring without repeating characters
    """"""
    if not s:
        return 0
    start, max_length = 0, 0
    char_index = {}
    for i, char in enumerate(s):
        if char in char_index and start <= char_index[char]:
            start = char_index[char] + 1
        else:
            max_length = max(max_length, i - start + 1)
        char_index[char] = i
    return max_length",135
37675185939,longest_palindromic_subsequence,"def longest_palindromic_subsequence(s: str) -> int:
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][n-1]",135
42663422590,longest_palindrome_subseq,"def longest_palindrome_subseq(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n - 1, -1, -1):
        dp[i][i] = 1
        for j in range(i + 1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][n - 1]",135
15952465711,find_unique_intersection,"def find_unique_intersection(list1, list2):
    # Create dictionaries to count occurrences of each string in both lists
    dict1 = {}
    dict2 = {}
    for item in list1:
        dict1[item] = dict1.get(item, 0) + 1
    for item in list2:
        dict2[item] = dict2.get(item, 0) + 1
    # Find the intersection of strings that appear exactly once in both lists
    result = [item for item in dict1 if item in dict2 and dict1[item] == 1 and dict2[item] == 1]
    return result",134
39641456526,longest_substring_with_k_unique,"def longest_substring_with_k_unique(s, k):
    if not s or k <= 0:
        return 0

    char_map = {}
    left = 0
    max_len = 0

    for right in range(len(s)):
        char_map[s[right]] = char_map.get(s[right], 0) + 1

        while len(char_map) > k:
            char_map[s[left]] -= 1
            if char_map[s[left]] == 0:
                del char_map[s[left]]
            left += 1

        max_len = max(max_len, right - left + 1)

    return max_len",134
73082516590,min_operations_to_palindrome,"def min_operations_to_palindrome(s: str) -> int:
    n = len(s)
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(n):
        for j in range(n - 1, -1, -1):
            if s[i] == s[j]:
                dp[i + 1][j] = dp[i][j + 1] + 1
            else:
                dp[i + 1][j] = max(dp[i][j], dp[i + 1][j + 1])
    return n - dp[n][0]",134
23127496420,max_sub_array,"def max_sub_array(arr, k):
    max_sum = 0
    window_sum = 0
    window_start = 0

    for window_end in range(len(arr)):
        window_sum += arr[window_end]  # add the next element
        # slide the window, we don't need to slide if we've not hit the required window size of 'k'
        if window_end >= k - 1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]  # subtract the element going out
            window_start += 1  # slide the window ahead

    return max_sum",134
74608432685,num_ways_to_decode,"def num_ways_to_decode(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] != '0':
            dp[i] = dp[i-1]
        two_digit = int(s[i-2:i])
        if 10 <= two_digit <= 26:
            dp[i] += dp[i-2]
    return dp[n]",134
10267138962,smallest_subsequence,"def smallest_subsequence(s: str) -> str:
    """"""
    Finds the lexicographically smallest subsequence of the given string
    that contains all the distinct characters of the string exactly once.
    
    :param s: Input string
    :return: Lexicographically smallest subsequence
    """"""
    last_occurrence = {char: idx for idx, char in enumerate(s)}
    result = []
    for idx, char in enumerate(s):
        if char not in result:
            while result and char < result[-1] and idx < last_occurrence[result[-1]]:
                result.pop()
            result.append(char)
    return ''.join(result)",134
17017982463,longest_Subarray,"def longest_Subarray(arr):
    n = len(arr)
    sum = 0
    max_len = 0
    sum_map = {}
    for i in range(n):
        if arr[i] == 0:
            arr[i] = -1
        else:
            arr[i] = 1
    for i in range(n):
        sum = sum + arr[i]
        if sum == 0:
            max_len = i + 1
        if sum in sum_map:
            max_len = max(max_len, i - sum_map[sum])
        else:
            sum_map[sum] = i
    return max_len",134
26627809689,binary_search,"def binary_search(arr, x):
    low = 0
    high = len(arr) - 1
    mid = 0

    while low <= high:

        mid = (high + low) // 2

        # If x is greater, ignore left half
        if arr[mid] < x:
            low = mid + 1

        # If x is smaller, ignore right half
        elif arr[mid] > x:
            high = mid - 1

        # x is present at mid
        else:
            return mid

    # If we reach here, then the element was not present
    return -1",134
73932256315,binary_search,"def binary_search(arr, x):
    low = 0
    high = len(arr) - 1
    mid = 0
 
    while low <= high:
 
        mid = (high + low) // 2
 
        # If x is greater, ignore left half
        if arr[mid] < x:
            low = mid + 1
 
        # If x is smaller, ignore right half
        elif arr[mid] > x:
            high = mid - 1
 
        # x is present at mid
        else:
            return True
 
    # If we reach here, then the element was not present
    return False",134
31299827775,find_longest_strings,"def find_longest_strings(inputArray):
    if(1 <= len(inputArray) <= 10):
        length_list = []
        for i in range(len(inputArray)):
            if(1 <= len(inputArray[i]) <= 10):
                pass
            else:
                return
        for i in range(len(inputArray)):
            length_list.append(len(inputArray[i]))
        
        max_value = max(length_list)
        max_indices = [i for i, x in enumerate(length_list) if x == max_value]
        
        longest_strings = []
        
        for i in max_indices:
            longest_strings.append(inputArray[i])
        return longest_strings",134
43646496381,are_anagrams,"def are_anagrams(str1, str2):
    str1 = str1.replace(' ', '').lower()
    str2 = str2.replace(' ', '').lower()

    if len(str1) != len(str2):
        return False

    count = {}
    for char in str1:
        if char in count:
            count[char] += 1
        else:
            count[char] = 1

    for char in str2:
        if char in count:
            count[char] -= 1
        else:
            return False

    for value in count.values():
        if value != 0:
            return False

    return True",134
2291013239,count_palindromic_substrings,"def count_palindromic_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # Count odd length palindromes
        total_count += expand_around_center(i, i)
        # Count even length palindromes
        total_count += expand_around_center(i, i + 1)
    return total_count",134
28515332476,is_valid_ISBN,"def is_valid_ISBN(isbn):
    if len(isbn) != 10:
        return False
    digits = []
    for i in range(9):
        if not isbn[i].isdigit():
            return False
        digits.append(int(isbn[i]))
    if isbn[9].isdigit():
        digits.append(int(isbn[9]))
    elif isbn[9] == 'X':
        digits.append(10)
    else:
        return False
    sum = 0
    for i in range(10):
        sum += digits[i] * (10 - i)
    return sum % 11 == 0",134
2289444969,valid_tree,"def valid_tree(n, edges):
    neighbors = [set() for _ in range(n)]
    for i, j in edges:
        neighbors[i].add(j)
        neighbors[j].add(i)
    
    visited = [False] * n
    if not dfs(0, -1, neighbors, visited):
        return False
    return all(visited)

def dfs(node, parent, neighbors, visited):
    if visited[node]:
        return False
    visited[node] = True
    for neighbor in neighbors[node]:
        if neighbor != parent:
            if not dfs(neighbor, node, neighbors, visited):
                return False
    return True",134
35128450003,is_isomorphic,"def is_isomorphic(s: str, t: str) -> bool:
    lens, lent = len(s), len(t)
    if lens != lent: return False 
        
    s2t, t2s = {}, {}
    for i in range(lens):
        si, ti = s[i], t[i]
        if si in s2t.keys() and s2t[si] != ti:
            return False 
        if ti in t2s.keys() and t2s[ti] != si:
            return False 
        s2t[si] = ti
        t2s[ti] = si
            
    return True",134
5406242455,eraseOverlapIntervals,"def eraseOverlapIntervals(intervals):
    if not intervals:
        return 0

    remove = 0
    intervals = sorted(intervals, key=lambda x: x[1])  # sort based on end
    endP = intervals[0][1]

    for i in range(1, len(intervals)):

        startN = intervals[i][0]
        endN = intervals[i][1]

        if startN < endP:
            remove += 1
        else:  # if the interval is not remove, we set a new StartPrev and new endPrev
            endP = endN

    return remove",134
11249562925,find_two_largest,"def find_two_largest(numbers):
    unique_numbers = list(set(numbers))
    unique_numbers.sort()
    return (unique_numbers[-1], unique_numbers[-2])

def main():
    assert find_two_largest([1, 2, 3, 4, 5]) == (5, 4)
    assert find_two_largest([5, 5, 5, 4, 4]) == (5, 4)
    assert find_two_largest([10, 10, 9, 8, 8]) == (10, 9)

if __name__ == ""__main__"":
    main()",134
41433768571,roman_to_int,"def roman_to_int(s):
    rom_val = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    int_val = 0
    for i in range(len(s)):
        if i > 0 and rom_val[s[i]] > rom_val[s[i - 1]]:
            int_val += rom_val[s[i]] - 2 * rom_val[s[i - 1]]
        else:
            int_val += rom_val[s[i]]
    return int_val",134
9820642919,generate_IP,"def generate_IP(s):
    def backtrack(start, ip):
        if start == len(s) and len(ip) == 4:
            res.append(""."".join(ip))
            return
        if len(ip) > 4:
            return
        for i in range(start, min(start+3, len(s))):
            if int(s[start:i+1]) <= 255 and (s[start] != '0' or len(s[start:i+1]) == 1):
                ip.append(s[start:i+1])
                backtrack(i+1, ip)
                ip.pop()
    res = []
    backtrack(0, [])
    return res",134
40710169844,count_palindromic_substrings,"def count_palindromic_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # Count odd length palindromes
        total_count += expand_around_center(i, i)
        # Count even length palindromes
        total_count += expand_around_center(i, i + 1)

    return total_count",134
74354382861,zero_sum_subarray,"def zero_sum_subarray(arr):
    sum_dict = {0: -1}
    max_len = 0
    max_start = -1
    curr_sum = 0
    for i, num in enumerate(arr):
        curr_sum += num
        if curr_sum in sum_dict:
            start = sum_dict[curr_sum] + 1
            if i - start > max_len:
                max_len = i - start
                max_start = start
        else:
            sum_dict[curr_sum] = i
    if max_start == -1:
        return []
    else:
        return [max_start, max_start + max_len]",134
7420050025,product_except_self,"def product_except_self(lst):
    n = len(lst)
    left_products = [1] * n
    right_products = [1] * n
    output = [1] * n

    left_product = 1
    for i in range(n):
        left_products[i] = left_product
        left_product *= lst[i]

    right_product = 1
    for i in range(n-1, -1, -1):
        right_products[i] = right_product
        right_product *= lst[i]

    for i in range(n):
        output[i] = left_products[i] * right_products[i]

    return output",133
23065933400,binary_search,"def binary_search(arr, x):
    low = 0
    high = len(arr) - 1
    mid = 0

    while low <= high:

        mid = (high + low) // 2

        # If x is greater, ignore left half
        if arr[mid] < x:
            low = mid + 1

        # If x is smaller, ignore right half
        elif arr[mid] > x:
            high = mid - 1

        # x is present at mid
        else:
            return True

    # If we reach here, then the element was not present
    return False",133
24354402385,find_longest_subarray,"def find_longest_subarray(arr, n):
    # Create a dictionary to store the first occurrence of a sum
    sum_first_occ = {0: -1}
    sum_val = 0
    max_len = 0

    for i in range(n):
        if arr[i] == 0:
            sum_val -= 1
        else:
            sum_val += 1

        if sum_val in sum_first_occ:
            curr_len = i - sum_first_occ[sum_val]
            max_len = max(max_len, curr_len)
        else:
            sum_first_occ[sum_val] = i

    return max_len",133
30899065116,insert_index,"def insert_index(nums, insert):
    left, right = 0, len(nums)
    while left < right:
        mid = (left + right) // 2
        if nums[mid] < insert:
            left = mid + 1
        else:
            right = mid
    return left

def main():
    nums = [1, 3, 5, 6]    #<---Change to your list of numbers HERE.
    insert = 5           #<---Enter the number you want to find its insertion index
    print(insert_index(nums, insert))

if __name__ == ""__main__"":
    main()",133
26482168168,longest_palindromic_subseq,"def longest_palindromic_subseq(s):
    n = len(s)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][n-1]",133
33759586968,word_segment,"def word_segment(s, wordDict):
    wordDict = set(wordDict)
    len_s = len(s)
    dp = [False] * len_s
    for i in range(len_s):
        if s[:i + 1] in wordDict:
            dp[i] = True
    if dp[-1]:
        return True
    for i in range(len_s):
        if dp[i]:
            for j in range(i + 1, len_s):
                if s[i + 1:j + 1] in wordDict:
                    dp[j] = True
                if dp[-1]:
                    return True
    return False",133
34555310920,min_in_rotate_array,"def min_in_rotate_array(rotateArray):
    if len(rotateArray) == 0:
        return 0
    if len(rotateArray) == 1:
        return rotateArray[0]
    low, high = 0, len(rotateArray) - 1
    while rotateArray[low] >= rotateArray[high]:
        if high - low == 1:
            return rotateArray[high]
        mid = (low + high) // 2
        if rotateArray[mid] >= rotateArray[low]:
            low = mid
        else:
            high = mid
    return rotateArray[low]",133
19062634654,reverse_linked_list_to_array,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list_to_array(head):
    current_Node = head
    count = 0
    newHead = None
    while current_Node:
        count += 1
        current_Node = current_Node.next
    array = [None] * count
    for i in range(count):
        newNode = ListNode(head.val)
        newNode.next = newHead
        newHead = newNode
        head = head.next
        array[count - i - 1] = newHead.val
    return array",133
69878226987,decode_ways,"def decode_ways(s, key):
    if not s or s[0]=='0':
        return 0
    n, dp = len(s), [0]*(len(s)+1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n+1):
        dp[i] = 0
        if s[i-1:i]!='0':
            dp[i] = dp[i-1]
        if s[i-2:i]<='26' and s[i-2:i]!='00':
            dp[i] += dp[i-2]
    return dp[n]",133
32620098252,merge_sorted_arrays,"def merge_sorted_arrays(arrays):
    from heapq import heappush, heappop
    min_heap = []
    result = []
    for i, array in enumerate(arrays):
        heappush(min_heap, (array[0], i, 0))
    while min_heap:
        val, array_idx, element_idx = heappop(min_heap)
        result.append(val)
        if element_idx + 1 < len(arrays[array_idx]):
            next_tuple = (arrays[array_idx][element_idx + 1],
                          array_idx,
                          element_idx + 1)
            heappush(min_heap, next_tuple)
    return result",133
27843747032,nth_ugly_number,"def nth_ugly_number(n):
    ugly = [1]
    i2 = i3 = i5 = 0
    while len(ugly) < n:
        while ugly[i2] * 2 <= ugly[-1]: i2 += 1
        while ugly[i3] * 3 <= ugly[-1]: i3 += 1
        while ugly[i5] * 5 <= ugly[-1]: i5 += 1
        ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))
    return ugly[-1]",133
73377209579,numWaysToReachLastCell,"def numWaysToReachLastCell(N: int, M: int) -> int:
    MOD = int(1e9) + 7
    dp = [[0]*M for _ in range(N)]
    dp[0][0] = 1
    for i in range(N):
        for j in range(M):
            if i-1 >= 0:
                dp[i][j] += dp[i-1][j]
            if j-1 >= 0:
                dp[i][j] += dp[i][j-1]
            dp[i][j] %= MOD
    return dp[-1][-1]",133
7000333438,min_repeat_substring_length,"def min_repeat_substring_length(s):
    n = len(s)
    for i in range(1, n//2 + 1):
        if n % i == 0:
            if s[:i] * (n//i) == s:
                return i
    return n

if __name__ == '__main__':
    print(min_repeat_substring_length(""abcabcabc""))
    print(min_repeat_substring_length(""abcdabcdabcdabcd""))
    print(min_repeat_substring_length(""aaaa""))
    print(min_repeat_substring_length(""abcdef""))
    print(min_repeat_substring_length(""aabbccddeeffaabbccddeeff""))",133
23462019816,longest_consecutive_subsequence,"def longest_consecutive_subsequence(s):
    if not s:
        return """"
    max_len = 1
    current_len = 1
    start = 0
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            current_len += 1
        else:
            if current_len > max_len:
                max_len = current_len
                start = i - max_len
            current_len = 1
    if current_len > max_len:
        max_len = current_len
        start = len(s) - max_len
    return s[start:start + max_len]",133
11031195633,length_longest_substring,"def length_longest_substring(s, k):
    if not s:
        return 0
    
    count = {}
    l = 0
    max_len = 0
    
    for r in range(len(s)):
        if s[r] in count:
            count[s[r]] += 1
        else:
            count[s[r]] = 1

        while len(count) > k:
            count[s[l]] -= 1
            if count[s[l]] == 0:
                del count[s[l]]
            l += 1
        
        max_len = max(max_len, r - l + 1)
    
    return max_len",133
33623637099,count_paths,"def count_paths(m: int, n: int) -> int:
    if m == 1 or n == 1:
        return 1
    dp = [[0] * n for _ in range(m)]
    for i in range(m):
        dp[i][0] = 1
    for j in range(n):
        dp[0][j] = 1
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[m-1][n-1]",133
2861173790,count_ways_to_reach_last_cell,"def count_ways_to_reach_last_cell(matrix, n, m):
    dp = [[0 for _ in range(m)] for _ in range(n)]
    if matrix[0][0] == 0:
        dp[0][0] = 1
    for i in range(n):
        for j in range(m):
            if matrix[i][j] == 0:
                if i > 0:
                    dp[i][j] += dp[i-1][j]
                if j > 0:
                    dp[i][j] += dp[i][j-1]
    return dp[n-1][m-1]",133
72056555766,roman_to_integer,"def roman_to_integer(s: str) -> int:
    roman_values = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000
    }
    total = 0
    prev_value = 0
    for char in reversed(s):
        value = roman_values[char]
        if value < prev_value:
            total -= value
        else:
            total += value
        prev_value = value
    return total",132
3766033128,decodeWays,"def decodeWays(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] != '0':
            dp[i] += dp[i-1]
        two_digit = int(s[i-2:i])
        if 10 <= two_digit <= 26:
            dp[i] += dp[i-2]
    return dp[n]",132
35995208976,calculate_levenshtein_distance,"def calculate_levenshtein_distance(s1, s2):
    if s1 == """":
        return len(s2)
    if s2 == """":
        return len(s1)
    if s1[-1] == s2[-1]:
        cost = 0
    else:
        cost = 1
       
    res = min([calculate_levenshtein_distance(s1[:-1], s2)+1,
               calculate_levenshtein_distance(s1, s2[:-1])+1, 
               calculate_levenshtein_distance(s1[:-1], s2[:-1]) + cost])
    return res",132
43063573729,largest_common_digit,"def largest_common_digit(X, Y):
    answer = ''
    tmp=0
    
    # Start from the largest digit
    for i in range(9,-1,-1):
        # Find the number of occurrences of the digit in both numbers
        tmp = min(X.count(str(i)),Y.count(str(i)))
        # If the digit is found in both numbers, add it to the answer
        if tmp > 0:
            answer+=str(i)
            # Return the answer as soon as we find a common digit
            return answer[0]
    
    # Return None if no common digit is found
    return ""None""",132
35213112382,merge_sorted_arrays,"def merge_sorted_arrays(arr1,arr2): 
    result = [] 
    i = j = 0
    while i < len(arr1) and j < len(arr2): 
        if arr1[i] < arr2[j]: 
            result.append(arr1[i]) 
            i += 1
        else: 
            result.append(arr2[j]) 
            j += 1
    while i < len(arr1): 
        result.append(arr1[i]) 
        i += 1
    while j < len(arr2): 
        result.append(arr2[j]) 
        j += 1
    return result",132
31288321297,max_common_subsequence,"def max_common_subsequence(str1, str2):
    dp = [[0 for _ in range(len(str2)+1)] for _ in range(len(str1)+1)]
    for i in range(1, len(str1)+1):
        for j in range(1, len(str2)+1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[-1][-1]",132
5001334762,minSwapsToSort,"def minSwapsToSort(arr):
    n = len(arr)
    pos = [0] * (n + 1)
    for i in range(n):
        pos[arr[i]] = i

    result = 0
    for i in range(n):
        correct_val = i + 1
        if arr[i] != correct_val:
            to_swap_idx = pos[correct_val]
            arr[i], arr[to_swap_idx] = arr[to_swap_idx], arr[i]
            pos[arr[to_swap_idx]], pos[arr[i]] = pos[arr[i]], pos[arr[to_swap_idx]]
            result += 1
    return result",132
4730930884,count_palindromic_substrings,"def count_palindromic_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # Odd length palindromes
        total_count += expand_around_center(i, i)
        # Even length palindromes
        total_count += expand_around_center(i, i + 1)
    return total_count",132
69856359801,count_palindromic_substrings,"def count_palindromic_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        total_count += expand_around_center(i, i)  # Odd length palindromes
        total_count += expand_around_center(i, i + 1)  # Even length palindromes

    return total_count",132
72195482625,decode_ways,"def decode_ways(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] != '0':
            dp[i] += dp[i-1]
        two_digit = int(s[i-2:i])
        if 10 <= two_digit <= 26:
            dp[i] += dp[i-2]
    return dp[n]",132
34263852335,max_Flip_1,"def max_Flip_1(arr,n):
    count_0 = 0
    count_1 = 0
    max_len = 0
    left = 0
    for right in range(n):
        if arr[right] == 0:
            count_0 += 1
        else:
            count_1 += 1
        if count_0 > 1:
            if arr[left] == 0:
                count_0 -= 1
            else:
                count_1 -= 1
            left += 1
        max_len = max(max_len,right-left+1)
    return max_len",132
6093712309,recover_array,"from collections import defaultdict, Counter
from itertools import chain

def recover_array(pairs):
    n = len(pairs) + 1
    graph = defaultdict(list)
    for a, b in pairs:
        graph[a].append(b)
        graph[b].append(a)
    start = next(e for e, cnt in Counter(chain(*pairs)).items() if cnt == 1)
    result = [start]
    seen = {start}
    for _ in range(1, n):
        start = next(ne for ne in graph[start] if ne not in seen)
        result.append(start)
        seen.add(start)
    return result",132
29398319437,count_palindromic_substrings,"def count_palindromic_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        total_count += expand_around_center(i, i)  # Odd length palindromes
        total_count += expand_around_center(i, i + 1)  # Even length palindromes
    return total_count",132
73334432826,simplify_polynomial,"def simplify_polynomial(polynomial):
    cnt = 0
    num = 0
    
    for i in polynomial.split():
        if 'x' in i:
            if len(i) > 1:
                i = i.replace('x', '')
                cnt += int(i)
            else:
                cnt += 1
        elif i.isnumeric():
            num += int(i)

    return (""{}x"".format(cnt if cnt > 1 else """") if cnt > 0 else """") + ("" + "" if cnt > 0 and num > 0 else """") + (""{}"".format(num) if num > 0 else ""0"")",132
24294674686,count_palindromic_substrings,"def count_palindromic_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        total_count += expand_around_center(i, i)  # Odd length palindromes
        total_count += expand_around_center(i, i + 1)  # Even length palindromes

    return total_count",132
684511967,is_symmetric_around_y_axis,"def is_symmetric_around_y_axis(points):
    max_val, min_val = float(""-inf""), float(""inf"")
    dic = {}
    for p in points:
        max_val = max(max_val, p[0])
        min_val = min(min_val, p[0])
        dic[str(p[0]) + "":"" + str(p[1])] = 1

    mid_val = (min_val + max_val) / 2
    for p in points:
        temp_str = str(-p[0]) + "":"" + str(p[1])
        if temp_str not in dic:
            return False

    return True",132
74047516800,numDecodings,"def numDecodings(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] != '0':
            dp[i] += dp[i-1]
        two_digit = int(s[i-2:i])
        if 10 <= two_digit <= 26:
            dp[i] += dp[i-2]
    return dp[n]",132
7252723977,largestNumber,"from functools import cmp_to_key
def compare(t1,t2):
    if(t1!=t2):
        t1,t2=str(t1),str(t2)
        if(t1+t2 > t2+t1):
            return -1
        if(t1+t2 < t2+t1):
            return 1
        return 0
    else:
        return 0

def largestNumber(nums):
    nums.sort(key=cmp_to_key(compare))
    l=''
    for i in range(len(nums)):
        l+=str(nums[i])
    if(int(l)+1==1):
        return '0'
    return l",132
5984934080,find_combinations,"def find_combinations(nums, k):
    def backtrack(start, path):
        if len(path) == k:
            result.append(path[:])
            return
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()

    result = []
    backtrack(0, [])
    return result

print(find_combinations([1, 2, 3], 2))
print(find_combinations([1, 2, 3, 4], 3))
print(find_combinations([1, 2, 3, 4, 5], 4))",132
12149679303,mergeSortedLists,"def mergeSortedLists(list1, list2):
    merged_list = []
    i = 0
    j = 0
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            merged_list.append(list1[i])
            i += 1
        else:
            merged_list.append(list2[j])
            j += 1
    while i < len(list1):
        merged_list.append(list1[i])
        i += 1
    while j < len(list2):
        merged_list.append(list2[j])
        j += 1
    return merged_list",132
37286667773,count_palindromic_substrings,"def count_palindromic_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # Odd length palindromes
        total_count += expand_around_center(i, i)
        # Even length palindromes
        total_count += expand_around_center(i, i + 1)
    return total_count",132
26188240309,decode_ways,"def decode_ways(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] != '0':
            dp[i] += dp[i-1]
        two_digit = int(s[i-2:i])
        if 10 <= two_digit <= 26:
            dp[i] += dp[i-2]
    return dp[n]",132
28372439130,max_length_product,"def max_length_product(words):
    words = sorted(words, key=lambda x: len(x), reverse=True)
    max_len = 0
    for i in range(len(words)):
        a_len = len(words[i])
        a_set = set(words[i])
        if a_len * a_len <= max_len:
            break
        for j in range(i + 1, len(words)):
            b_len = len(words[j])
            if b_len <= (max_len // a_len):
                break
            if a_set.isdisjoint(set(words[j])):
                max_len = max(max_len, a_len * b_len)
    return max_len",132
36142095433,nthUglyNumber,"def nthUglyNumber(n):
    ugly = [1]
    i2 = i3 = i5 = 0
    while len(ugly) < n:
        while ugly[i2] * 2 <= ugly[-1]: i2 += 1
        while ugly[i3] * 3 <= ugly[-1]: i3 += 1
        while ugly[i5] * 5 <= ugly[-1]: i5 += 1
        ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))
    return ugly[-1]",132
781233425,remove_duplicates_from_doubly_linked_list,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

def remove_duplicates_from_doubly_linked_list(arr):
    if len(arr) == 0:
        return []
    head = Node(arr[0])
    current = head
    for i in range(1, len(arr)):
        if arr[i] != arr[i-1]:
            current.next = Node(arr[i])
            current.next.prev = current
            current = current.next
    result = []
    while head:
        result.append(head.data)
        head = head.next
    return result",132
70944400440,roman_to_int,"def roman_to_int(s: str) -> int:
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0

    for i in range(len(s)-1, -1, -1):
        value = roman_values[s[i]]
        if value < prev_value:
            total -= value
        else:
            total += value
        prev_value = value

    return total",132
5963257445,decode_ways,"def decode_ways(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] != '0':
            dp[i] += dp[i-1]
        two_digit = int(s[i-2:i])
        if 10 <= two_digit <= 26:
            dp[i] += dp[i-2]
    return dp[n]",132
28042397355,find_palindromic_substrings,"def find_palindromic_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        total_count += expand_around_center(i, i)  # odd length palindromes
        total_count += expand_around_center(i, i + 1)  # even length palindromes
    return total_count",132
43256274161,is_valid,"def is_valid(s: str) -> bool:
    string = list(s)
    openings = ['(','[','{'] 
    closings = [')',']','}'] 
    stack = []

    for i in range(len(string)):
        if string[i] in openings:
            stack.append(string[i])

        if string[i] in closings:    
            if len(stack) == 0:
                return False    
            
            check = stack.pop()
            
            if closings.index(string[i]) != openings.index(check): 
                return False

    if len(stack) != 0:
        return False
    
    else:
        return True",132
25892389547,min_Jumps,"def min_Jumps(arr):
    n = len(arr)
    jumps = [0 for i in range(n)]
 
    if (n == 0) or (arr[0] == 0):
        return float('inf')
 
    jumps[0] = 0
    for i in range(1, n):
        jumps[i] = float('inf')
        for j in range(i):
            if (i <= j + arr[j]) and (jumps[j] != float('inf')):
                jumps[i] = min(jumps[i], jumps[j] + 1)
                break
    return jumps[n-1]",132
13325813826,maximum_after_decrease_rearrange,"def maximum_after_decrease_rearrange(arr):
    # Sort the array
    arr.sort()

    # Initialize the first element to be 1
    arr[0] = 1

    # Iterate through the array from the second element
    for i in range(1, len(arr)):
        # If the current element is greater than the previous element + 1, reduce it
        if arr[i] > arr[i - 1] + 1:
            arr[i] = arr[i - 1] + 1

    # The maximum value will be the last element in the array
    return arr[-1]",132
30002129765,find_combinations,"def find_combinations(nums, target):
    def backtrack(remain, combo, start):
        if remain == 0:
            results.append(list(combo))
            return
        elif remain < 0:
            return
        
        for i in range(start, len(nums)):
            # Add the number to the combination
            combo.append(nums[i])
            # Give the current number to the next position with the remainder
            backtrack(remain - nums[i], combo, i)
            # Backtrack, remove the number from the combination
            combo.pop()
    
    nums.sort()
    results = []
    backtrack(target, [], 0)
    return results",132
38902935381,num_ways,"def num_ways(n: int) -> int:
    if n <= 1:
        return 1
    mod = 10 ** 9 + 7
    one = two = 1
    res = 0
    for i in range(2, n+1):
        res = (one + two) % mod
        one, two = res, one
    return res

if __name__ == '__main__':
    assert num_ways(2) == 2
    assert num_ways(7) == 21
    assert num_ways(10) == 89",132
10945497654,convert_snake_to_camel,"def convert_snake_to_camel(s: str) -> str:
    components = s.split('_')
    # Capitalize the first letter of each component except the first one
    # Then join them together
    return components[0] + ''.join(x.title() for x in components[1:])

# Test cases
assert convert_snake_to_camel(""this_is_a_test_string"") == ""thisIsATestString""
assert convert_snake_to_camel(""snake_case_to_camel_case"") == ""snakeCaseToCamelCase""
assert convert_snake_to_camel(""example_snake_case"") == ""exampleSnakeCase""",132
20149257682,longest_substring_without_repeating,"def longest_substring_without_repeating(s):
    if not s:
        return """"
    left = 0
    right = 0
    max_len = 0
    max_substring = """"
    char_dict = {}
    while right < len(s):
        if s[right] in char_dict:
            left = max(char_dict[s[right]] + 1, left)
        char_dict[s[right]] = right
        if right - left + 1 > max_len:
            max_len = right - left + 1
            max_substring = s[left:right+1]
        right += 1
    return max_substring",132
43551421324,str_find,"def str_find(s, sub):
    m, n = len(sub), len(s)
    if m > n:
        return -1

    low, high = 0, 0
    while high < n:
        i = 0
        while i < m and high < n and s[high] == sub[i]:
            if i == m - 1:
                return low
            high, i = high + 1, i + 1

        if i == 0:
            low += 1 + i
        else:
            low += 1

        high = low

    return -1",131
74449111864,prev_permutation,"def prev_permutation(A):
    lenn = len(A)
    i = lenn - 1
    while i > 0 and A[i-1] <= A[i]:
        i -= 1
    if i == 0:
        return A
    left = i - 1
    right = lenn - 1
    while right >= i and A[right] >= A[left]:
        right -= 1
    while A[right] == A[right - 1] and right >= i:
        right -= 1
    A[right], A[left] = A[left], A[right]
    return A",131
34602033761,min_subarray_length,"def min_subarray_length(target, nums):
    if nums == None or len(nums) == 0:
        return 0
    if nums[0] >= target:
        return 1

    start = 0
    end = 0
    window_sum = 0
    minimum = float('inf')

    while end < len(nums):
        window_sum += nums[end]
        end += 1

        while window_sum >= target:
            minimum = min(minimum, end - start)
            window_sum -= nums[start]
            start += 1

    return minimum if minimum != float('inf') else 0",131
22958281033,count_palindromic_substrings,"def count_palindromic_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        total_count += expand_around_center(i, i)  # Odd length palindromes
        total_count += expand_around_center(i, i+1)  # Even length palindromes

    return total_count",131
9656265007,subarraysDivByK,"from collections import Counter

def subarraysDivByK(A, K):
    n = len(A)
    P = [0 for i in range(n+1)]
    mods = [0 for i in range(n+1)]
    
    for i in range(n):
        P[i+1] = P[i] + A[i]
        mods[i+1] = P[i+1] % K

    counter = Counter(mods)
    res = 0

    for key in counter:
        value = counter.get(key,0)
        res = res + int((value * (value-1))/2)

    return res",131
38419063192,merge_sorted_lists,"def merge_sorted_lists(l1, l2):
    i, j = 0, 0
    merged_list = []
    while i < len(l1) and j < len(l2):
        if l1[i] < l2[j]:
            merged_list.append(l1[i])
            i += 1
        else:
            merged_list.append(l2[j])
            j += 1
    while i < len(l1):
        merged_list.append(l1[i])
        i += 1
    while j < len(l2):
        merged_list.append(l2[j])
        j += 1
    return merged_list",131
13354928350,min_operations_to_palindrome,"def min_operations_to_palindrome(s):
    n = len(s)
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    
    for i in range(n):
        for j in range(n - 1, -1, -1):
            if s[i] == s[j]:
                dp[i + 1][j] = dp[i][j + 1] + 1
            else:
                dp[i + 1][j] = max(dp[i][j], dp[i + 1][j + 1])
    
    return n - dp[n][0]",131
35384194715,max_nested_parentheses,"def max_nested_parentheses(s):
    # Initialize the maximum depth and current depth to 0
    max_depth = curr_depth = 0
    # Iterate over the string
    for char in s:
        # If the character is an open parenthesis, increment the current depth
        if char == '(':
            curr_depth += 1
            # Update the maximum depth if necessary
            max_depth = max(max_depth, curr_depth)
        # If the character is a close parenthesis, decrement the current depth
        elif char == ')':
            curr_depth -= 1
    # Return the maximum depth
    return max_depth",131
20528245180,is_good_number,"def is_good_number(N: int) -> bool:
    valid_digits = {'0', '1', '8', '2', '5', '6', '9'}
    rotation_map = {'0': '0', '1': '1', '8': '8', '2': '5', '5': '2', '6': '9', '9': '6'}
    original_number = str(N)
    rotated_number = ''
    
    for digit in original_number:
        if digit not in valid_digits:
            return False
        rotated_number += rotation_map[digit]
    
    return original_number != rotated_number",131
35048109367,valid_bracket_sequence,"def valid_bracket_sequence(s: str) -> bool:
    stack = [] # create an empty stack
    for char in s: # iterate over the string
        if char == '(': # if the character is an opening bracket
            stack.append(char) # push it to the stack
        elif char == ')': # if the character is a closing bracket
            if not stack: # if the stack is empty
                return False # return False
            stack.pop() # otherwise, pop the last opening bracket from the stack
    return not stack # if the stack is empty at the end, return True, otherwise return False",131
13032298103,merge_sorted_lists,"def merge_sorted_lists(list1, list2):
    merged_list = []
    i, j = 0, 0
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            merged_list.append(list1[i])
            i += 1
        else:
            merged_list.append(list2[j])
            j += 1
    while i < len(list1):
        merged_list.append(list1[i])
        i += 1
    while j < len(list2):
        merged_list.append(list2[j])
        j += 1
    return merged_list",131
20789211391,isomorphic_strings,"def isomorphic_strings(str1, str2):
    if len(str1) != len(str2):
        return False
    hash1 = {}
    hash2 = {}
    for i in range(len(str1)):
        if str1[i] in hash1:
            if hash1[str1[i]] != str2[i]:
                return False
        else:
            hash1[str1[i]] = str2[i]
        if str2[i] in hash2:
            if hash2[str2[i]] != str1[i]:
                return False
        else:
            hash2[str2[i]] = str1[i]
    return True",131
29205997879,max_consecutive_repeating,"def max_consecutive_repeating(s):
    if not s:
        return """"
    max_char = s[0]
    max_count = 1
    current_char = s[0]
    current_count = 1
    for i in range(1, len(s)):
        if s[i] == current_char:
            current_count += 1
        else:
            if current_count > max_count:
                max_count = current_count
                max_char = current_char
            current_char = s[i]
            current_count = 1
    if current_count > max_count:
        max_char = current_char
    return max_char",131
33971826605,search_matrix,"def search_matrix(matrix, target):
    """"""
    :type matrix: List[List[int]]
    :type target: int
    :rtype: bool
    """"""
    if not matrix or not matrix[0]:
        return False

    n_rows = len(matrix)
    n_cols = len(matrix[0])

    i, j = n_rows - 1, 0

    while i >= 0 and j < n_cols:
        if matrix[i][j] < target:
            j += 1
        elif matrix[i][j] > target:
            i -= 1
        else:
            return True

    return False",131
6428029526,find_max_bitonic,"def find_max_bitonic(arr):
    def binary_search(left, right):
        if left <= right:
            mid = (left + right) // 2
            if arr[mid - 1] < arr[mid] > arr[mid + 1]:
                return mid
            elif arr[mid] < arr[mid + 1]:
                return binary_search(mid + 1, right)
            else:
                return binary_search(left, mid - 1)
        return -1
    index = binary_search(0, len(arr) - 2)
    if index != -1:
        return arr[index]
    return arr[-1]",131
37892443877,find_second_largest,"def find_second_largest(numbers):
    if len(numbers) < 2:
        return None
    numbers = list(set(numbers))
    if len(numbers) < 2:
        return None
    numbers.sort()
    return numbers[-2]

assert find_second_largest([1, 2, 3, 4, 5]) == 4
assert find_second_largest([-1, -2, -3, -4, -5]) == -2
assert find_second_largest([10, 20, 20, 30, 40, 40]) == 30",131
9624885317,min_operations_to_palindrome,"def min_operations_to_palindrome(s):
    n = len(s)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 0
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1]
            else:
                dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1
    return dp[0][n-1]",131
42853790035,largest_palindrome_product,"def largest_palindrome_product(n):
    def is_palindrome(x):
        return str(x) == str(x)[::-1]

    max_num = 10 ** n
    min_num = 10 ** (n - 1)
    max_palindrome = 0
    for i in range(max_num - 1, min_num - 1, -1):
        for j in range(i, min_num - 1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if is_palindrome(product):
                max_palindrome = product
    return max_palindrome",131
37142176729,check_nested_structure,"def check_nested_structure(string):
    if len(string) == 0:
        return True
    if string[0] == string[-1] == 'b':
        b_num = string.find('a')
        a_num = string.count('a', b_num, -1)
        if a_num != string.count('b', b_num, -1):
            return False
        return check_nested_structure(string[b_num:-b_num])
    elif string[-1] == 'a':
        return check_nested_structure(string[:-1])
    elif string[0] == 'a':
        return check_nested_structure(string[1:])
    return False",131
7085253551,number_of_days_in_month,"def is_leap_year(year):
    if year % 400 == 0:
        return True
    elif year % 100 == 0:
        return False
    elif year % 4 == 0:
        return True
    else:
        return False

def number_of_days_in_month(year, month):
    if month == 2:
        if is_leap_year(year):
            return 29
        else:
            return 28
    elif month in [4, 6, 9, 11]:
        return 30
    else:
        return 31",131
29743543880,find_Largest_Palindrome,"def find_Largest_Palindrome(n):
    def is_palindrome(x):
        return str(x) == str(x)[::-1]
    
    upper_limit = 10**n - 1
    lower_limit = 10**(n-1)
    max_palindrome = 0
    for i in range(upper_limit, lower_limit-1, -1):
        for j in range(i, lower_limit-1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if is_palindrome(product):
                max_palindrome = product
    return max_palindrome",131
32627448973,max_profit_twice,"def max_profit_twice(prices):
    if len(prices) < 2:
        return 0

    # Initialize profits to zero
    first_buy = float('inf')
    second_buy = float('inf')
    first_profit = 0
    second_profit = 0

    for price in prices:
        # Buy 1st or 2nd stock
        first_buy = min(first_buy, price)
        first_profit = max(first_profit, price - first_buy)
        second_buy = min(second_buy, price - first_profit)
        second_profit = max(second_profit, price - second_buy)

    return second_profit",131
24756199978,reverse_vowels,"def reverse_vowels(s: str) -> str:
    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}
    s = list(s)
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] in vowels:
            while s[right] not in vowels and left < right:
                right -= 1
            s[left], s[right] = s[right], s[left]
            right -= 1
        left += 1
    return ''.join(s)",131
1789982949,minLength,"from collections import deque

def minLength(s, dict):
    queue = deque([s])
    unique = set([s])
    result = len(s)
    while queue:
        string = queue.popleft()
        for sub in dict:
            found = string.find(sub)
            while found != -1:
                new_s = string[:found] + string[found + len(sub):]
                if new_s not in unique:
                    if (len(new_s)) < result:
                        result = len(new_s)
                    queue.append(new_s)
                    unique.add(new_s)
                found = string.find(sub, found + 1)
    return result",131
38812482171,length_of_longest_substring_k_distinct,"def length_of_longest_substring_k_distinct(s, k):
    if len(s) == 0: return 0
    dict = {}
    start = 0
    maxLength = 0
    for i in range(len(s)):
        dict[s[i]] = i
        if len(dict) > k:
            currMin = len(s)
            for ch in dict:
                if dict[ch] < currMin: currMin = dict[ch]
                start = dict[s[currMin]] + 1
            del dict[s[currMin]]
        maxLength = max(maxLength, i - start + 1)
    return maxLength",131
846961038,first_non_repeated,"from collections import OrderedDict

def first_non_repeated(s):
    # Create an ordered dictionary to remember the order of characters
    char_count = OrderedDict()

    # Iterate over the string and count the occurrences of each character
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

    # Find the first character with a count of 1
    for char, count in char_count.items():
        if count == 1:
            return char

    # Return an empty string if no non-repeating character is found
    return """"",131
20999115225,longest_palindrome_subseq,"def longest_palindrome_subseq(s):
    n = len(s)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = 2 + dp[i+1][j-1]
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][n-1]",130
40288658293,threeSum,"def threeSum(nums):
    result = set()
    nums.sort()
    for i in range(len(nums)-2):
        j = i+1
        k = len(nums)-1
        while j < k:
            if nums[i] + nums[j] + nums[k] == 0:
                result.add((nums[i], nums[j], nums[k]))
                j += 1
                k -= 1
            elif nums[i] + nums[j] + nums[k] < 0:
                j += 1
            else:
                k -= 1
    return [list(item) for item in result]",130
3209058672,merge_items,"from typing import List

def merge_items(items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:
    d = dict()
    for item in items1:
        value, weight = item
        if value in d:
            d[value] += weight
        else:
            d[value] = weight
    for item in items2:
        value, weight = item
        if value in d:
            d[value] += weight
        else:
            d[value] = weight
    result = []
    for key in sorted(d.keys()):
        result.append([key, d[key]])
    return result",130
72050536886,n_queens,"answer = 0

def check(d, v, row):
    for i in range(d):
        if row[i] == v or abs(v - row[i]) == d - i:
            return False
    return True

def dfs(d, n, row):
    global answer
    if d == n:
        answer += 1
        return
    for i in range(n):
        if check(d, i, row):
            row[d] = i
            dfs(d + 1, n, row)

def n_queens(n):
    dfs(0, n, [0] * n)
    return answer",130
28618983390,minJumps,"def minJumps(arr):
    n = len(arr)
    jumps = [0 for i in range(n)]
    if (n == 0) or (arr[0] == 0):
        return float('inf')
    jumps[0] = 0
    for i in range(1, n):
        jumps[i] = float('inf')
        for j in range(i):
            if (i <= j + arr[j]) and (jumps[j] != float('inf')):
                jumps[i] = min(jumps[i], jumps[j] + 1)
                break
    return jumps[n-1]",130
74118660393,count_palindromes,"def count_palindromes(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        total_count += expand_around_center(i, i)  # Odd length palindromes
        total_count += expand_around_center(i, i + 1)  # Even length palindromes

    return total_count",130
9656635451,minJumps,"def minJumps(arr):
    n = len(arr)
    jumps = [0 for i in range(n)]
    if (n == 0) or (arr[0] == 0):
        return float('inf')
    jumps[0] = 0
    for i in range(1, n):
        jumps[i] = float('inf')
        for j in range(i):
            if (i <= j + arr[j]) and (jumps[j] != float('inf')):
                jumps[i] = min(jumps[i], jumps[j] + 1)
                break
    return jumps[n-1]",130
16364710425,count_palindrome_substrings,"def count_palindrome_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # Odd length palindromes
        total_count += expand_around_center(i, i)
        # Even length palindromes
        total_count += expand_around_center(i, i + 1)
    return total_count",130
3411590050,lengthOfLongestSubstringKDistinct,"from collections import defaultdict

def lengthOfLongestSubstringKDistinct(s, k):
    if len(s) == 0: return 0
    char_map = defaultdict(int)
    start = 0
    max_length = 0
    for end in range(len(s)):
        char_map[s[end]] += 1
        while len(char_map) > k:
            char_map[s[start]] -= 1
            if char_map[s[start]] == 0:
                del char_map[s[start]]
            start += 1
        max_length = max(max_length, end - start + 1)
    return max_length",130
41692794032,count_ways,"def count_ways(n):
    # Base case
    if n <= 1:
        return n

    # Initialize an array to store the number of ways to reach each stair
    ways = [0] * (n + 1)
    ways[0] = 1
    ways[1] = 1

    # Fill the array using the recurrence relation: ways[i] = ways[i-1] + ways[i-2]
    for i in range(2, n + 1):
        ways[i] = ways[i - 1] + ways[i - 2]

    return ways[n]",130
15550498933,decode_message,"def decode_message(s: str) -> int:
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] != '0':
            dp[i] = dp[i-1]
        if '10' <= s[i-2:i] <= '26':
            dp[i] += dp[i-2]
    return dp[n]",130
19487449737,max_two_elements,"def max_two_elements(arr):
  # Initialize the maximum and second maximum values to the first and second elements of the list
  max1 = max(arr[0], arr[1])
  max2 = min(arr[0], arr[1])

  # Iterate through the rest of the list, updating the maximum and second maximum values as necessary
  for i in range(2, len(arr)):
    if arr[i] > max1:
      max2 = max1
      max1 = arr[i]
    elif arr[i] > max2:
      max2 = arr[i]

  return (max1, max2)",130
17739374536,is_valid_url,"import re

def is_valid_url(url):
    url_regex = re.compile(
        r'^(http|https)://'  # protocol
        r'([A-Za-z0-9][A-Za-z0-9-]{0,61}[A-Za-z0-9])'  # domain name
        r'(\.[A-Za-z0-9][A-Za-z0-9-]{0,61}[A-Za-z0-9])+'  # subdomains
        r'(/[\w-]+)*$'  # optional path
    )
    return bool(url_regex.match(url))",130
5440428384,find_Min_Num,"def find_Min_Num(arr,n) : 
    arr.sort() 
    num = arr[0] 
    if(num == 0) : 
        for i in range(n) : 
            if (arr[i] != 0) : 
                num = arr[i] 
                break
        for i in range(n) : 
            if (arr[i] != num) : 
                num = (num * 10) + arr[i] 
    else : 
        for i in range(1,n) : 
            num = (num * 10) + arr[i] 
    return num",130
12523492286,event_count,"from bisect import bisect_right, bisect_left
from typing import List

def event_count(events: List[List[int]], times: List[int]) -> List[int]:
    start_times = sorted([s for s, _ in events])
    end_times = sorted([e for _, e in events])
    
    result = []
    for t in times:
        count_before_t = bisect_right(start_times, t)
        count_wilted_before_t = bisect_left(end_times, t)
        full_bloom_count = count_before_t - count_wilted_before_t
        result.append(full_bloom_count)

    return result",130
74945081407,longest_subarray,"def longest_subarray(arr):
    max_len = 0
    max_start = 0
    count = 0
    sum_map = {0: -1}
    for i, val in enumerate(arr):
        if val == 0:
            count -= 1
        else:
            count += 1
        if count in sum_map:
            if i - sum_map[count] > max_len:
                max_len = i - sum_map[count]
                max_start = sum_map[count] + 1
        else:
            sum_map[count] = i
    return arr[max_start:max_start + max_len]",130
35317882841,longest_zeros,"def longest_zeros(n):
    binary = bin(n)[2:]
    max_gap = 0
    current_gap = 0
    found_one = False
    for bit in binary:
        if bit == '1':
            if found_one and current_gap > max_gap:
                max_gap = current_gap
            current_gap = 0
            found_one = True
        elif found_one:
            current_gap += 1
    return max_gap

print(longest_zeros(1041)) # 5
print(longest_zeros(32)) # 0
print(longest_zeros(9)) # 2",130
42634464853,subarray_sum,"def subarray_sum(nums, k: int) -> int:
    if len(nums) == 0:
        return 0
    d = {0: 1}  # Initialize dictionary (hash table), set value of 0 to 1
    pre_sum = 0
    cnt = 0
    for num in nums:
        pre_sum += num
        if d.get(pre_sum - k):
            cnt += d[pre_sum - k]
        if d.get(pre_sum):
            d[pre_sum] += 1
        else:
            d[pre_sum] = 1
    return cnt",130
15809852898,max_substring_length,"def max_substring_length(s):
    if len(s) == 0:
        return 0
    max_len = 0
    start = 0
    end = 0
    sdict = {}
    while(end < len(s)):
        if s[end] not in sdict or sdict[s[end]] < start:
            sdict[s[end]] = end
            end += 1
            max_len = max(max_len, end-start)
        else:
            start = sdict[s[end]] + 1
            sdict[s[end]] = end
            end += 1
    return max_len",130
12146439769,abs_sort_list,"def abs_sort_list(nums):
    return sorted(list(set([abs(num) for num in nums])))

#Test cases
assert abs_sort_list([1, -2, 3, -4, 5]) == [1, 2, 3, 4, 5]
assert abs_sort_list([-1, -2, -3, -4, -5]) == [1, 2, 3, 4, 5]
assert abs_sort_list([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]",130
4458380740,minimum_swaps,"def minimum_swaps(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    indexes = {value: index for index, value in enumerate(arr)}
    for i in range(n):
        correct_val = temp[i]
        if arr[i] != correct_val:
            to_swap_idx = indexes[correct_val]
            arr[i], arr[to_swap_idx] = arr[to_swap_idx], arr[i]
            # Update the indexes dictionary
            indexes[arr[to_swap_idx]] = to_swap_idx
            indexes[arr[i]] = i
            ans += 1
    return ans",130
15951400471,commonElements,"def commonElements(nums1, nums2):
    dict1 = {}
    dict2 = {}
    for i in nums1:
        if i in dict1:
            dict1[i] += 1
        else:
            dict1[i] = 1
    for j in nums2:
        if j in dict2:
            dict2[j] += 1
        else:
            dict2[j] = 1
    result = []
    for key in dict1:
        if key in dict2:
            count = min(dict1[key], dict2[key])
            result.extend([key]*count)
    return result",130
29392610656,max_sliding_window,"from collections import deque

def max_sliding_window(nums, k):
    n = len(nums)
    window = deque()
    output = []

    for i in range(k):
        while window and nums[i] >= nums[window[-1]]:
            window.pop()
        window.append(i)

    for i in range(k, n):
        output.append(nums[window[0]])
        while window and window[0] <= i - k:
            window.popleft()
        while window and nums[i] >= nums[window[-1]]:
            window.pop()
        window.append(i)

    output.append(nums[window[0]])
    return output",130
34256214802,sum_tree,"# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def sum_tree(root):
    if root is None:
        return 0
    else:
        return root.val + sum_tree(root.left) + sum_tree(root.right)

# Test case
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.right = TreeNode(6)
assert sum_tree(root) == 21",130
4098521020,find_smallest_rectangle,"from typing import List

def find_smallest_rectangle(points: List[List[int]]) -> int:
    if len(points) <= 2:
        return 0
    
    min_x, max_x = float('inf'), float('-inf')
    min_y, max_y = float('inf'), float('-inf')
    
    for x, y in points:
        min_x = min(min_x, x)
        max_x = max(max_x, x)
        min_y = min(min_y, y)
        max_y = max(max_y, y)
        
    return (max_x - min_x) * (max_y - min_y)",130
72896569423,minimum_jumps,"def minimum_jumps(arr):
    n = len(arr)
    jumps = [0 for i in range(n)]
    if (n == 0) or (arr[0] == 0):
        return float('inf')
    jumps[0] = 0
    for i in range(1, n):
        jumps[i] = float('inf')
        for j in range(i):
            if (i <= j + arr[j]) and (jumps[j] != float('inf')):
                jumps[i] = min(jumps[i], jumps[j] + 1)
                break
    return jumps[n-1]",130
11674676234,palindrome_substrings,"def palindrome_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # Count odd length palindromes
        total_count += expand_around_center(i, i)
        # Count even length palindromes
        total_count += expand_around_center(i, i + 1)

    return total_count",130
18026416347,ways_to_sum,"def ways_to_sum(n):
    if n == 0:
        return 0
    if n < 0:
        return 0

    dp = [0] * (n + 1)
    dp[0] = 1

    for i in range(1, n + 1):
        dp[i] += dp[i - 1] if i >= 1 else 0
        dp[i] += dp[i - 3] if i >= 3 else 0
        dp[i] += dp[i - 4] if i >= 4 else 0

    return dp[n]",130
10200868118,longest_Consecutive_Subsequence,"def longest_Consecutive_Subsequence(arr, n):
    if n == 0:
        return 0
    arr.sort()
    max_len = 1
    current_len = 1
    for i in range(1, n):
        if arr[i] == arr[i-1]:
            continue
        if arr[i] == arr[i-1] + 1:
            current_len += 1
        else:
            if current_len > max_len:
                max_len = current_len
            current_len = 1
    if current_len > max_len:
        max_len = current_len
    return max_len",130
10992933612,largest_palindrome,"def largest_palindrome(n):
    def is_palindrome(num):
        return str(num) == str(num)[::-1]

    max_num = 10 ** n - 1
    min_num = 10 ** (n - 1)
    max_palindrome = 0
    for i in range(max_num, min_num - 1, -1):
        for j in range(i, min_num - 1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if is_palindrome(product):
                max_palindrome = product
    return max_palindrome",130
75261577625,count_palindromes,"def count_palindromes(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # Odd length palindromes
        total_count += expand_around_center(i, i)
        # Even length palindromes
        total_count += expand_around_center(i, i + 1)
    return total_count",130
29141163765,count_negatives,"import bisect

def count_negatives(grid):
    n, m = len(grid), len(grid[0])
    s = bisect.bisect(grid[0], 0, key= lambda x: -x)
    res = 0
    for i, row in enumerate(grid):
        j = s - 1
        for j in range(s - 1, -1, -1):
            if row[j] >= 0:
                break
        s = j + 1
        res += (m - j - 1) if row[j] >= 0 else m
    return res",129
37227341514,hex_to_decimal,"def hex_to_decimal(hex_string):
    hex_values = {'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'A':10,'B':11,'C':12,'D':13,'E':14,'F':15}
    decimal = 0
    power = len(hex_string) - 1
    for digit in hex_string:
        decimal += hex_values[digit] * (16**power)
        power -=1
    return decimal",129
26910167493,decode_variations,"def decode_variations(s):
    if not s or s[0] == '0':
        return 0
    prev, curr = 1, 1
    for i in range(1, len(s)):
        if s[i] == '0':
            if s[i-1] > '2':
                return 0
            curr = 0
        if s[i-1] == '1' or (s[i-1] == '2' and s[i] <= '6'):
            curr, prev = curr + prev, curr
        else:
            prev = curr
    return curr",129
18553248422,shortest_subarray_length,"def shortest_subarray_length(nums):
    n = len(nums)
    max_seen, min_seen = float('-inf'), float('inf')
    start, end = -1, -1
    for i in range(n):
        if nums[i] < max_seen:
            end = i
        else:
            max_seen = nums[i]
        if nums[n - 1 - i] > min_seen:
            start = n - 1 - i
        else:
            min_seen = nums[n - 1 - i]
    if start == -1:
        return 0
    return end - start + 1",129
5467764929,minSwaps,"def minSwaps(arr):
    n = len(arr)
    arrpos = [*enumerate(arr)]
    arrpos.sort(key=lambda it: it[1])
    vis = {k: False for k in range(n)}
    ans = 0
    for i in range(n):
        if vis[i] or arrpos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not vis[j]:
            vis[j] = True
            j = arrpos[j][0]
            cycle_size += 1
        ans += cycle_size - 1
    return ans",129
30884570191,maxPathSum,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxPathSum(root):
    def dfs(node):
        nonlocal max_sum
        if not node:
            return 0
        left = max(0, dfs(node.left))
        right = max(0, dfs(node.right))
        max_sum = max(max_sum, left + right + node.val)
        return max(left, right) + node.val

    max_sum = float('-inf')
    dfs(root)
    return max_sum",129
34385421259,grid_ways,"def grid_ways(m,n):
    if m == 1 or n == 1:
        return 1
    dp = [[0 for _ in range(n)] for _ in range(m)]
    for i in range(m):
        dp[i][0] = 1
    for j in range(n):
        dp[0][j] = 1
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[m-1][n-1]",129
4099540530,generate_parentheses,"def generate_parentheses(n):
    def generate(A = []):
        if len(A) == 2*n:
            if valid(A):
                ans.append("""".join(A))
        else:
            A.append('(')
            generate(A)
            A.pop()
            A.append(')')
            generate(A)
            A.pop()

    def valid(A):
        bal = 0
        for c in A:
            if c == '(': bal += 1
            else: bal -= 1
            if bal < 0: return False
        return bal == 0

    ans = []
    generate()
    return ans",129
8048038617,heap_sort,"from heapq import heappush, heappop

def heap_sort(arr):
    """"""
    Sorts a list of integers in ascending order using a heap sort algorithm.

    Time Complexity: O(n log n) where n is the number of elements in the list.
    Space Complexity: O(n) for the heap.

    :param arr: List of integers to be sorted.
    :return: Sorted list of integers.
    """"""
    heap = []
    for i in arr:
        heappush(heap, i)
    sorted_arr = []
    while heap:
        sorted_arr.append(heappop(heap))
    return sorted_arr",129
29630270514,count_palindrome_substrings,"def count_palindrome_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # Odd length palindromes
        total_count += expand_around_center(i, i)
        # Even length palindromes
        total_count += expand_around_center(i, i+1)
    return total_count",129
18205712781,longest_substring_without_repeating,"def longest_substring_without_repeating(s: str) -> int:
    # Initialize a dictionary to keep track of characters and their positions
    char_map = {}
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # If the character is already in the current substring, move the left pointer
        if s[right] in char_map and char_map[s[right]] >= left:
            left = char_map[s[right]] + 1
        
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    
    return max_length",129
21558686572,palindrome_partitioning,"def palindrome_partitioning(s):
    res, subset = [], []

    def backtrack(start_index):
        if start_index >= len(s):  # 递归终止条件
            res.append(subset[:])
        for i in range(start_index,len(s)):
            substring = s[start_index : i + 1]
            if substring == substring[::-1]: 
                subset.append(substring)
            else:   # 不包含的话，会pop from empty list
                continue
            backtrack(i+1)  #寻找i+1为起始位置的子串
            subset.pop()

    backtrack(0)
    return res",129
5689718773,max_engineer_performance,"from typing import List
import heapq

def max_engineer_performance(n: int, speed: List[int], efficiency: List[int], k: int) -> int:
    heap = []
    curr_sum = 0
    ans = float('-inf')
    
    for e, s in sorted(zip(efficiency, speed), reverse=True):
        heapq.heappush(heap, s)
        curr_sum += s
        ans = max(ans, curr_sum * e)
        
        if len(heap) >= k:
            curr_sum -= heapq.heappop(heap)
    
    return ans % (10**9 + 7)",129
21273545984,days_in_month,"def days_in_month(year, month):
    month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    if month == 2 and is_leap_year(year):
        return 29
    return month_days[month - 1]

def is_leap_year(year):
    return (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0))",129
15552634096,validTree,"from collections import defaultdict

def validTree(n, edges):
    dic = defaultdict(list)
    for A, B in edges:
        dic[A].append(B)
        dic[B].append(A)

    visited = set()

    def DFS(v, parent):
        if v in visited: return
        visited.add(v)
        for neighbor in dic[v]:
            if neighbor == parent:
                continue
            if neighbor in visited: 
                return False
            result = DFS(neighbor, v)
            if not result: return False
        return True

    return DFS(0, -1) and len(visited) == n",129
20352375977,find_majority_element,"def find_majority_element(arr):
    major_index = 0
    count = 1

    for i in range(len(arr)):
        if arr[i] == arr[major_index]:
            count += 1
        else:
            count -= 1
        if count == 0:
            major_index = i
            count = 1

    count = 0
    for i in range(len(arr)):
        if arr[i] == arr[major_index]:
            count += 1

    if count > len(arr) // 2:
        return arr[major_index]
    else:
        return -1",129
29740975064,multiply,"def multiply(num1, num2):
    res = [0] * (len(num1) + len(num2))
    for i, e1 in enumerate(reversed(num1)):
        for j, e2 in enumerate(reversed(num2)):
            res[i + j] += int(e1) * int(e2)
            res[i + j + 1] += res[i + j] // 10
            res[i + j] %= 10

    while len(res) > 1 and res[-1] == 0: res.pop()
    return ''.join(map(str, res[::-1]))",129
71399216957,anagram_substrings,"from collections import Counter

def anagram_substrings(text, pattern):
    pattern_length = len(pattern)
    pattern_counter = Counter(pattern)
    window_counter = Counter(text[:pattern_length-1])
    result = []

    for i in range(pattern_length-1, len(text)):
        window_counter[text[i]] += 1
        if window_counter == pattern_counter:
            result.append(i-pattern_length+1)
        window_counter[text[i-pattern_length+1]] -= 1
        if window_counter[text[i-pattern_length+1]] == 0:
            del window_counter[text[i-pattern_length+1]]

    return len(result)",129
33086739703,ways_to_reach,"def ways_to_reach(m, n, obstacles):
    dp = [[0 for _ in range(n)] for _ in range(m)]
    dp[0][0] = 1
    for i in range(m):
        for j in range(n):
            if (i, j) in obstacles:
                dp[i][j] = 0
            else:
                if i > 0:
                    dp[i][j] += dp[i-1][j]
                if j > 0:
                    dp[i][j] += dp[i][j-1]
    return dp[m-1][n-1]",129
41261734557,count_palindrome_substrings,"def count_palindrome_substrings(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        total_count += expand_around_center(i, i)  # Odd length palindromes
        total_count += expand_around_center(i, i+1)  # Even length palindromes
    return total_count",129
70470003510,count_palindromes,"def count_palindromes(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # Odd length palindromes
        total_count += expand_around_center(i, i)
        # Even length palindromes
        total_count += expand_around_center(i, i+1)

    return total_count",129
38579774093,maximum_swap,"def maximum_swap(num):
    num = list(str(num))
    max_idx = left = right = -1
    current_max = float(""-inf"")
    for i in range(len(num)-1, -1, -1):
        if int(num[i]) > current_max:
            current_max = int(num[i])
            max_idx = i
        elif int(num[i]) < current_max:
            left = i
            right = max_idx
    if left == -1:
        return int("""".join(num))
    num[left], num[right] = num[right], num[left]
    return int("""".join(num))",129
73731283557,do_rectangles_intersect,"def do_rectangles_intersect(bottom_left1, top_right1, bottom_left2, top_right2):
    x1, y1 = bottom_left1
    x2, y2 = top_right1
    x3, y3 = bottom_left2
    x4, y4 = top_right2
    
    # Check if one rectangle is to the left of the other
    if x1 >= x4 or x3 >= x2:
        return False

    # Check if one rectangle is above the other
    if y1 >= y4 or y3 >= y2:
        return False

    return True",129
70676527497,word_pattern,"def word_pattern(pattern, str):
    many_s = str.split()
    if len(pattern) != len(many_s):
        return False
    c_s = {}
    s_c = {}
    for c, s in zip(pattern, str.split()):
        if c not in c_s and s not in s_c:
            c_s[c] = s
            s_c[s] = c
        elif c in c_s and s in s_c:
            if (c == s_c[s] and s == c_s[c]):
                pass
            else:
                return False
        else:
            return False
    return True",129
70726564281,num_to_words,"def num_to_words(nums):
    """"""
    :type nums: List[int]
    :rtype: List[str]
    """"""
    num_dict = {0: 'zero', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine'}
    res_list = []
    for num in nums:
        res_list.append(num_dict[num])
    return res_list

nums = [1,2,3]
obj = num_to_words(nums)",129
70656381468,max_subarray_sum_of_k,"def max_subarray_sum_of_k(arr, k):
    max_sum = float('-inf')
    window_sum = 0
    window_start = 0

    for window_end in range(len(arr)):
        window_sum += arr[window_end]  # Add the next element to the window

        # Slide the window if we hit the size k
        if window_end >= k - 1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]  # Subtract the element going out
            window_start += 1  # Slide the window ahead

    return max_sum",128
74523207805,longest_palindrome_subsequence,"def longest_palindrome_subsequence(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][n-1]",128
17490491173,mountain_peak,"def mountain_peak(nums):
    if not nums:
        return -1

    l, m, r = 0, 0, len(nums) - 1

    while l + 1 < r:
        m = l + (r - l) // 2
        """"""
        `m+1` will not out of range
        if len(nums) == 1 || 2, the code in this loop will not execute
        """"""
        if nums[m] > nums[m+1]:
            r = m
        else:
            l = m

    return max(nums[l], nums[r])",128
5447877833,max_sum_subarray_of_size_k,"def max_sum_subarray_of_size_k(arr, k):
    max_sum = 0
    window_sum = 0
    window_start = 0

    for window_end in range(len(arr)):
        window_sum += arr[window_end]  # add the next element to window

        # slide the window if we hit the size k
        if window_end >= k-1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]  # subtract the element going out of window
            window_start += 1  # slide the window ahead
    return max_sum",128
25042404196,longest_substring_with_k_distinct,"def longest_substring_with_k_distinct(s: str, k: int) -> int:
    l = 0
    res = 0
    hashmap = {}
    for r in range(len(s)):
        if s[r] in hashmap:
            hashmap[s[r]] += 1
        else:
            hashmap[s[r]] = 1

        while len(hashmap) > k:
            hashmap[s[l]] -= 1
            if hashmap[s[l]] == 0:
                del hashmap[s[l]]
            l += 1

        res = max(res, r - l + 1)
    return res",128
1416274799,topKFrequent,"import heapq
from typing import List


def topKFrequent(nums: List[int], k: int) -> List[int]:
    element_count = {}
    for num in nums:
        element_count[num] = element_count.get(num, 0) + 1

    # Create a max heap to store elements based on their frequency
    max_heap = [(-count, num) for num, count in element_count.items()]
    heapq.heapify(max_heap)

    top_k = []
    for _ in range(k):
        count, num = heapq.heappop(max_heap)
        top_k.append(num)

    return top_k",128
4027772429,findLongestSubString,"def findLongestSubString(s:str)->int:
    if (s is None or len(s)==0):
        return 0
    ans = 1
    dictChar = {}
    l=0
    r=0
    while (r<len(s)):
        c = s[r]
        if (not (c in dictChar.keys())):
            dictChar[c]=r
            curLength = r-l+1
            ans = max(ans,curLength)     
            r+=1       
        else:
            l = dictChar[c]+1
            dictChar.pop(c,None)
    
    return ans",128
5616102158,max_points,"from collections import defaultdict
import math

def max_points(points):
    pointsLength = len(points)
    maxPoints = 2

    if pointsLength == 1:
        return 1

    for i in range(pointsLength):
        AnglesDict = defaultdict(int)
        for j in range(pointsLength):
            if j != i:
                AnglesDict[math.atan2(points[j][1] - points[i][1],points[j][0] - points[i][0])] += 1
        maxPoints = max( maxPoints, max(AnglesDict.values()) + 1)

    return maxPoints",128
38559502467,minMeetingRooms,"import heapq

def minMeetingRooms(intervals):
    intervals.sort(key=lambda x: x[0])
    minHeap = []
    heapq.heappush(minHeap, intervals[0][1])
    max_count = 1
    for i in range(1, len(intervals)):
        interval = intervals[i]
        if interval[0] >= minHeap[0]:
            heapq.heappop(minHeap)
            heapq.heappush(minHeap, interval[1])
        else:
            heapq.heappush(minHeap, interval[1])
        max_count = max(max_count, len(minHeap))
    return max_count",128
70248579061,longest_substring_no_repeats,"def longest_substring_no_repeats(s: str) -> str:
    if not s:
        return """"
    start = 0
    max_len = 0
    max_substring = """"
    seen = {}
    for end in range(len(s)):
        if s[end] in seen and start <= seen[s[end]]:
            start = seen[s[end]] + 1
        else:
            if end - start + 1 > max_len:
                max_len = end - start + 1
                max_substring = s[start:end+1]
        seen[s[end]] = end
    return max_substring",128
38641369106,top_k_frequent,"from typing import List
from collections import Counter

def top_k_frequent(nums: List[int], k: int) -> List[int]:
    if not nums:
        return []
    
    counter = Counter(nums)
    buckets = [[] for _ in range(len(nums) + 1)]
    for num, freq in counter.items():
        buckets[freq].append(num)
    
    result = []
    for i in range(len(buckets) - 1, 0, -1):
        for num in sorted(buckets[i]):
            result.append(num)
            if len(result) == k:
                return result
    
    return result",128
39802896876,longest_palindrome_subsequence,"def longest_palindrome_subsequence(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][n-1]",128
27840877139,maxSumNonAdjacent,"def maxSumNonAdjacent(arr):
    if len(arr) == 0:
        return 0
    elif len(arr) == 1:
        return arr[0]
    elif len(arr) == 2:
        return max(arr[0], arr[1])
    dp = [0] * len(arr)
    dp[0] = arr[0]
    dp[1] = max(arr[0], arr[1])
    for i in range(2, len(arr)):
        dp[i] = max(dp[i-1], dp[i-2] + arr[i])
    return dp[-1]",128
29848072972,ways_to_climb,"def ways_to_climb(n):
    if n == 1 or n == 0:
        return 1
    elif n == 2:
        return 2
    else:
        one_step_before = 1
        two_steps_before = 2
        three_steps_before = 4
        i = 3
        while(i < n):
            nth_step = one_step_before + two_steps_before + three_steps_before
            one_step_before = two_steps_before
            two_steps_before = three_steps_before
            three_steps_before = nth_step
            i += 1
        return three_steps_before",128
35847888386,longest_palindrome_subsequence,"def longest_palindrome_subsequence(nums):
    n = len(nums)
    dp = [[0] * n for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if nums[i] == nums[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][n-1]",128
23127014910,longest_substring_with_2_distinct_chars,"def longest_substring_with_2_distinct_chars(s: str) -> int:
    left = 0
    max_length = 0
    char_map = {}
    
    for right in range(len(s)):
        char_map[s[right]] = char_map.get(s[right], 0) + 1
        
        while len(char_map) > 2:
            char_map[s[left]] -= 1
            if char_map[s[left]] == 0:
                del char_map[s[left]]
            left += 1
        
        max_length = max(max_length, right - left + 1)
    
    return max_length",128
5702366127,sum_ways,"def sum_ways(n):
    if n == 0 or n == 1:
        return 1
    if n == 2:
        return 1
    if n == 3:
        return 2
    dp = [0] * (n+1)
    dp[0], dp[1], dp[2], dp[3] = 1, 1, 1, 2
    for i in range(4, n+1):
        dp[i] = dp[i-1] + dp[i-3] + dp[i-4]
    return dp[n]",128
5121383434,num_days_in_month,"def num_days_in_month(year, month):
    if month in [1, 3, 5, 7, 8, 10, 12]:
        return 31
    elif month in [4, 6, 9, 11]:
        return 30
    elif month == 2:
        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
            return 29
        else:
            return 28
    else:
        raise ValueError(""Invalid month"")",128
37809016054,median_sorted_arrays,"def median_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2
    else:
        return nums[length // 2]

# Test cases
assert median_sorted_arrays([1, 3], [2]) == 2.0
assert median_sorted_arrays([1, 2], [3, 4]) == 2.5
assert median_sorted_arrays([], [1]) == 1.0",128
10950139735,find_ways,"def find_ways(n):
    if n == 0 or n == 1:
        return 1
    if n == 2:
        return 1
    if n == 3:
        return 2
    ways = [0] * (n+1)
    ways[0], ways[1], ways[2], ways[3] = 1, 1, 1, 2
    for i in range(4, n+1):
        ways[i] = ways[i-1] + ways[i-3] + ways[i-4]
    return ways[n]",128
16079793011,closest_pair,"from math import sqrt

def distance(p1, p2):
    return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def closest_pair(points):
    min_distance = float('inf')
    closest_pair = None
    for i, p1 in enumerate(points):
        for j, p2 in enumerate(points[i+1:], i+1):
            dist = distance(p1, p2)
            if dist < min_distance:
                min_distance = dist
                closest_pair = (p1, p2)
    return closest_pair",128
20081142499,min_jumps,"def min_jumps(arr):
    n = len(arr)
    jumps = [0]*n
    if (n == 0) or (arr[0] == 0):
        return float(""inf"")
    jumps[0] = 0
    for i in range(1, n):
        jumps[i] = float(""inf"")
        for j in range(i):
            if (i <= j + arr[j]) and (jumps[j] != float(""inf"")):
                jumps[i] = min(jumps[i], jumps[j] + 1)
                break
    return jumps[n-1]",128
27625918388,delete_greatest_value,"import heapq
import math

def delete_greatest_value(grid):
    m = len(grid)
    n = len(grid[0])
    val = math.inf
    for i in range(m):
        for j in range(n):
            grid[i][j] = -1 * grid[i][j]
    for i in range(len(grid)):
        heapq.heapify(grid[i])
    res = 0
    for j in range(n):
        val = math.inf
        for i in range(len(grid)):
            val = min(val, heapq.heappop(grid[i]))
        res += (-1 * val)
    return res",128
73595722309,largest_triplet_product,"def largest_triplet_product(arr):
    arr.sort()
    n = len(arr)
    return max(arr[0]*arr[1]*arr[n-1], arr[n-1]*arr[n-2]*arr[n-3])

assert largest_triplet_product([1, 2, 3, 4, 5]) == 60
assert largest_triplet_product([10, 3, 5, 6, 20]) == 1200
assert largest_triplet_product([-10, -3, -5, -6, -20]) == -90",128
22976148507,count_unique_pairs,"def count_unique_pairs(arr, k):
    if k < 0:
        return 0
    pairs = 0
    elements = {}
    for num in arr:
        if num in elements:
            elements[num] += 1
        else:
            elements[num] = 1
    for num in elements:
        if k > 0 and num + k in elements:
            pairs += elements[num] * elements[num + k]
        elif k == 0 and elements[num] > 1:
            pairs += elements[num] * (elements[num] - 1) // 2
    return pairs",128
36395145149,min_Palindrome_Operations,"def min_Palindrome_Operations(s):
    n = len(s)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    for gap in range(1, n):
        for left in range(n - gap):
            right = left + gap
            if s[left] == s[right]:
                dp[left][right] = dp[left + 1][right - 1]
            else:
                dp[left][right] = min(dp[left + 1][right], dp[left][right - 1]) + 1
    return dp[0][n - 1]",128
9217970012,coin_change,"def coin_change(amount, coins):
    if amount <= 0: return int(amount == 0)

    dp = [0] * (amount + 1)
    dp[0] = 1

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]

    return dp[amount]

# Test cases
assert coin_change(5, [1, 2, 5]) == 4
assert coin_change(3, [2]) == 0
assert coin_change(10, [10]) == 1",128
25115836208,find_largest_palindrome,"def find_largest_palindrome(n: int) -> int:
    max_num = 10 ** n - 1
    min_num = 10 ** (n - 1)
    max_palindrome = 0

    for i in range(max_num, min_num - 1, -1):
        for j in range(i, min_num - 1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            str_product = str(product)
            if str_product == str_product[::-1]:
                max_palindrome = product

    return max_palindrome",128
12634884121,is_largest_palindrome,"def is_largest_palindrome(n):
    if str(n) != str(n)[::-1]:
        return False
    for i in range(999, 99, -1):
        if n % i == 0 and 99 < n // i < 1000:
            return True
    return False
def largest_palindrome():
    return max(i*j for i in range(100, 1000) for j in range(100, 1000) if is_largest_palindrome(i * j))
print(largest_palindrome())",128
21635654101,min_swaps,"def min_swaps(nums):
    n = len(nums)
    answer = 0
    temp = nums.copy()
    nums.sort()
    index_map = {val : i for i, val in enumerate(temp)}
 
    for i in range(n):
        correct_val = nums[i]
        if temp[i] != correct_val:
            answer += 1
            temp[i], temp[index_map[correct_val]] = temp[index_map[correct_val]], temp[i]
 
            index_map[temp[index_map[correct_val]]] = index_map[correct_val]
            index_map[correct_val] = i
    return answer",128
14347043386,maxProfit,"def maxProfit(prices):
    if not prices:
        return 0
    
    # Initialize the dp array
    dp = [[0]*len(prices) for _ in range(3)]
    
    # Fill the dp array
    for i in range(1,3):
        max_diff = -prices[0]
        for j in range(1,len(prices)):
            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)
            max_diff = max(max_diff, dp[i-1][j] - prices[j])
    
    return dp[2][-1]",128
26405477417,highest_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def highest_prime(nums):
    primes = [num for num in nums if is_prime(num)]
    return max(primes) if primes else -1",128
3314799362,merge_sorted_lists,"def merge_sorted_lists(list1, list2):
    merged_list = []
    i = j = 0

    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            merged_list.append(list1[i])
            i += 1
        else:
            merged_list.append(list2[j])
            j += 1

    while i < len(list1):
        merged_list.append(list1[i])
        i += 1

    while j < len(list2):
        merged_list.append(list2[j])
        j += 1

    return merged_list",128
22128921608,merge_sorted_lists,"def merge_sorted_lists(list1, list2):
    merged_list = []
    i = j = 0
    while i < len(list1) and j < len(list2):
        if list1[i] <= list2[j]:
            merged_list.append(list1[i])
            i += 1
        else:
            merged_list.append(list2[j])
            j += 1
    while i < len(list1):
        merged_list.append(list1[i])
        i += 1
    while j < len(list2):
        merged_list.append(list2[j])
        j += 1
    return merged_list",128
953909854,longest_palindrome_subseq,"def longest_palindrome_subseq(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i in range(n-1, -1, -1):
        dp[i][i] = 1
        for j in range(i+1, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][n-1]",128
11215862440,largest_palindrome,"def is_palindrome(n):
    return str(n) == str(n)[::-1]

def largest_palindrome(n):
    max_num = 10**n - 1
    min_num = 10**(n-1)
    max_palindrome = 0

    for i in range(max_num, min_num - 1, -1):
        for j in range(i, min_num - 1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if is_palindrome(product):
                max_palindrome = product

    return max_palindrome",127
10033562236,roman_to_int,"def roman_to_int(s: str) -> int:
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    for char in s:
        value = roman_values[char]
        if value > prev_value:
            total += value - 2 * prev_value
        else:
            total += value
        prev_value = value
    return total",127
24021253299,reverse_even_indices,"def reverse_even_indices(lst):
    # Extract even-indexed elements
    even_elements = [lst[i] for i in range(0, len(lst), 2)]

    # Reverse the even-indexed elements
    even_elements.reverse()

    # Create a new list with the reversed even-indexed elements and original odd-indexed elements
    result = []
    even_index = 0
    for i in range(len(lst)):
        if i % 2 == 0:
            result.append(even_elements[even_index])
            even_index += 1
        else:
            result.append(lst[i])

    return result",127
31473756255,climbStairs,"def climbStairs(n: int) -> int:
    if n == 1:
        return 1
    elif n == 2:
        return 2
    elif n == 3:
        return 4
    dp = [0] * (n + 1)
    dp[1], dp[2], dp[3] = 1, 2, 4
    for i in range(4, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
    return dp[-1]",127
37413427410,minimumSwaps,"def minimumSwaps(arr):
    n = len(arr)
    answer = 0
    temp = arr.copy()
    temp.sort()
    index_map = {val:idx for idx,val in enumerate(arr)}
    
    for i in range(n):
        correct_val = temp[i]
        if arr[i] != correct_val:
            to_swap_idx = index_map[correct_val]
            arr[i],arr[to_swap_idx] = arr[to_swap_idx],arr[i]
            index_map[arr[to_swap_idx]] = to_swap_idx
            index_map[arr[i]] = i
            answer += 1
    return answer",127
32885659637,month_days,"def month_days(year, month):
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    if month == 2:
        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
            return 29
        else:
            return 28
    else:
        return days_in_month[month-1]",127
43826762963,quickSelect,"def quickSelect(arr, k):
    if len(arr) == 1:
        return arr[0]

    pivot = arr[len(arr) // 2]

    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    if k <= len(left):
        return quickSelect(left, k)
    elif k > len(left) + len(middle):
        return quickSelect(right, k - len(left) - len(middle))
    else:
        return middle[0]",127
2602304692,valid_mountain_array,"def valid_mountain_array(arr):
    if len(arr) < 3: return False
    isChanged = False
    for i in range(1, len(arr)):
        if not isChanged and arr[i] <= arr[i - 1]:
            isChanged = True
            if i == 1: return False
            if i == len(arr) - 1 : 
                if arr[i] < arr[i - 1]: return True
                else: return False
            continue
        if isChanged and arr[i] >= arr[i - 1]:
            return False             
    return isChanged",127
31743463510,quickselect,"def quickselect(arr, k):
    if len(arr) == 1:
        return arr[0]

    pivot = arr[len(arr) // 2]

    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    if k <= len(left):
        return quickselect(left, k)
    elif k > len(left) + len(middle):
        return quickselect(right, k - len(left) - len(middle))
    else:
        return middle[0]",127
39809312931,find_anagrams,"def find_anagrams(word, word_list):
    word_dict = {}
    for char in word:
        if char not in word_dict:
            word_dict[char] = 1
        else:
            word_dict[char] += 1
    anagrams = []
    for w in word_list:
        if len(w) == len(word):
            temp_dict = word_dict.copy()
            for char in w:
                if char in temp_dict and temp_dict[char] > 0:
                    temp_dict[char] -= 1
                else:
                    break
            else:
                anagrams.append(w)
    return anagrams",127
42590375503,min_flips,"def min_flips(s: str) -> int:
    flips1, flips2 = 0, 0
    for i in range(len(s)):
        expected_char = str(i % 2)
        if s[i] != expected_char:
            flips1 += 1
        else:
            flips2 += 1
    return min(flips1, flips2)

print(min_flips(""001"")) # Expected output: 1
print(min_flips(""0101"")) # Expected output: 0
print(min_flips(""1111"")) # Expected output: 2",127
34774884039,check_subarray_sum,"def check_subarray_sum(nums, k):
    if k == 0:
        return any(nums[i] == 0 and nums[i + 1] == 0 for i in range(len(nums) - 1))
    else:
        hash_map, sum = {0 : -1}, 0
        for i, num in enumerate(nums):
            sum += num
            if k != 0:
                sum %= k
            if sum not in hash_map:
                hash_map[sum] = i
            elif i - hash_map[sum] > 1:
                return True
        return False",127
20978512712,find_min_platforms,"def find_min_platforms(arrival, departure):
    if not arrival or not departure:
        return 0
    arrival.sort()
    departure.sort()
    platforms_needed = 1
    result = 1
    i = 1
    j = 0
    while (i < len(arrival) and j < len(departure)):
        if arrival[i] <= departure[j]:
            platforms_needed += 1
            i += 1
            if platforms_needed > result:
                result = platforms_needed
        else:
            platforms_needed -= 1
            j += 1
    return result",127
16248348411,longest_substring_in_alphabetical_order,"def longest_substring_in_alphabetical_order(s):
    if not s:
        return """"
    max_len = 1
    start = 0
    max_start = 0
    for i in range(1, len(s)):
        if s[i] < s[i-1]:
            if i - start > max_len:
                max_len = i - start
                max_start = start
            start = i
    if len(s) - start > max_len:
        max_start = start
        max_len = len(s) - start
    return s[max_start:max_start + max_len]",127
13086981235,max_histogram_area,"def max_histogram_area(heights):
    stack=[-1]
    m = 0
    for i,h in enumerate(heights):
        while stack[-1]>-1 and heights[stack[-1]]>=h:
            currentHeight = heights[stack.pop()]
            currentWidth = i-stack[-1]-1
            m=max(m,currentHeight*currentWidth)
        stack.append(i)
    while stack[-1]>-1:
        currentHeight = heights[stack.pop()]
        currentWidth = len(heights)-stack[-1]-1
        m=max(m,currentHeight*currentWidth)            
    return m",127
32678048508,minJumps,"def minJumps(arr):
    n = len(arr)
    if n <= 1:
        return 0
    if arr[0] == 0:
        return -1
    maxReach = arr[0]
    step = arr[0]
    jump = 1
    for i in range(1, n):
        if i == n - 1:
            return jump
        maxReach = max(maxReach, i + arr[i])
        step -= 1
        if step == 0:
            jump += 1
            step = maxReach - i
    return -1",127
14365459049,all_paths,"def all_paths(G):
    sz = len(G)
    dp = [None for _ in range(0, sz)]
    dp[-1] = [[sz-1]]
    stack = [(0, False)]
    while stack:
        t, flag = stack.pop()
        if dp[t] == None:
            if flag:
                dp[t] = []
                for i in G[t]:
                    dp[t].extend([[t]+j for j in dp[i]])
            else:
                stack.append((t, True))
                stack.extend([(j, False) for j in G[t]])
    return dp[0]",127
42110899498,count_components,"def dfs(node, visited, graph):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(neighbor, visited, graph)

def count_components(n, edges):
    graph = {i: [] for i in range(n)}
    for edge in edges:
        graph[edge[0]].append(edge[1])
        graph[edge[1]].append(edge[0])
    
    visited = set()
    count = 0
    for node in range(n):
        if node not in visited:
            dfs(node, visited, graph)
            count += 1
    return count",127
19290032430,count_Palindromic_substrings,"def count_Palindromic_substrings(s):
    def expandAroundCenter(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        total_count += expandAroundCenter(i, i) # Odd length palindromes
        total_count += expandAroundCenter(i, i+1) # Even length palindromes
    return total_count",127
29767899419,is_valid_path,"def is_valid_path(paths):
    if "".."" in paths[1:-1]: # "".."" should not be in the middle of the path
        return False
    elif ""../"" in """".join(paths) or ""./"" in """".join(paths): # "".."" or ""."" should not be together
        return False
    elif "".."" in paths[-1]: # "".."" should not be the last element
        return False
    elif len(paths) > 1 and "".."" in paths[0]: # "".."" should not be the first element unless it's the only element
        return False
    return True",127
71455495749,palindrome_count,"def palindrome_count(s):
    def expand_around_center(left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # Odd length palindromes
        total_count += expand_around_center(i, i)
        # Even length palindromes
        total_count += expand_around_center(i, i + 1)
    return total_count",127
70451767876,longest_word_chain,"from typing import List

def longest_word_chain(words: List[str]) -> int:
    wordSet = set(words)
    cache = dict()

    def dfs(word):
        if word not in wordSet:
            return 0
        if word in cache:
            return cache[word]

        max_len = 1
        for i in range(len(word)):
            newWord = word[:i] + word[i+1:]
            max_len = max(max_len, 1 + dfs(newWord))
        cache[word] = max_len
        return max_len

    return max(dfs(word) for word in words)",127
43173774634,quickselect,"def quickselect(nums, k):
    if len(nums) == 1:
        return nums[0]

    pivot = nums[len(nums) // 2]

    left = [x for x in nums if x < pivot]
    middle = [x for x in nums if x == pivot]
    right = [x for x in nums if x > pivot]

    if k <= len(left):
        return quickselect(left, k)
    elif k > len(left) + len(middle):
        return quickselect(right, k - len(left) - len(middle))
    else:
        return middle[0]",127
18138905008,longest_substring_without_repeating_characters,"def longest_substring_without_repeating_characters(s):
    start = 0
    end = 0
    max_length = 0
    max_start = 0
    char_dict = {}
    while end < len(s):
        if s[end] in char_dict:
            start = max(start, char_dict[s[end]] + 1)
        char_dict[s[end]] = end
        if end - start + 1 > max_length:
            max_length = end - start + 1
            max_start = start
        end += 1
    return s[max_start:max_start + max_length]",127
70045697784,find_kth_smallest,"import heapq

def find_kth_smallest(nums, k):
    """"""
    Finds the kth smallest element in an unsorted array using a min heap.
    :param nums: List[int] - the input array
    :param k: int - the kth position to find the smallest element
    :return: int - the kth smallest element in the array
    """"""
    min_heap = []
    for num in nums:
        heapq.heappush(min_heap, num)
    for _ in range(k-1):
        heapq.heappop(min_heap)
    return heapq.heappop(min_heap)",126
37541706676,largest_palindrome_product,"def is_palindrome(n):
    return str(n) == str(n)[::-1]

def largest_palindrome_product(n):
    max_num = 10**n - 1
    min_num = 10**(n-1)
    max_palindrome = 0
    for i in range(max_num, min_num-1, -1):
        for j in range(i, min_num-1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if is_palindrome(product):
                max_palindrome = product
    return max_palindrome",126
27220432159,most_frequent_char,"def most_frequent_char(s):
    char_frequency = {}
    for char in s:
        if char in char_frequency:
            char_frequency[char] += 1
        else:
            char_frequency[char] = 1

    max_freq = 0
    most_frequent_char = None
    for char, freq in char_frequency.items():
        if freq > max_freq:
            max_freq = freq
            most_frequent_char = char
        elif freq == max_freq and s.find(char) < s.find(most_frequent_char):
            most_frequent_char = char
    return most_frequent_char",126
338650958,calculate_traffic_time,"def calculate_traffic_time(timeSeries, duration):
    """"""
    Calculate total time spent in traffic based on time series of cars entering and exiting a traffic jam,
    and the duration of the traffic jam.
    """"""
    total_time = 0
    if len(timeSeries) >= 1:
        for i in range(1, len(timeSeries)):
            delta = timeSeries[i] - timeSeries[i - 1]
            if delta >= duration:
                total_time += duration
            else:
                total_time += delta
        total_time += duration
    else:
        total_time = duration
    return total_time",126
38901203021,decode_string,"def decode_string(s: str) -> str:
    """"""
    Decodes an encoded string.
    """"""
    # 用栈模拟
    stk = []
    ctr = res = ''
    for i in range(len(s)):
        if s[i] == '[':
            stk.append([res, int(ctr)])
            ctr = res = ''
        elif s[i] == ']':
            pre, cnt = stk.pop()
            res = pre + res * cnt
        elif '0' <= s[i] <= '9':
            ctr += s[i]
        else:
            res += s[i]
    return res",126
24463815586,min_meeting_rooms,"def min_meeting_rooms(intervals):
    d = []
    for start, end in intervals:
        d.append((start, 1))
        d.append((end, -1))

    d.sort(key=lambda x: x[0] * 10000 + x[1])

    prev, count, ret = 0, 0, 0
    for time, delta in d:
        count += delta
        if prev != time:
            ret = max(ret, count if delta > 0 else count + 1)
        prev = time

    return max(ret, count)",126
39070311577,maxProductKConsecutive,"def maxProductKConsecutive(nums, k):
    """"""
    :type nums: List[int]
    :type k: int
    :rtype: int
    """"""
    if k > len(nums):
        return None

    max_product = float('-inf')
    current_product = 1

    for i in range(k):
        current_product *= nums[i]

    max_product = max(max_product, current_product)

    for i in range(k, len(nums)):
        current_product = current_product // nums[i-k] * nums[i]
        max_product = max(max_product, current_product)

    return max_product",126
43165952827,rearrange_largest,"def rearrange_largest(num):
    """"""
    Rearranges the digits of the given non-negative integer to form the largest possible number.
    
    :param num: A non-negative integer
    :return: The largest possible number formed by the digits of num
    """"""
    # Convert the integer to a list of its digits
    digits = [int(d) for d in str(num)]
    # Sort the digits in descending order
    digits.sort(reverse=True)
    # Convert the sorted list back to an integer
    largest_num = int(''.join(str(d) for d in digits))
    return largest_num",126
31041188632,days_in_month,"def days_in_month(year, month):
    if month in [1, 3, 5, 7, 8, 10, 12]:
        return 31
    elif month in [4, 6, 9, 11]:
        return 30
    elif month == 2:
        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
            return 29
        else:
            return 28
    else:
        return ""Invalid month""",126
23729593538,romanToInt,"def romanToInt(s: str) -> int:
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    for char in s:
        value = roman_values[char]
        if value > prev_value:
            total += value - 2 * prev_value
        else:
            total += value
        prev_value = value
    return total",126
5681925021,romanToInt,"def romanToInt(s: str) -> int:
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    for char in s:
        value = roman_values[char]
        if value > prev_value:
            total += value - 2 * prev_value
        else:
            total += value
        prev_value = value
    return total",126
13162205796,merge_two_sorted_arrays,"def merge_two_sorted_arrays(arr1, arr2):
    result = []
    i, j = 0, 0

    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            result.append(arr1[i])
            i += 1
        else:
            result.append(arr2[j])
            j += 1

    while i < len(arr1):
        result.append(arr1[i])
        i += 1

    while j < len(arr2):
        result.append(arr2[j])
        j += 1

    return result",126
2299426661,longest_substring_without_repeating_characters,"def longest_substring_without_repeating_characters(s: str) -> str:
    start = 0
    max_length = 0
    max_substring = ''
    used_chars = {}

    for i in range(len(s)):
        if s[i] in used_chars and start <= used_chars[s[i]]:
            start = used_chars[s[i]] + 1
        else:
            if i - start + 1 > max_length:
                max_length = i - start + 1
                max_substring = s[start:i+1]

        used_chars[s[i]] = i

    return max_substring",126
70802558263,max_distance_to_closest,"def max_distance_to_closest(seats):
    st = 0
    m = 1
    for i in range(0, len(seats), 1):
        if seats[i] == 1:
            if st != 0 or (st == 0 and seats[0] != 0):
                m = max(m, (i - st) // 2)
            elif st == 0 and seats[0] == 0:
                m = max(m, i - st)   
            st = i
    m = max(m, i - st)    
    return m",126
6217666375,merge_intervals,"def merge_intervals(intervals):
    if len(intervals) == 1:
        return intervals

    intervals.sort()

    answer = [intervals[0][:]]

    for i in range(1, len(intervals)):
        interval = intervals[i]
        prev = answer[-1]

        if prev[1] < interval[0] or interval[1] < prev[0]:
            answer.append(interval)
        else:
            start = min(prev[0], interval[0])
            end = max(prev[1], interval[1])
            answer[-1] = [start, end]

    return answer",126
71759504435,max_prime_diff,"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def max_prime_diff(list1):
    primes = [num for num in list1 if is_prime(num)]
    max_diff = 0
    for i in range(len(primes)):
        for j in range(i + 1, len(primes)):
            max_diff = max(max_diff, abs(primes[i] - primes[j]))
    return max_diff",126
28188437147,check_month_days,"def check_month_days(month, year):
    if month in [1, 3, 5, 7, 8, 10, 12]:
        return 31
    elif month in [4, 6, 9, 11]:
        return 30
    elif month == 2:
        if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):
            return 29
        else:
            return 28
    else:
        return ""Invalid month""",126
32065284361,merge_sorted_lists,"def merge_sorted_lists(list1, list2):
    result = []
    i = 0
    j = 0
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            result.append(list1[i])
            i += 1
        else:
            result.append(list2[j])
            j += 1
    while i < len(list1):
        result.append(list1[i])
        i += 1
    while j < len(list2):
        result.append(list2[j])
        j += 1
    return result",126
34875528424,reverse_stack,"def reverse_stack(stack):
    if not stack:
        return []
    temp_stack = []
    while stack:
        temp_stack.append(stack.pop())
    return temp_stack

assert reverse_stack([1, 2, 3, 4, 5]) == [5, 4, 3, 2, 1]
assert reverse_stack([10, 20, 30, 40, 50]) == [50, 40, 30, 20, 10]
assert reverse_stack([100]) == [100]",126
7062394508,max_subarray_sum_of_size_k,"def max_subarray_sum_of_size_k(arr, k):
    max_sum = float('-inf')
    window_sum = 0
    window_start = 0
    
    for window_end in range(len(arr)):
        window_sum += arr[window_end]  # add the next element
        # slide the window if we've hit the size k
        if window_end >= k-1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]  # subtract the element going out
            window_start += 1  # slide the window ahead
    return max_sum",126
73480266629,romanToInt,"def romanToInt(s: str) -> int:
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    for char in s:
        value = roman_values[char]
        if value > prev_value:
            total += value - 2 * prev_value
        else:
            total += value
        prev_value = value
    return total",126
38046210846,numberOfWays,"def numberOfWays(distance):
    if distance == 1:
        return 1
    if distance == 2:
        return 2
    if distance == 3:
        return 4
    ways = [0] * (distance + 1)
    ways[1] = 1
    ways[2] = 2
    ways[3] = 4
    for i in range(4, distance + 1):
        ways[i] = ways[i - 1] + ways[i - 2] + ways[i - 3]
    return ways[distance]",126
41838336133,minimum_keypresses,"from collections import Counter

def minimum_keypresses(s: str) -> int:
    counter = Counter(s)
    order = sorted([c for c in counter], key=lambda c: counter[c], reverse=True)
    c_to_i = {c: i for i, c in enumerate(order)}
    result = 0
    for c, freq in counter.items():
        if c_to_i[c] < 9:
            result += freq
        elif c_to_i[c] < 18:
            result += freq * 2
        else:
            result += freq * 3
    return result",126
10682652197,max_stock_profit,"def max_stock_profit(prices):
    length = len(prices)
    
    dp = [[0, 0] for _ in range(length)]
    
    dp[0][0] = - prices[0]
    dp[0][1] = 0
    
    for i in range(1, length):
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
    
    return dp[-1][1]",126
5159925012,reverse_words,"def reverse_words(sentence):
    """"""
    Reverses the words in a given sentence while preserving the order of the words.
    
    Args:
        sentence (str): The input sentence to reverse the words of.
        
    Returns:
        str: The sentence with reversed words.
    """"""
    # Split the sentence into words
    words = sentence.split()
    
    # Reverse each word in the list of words
    reversed_words = [word[::-1] for word in words]
    
    # Join the reversed words back into a sentence
    reversed_sentence = ' '.join(reversed_words)
    
    return reversed_sentence",126
10954675787,first_prime,"def is_prime(num):
    if num <= 1:
        return False
    elif num <= 3:
        return True
    elif num % 2 == 0 or num % 3 == 0:
        return False
    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True

def first_prime(nums):
    first_prime = next((el for el in nums if is_prime(el)),-1)
    return first_prime",126
11441329463,check_isbn,"def check_isbn(isbn):
    isbn = isbn.replace('-', '')
    if len(isbn) != 10 or not isbn[:-1].isdigit() or isbn[-1] not in '0123456789X':
        return False
    sum = 0
    for i in range(9):
        sum += int(isbn[i]) * (i + 1)
    sum += 10 * 10 if isbn[-1] == 'X' else int(isbn[-1]) * 10
    return sum % 11 == 0",126
10190578868,is_magic_square,"def is_magic_square(matrix):
    n = len(matrix)
    if n == 0:
        return False
    magic_sum = sum(matrix[0])

    # Check rows and columns
    for i in range(n):
        if sum(matrix[i]) != magic_sum or sum(matrix[j][i] for j in range(n)) != magic_sum:
            return False

    # Check diagonals
    if sum(matrix[i][i] for i in range(n)) != magic_sum or sum(matrix[i][n-i-1] for i in range(n)) != magic_sum:
        return False

    return True",126
25908051493,minPathSum,"def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    for i in range(m):
        for j in range(n):
            if i == 0 and j == 0:
                continue
            elif i == 0:
                grid[i][j] += grid[i][j-1]
            elif j == 0:
                grid[i][j] += grid[i-1][j]
            else:
                grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    return grid[m-1][n-1]",126
12582731190,decodeWays,"def decodeWays(s):
    if not s or s[0] == '0': return 0
    n = len(s)
    dp = [0] * (n+1)
    dp[0] = 1
    dp[1] = 1
    for i in range(1, n):
        if int(s[i]) > 0:
            dp[i+1] += dp[i]
        if 10 <= int(s[i-1:i+1]) <= 26:
            dp[i+1] += dp[i-1]
    return dp[n]",126
3088380570,merge_arrays,"def merge_arrays(nums1, m, nums2, n):
    while m > 0 and n > 0:
        if nums1[m - 1] > nums2[n - 1]:
            nums1[m + n - 1] = nums1[m - 1]
            m -= 1
        else:
            nums1[m + n - 1] = nums2[n - 1]
            n -= 1
    while n > 0:
        nums1[n - 1] = nums2[n - 1]
        n -= 1
    return nums1",126
2474136943,romanToInt,"def romanToInt(s: str) -> int:
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    for char in s:
        value = roman_values[char]
        if value > prev_value:
            total += value - 2 * prev_value
        else:
            total += value
        prev_value = value
    return total",126
39005972068,longest_substring_without_repeating_characters,"def longest_substring_without_repeating_characters(s: str) -> str:
    start = 0
    max_length = 0
    max_substring = """"
    used_chars = {}

    for i in range(len(s)):
        if s[i] in used_chars and start <= used_chars[s[i]]:
            start = used_chars[s[i]] + 1
        else:
            if i - start + 1 > max_length:
                max_length = i - start + 1
                max_substring = s[start:i+1]

        used_chars[s[i]] = i

    return max_substring",126
4674731552,count_components,"from collections import defaultdict

def count_components(n, edges):
    graph = defaultdict(list)
    for edge in edges:
        graph[edge[0]].append(edge[1])
        graph[edge[1]].append(edge[0])

    visited = set()

    def dfs(node):
        if node in visited:
            return False
        visited.add(node)
        for neighbor in graph[node]:
            dfs(neighbor)
        return True

    count = 0
    for i in range(n):
        if i not in visited and dfs(i):
            count += 1
    return count + n - len(visited)",126
23241496475,print_parentheses,"def print_parentheses(n):
    def generate_parentheses(n, open_count, close_count, current, result):
        if len(current) == 2 * n:
            result.append(current)
            return
        if open_count < n:
            generate_parentheses(n, open_count + 1, close_count, current + '(', result)
        if close_count < open_count:
            generate_parentheses(n, open_count, close_count + 1, current + ')', result)

    result = []
    generate_parentheses(n, 0, 0, '', result)
    return result",126
5339304589,findMaxLen,"def findMaxLen(str):
    n = len(str)
    hash_map = dict()
    curr_sum = 0
    max_len = 0
    for i in range(0, n):
        if (str[i] == '0'):
            curr_sum += -1
        else:
            curr_sum += 1
        if (curr_sum == 0):
            max_len = i + 1
        if curr_sum in hash_map:
            max_len = max(max_len, i - hash_map[curr_sum])
        else:
            hash_map[curr_sum] = i
    return max_len",126
36886463506,countPaths,"def countPaths(n, m):
    # Initialize the first row and column of the DP table
    dp = [[0 for _ in range(m)] for _ in range(n)]
    
    for i in range(n):
        dp[i][0] = 1

    for j in range(m):
        dp[0][j] = 1

    for i in range(1, n):
        for j in range(1, m):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]

    return dp[n-1][m-1]",126
40025800263,shortest_path,"import heapq

def shortest_path(graph, start, end):
    distances = {node: float('infinity') for node in graph}
    distances[start] = 0
    queue = [(0, start)]
    while queue:
        current_distance, current_node = heapq.heappop(queue)
        if current_distance > distances[current_node]:
            continue
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(queue, (distance, neighbor))
    return distances[end]",125
30970901207,minSwaps,"from collections import Counter

def minSwaps(arr):
    n = len(arr)
    sorted_arr = sorted(arr)
    swaps = 0
    visited = [False] * n

    for i in range(n):
        if visited[i] or sorted_arr[i] == arr[i]:
            continue
        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = sorted_arr.index(arr[j])
            cycle_size += 1
        if cycle_size > 0:
            swaps += (cycle_size - 1)
    return swaps",125
13980581871,longest_subarray_with_zero_sum,"def longest_subarray_with_zero_sum(arr):
    max_len = 0
    sum_val = 0
    sum_map = {}
    
    for i in range(len(arr)):
        sum_val += arr[i]
        
        if arr[i] == 0 and max_len == 0:
            max_len = 1
            
        if sum_val == 0:
            max_len = i + 1
            
        if sum_val in sum_map:
            max_len = max(max_len, i - sum_map[sum_val])
        else:
            sum_map[sum_val] = i
            
    return max_len",125
18031602043,max_in_sliding_window,"from collections import deque

def max_in_sliding_window(nums, k):
    dq = deque()
    res = []

    for i in range(k):
        while dq and nums[i] >= nums[dq[-1]]:
            dq.pop()
        dq.append(i)
    res.append(nums[dq[0]])

    for i in range(k,len(nums)):
        if dq and dq[0] == i - k:
            dq.popleft()
        while dq and nums[i] >= nums[dq[-1]]:
            dq.pop()
        dq.append(i)
        res.append(nums[dq[0]])

    return res",125
38122963550,decode_message,"def decode_message(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        if s[i-1] != '0':
            dp[i] += dp[i-1]
        if 10 <= int(s[i-2:i]) <= 26:
            dp[i] += dp[i-2]
    return dp[n]",125
74038846125,decode_Ways,"def decode_Ways(s):
    if not s or s[0] == '0':
        return 0
    dp = [0] * (len(s) + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, len(s) + 1):
        if s[i-1] != '0':
            dp[i] = dp[i-1]
        if '10' <= s[i-2:i] <= '26':
            dp[i] += dp[i-2]
    return dp[len(s)]",125
72466161588,minimumSwaps,"def minimumSwaps(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    visited = {i:False for i in range(n)}
    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue
        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = arr.index(temp[j])
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",125
71397389640,max_subarrays,"from collections import deque

def max_subarrays(arr,k):
    d = deque()
    maxVal = []
    
    for i in range(k):
        while d and arr[i] >= arr[d[-1]]:
            d.pop()
        d.append(i)
        
    for i in range(k,len(arr)):
        maxVal.append(arr[d[0]])
        
        while d and d[0] <= i-k:
            d.popleft()
            
        while d and arr[i] >= arr[d[-1]]:
            d.pop()
        d.append(i)
    maxVal.append(arr[d[0]])
    return maxVal",125
18268108738,minSwaps,"def minSwaps(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    visited = {i:False for i in range(n)}
    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue
        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = temp.index(arr[j])
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",125
30922956721,find_pairs,"def find_pairs(numbers, target, n):
    result = []
    if len(numbers) < n:
        return result
    
    numbers.sort()
    left, right = 0, len(numbers) - 1
    
    while left < right:
        current_sum = sum(numbers[left:left+n-1]) + numbers[right]
        if current_sum == target:
            result.append(numbers[left:left+n-1] + [numbers[right]])
            left += 1
            right -= 1
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    
    return result",125
73895973136,prime_sum,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def prime_sum(numbers):
    prime_numbers = [x for x in numbers if is_prime(x)]
    return sum(prime_numbers)",125
15930250492,get_prime_numbers,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def get_prime_numbers(start, end):
    return [n for n in range(start, end+1) if is_prime(n)]",125
6376825087,minSwaps,"def minSwaps(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    visited = {i:False for i in range(n)}

    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue

        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = temp.index(arr[j])
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",125
43016371957,nth_lucas,"def nth_lucas(n):
    """"""
    Calculate the nth Lucas number.
    :param n: int, the position in the Lucas sequence.
    :return: int, the nth Lucas number.
    """"""
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        return nth_lucas(n - 1) + nth_lucas(n - 2)

# Test cases
assert nth_lucas(0) == 2
assert nth_lucas(1) == 1
assert nth_lucas(5) == 11",125
11420600593,generate_phone_combinations,"def generate_phone_combinations(digits):
    dic = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}
    ans = []
    
    def dfs(step, temp):
        if step == len(digits):
            ans.append(temp)
            return
        
        for x in dic[digits[step]]:
            dfs(step + 1, temp + x)
    
    if digits:
        dfs(0, '')
    return ans",125
36403266749,max_sightseeing_score,"def max_sightseeing_score(values):
    arr1 = [values[0]]
    arr2 = []
    for index in range(1,len(values)):
        arr1.append(values[index] + index)
        arr2.append(values[index] - index)
    arr1.pop()
    for index in range(len(values)-3,-1,-1):
        arr2[index] = max(arr2[index], arr2[index+1])
    maxim = - float(""inf"")
    for index in range(len(values)-1):
        maxim = max(maxim, arr1[index] + arr2[index])
    return maxim",125
24022709728,days_in_month,"def days_in_month(year, month):
    if month in [1, 3, 5, 7, 8, 10, 12]:
        return 31
    elif month in [4, 6, 9, 11]:
        return 30
    elif month == 2:
        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
            return 29
        else:
            return 28
    else:
        return None",125
34944080802,count_ways_to_climb,"def count_ways_to_climb(n):
    if n == 0 or n == 1:
        return 1
    if n == 2:
        return 2
    one_step_before = 1
    two_steps_before = 1
    three_steps_before = 2
    for _ in range(3, n):
        current_step = one_step_before + two_steps_before + three_steps_before
        one_step_before, two_steps_before, three_steps_before = two_steps_before, three_steps_before, current_step
    return one_step_before + two_steps_before + three_steps_before",125
74125367395,largest_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def largest_prime(n):
    for i in range(n, 1, -1):
        if is_prime(i):
            return i",125
72042509407,min_elements_to_remove,"def min_elements_to_remove(arr):
    n = len(arr)
    dp = [[0 for _ in range(n)] for _ in range(n)]

    for gap in range(1, n):
        for i in range(n - gap):
            j = i + gap
            if arr[i] == arr[j]:
                dp[i][j] = dp[i + 1][j - 1]
            else:
                dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1

    return dp[0][n - 1]",125
34947509149,LCS,"def LCS(X, Y):
    m = len(X)
    n = len(Y)
    dp = [[0]*(n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if X[i-1] == Y[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]",125
21602796818,minimum_swaps,"def minimum_swaps(arr):
    n = len(arr)
    answer = 0
    temp = arr.copy()
    temp.sort()
    index_map = {value: index for index, value in enumerate(arr)}
    
    for i in range(n):
        correct = temp[i]
        if arr[i] != correct:
            to_swap_idx = index_map[correct]
            arr[i], arr[to_swap_idx] = arr[to_swap_idx], arr[i]
            index_map[arr[to_swap_idx]] = to_swap_idx
            index_map[correct] = i
            answer += 1
    return answer",125
43745762563,look_and_say,"def look_and_say(n):
    res = '1'
    if n == 1:
        return res
    for _ in range(n - 1):
        res = say(res)
    return res

def say(x):
    counter = []
    for i in x:
        if not counter:
            counter.append([i, 0])
        if i == counter[-1][0]:
            counter[-1][1] += 1
        else:
            counter.append([i, 1])
    return ''.join([str(i[1]) + i[0] for i in counter])",125
15907571668,max_substring_length,"def max_substring_length(s: str, k: int) -> int:
    char_map = {}
    left = 0
    max_len = 0
    
    for right in range(len(s)):
        char_map[s[right]] = char_map.get(s[right], 0) + 1
        
        while len(char_map) > k:
            char_map[s[left]] -= 1
            if char_map[s[left]] == 0:
                del char_map[s[left]]
            left += 1
        
        max_len = max(max_len, right - left + 1)
    
    return max_len",125
14896356001,merge_sorted_arrays,"def merge_sorted_arrays(arr1, arr2):
    merged = []
    i, j = 0, 0
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            merged.append(arr1[i])
            i += 1
        else:
            merged.append(arr2[j])
            j += 1
    while i < len(arr1):
        merged.append(arr1[i])
        i += 1
    while j < len(arr2):
        merged.append(arr2[j])
        j += 1
    return merged",125
18517861285,prime_number_list,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def prime_number_list(n):
    return [num for num in range(1, n + 1) if is_prime(num)]",125
24294669306,minimum_swaps,"def minimum_swaps(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    visited = {i:False for i in range(n)}

    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue

        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = arr.index(temp[j])
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",125
30654300068,minimum_swaps,"def minimum_swaps(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    visited = {i:False for i in range(n)}

    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue

        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = arr.index(temp[j])
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",125
71535676909,check_anagrams,"def check_anagrams(str1, str2):
    filtered_str1 = []
    for c in str1:
        if c.isalpha():
            filtered_str1.append(c.lower())
    
    filtered_str2 = []
    for c in str2:
        if c.isalpha():
            filtered_str2.append(c.lower())
    
    if """".join(filtered_str1) == """".join(filtered_str2):
        return 'YES'
    
    filtered_str1.sort()
    filtered_str2.sort()

    if """".join(filtered_str1) == """".join(filtered_str2):
        return 'YES'
    
    return 'NO'",125
31042110580,can_transform_string,"from collections import defaultdict

def can_transform_string(s, t, k):
    if len(s) != len(t):
        return False
    if s == t:
        return True

    counts = defaultdict(int)

    for i in range(len(s)):
        shift = (ord(t[i]) - ord(s[i])) % 26
        if shift > 0:
            counts[shift] += 1

    for shift, count in counts.items():
        total_shift = shift + 26 * (count - 1)
        if total_shift > k:
            return False

    return True",125
15630950710,month_days,"def month_days(year, month):
    if month in [1, 3, 5, 7, 8, 10, 12]:
        return 31
    elif month in [4, 6, 9, 11]:
        return 30
    elif month == 2:
        if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):
            return 29
        else:
            return 28
    else:
        return ""Invalid month""",125
1958986481,minSwaps,"def minSwaps(nums):
    n = len(nums)
    ans = 0
    temp = nums.copy()
    temp.sort()
    visited = {i:False for i in range(n)}

    for i in range(n):
        if visited[i] or temp[i] == nums[i]:
            continue

        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = temp.index(nums[j])
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",125
21557667062,largestRectangleArea,"def largestRectangleArea(heights):
    if not heights:
        return 0
    n = len(heights)
    max_area = 0
    stack = []

    for i in range(n + 1):
        value = -1 if i == n else heights[i]
        while stack and heights[stack[-1]] >= value:
            top = stack.pop(-1) 
            left = stack[-1] if stack else -1
            width = i - left - 1
            max_area = max(max_area, width * heights[top])
        stack.append(i)

    return max_area",125
30875842275,max_sub_array,"def max_sub_array(arr, k):
    max_sum = 0
    window_sum = 0
    window_start = 0

    for window_end in range(len(arr)):
        window_sum += arr[window_end]  # Add the next element to the window

        # Slide the window if we've hit the size k
        if window_end >= k - 1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]  # Subtract the element going out
            window_start += 1  # Slide the window ahead

    return max_sum",125
44680778373,minSwaps,"def minSwaps(arr):
    n = len(arr)
    answer = 0
    temp = arr.copy()
    temp.sort()
    visited = {i:False for i in range(n)}

    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue

        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = temp.index(arr[j])
            cycle_size += 1
        if cycle_size > 0:
            answer += (cycle_size - 1)
    return answer",125
2099374745,two_sum_pairs,"def two_sum_pairs(nums, target):
    if not nums or len(nums) < 2:
        return 0

    sortedNums = sorted(nums)
    left, right, count = 0, len(sortedNums) - 1, 0

    while left < right:
        if sortedNums[left] + sortedNums[right] > target:
            count += left
            right -= 1
            continue
        if sortedNums[left] + sortedNums[right] <= target:
            count += (left + 1)
            left += 1

    return count",125
71081521033,minimum_swaps,"def minimum_swaps(arr):
    n = len(arr)
    answer = 0
    temp = arr.copy()
    temp.sort()
    indexes = {v: i for i, v in enumerate(arr)}
    for i in range(n):
        correct_value = temp[i]
        if arr[i] != correct_value:
            to_swap_idx = indexes[correct_value]
            arr[i], arr[to_swap_idx] = arr[to_swap_idx], arr[i]
            indexes[arr[to_swap_idx]], indexes[arr[i]] = indexes[arr[i]], indexes[arr[to_swap_idx]]
            answer += 1
    return answer",125
33186325809,solution,"def solution(arr):
    _lcm = 0;
    if len(arr) ==1:
        return arr[0]
    else:
        arr.sort(reverse=True)
        _lcm = lcm(arr[0], arr[1])

    for i in range(2, len(arr)):
        _lcm = lcm(_lcm, arr[i])

    return _lcm

def gcd(a,b):
    while b != 0:
        r = a%b;
        a=b;
        b=r;

    return a

def lcm(a,b):
    return a * b // gcd(a,b)",125
23266312453,convert_to_zigzag,"def convert_to_zigzag(s: str, numRows: int) -> str:
    if numRows >= len(s) or numRows == 1:
        return s
    cycle = 2 * numRows - 2
    result = []
    for i in range(numRows):
        for j in range(0, len(s), cycle):
            if j + i < len(s):
                result.append(s[j+i])
            if i > 0 and i < numRows - 1 and j + cycle - i < len(s):
                result.append(s[j + cycle - i])
    return ''.join(result)",125
37843995852,minimum_swaps,"def minimum_swaps(arr):
    n = len(arr)
    answer = 0
    temp = arr.copy()
    temp.sort()
    indexes = {v: i for i, v in enumerate(arr)}
    for i in range(n):
        correct_val = temp[i]
        if arr[i] != correct_val:
            to_swap_idx = indexes[correct_val]
            arr[i], arr[to_swap_idx] = arr[to_swap_idx], arr[i]
            indexes[arr[to_swap_idx]], indexes[arr[i]] = indexes[arr[i]], indexes[arr[to_swap_idx]]
            answer += 1
    return answer",125
12186125997,find_intersection,"def find_intersection(arr1, arr2):
    i, j = 0, 0
    intersection = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] == arr2[j]:
            if len(intersection) == 0 or intersection[-1] != arr1[i]:  # Avoid duplicates in the result
                intersection.append(arr1[i])
            i += 1
            j += 1
        elif arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return intersection",125
39658265490,minSwaps,"def minSwaps(nums):
    n = len(nums)
    answer = 0
    temp = nums.copy()
    nums.sort()
    visited = {i:False for i in range(n)}

    for i in range(n):
        if visited[i] or temp[i] == nums[i]:
            continue

        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = temp.index(nums[j])
            cycle_size += 1
        if cycle_size > 0:
            answer += (cycle_size - 1)
    return answer",125
18552609579,find_unsorted_subarray,"def find_unsorted_subarray(nums):
    sorted_nums = sorted(nums)
    start, end = -1, -1

    i = 0
    while i < len(nums):
        if nums[i] != sorted_nums[i]:
            start = i
            break
        i += 1

    if start == -1:
        return 0

    i = len(nums) - 1
    while i >= 0:
        if nums[i] != sorted_nums[i]:
            end = i
            break
        i -= 1

    return end - start + 1",124
5688539735,check_rectangle,"def check_rectangle(coordinates):
    x_coords = sorted([coord[0] for coord in coordinates])
    y_coords = sorted([coord[1] for coord in coordinates])
    if len(set(x_coords)) != 2 or len(set(y_coords)) != 2:
        return False
    if (x_coords[0], y_coords[0]) in coordinates and (x_coords[0], y_coords[1]) in coordinates and (x_coords[1], y_coords[0]) in coordinates and (x_coords[1], y_coords[1]) in coordinates:
        return True
    return False",124
36752768734,remove_k_digits,"def remove_k_digits(number, k):
    # 내림차순으로 정렬된 경우
    if list(number) == sorted(number, reverse=True):
        return number[:-k]
    
    # 숫자를 담을 스택
    stack = []
    
    for value in number:
        # 뒤에서부터 탐색하며 value보다 작은 값 제거
        while stack and stack[-1] < value and k > 0:
            stack.pop()
            k -= 1
        stack.append(value)

    # 문자열로 반환 
    return """".join(stack)",124
28762542860,nth_ugly_number,"import heapq

def nth_ugly_number(n):
    ugly_numbers = [1]
    seen = {1}
    factors = [2, 3, 5]

    for _ in range(1, n):
        current_ugly = heapq.heappop(ugly_numbers)
        for factor in factors:
            new_ugly = current_ugly * factor
            if new_ugly not in seen:
                seen.add(new_ugly)
                heapq.heappush(ugly_numbers, new_ugly)

    return heapq.heappop(ugly_numbers)",124
7313449946,find_first_non_repeating_char,"from collections import OrderedDict

def find_first_non_repeating_char(s):
    char_count = OrderedDict()
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char, count in char_count.items():
        if count == 1:
            return char
    return ""-""

print(find_first_non_repeating_char(""leetcode""))  # ""l""
print(find_first_non_repeating_char(""loveleetcode""))  # ""v""
print(find_first_non_repeating_char(""aabb""))  # ""-""",124
7127155881,find_longest_consecutive_sequence,"def find_longest_consecutive_sequence(s):
    max_length = 1
    max_char = s[0]
    current_length = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_length += 1
        else:
            if current_length > max_length:
                max_length = current_length
                max_char = s[i-1]
            current_length = 1
    if current_length > max_length:
        max_length = current_length
        max_char = s[-1]
    return max_char * max_length",124
28989441494,highest_product_of_three,"def highest_product_of_three(nums):
    if len(nums) < 3:
        raise ValueError(""Input list must have at least three elements."")
    
    # Sort the list in non-ascending order
    nums.sort(reverse=True)
    
    # The highest product of three can be either:
    # 1. The product of the top three numbers
    # 2. The product of the two lowest (possibly negative) numbers and the highest number
    return max(nums[0] * nums[1] * nums[2], nums[0] * nums[-1] * nums[-2])",124
41303898979,find_min_length,"def find_min_length(arr):
    n = len(arr)
    start = -1
    end = -1
    max_seen = float('-inf')
    min_seen = float('inf')
    for i in range(n):
        if arr[i] < max_seen:
            end = i
        else:
            max_seen = arr[i]
        if arr[n-1-i] > min_seen:
            start = n-1-i
        else:
            min_seen = arr[n-1-i]
    if start == -1:
        return 0
    return end - start + 1",124
70689234305,max_product,"def max_product(arr):
    arr.sort()
    n = len(arr)
    return max(arr[0] * arr[1], arr[n-1] * arr[n-2])

print(max_product([1, 2, 3, 4, 5])) # 20
print(max_product([-1, -2, -3, -4, -5])) # 20
print(max_product([-1, -2, 0, 1, 2])) # 2
print(max_product([0, 0, 0, 0])) # 0",124
18513819012,find_valid_ip_addresses,"def find_valid_ip_addresses(s):
    def dfs(start, path):
        if start == len(s) and len(path) == 4:
            result.append(""."".join(path))
            return
        if len(path) > 4:
            return
        for i in range(start, min(start+3, len(s))):
            if int(s[start:i+1]) <= 255 and (s[start] != '0' or i == start):
                dfs(i+1, path + [s[start:i+1]])
    
    result = []
    dfs(0, [])
    return result",124
42384502483,minimumSwaps,"def minimumSwaps(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    visited = [False for i in range(n)]
 
    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue
 
        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = temp.index(arr[j])
            cycle_size += 1
 
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",124
40810153843,count_pairs_with_sum,"from collections import defaultdict


def count_pairs_with_sum(arr, target_sum):
    """"""
    Counts the number of pairs in the array that add up to a specific target sum.

    :param arr: List of integers.
    :param target_sum: The target sum to find pairs for.
    :return: The number of pairs that add up to the target sum.
    """"""
    freq_map = defaultdict(int)
    count = 0

    for num in arr:
        complement = target_sum - num
        count += freq_map[complement]
        freq_map[num] += 1

    return count",124
39500534501,count_nested_sublists,"def count_nested_sublists(lst):
    if not isinstance(lst, list):
        return 0
    return max((count_nested_sublists(item) for item in lst), default=0) + 1

# Test cases
print(count_nested_sublists([1, [2, [3, [4]]]]))  # Expected output: 4
print(count_nested_sublists([[1, 2], [3, [4, 5]]]))  # Expected output: 3
print(count_nested_sublists([1, 2, 3]))  # Expected output: 1",124
17647493884,isAlienSorted,"from typing import List

def isAlienSorted(words: List[str], order: str) -> bool:
    dic = {c: i for i, c in enumerate(order)}
    for i in range(len(words) - 1):
        for j in range(len(words[i])):
            if j == len(words[i + 1]):
                return False
            idx1 = dic[words[i][j]]
            idx2 = dic[words[i + 1][j]]
            if idx1 > idx2:
                return False
            if idx1 < idx2:
                break
    return True",124
2950392235,combineLists,"def combineLists(list1, list2):
    result = {}
    list1_len = len(list1)
    list2_len = len(list2)
    min_len = min(list1_len, list2_len)

    for i in range(min_len):
        result[list1[i]] = list2[i]

    if list1_len < list2_len:
        for i in range(list1_len, list2_len):
            result[None] = list2[i]
    else:
        for i in range(list2_len, list1_len):
            result[list1[i]] = None

    return result",124
9748590488,reverse_digits_in_string,"def reverse_digits_in_string(s):
    digits = []
    non_digits = []
    for char in s:
        if char.isdigit():
            digits.append(char)
        else:
            non_digits.append(char)
    digits_reversed = digits[::-1]
    result = []
    digit_index = 0
    non_digit_index = 0
    for char in s:
        if char.isdigit():
            result.append(digits_reversed[digit_index])
            digit_index += 1
        else:
            result.append(non_digits[non_digit_index])
            non_digit_index += 1
    return ''.join(result)",124
10780895224,longest_substring_with_k_replacements,"def longest_substring_with_k_replacements(s, k):
    max_count = start = max_length = 0
    char_count = {}
    
    for end in range(len(s)):
        char_count[s[end]] = char_count.get(s[end], 0) + 1
        max_count = max(max_count, char_count[s[end]])
        
        if (end - start + 1) - max_count > k:
            char_count[s[start]] -= 1
            start += 1
        
        max_length = max(max_length, end - start + 1)
    
    return max_length",124
18875263538,find_rotation_count,"def find_rotation_count(arr):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        next = (mid + 1) % len(arr)
        prev = (mid - 1 + len(arr)) % len(arr)
        if arr[mid] <= arr[prev] and arr[mid] <= arr[next]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        else:
            low = mid + 1
    return 0",124
40557987404,max_subarray_length,"def max_subarray_length(arr, target_sum):
    max_length = 0
    current_sum = 0
    start_index = 0
    sum_dict = {0: -1}

    for i, num in enumerate(arr):
        current_sum += num

        if current_sum == target_sum:
            max_length = i + 1

        if current_sum - target_sum in sum_dict:
            max_length = max(max_length, i - sum_dict[current_sum - target_sum])

        if current_sum not in sum_dict:
            sum_dict[current_sum] = i

    return max_length",124
74144755689,eval_rpn,"from typing import List

def eval_rpn(tokens: List[str]) -> int:
    stack = []
    func_map = {
        ""+"": lambda x, y: x + y,
        ""-"": lambda x, y: y - x,
        ""*"": lambda x, y: x * y,
        ""/"": lambda x, y: int(y / x),
    }
    for token in tokens:
        try:
            num = int(token)
            stack.append(num)
        except ValueError:
            res = func_map[token](stack.pop(), stack.pop())
            stack.append(res)
    return stack.pop()",124
27912870373,longest_consecutive_subsequence,"def longest_consecutive_subsequence(s):
    max_len = 1
    max_subseq = s[0]
    current_len = 1
    current_subseq = s[0]
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_len += 1
            current_subseq += s[i]
            if current_len > max_len:
                max_len = current_len
                max_subseq = current_subseq
        else:
            current_len = 1
            current_subseq = s[i]
    return max_subseq",124
28462620354,valid_valley_array,"def valid_valley_array(A):
    """"""
    :type A: List[int]
    :rtype: bool
    """"""
    n = len(A)

    if n < 3:
        return False

    i = 0

    while i < n - 1 and A[i] > A[i + 1]:
        i += 1

    if i + 1 == n or i == 0:
        return False

    while i < n - 1 and A[i] < A[i + 1]:
        i += 1

    return i + 1 == n",124
6991284408,minimum_path_sum,"def minimum_path_sum(triangle):
    if not triangle:
        return 0
    for i in range(1, len(triangle)):
        for j in range(len(triangle[i])):
            if j == 0:
                triangle[i][j] += triangle[i-1][j]
            elif j == len(triangle[i])-1:
                triangle[i][j] += triangle[i-1][j-1]
            else:
                triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j])
    return min(triangle[-1])",123
23461979466,reverse_vowels,"def reverse_vowels(s: str) -> str:
    vowels = set('aeiouAEIOU')
    s = list(s)
    left, right = 0, len(s) - 1
    while left < right:
        while left < right and s[left] not in vowels:
            left += 1
        while left < right and s[right] not in vowels:
            right -= 1
        s[left], s[right] = s[right], s[left]
        left, right = left + 1, right - 1
    return ''.join(s)",123
24491259144,max_product_of_three,"def max_product_of_three(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])

assert max_product_of_three([-10, -10, 5, 2]) == 500
assert max_product_of_three([1, 2, 3]) == 6
assert max_product_of_three([1, 2, 3, 4]) == 24
assert max_product_of_three([-1, -2, -3, -4]) == -6",123
29773122158,validPath,"from collections import defaultdict

def validPath(n, edges, source, destination):
    if source == destination:
        return True
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    seen = set()
    to_visit = [source]
    while to_visit:
        u = to_visit.pop()
        if u not in seen:
            seen.add(u)
            for v in graph[u]:
                if v == destination:
                    return True
                if v not in seen:
                    to_visit.append(v)
    return False",123
16469113757,min_swaps_to_sort,"def min_swaps_to_sort(arr):
    n = len(arr)
    count = 0
    temp = arr.copy()
    temp.sort()
    visited = [False] * n

    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue

        cycle_size = 0
        j = i

        while not visited[j]:
            visited[j] = True
            j = temp.index(arr[j])
            cycle_size += 1

        if cycle_size > 0:
            count += (cycle_size - 1)
    return count",123
30637510690,num_ways_to_roll_dice,"from functools import lru_cache

def num_ways_to_roll_dice(d: int, f: int, target: int) -> int:
    @lru_cache(None)
    def backtrack(remaining_dice, current_target):
        if current_target < 0:
            return 0
        if remaining_dice == 0:
            return 1 if current_target == 0 else 0
        return sum(backtrack(remaining_dice-1, current_target-i) for i in range(1, f+1))
    return backtrack(d, target) % (10**9+7)",123
74099811279,find_sequences,"from math import sqrt

def find_sequences(target):
    res = []
    for num in range(1, target // 2 + 1):
        b = 2 * num - 1
        c = -2 * target
        for length in range(2, int((-b + sqrt(b ** 2 - 4 * c)) // 2) + 1):
            sum1 = (2 * num + length - 1) * length / 2
            if int(sum1) == target:
                res.append(list(range(num, num + length)))
    return res",123
35849669229,can_reach,"from collections import deque

def can_reach(arr, start):
    queue = deque([start])
    seen = set([start])
    while queue:
        i = queue.popleft()
        if arr[i] == 0: return True
        next_right, next_left = i + arr[i], i - arr[i]
        if next_left >= 0 and next_left not in seen:
            queue.append(next_left)
            seen.add(next_left)
        if next_right < len(arr) and next_right not in seen:
            queue.append(next_right)
            seen.add(next_right)
    return False",123
34785959205,find_largest_smaller_than,"def find_largest_smaller_than(numbers, target):
  if not numbers or target <= numbers[0]:
    return None
  left, right = 0, len(numbers) - 1
  while left <= right:
    mid = (left + right) // 2
    if numbers[mid] < target:
      if mid + 1 < len(numbers) and numbers[mid + 1] >= target:
        return numbers[mid]
      left = mid + 1
    else:
      right = mid - 1
  return numbers[right] if right >= 0 else None",123
9251341325,count_Paths,"def count_Paths(grid):
    m, n = grid
    dp = [[0 for x in range(n+1)] for y in range(m+1)]
    dp[1][1] = 1
    for i in range(1, m+1):
        for j in range(1, n+1):
            if i == 1 and j == 1:
                dp[i][j] = 1
            else:
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[m][n]",123
3349148842,maximum_product_of_three,"def maximum_product_of_three(arr):
    arr.sort()
    return max(arr[0]*arr[1]*arr[-1], arr[-1]*arr[-2]*arr[-3])

assert maximum_product_of_three([1, 2, 3, 4]) == 24
assert maximum_product_of_three([-1, -2, -3, 4]) == 24
assert maximum_product_of_three([-1, -2, 1, 2]) == 4
assert maximum_product_of_three([-1, -2, -3, -4]) == -6",123
23329924719,min_sub_sequence_len,"def min_sub_sequence_len(sequence, target):
    start_index = end_index = total = 0
    length = len(sequence)
    
    min_sub_length = length + 1
    
    while end_index < length:
        total += sequence[end_index]
        
        while total >= target:
            current_length = end_index - start_index + 1
            min_sub_length = min(min_sub_length, current_length)
            total -= sequence[start_index]
            start_index += 1
        end_index += 1
    return 0 if min_sub_length == length + 1 else min_sub_length",123
10772438451,maximum_crossing_sum,"def maximum_crossing_sum(arr):
    max_left_sum = max_right_sum = float('-inf')
    temp_sum = 0
    for i in range(len(arr)//2 - 1, -1, -1):
        temp_sum += arr[i]
        if temp_sum > max_left_sum:
            max_left_sum = temp_sum

    temp_sum = 0
    for i in range(len(arr)//2, len(arr)):
        temp_sum += arr[i]
        if temp_sum > max_right_sum:
            max_right_sum = temp_sum

    return max_left_sum + max_right_sum",123
74354384141,max_subarray_length,"def max_subarray_length(nums, target):
    """"""
    :type nums: List[int]
    :type target: int
    :rtype: int
    """"""
    max_len = 0
    sum_dict = {0: -1}
    sum_val = 0
    for i in range(len(nums)):
        sum_val += nums[i]
        if sum_val not in sum_dict:
            sum_dict[sum_val] = i
        if sum_val - target in sum_dict:
            max_len = max(max_len, i - sum_dict[sum_val-target])
    return max_len",123
5295057273,find_prime_palindrome,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def is_palindrome(n):
    return str(n) == str(n)[::-1]

def find_prime_palindrome(start, end):
    prime_palindrome_dict = {}
    for num in range(start, end + 1):
        if is_prime(num):
            prime_palindrome_dict[num] = is_palindrome(num)
    return prime_palindrome_dict",123
20564140534,min_swaps_to_sort,"def min_swaps_to_sort(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    visited = [False] * n
    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue
        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = temp.index(arr[j])
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",123
7894075892,min_path_sum,"def min_path_sum(grid):
    m, n = len(grid), len(grid[0])
    for i in range(m):
        for j in range(n):
            if i == 0 and j == 0:
                continue
            elif i == 0:
                grid[i][j] += grid[i][j-1]
            elif j == 0:
                grid[i][j] += grid[i-1][j]
            else:
                grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    return grid[-1][-1]",123
29161362485,check_and_sort,"def check_and_sort(arr):
    n = len(arr)
    if n == 1:
        return arr

    sorted = True
    for i in range(n - 1):
        if arr[i] > arr[i + 1]:
            sorted = False
            break

    if sorted:
        return arr

    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

    return arr",123
18400973124,findCircleNum,"from typing import List


def findCircleNum(isConnected: List[List[int]]) -> int:
    if not isConnected:
        return 0
    visited = set()

    def dfs(isConnected, i):
        for j in range(len(isConnected)):
            if isConnected[i][j] == 1 and j not in visited:
                visited.add(j)
                dfs(isConnected, j)

    cities = len(isConnected)
    ret = 0
    for i in range(cities):
        if i not in visited:
            ret += 1
            dfs(isConnected, i)
    return ret",123
72977635547,min_swaps_to_sort,"def min_swaps_to_sort(arr):
    n = len(arr)
    count = 0
    temp = arr.copy()
    temp.sort()
    visited = [False] * n
    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue
        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = temp.index(arr[j])
            cycle_size += 1
        if cycle_size > 0:
            count += (cycle_size - 1)
    return count",123
30812906052,car_fleets,"def car_fleets(target, position, speed):
    def compute_arrival_time(curr_pos, curr_speed):
        nonlocal target
        return (target - curr_pos) / curr_speed

    cars = sorted(zip(position, speed), key=lambda x: x[0], reverse=True)
    arrival_bound = None
    fleets = 0
    for pos, sp in cars:
        curr_arrival = compute_arrival_time(pos, sp)
        if not arrival_bound or curr_arrival > arrival_bound:
            arrival_bound = curr_arrival
            fleets += 1
    return fleets",123
10790682995,minimumSwaps,"def minimumSwaps(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    indexes = {v: i for i, v in enumerate(arr)}
    for i in range(n):
        correct_val = temp[i]
        if arr[i] != correct_val:
            to_swap_idx = indexes[correct_val]
            indexes[arr[i]], indexes[correct_val] = indexes[correct_val], indexes[arr[i]]
            arr[i], arr[to_swap_idx] = arr[to_swap_idx], arr[i]
            ans += 1
    return ans",123
22961855432,longest_consecutive_subsequence,"from collections import defaultdict

def longest_consecutive_subsequence(nums):
    if not nums:
        return 0

    seen = defaultdict(bool)
    for num in nums:
        seen[num] = True

    longest_streak = 0

    for num in nums:
        if not seen[num - 1]:
            current_num = num
            current_streak = 1

            while seen[current_num + 1]:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",123
9556377277,minimumSwaps,"def minimumSwaps(arr):
    swaps = 0
    temp = arr.copy()
    temp.sort()
    index_map = {v: i for i, v in enumerate(arr)}
    for i in range(len(arr)):
        correct_val = temp[i]
        if arr[i] != correct_val:
            to_swap_idx = index_map[correct_val]
            arr[i], arr[to_swap_idx] = arr[to_swap_idx], arr[i]
            index_map[arr[to_swap_idx]] = to_swap_idx
            index_map[correct_val] = i
            swaps += 1
    return swaps",123
41913976999,next_prime,"def next_prime(n):
    def is_prime(num):
        if num <= 1:
            return False
        if num <= 3:
            return True
        if num % 2 == 0 or num % 3 == 0:
            return False
        i = 5
        while i * i <= num:
            if num % i == 0 or num % (i + 2) == 0:
                return False
            i += 6
        return True

    while True:
        n += 1
        if is_prime(n):
            return n",123
13143837738,evaluate_rpn,"def evaluate_rpn(expression):
    stack = []
    operators = set(['+', '-', '*', '/'])
    for token in expression.split():
        if token not in operators:
            stack.append(int(token))
        else:
            right_operand = stack.pop()
            left_operand = stack.pop()
            if token == '+':
                stack.append(left_operand + right_operand)
            elif token == '-':
                stack.append(left_operand - right_operand)
            elif token == '*':
                stack.append(left_operand * right_operand)
            elif token == '/':
                stack.append(int(left_operand / right_operand))
    return stack.pop()",123
74626144276,eval_postfix,"def eval_postfix(expression):
    operations = {
        '+': lambda x, y: x + y,
        '-': lambda x, y: x - y,
        '*': lambda x, y: x * y,
        '/': lambda x, y: int(float(x) / float(y))
    }

    stack = []

    for ele in expression:
        if ele in operations:
            temp1 = stack.pop()
            temp2 = stack.pop()
            stack.append(operations[ele](temp2, temp1))
        else:
            stack.append(int(ele))
    return stack[0]",123
14260677125,connected_components,"from collections import defaultdict

def dfs(node, visited, graph):
    visited[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs(neighbor, visited, graph)

def connected_components(edges):
    graph = defaultdict(list)
    for edge in edges:
        graph[edge[0]].append(edge[1])
        graph[edge[1]].append(edge[0])

    visited = defaultdict(bool)
    components = 0

    for node in graph:
        if not visited[node]:
            dfs(node, visited, graph)
            components += 1

    return components",123
3139102041,days_in_month,"def days_in_month(date: str) -> int:
    y, m = map(int, date.split('-'))
    mm = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    if y % 400 == 0 or (y % 100 != 0 and y % 4 == 0):
        mm[1] = 29
    return mm[m - 1]",123
30050964094,is_valid_password,"import re

def is_valid_password(password):
    if len(password) < 8:
        return False
    if re.search(r""[a-z]"", password) is None:
        return False
    if re.search(r""[A-Z]"", password) is None:
        return False
    if re.search(r""\d"", password) is None:
        return False
    if re.search(r""[!@#$%^&*()-_=+[]{}|;:,.<>/?]"", password) is None:
        return False
    if "" "" in password:
        return False
    return True",122
5163996790,mergeSortedLists,"def mergeSortedLists(l1, l2):
    i = j = 0
    result = []
    while i < len(l1) and j < len(l2):
        if l1[i] < l2[j]:
            result.append(l1[i])
            i += 1
        else:
            result.append(l2[j])
            j += 1
    while i < len(l1):
        result.append(l1[i])
        i += 1
    while j < len(l2):
        result.append(l2[j])
        j += 1
    return result",122
12132317834,roman_to_int,"def roman_to_int(s):
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    for char in s:
        value = roman_values[char]
        if value > prev_value:
            total += value - 2 * prev_value
        else:
            total += value
        prev_value = value
    return total",122
31953497981,roman_to_int,"def roman_to_int(s):
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    for char in s:
        value = roman_values[char]
        if value > prev_value:
            total += value - 2 * prev_value
        else:
            total += value
        prev_value = value
    return total",122
71969639487,kth_largest_element,"import heapq

def kth_largest_element(nums, k):
    """"""
    Finds the kth largest element in a given list of integers using a heap data structure.

    :param nums: List[int] - A list of integers.
    :param k: int - The kth position to find the largest element.
    :return: int - The kth largest element in the list.
    """"""
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)
    return heap[0]",122
13951556047,is_isomorphic,"def is_isomorphic(s: str, t: str) -> bool:
    letras_dict = {}

    if len(s) != len(t):
        return False

    for letra_1, letra_2 in zip(s, t):
        if letra_1 in letras_dict.keys() or letra_2 in letras_dict.values():
            continue
        else:
            letras_dict[letra_1] = letra_2

    result = """"
    try:
        for letra in s:
            result += letras_dict[letra]
    except KeyError:
        return False
    return result == t",122
17502870484,roman_to_int,"def roman_to_int(s: str) -> int:
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    for char in reversed(s):
        value = roman_values[char]
        if value < prev_value:
            total -= value
        else:
            total += value
        prev_value = value
    return total",122
70248706421,max_circular_subarray_sum,"def max_circular_subarray_sum(nums):
    s, curr_max, curr_min, sum_max, sum_min = 0, 0, 0, nums[0], nums[0]
    for n in nums:
        s += n
        curr_max = max(curr_max, 0) + n
        curr_min = min(curr_min, 0) + n
        sum_max = max(sum_max, curr_max)
        sum_min = min(sum_min, curr_min)
    
    return sum_max if s == sum_min else max(sum_max, s - sum_min)",122
34656974034,kth_largest_element,"import heapq

def kth_largest_element(nums, k):
    """"""
    Finds the kth largest element in an unsorted list using a min heap.

    :param nums: List[int] - The unsorted list of integers.
    :param k: int - The kth largest element to find.
    :return: int - The kth largest element.
    """"""
    min_heap = []
    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    return min_heap[0]",122
24935582081,can_form,"from collections import Counter

def can_form(str1, str2):
    """"""
    Checks if string str1 can be formed from string str2.
    
    :param str1: str, the string to be formed
    :param str2: str, the string to form from
    :return: bool, True if str1 can be formed from str2, False otherwise
    """"""
    counter1 = Counter(str1)
    counter2 = Counter(str2)
    for char in counter1:
        if counter1[char] > counter2[char]:
            return False
    return True",122
28078097442,combination_sum2,"def combination_sum2(candidates, target):
    def dfs(candidates, target, start, path, res):
        if target < 0:
            return
        if target == 0:
            res.append(path)
            return
        for i in range(start, len(candidates)):
            if i > start and candidates[i] == candidates[i-1]:
                continue
            dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)
    candidates.sort()
    res = []
    dfs(candidates, target, 0, [], res)
    return res",122
72943629007,minimum_swaps_to_sort,"def minimum_swaps_to_sort(arr):
    n = len(arr)
    count = 0
    sorted_arr = sorted(arr)
    visited = [False] * n
    
    for i in range(n):
        if visited[i] or sorted_arr[i] == arr[i]:
            continue
        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = sorted_arr.index(arr[j])
            cycle_size += 1
        if cycle_size > 0:
            count += (cycle_size - 1)
    return count",122
44946243713,is_perfect_number,"def is_perfect_number(n):
    if n < 1:
        return False
    sum = 1
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            if i * (n // i) == n:
                sum = sum + i + n//i
            i += 1
    return sum == n

assert is_perfect_number(6) == True
assert is_perfect_number(28) == True
assert is_perfect_number(12) == False",122
23940929966,count_steps,"def count_steps(n):
    # Base cases
    if n == 1:
        return 1
    elif n == 2:
        return 2
    # Create a list to store results of subproblems
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    # Fill the dp table in bottom up manner
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]",122
32976563255,combination_sum,"def combination_sum(candidates, target):
    def getPath(candidates, index, path, target, rtn_lst):
        if target < 0:
            return
        if target == 0:
            rtn_lst.append(path)
        for i in range(index, len(candidates)):
            getPath(candidates, i, path + [candidates[i]], target - candidates[i], rtn_lst)
    rtn_lst = []
    candidates.sort()
    getPath(candidates, 0, [], target, rtn_lst)
    return [sorted(lst) for lst in set(tuple(sorted(sublist)) for sublist in rtn_lst)]",122
73982103020,nth_ugly_number,"import heapq

def nth_ugly_number(n):
    ugly_numbers = [1]
    seen = {1}
    factors = [2, 3, 5]
    
    for _ in range(1, n):
        current_ugly = heapq.heappop(ugly_numbers)
        for factor in factors:
            new_ugly = current_ugly * factor
            if new_ugly not in seen:
                seen.add(new_ugly)
                heapq.heappush(ugly_numbers, new_ugly)
                
    return ugly_numbers[0]",122
21643710304,coinChange,"def coinChange(coins: list[int], amount: int) -> int:

    def bestChange(coins, amount, count=0):

        if amount == 0:
            return count

        min_val = float('inf')

        for coin in coins:
            if amount - coin < 0:
                continue
            possible = bestChange(coins, amount-coin, count+1)
            if possible:
                min_val = min(min_val, possible)
        return min_val if min_val != float('inf') else -1

    return bestChange(tuple(coins), amount)",122
32070753959,next_larger,"def next_larger(n):
    array = list(str(n))
    length = len(array)
    for i in range(length - 2, -1, -1):
        if array[i] < array[i + 1]:
            break
    else:
        return -1

    for j in range(length - 1, i, -1):
        if array[j] > array[i]:
            break

    array[i], array[j] = array[j], array[i]
    array[i + 1:] = reversed(array[i + 1:])
    return int(''.join(array))",122
24369790257,findShortestSubArray,"from collections import defaultdict

def findShortestSubArray(nums):
    count = defaultdict(int)
    first = {}
    res = 0
    max_count = 0
    for i, x in enumerate(nums):
        if x not in first:
            first[x] = i
        count[x] += 1
        if count[x] > max_count:
            max_count = count[x]
            res = i - first[x] + 1
        elif count[x] == max_count:
            res = min(res, i - first[x] + 1)
    return res",122
10542431138,string_chain,"def string_chain(strings):
    if len(strings) == 0:
        return True
    strings.sort()
    for i in range(len(strings)):
        if string_chain_helper(strings[:i] + strings[i+1:], strings[i]):
            return True
    return False

def string_chain_helper(strings, current):
    if len(strings) == 0:
        return True
    for i in range(len(strings)):
        if strings[i][0] == current[-1]:
            if string_chain_helper(strings[:i] + strings[i+1:], strings[i]):
                return True
    return False",122
37769518978,roman_to_int,"def roman_to_int(s):
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0

    for char in s:
        value = roman_values[char]
        if value > prev_value:
            total += value - 2 * prev_value
        else:
            total += value
        prev_value = value

    return total",122
13078030043,is_valid_bst,"from typing import Optional


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def is_valid_bst(root: Optional[TreeNode]) -> bool:
    def validate(node, low=-float('inf'), high=float('inf')):
        if not node:
            return True
        if not low < node.val < high:
            return False
        return validate(node.left, low, node.val) and validate(node.right, node.val, high)
    return validate(root)",122
35203668059,list_intersection,"def list_intersection(list1, list2):
    """"""
    Finds the intersection of two lists.
    :param list1: list of integers
    :param list2: list of integers
    :return: list of common elements without duplicates
    """"""
    # Convert both lists to sets to remove duplicates and find the intersection
    set1 = set(list1)
    set2 = set(list2)

    # Find the intersection of the two sets
    intersection = set1.intersection(set2)

    # Convert the intersection set back to a list and return it
    return list(intersection)",122
11667220313,roman_to_int,"def roman_to_int(s):
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    for char in s:
        value = roman_values[char]
        if value > prev_value:
            total += value - 2 * prev_value
        else:
            total += value
        prev_value = value
    return total",122
73482474995,max_robbery,"def max_robbery(houses):
    def rob(houses):
        dp = [0] * len(houses)
        dp[0] = houses[0]
        dp[1] = max(houses[0], houses[1])
        for i in range(2, len(houses)):
            dp[i] = max(dp[i-1], dp[i-2] + houses[i])
        return dp[-1]

    if len(houses) == 1:
        return houses[0]
    return max(rob(houses[:-1]), rob(houses[1:]))",122
6600756257,evalRPN,"def evalRPN(tokens):
    operators = {'+', '-', '/', '*'}
    nums = []
    for token in tokens:
        if token not in operators:
            nums.append(int(token))
        else:
            num2 = nums.pop()
            num1 = nums.pop()
            if token == '+':
                nums.append(num1 + num2)
            elif token == '-':
                nums.append(num1 - num2)
            elif token == '*':
                nums.append(num1 * num2)
            elif token == '/':
                nums.append(int(num1 / num2))
    return nums[-1]",122
25351217666,minimum_swaps,"def minimum_swaps(arr):
    swaps = 0
    sorted_arr = sorted(arr)
    index_map = {val: idx for idx, val in enumerate(arr)}
    
    for i in range(len(arr)):
        correct_val = sorted_arr[i]
        if arr[i] != correct_val:
            to_swap_idx = index_map[correct_val]
            arr[i], arr[to_swap_idx] = arr[to_swap_idx], arr[i]
            index_map[arr[to_swap_idx]] = to_swap_idx
            index_map[correct_val] = i
            swaps += 1
            
    return swaps",122
73566028233,find_most_frequent_char,"def find_most_frequent_char(s):
    if not s:
        return None

    char_count = {}
    max_count = 0
    most_frequent_char = s[0]
    
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

        if char_count[char] > max_count or (char_count[char] == max_count and char < most_frequent_char):
            max_count = char_count[char]
            most_frequent_char = char

    return most_frequent_char",122
35516003769,max_equal_subsequence,"def max_equal_subsequence(lst):
    if not lst:
        return []
    max_subsequence = []
    current_subsequence = [lst[0]]
    for i in range(1, len(lst)):
        if lst[i] == lst[i-1]:
            current_subsequence.append(lst[i])
        else:
            if len(current_subsequence) > len(max_subsequence):
                max_subsequence = current_subsequence
            current_subsequence = [lst[i]]
    if len(current_subsequence) > len(max_subsequence):
        max_subsequence = current_subsequence
    return max_subsequence",122
426054846,count_increasing_days,"from typing import List

def count_increasing_days(prices: List[int]) -> int:
    """"""
    Counts the number of days the stock price is strictly greater than the previous day's price.
    
    :param prices: List[int] representing stock prices for a series of consecutive days.
    :return: Integer representing the number of days where the price is strictly greater than the previous day's price.
    """"""
    count = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            count += 1
    return count",122
31474227005,levenshtein_distance,"def levenshtein_distance(str1, str2):
    if str1 == """":
        return len(str2)
    if str2 == """":
        return len(str1)
    cost = 0 if str1[-1] == str2[-1] else 1
    res = min([
        levenshtein_distance(str1[:-1], str2) + 1,
        levenshtein_distance(str1, str2[:-1]) + 1,
        levenshtein_distance(str1[:-1], str2[:-1]) + cost,
    ])
    return res",122
9793846003,roman_to_int,"def roman_to_int(s: str) -> int:
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    result = 0
    prev_value = 0
    for char in reversed(s):
        value = roman_values[char]
        if value < prev_value:
            result -= value
        else:
            result += value
        prev_value = value
    return result",122
11065387575,max_substring_length,"from collections import defaultdict

def max_substring_length(s: str, k: int) -> int:
    max_len = most_freq = left = 0
    cnt = defaultdict(int)
    
    for right in range(len(s)):
        cnt[s[right]] += 1
        most_freq = max(most_freq, cnt[s[right]])
        if right - left + 1 - most_freq > k:
            cnt[s[left]] -= 1
            left += 1
        else:
            max_len = max(max_len, right - left + 1)
                        
    return max_len",122
22698684123,is_valid_valley_array,"def is_valid_valley_array(arr):
    n = len(arr)
    if n < 4:
        return False
    max_i = arr.index(max(arr))
    i = max_i-1
    while i >= 0:
        if not arr[i+1] > arr[i]:
            return False
        i -= 1
    i = max_i +1
    while i < n:
        if not arr[i-1] > arr[i]:
            return False
        i += 1
    return max_i != 0 and max_i != n-1",121
32568737059,minimumSwaps,"def minimumSwaps(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    visited = [False] * n
    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue
        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = temp.index(arr[j])
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",121
40987620312,isAnagram,"def isAnagram(s: str, t: str) -> bool:
    if len(s) != len(t):
        return False
    count_s = [0] * 26
    count_t = [0] * 26

    for i in range(len(s)):
        count_s[ord(s[i]) - ord('a')] += 1
        count_t[ord(t[i]) - ord('a')] += 1

    for i in range(26):
        if count_s[i] != count_t[i]:
            return False

    return True",121
72511149692,romanToInt,"def romanToInt(s):
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    for char in s:
        value = roman_values[char]
        if value > prev_value:
            total += value - 2 * prev_value
        else:
            total += value
        prev_value = value
    return total",121
11820027458,find_frequent_chars,"from collections import Counter

def find_frequent_chars(s):
    if not s:
        return []
    counter = Counter(s)
    max_freq = max(counter.values())
    return sorted([char for char, freq in counter.items() if freq == max_freq])

print(find_frequent_chars(""hello world"")) # ['l']
print(find_frequent_chars(""character"")) # ['c', 'a', 'r']
print(find_frequent_chars(""mississippi"")) # ['i', 's']
print(find_frequent_chars(""abcd"")) # ['a', 'b', 'c', 'd']",121
34480233208,longest_subarray,"def longest_subarray(arr):
    n = len(arr)
    sum = 0
    max_len = 0
    sum_index = {}
    for i in range(0, n):
        if (arr[i] == 0):
            sum -= 1
        else:
            sum += 1
        if (sum == 0):
            max_len = i + 1
        if (sum in sum_index):
            max_len = max(max_len, i - sum_index[sum])
        else:
            sum_index[sum] = i
    return max_len",121
22112440114,reverseParentheses,"def reverseParentheses(s):
    opened = []
    pair = {}
    for i, c in enumerate(s):
        if c == '(':
            opened.append(i)
        elif c == ')':
            j = opened.pop()
            pair[i], pair[j] = j, i

    res = []
    i, d = 0, 1
    while i < len(s):
        if s[i] in '()':
            i = pair[i]
            d = -d
        else:
            res.append(s[i])
        i += d
    return ''.join(res)",121
71392094910,minimum_swaps,"def minimum_swaps(arr):
    n = len(arr)
    answer = 0
    temp = arr.copy()
    temp.sort()
    indexes = {value: index for index, value in enumerate(arr)}
    
    for i in range(n):
        correct = temp[i]
        if arr[i] != correct:
            to_swap_idx = indexes[correct]
            arr[to_swap_idx], arr[i] = arr[i], arr[to_swap_idx]
            indexes[arr[to_swap_idx]] = to_swap_idx
            indexes[arr[i]] = i
            answer += 1
    return answer",121
70726640761,longest_substring_without_repeating_characters,"def longest_substring_without_repeating_characters(s):
    max_length = 0
    start = 0
    max_substring = """"
    used_chars = {}

    for i in range(len(s)):
        if s[i] in used_chars and start <= used_chars[s[i]]:
            start = used_chars[s[i]] + 1
        else:
            if i - start + 1 > max_length:
                max_length = i - start + 1
                max_substring = s[start:i+1]

        used_chars[s[i]] = i

    return max_substring",121
28531573670,palindrome_length,"def palindrome_length(s: str) -> int:
    char_counts = {}
    for char in s:
        if char in char_counts:
            char_counts[char] += 1
        else:
            char_counts[char] = 1
    length = 0
    odd_encountered = False
    for count in char_counts.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_encountered = True
    if odd_encountered:
        length += 1
    return length",121
16217656651,check_isbn,"def check_isbn(isbn):
    if len(isbn) != 10:
        return False
    total = 0
    for i in range(9):
        if not isbn[i].isdigit():
            return False
        total += (i+1) * int(isbn[i])
    if isbn[9].isdigit():
        total += 10 * int(isbn[9])
    elif isbn[9] == 'X':
        total += 10 * 10
    else:
        return False
    return total % 11 == 0",121
29689189465,longest_subarray_with_zero_sum,"def longest_subarray_with_zero_sum(arr):
    max_len = 0
    curr_sum = 0
    sum_map = {}
    for i in range(len(arr)):
        curr_sum += arr[i]
        if arr[i] is 0 and max_len == 0:
            max_len = 1
        if curr_sum == 0:
            max_len = i + 1
        if curr_sum in sum_map:
            max_len = max(max_len, i - sum_map[curr_sum])
        else:
            sum_map[curr_sum] = i
    return max_len",121
17250176306,longest_substring_without_repeating,"def longest_substring_without_repeating(s):
    charIndexMap = {}
    start = 0
    maxLength = 0
    maxStart = 0
    for i in range(len(s)):
        if s[i] in charIndexMap and charIndexMap[s[i]] >= start:
            start = charIndexMap[s[i]] + 1
        charIndexMap[s[i]] = i
        if i - start + 1 > maxLength:
            maxLength = i - start + 1
            maxStart = start
    return s[maxStart:maxStart + maxLength]",121
6777044737,count_unique_pairs,"from typing import List

def count_unique_pairs(nums: List[int], target: int) -> int:
    nums.sort()
    n = len(nums)
    l, r = 0, n-1
    pairs = set()
    while l < r:
        if nums[l] + nums[r] < target:
            l += 1
        elif nums[l] + nums[r] > target:
            r -= 1
        else:
            pairs.add((nums[l], nums[r]))
            l += 1
            r -= 1
    return len(pairs)",121
18230544525,is_binary_search_tree,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def in_order_traversal(node, values):
    if node is not None:
        in_order_traversal(node.left, values)
        values.append(node.val)
        in_order_traversal(node.right, values)

def is_binary_search_tree(root):
    values = []
    in_order_traversal(root, values)
    return all(values[i] < values[i+1] for i in range(len(values)-1))",121
12283805858,canVisitAllRooms,"from collections import deque
from typing import List


def canVisitAllRooms(rooms: List[List[int]]) -> bool:
    """"""
    Time: O(n)
    Space: O(n)
        n - number of rooms
    """"""
    q = deque([0])
    seen = set()
    n = len(rooms)

    while q:
        room = q.popleft()
        if room in seen:
            continue

        seen.add(room)
        for unlocked in rooms[room]:
            if unlocked not in seen:
                q.append(unlocked)

    return len(seen) == n",121
72484904184,coinChange,"from collections import deque

def coinChange(coins, amount):
    coins.sort(reverse=True)
    queue = deque([(amount, 0)])
    visited = {amount}
    
    while queue:
        curr_amount, curr_coins = queue.popleft()
        
        if curr_amount == 0:
            return curr_coins
        
        for coin in coins:
            next_amount = curr_amount - coin
            if next_amount >= 0 and next_amount not in visited:
                visited.add(next_amount)
                queue.append((next_amount, curr_coins + 1))
    
    return -1",121
4341220890,longest_unique_substring,"def longest_unique_substring(s):
    """"""
    :type s: str
    :rtype: str
    """"""
    start = 0
    max_length = 0
    max_substring = ''
    seen = {}

    for end, char in enumerate(s):
        if char in seen:
            start = max(start, seen[char] + 1)

        seen[char] = end
        if end - start + 1 > max_length:
            max_length = end - start + 1
            max_substring = s[start:end+1]

    return max_substring",121
32300708129,check_isbn,"def check_isbn(isbn):
    if len(isbn) != 10:
        return False
    total = 0
    for i in range(9):
        if not isbn[i].isdigit():
            return False
        total += (i+1) * int(isbn[i])
    if isbn[9].isdigit():
        total += 10 * int(isbn[9])
    elif isbn[9] == 'X':
        total += 10 * 10
    else:
        return False
    return total % 11 == 0",121
72512356675,largest_palindrome_product,"def is_palindrome(n):
    return str(n) == str(n)[::-1]

def largest_palindrome_product(n):
    start = 10**(n-1)
    end = 10**n - 1
    largest_palindrome = 0
    for i in range(end, start-1, -1):
        for j in range(i, start-1, -1):
            product = i * j
            if product <= largest_palindrome:
                break
            if is_palindrome(product):
                largest_palindrome = product
    return largest_palindrome",121
35751106551,is_valid_ISBN,"def is_valid_ISBN(isbn):
    isbn = isbn.replace(""-"", """")
    if len(isbn) != 10:
        return False
    try:
        total = 0
        for i in range(9):
            total += int(isbn[i]) * (10 - i)
        last_digit = isbn[-1]
        if last_digit == 'X':
            last_digit = 10
        else:
            last_digit = int(last_digit)
        total += last_digit
        return total % 11 == 0
    except ValueError:
        return False",121
4495871308,min_swaps,"def min_swaps(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    visited = [False] * n
    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue
        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = temp.index(arr[j])
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",121
73838557303,sliding_window,"from collections import deque
def sliding_window(nums, k):
    if not nums:
        return []
    if k == 1:
        return nums
    if k == len(nums):
        return [max(nums)]
    result = []
    queue = deque()
    for i in range(len(nums)):
        while queue and nums[queue[-1]] <= nums[i]:
            queue.pop()
        queue.append(i)
        if queue[0] == i - k:
            queue.popleft()
        if i >= k - 1:
            result.append(nums[queue[0]])
    return result",121
37813230322,ways_to_sum,"def ways_to_sum(n):
    if n == 0:
        return 0
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        if i - 1 >= 0:
            dp[i] += dp[i - 1]
        if i - 3 >= 0:
            dp[i] += dp[i - 3]
        if i - 4 >= 0:
            dp[i] += dp[i - 4]
    return dp[n]",121
24718775197,is_isomorphic,"def is_isomorphic(s: str, t: str) -> bool:
    if len(s) != len(t):
        return False
    mapping_s_t = {}
    mapping_t_s = {}
    for c1, c2 in zip(s, t):
        if (c1 in mapping_s_t and mapping_s_t[c1] != c2) or (c2 in mapping_t_s and mapping_t_s[c2] != c1):
            return False
        mapping_s_t[c1] = c2
        mapping_t_s[c2] = c1
    return True",121
29177944224,romanToInt,"def romanToInt(s: str) -> int:
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    for c in reversed(s):
        value = roman_values[c]
        if value < prev_value:
            total -= value
        else:
            total += value
        prev_value = value
    return total",121
42513860738,max_profit,"def max_profit(prices):
    """"""
    Finds the maximum profit that can be achieved from a list of stock prices,
    given that you can only make one transaction.
    
    :param prices: List of stock prices.
    :return: Maximum profit that can be achieved.
    """"""
    if not prices:
        return 0

    min_price = prices[0]
    max_profit = 0

    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)

    return max_profit",121
74952367359,max_nested_lists,"def max_nested_lists(lst):
    depth = 0
    max_depth = 0
    for item in lst:
        if isinstance(item, list):
            max_depth, depth = max_nested_lists_helper(item, depth+1, max_depth)
    return max_depth

def max_nested_lists_helper(lst, depth, max_depth):
    for item in lst:
        if isinstance(item, list):
            max_depth, depth = max_nested_lists_helper(item, depth+1, max_depth)
        else:
            max_depth = max(max_depth, depth)
    return max_depth, depth-1",121
19954633266,intersection_sorted_arrays,"def intersection_sorted_arrays(arr1, arr2):
    i, j = 0, 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] == arr2[j]:
            if not result or arr1[i] != result[-1]:  # Avoid duplicates in the result
                result.append(arr1[i])
            i += 1
            j += 1
        elif arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return result",121
41408030972,num_distinct_subsequences,"def num_distinct_subsequences(s):
    dp = [0] * (len(s) + 1)
    dp[0] = 1
    last_occurrence = {}
    for i in range(1, len(s) + 1):
        dp[i] = 2 * dp[i - 1]
        if s[i - 1] in last_occurrence:
            dp[i] -= dp[last_occurrence[s[i - 1]] - 1]
        last_occurrence[s[i - 1]] = i
    return dp[len(s)] - 1",121
18046000319,largest_subarray_sum,"def largest_subarray_sum(arr, given_sum):
    current_sum = 0
    max_sum = -1
    start = 0

    for i in range(len(arr)):
        current_sum += arr[i]

        # If current_sum is greater than given_sum, remove elements from the start
        while current_sum > given_sum:
            current_sum -= arr[start]
            start += 1

        # Update max_sum if the current_sum is greater than max_sum
        if current_sum == given_sum:
            max_sum = max(max_sum, current_sum)

    return max_sum",121
23473573125,remove_k_smallest_digits,"from collections import Counter

def remove_k_smallest_digits(num, k):
    str_num = str(num)
    freq = Counter(str_num)
    unique_digits = sorted(set(str_num))
    
    for digit in unique_digits:
        if k == 0:
            break
        if freq[digit] <= k:
            k -= freq[digit]
            str_num = str_num.replace(digit, """")
        else:
            str_num = ''.join([i for i in str_num if i != digit][:k]) + str_num[k:]
            k = 0
    
    return str_num",121
29052952171,intersection_sorted_lists,"def intersection_sorted_lists(lst1, lst2):
    i, j = 0, 0
    result = []
    while i < len(lst1) and j < len(lst2):
        if lst1[i] == lst2[j]:
            if result == [] or result[-1] != lst1[i]: # Avoid duplicates in the result
                result.append(lst1[i])
            i += 1
            j += 1
        elif lst1[i] < lst2[j]:
            i += 1
        else:
            j += 1
    return result",121
21761064110,maxRepeatChar,"def maxRepeatChar(str):
    maxChar = str[0]
    maxCount = 1
    currentChar = str[0]
    currentCount = 1

    for i in range(1, len(str)):
        if str[i] == currentChar:
            currentCount += 1
        else:
            if currentCount > maxCount:
                maxCount = currentCount
                maxChar = currentChar
            currentChar = str[i]
            currentCount = 1

    if currentCount > maxCount:
        maxChar = currentChar

    return maxChar",121
73793605631,next_greater_elements,"def next_greater_elements(nums):
    if not nums:
        return []
    res = []
    stack = []
    i = 0
    while i < len(nums):
        if len(stack) == 0:
            stack.append((nums[i], i))
            res.append(0)
        else:
            while len(stack) > 0 and stack[-1][0] < nums[i]:
                val, ind = stack.pop()
                res[ind] = nums[i]
            res.append(0)
            stack.append((nums[i], i))
        i += 1
    return res",121
30778175743,find_common,"def find_common(list1, list2):
    if not list1 or not list2:
        return []
    common_list = []
    min_sum = float('inf')
    index_dict = {restaurant: index for index, restaurant in enumerate(list1)}
    for index, restaurant in enumerate(list2):
        if restaurant in index_dict:
            total_sum = index + index_dict[restaurant]
            if total_sum < min_sum:
                min_sum = total_sum
                common_list = [restaurant]
            elif total_sum == min_sum:
                common_list.append(restaurant)
    return common_list",121
6167956166,reverse_and_negate,"def reverse_and_negate(numbers):
    return [num * -1 if num > 0 else num * -1 for num in reversed(numbers)]

assert reverse_and_negate([1, 2, 3, 4, 5]) == [-5, -4, -3, -2, -1]
assert reverse_and_negate([5, 3, -2]) == [2, -3, -5]
assert reverse_and_negate([-1, -2, -3, -4]) == [4, 3, 2, 1]",120
34587313971,minSwap,"def minSwap(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    visited = [False] * n
    for i in range(n):
        if visited[i] or temp[i] == arr[i]:
            continue
        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = temp.index(arr[j])
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",120
22863639582,min_swap,"def min_swap(arr):
    n = len(arr)
    ans = 0
    temp = arr.copy()
    temp.sort()
    vis = [0]*n

    for i in range(n):
        if(vis[i] or temp[i] == arr[i]):
            continue
        cycle_size = 0
        j = i
        while(not vis[j]):
            vis[j] = 1
            j = temp.index(arr[j])
            cycle_size += 1
        if cycle_size > 0:
            ans += (cycle_size - 1)
    return ans",120
42020237374,isBipartite,"from collections import deque

def isBipartite(graph):
    n = len(graph)
    color = [0] * n
    for i in range(n):
        if color[i] == 0:
            queue = deque([i])
            color[i] = 1
            while queue:
                node = queue.popleft()
                for neighbor in graph[node]:
                    if color[neighbor] == color[node]:
                        return False
                    if color[neighbor] == 0:
                        color[neighbor] = -color[node]
                        queue.append(neighbor)
    return True",120
44850585248,second_smallest,"def second_smallest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return None
    unique_numbers.sort()
    return unique_numbers[1]

if __name__ == '__main__':
    print(second_smallest([1, 2, 3, 4, 5]) == 2)
    print(second_smallest([5, 1, 4, 3, 2]) == 2)
    print(second_smallest([]) == None)
    print(second_smallest([1, 1]) == None)",120
28525100613,distinct_subsequences,"def distinct_subsequences(s):
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    last_occurrence = {}
    for i in range(1, n + 1):
        dp[i] = 2 * dp[i - 1]
        if s[i - 1] in last_occurrence:
            dp[i] -= dp[last_occurrence[s[i - 1]]]
        last_occurrence[s[i - 1]] = i - 1
    return dp[n] - 1",120
6913507420,find_longest_consecutive_subsequence,"def find_longest_consecutive_subsequence(arr, n):
    arr.sort()
    max_len = 1
    current_len = 1
    for i in range(1, n):
        if arr[i] == arr[i-1]:
            continue
        if arr[i] == arr[i-1] + 1:
            current_len += 1
        else:
            if current_len > max_len:
                max_len = current_len
            current_len = 1
    if current_len > max_len:
        max_len = current_len
    return max_len",120
35775367408,reverse_string_stack,"class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return not bool(self.items)

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()

    def peek(self):
        return self.items[-1]

    def size(self):
        return len(self.items)

def reverse_string_stack(s):
    stack = Stack()
    for char in s:
        stack.push(char)
    reversed_string = ''
    while not stack.is_empty():
        reversed_string += stack.pop()
    return reversed_string",120
12893348563,get_Longest_Subarray,"def get_Longest_Subarray(arr,sum):
    n = len(arr)
    curr_sum = 0
    max_length = 0
    sum_index_map = {}
    for i in range(n):
        curr_sum += arr[i]
        if curr_sum == sum:
            max_length = i + 1
        if (curr_sum - sum) in sum_index_map:
            max_length = max(max_length, i - sum_index_map[curr_sum - sum])
        if curr_sum not in sum_index_map:
            sum_index_map[curr_sum] = i
    return max_length",120
73096158424,max_length_subarray,"def max_length_subarray(arr, target):
    max_len = 0
    current_sum = 0
    start = 0
    sum_dict = {}
    for end in range(len(arr)):
        current_sum += arr[end]
        if current_sum == target:
            max_len = max(max_len, end - start + 1)
        if current_sum - target in sum_dict:
            max_len = max(max_len, end - sum_dict[current_sum - target])
        if current_sum not in sum_dict:
            sum_dict[current_sum] = end
    return max_len",120
28183038807,minimumSwaps,"def minimumSwaps(arr):
    n = len(arr)
    answer = 0
    temp = arr.copy()
    temp.sort()
    indexes = {v: i for i, v in enumerate(arr)}
    for i in range(n):
        correct = temp[i]
        if arr[i] != correct:
            to_swap_idx = indexes[correct]
            arr[i], arr[to_swap_idx] = arr[to_swap_idx], arr[i]
            indexes[arr[to_swap_idx]] = to_swap_idx
            indexes[correct] = i
            answer += 1
    return answer",120
70023170327,find_longest_unique_substring,"def find_longest_unique_substring(s):
    n = len(s)
    last_seen = {}
    start = 0
    longest = (0, 0)
    for i, char in enumerate(s):
        if char in last_seen and last_seen[char] >= start:
            start = last_seen[char] + 1
        last_seen[char] = i
        if i - start + 1 > longest[1] - longest[0]:
            longest = (start, i + 1)
    return s[longest[0]:longest[1]]",120
6417691618,largest_palindrome_product,"def largest_palindrome_product(n):
    max_num = 10**n - 1
    min_num = 10**(n-1)
    max_palindrome = 0

    for i in range(max_num, min_num - 1, -1):
        for j in range(i, min_num - 1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if str(product) == str(product)[::-1]:
                max_palindrome = max(max_palindrome, product)

    return max_palindrome",120
26378318800,trap,"def trap(height):
    if not height:
        return 0

    left, right = 0, len(height) - 1
    max_left, max_right = height[left], height[right]
    result = 0

    while left < right:
        if max_left < max_right:
            left += 1
            max_left = max(max_left, height[left])
            result += max_left - height[left]
        else:
            right -= 1
            max_right = max(max_right, height[right])
            result += max_right - height[right]

    return result",120
430429014,longest_substring_without_repeating,"def longest_substring_without_repeating(s):
    max_length = 0
    start = 0
    max_substring = """"
    used_chars = {}

    for i in range(len(s)):
        if s[i] in used_chars and start <= used_chars[s[i]]:
            start = used_chars[s[i]] + 1
        else:
            if i - start + 1 > max_length:
                max_length = i - start + 1
                max_substring = s[start:i+1]

        used_chars[s[i]] = i

    return max_substring",120
15520753999,is_bipartite,"from queue import Queue

def is_bipartite(graph):
    colors = {}  # store nodes and its color
    q = Queue()

    for i in range(len(graph)):
        if i not in colors:
            q.put(i)
            colors[i] = 0

            while not q.empty():
                cur = q.get()
                for v in graph[cur]:
                    if v in colors and colors[v] == colors[cur]:
                        return False
                    elif v not in colors:
                        colors[v] = 1 - colors[cur]
                        q.put(v)

    return True",120
6453294621,num_ways_decode,"def num_ways_decode(s: str) -> int:
    if not s or s[0] == '0':
        return 0

    two = 1
    one = 1

    for i in range(1, len(s)):
        curr = 0
        if s[i] != '0':
            curr += one
        if s[i-1] == '1' or (s[i-1] == '2' and s[i] <= '6'):
            curr += two
        two, one = one, curr

    return one",120
73980058770,search_2D_matrix,"def search_2D_matrix(matrix, target):
    rowlen , collen = len(matrix), len(matrix[0])
    if rowlen == 0:
        return False
    s,h = 0, rowlen*collen - 1
    while(s <= h):
        mid = (s+h)//2
        ele = matrix[mid//collen][mid%collen]
        if(ele == target):
            return True
        elif(ele < target):
            s = mid + 1
        else:
            h = mid - 1
    return False",120
16699275583,unique_binary_search_trees,"def unique_binary_search_trees(n):
    if n == 0:
        return 1
    num_trees = [0 for _ in range(n+1)]
    num_trees[0] = 1
    num_trees[1] = 1

    for nodes in range(2, n+1):
        for root in range(1, nodes+1):
            left_subtrees = num_trees[root-1]
            right_subtrees = num_trees[nodes-root]
            num_trees[nodes] += left_subtrees * right_subtrees

    return num_trees[n]",120
70155927169,longestPalindromicSubString,"def helper(s,l,r):
    while l>=0 and r<len(s) and s[l]==s[r]:
        l=l-1
        r=r+1
    return s[l+1:r]

def longestPalindromicSubString(s):
    res=''
    for i in range(len(s)):
        #odd case
        temp=helper(s,i,i)
        if len(temp)>len(res):
            res=temp
        #even case
        temp=helper(s,i,i+1)
        if len(temp)>len(res):
            res=temp
    return  res",120
42121064876,maxEvents,"import heapq

def maxEvents(events):
    events.sort()
    heap = []
    res = 0
    event_days = 0
    while events or heap:
        if not heap:
            event_days = events[0][0]
        while events and events[0][0] <= event_days:
            heapq.heappush(heap, events.pop(0)[1])
        heapq.heappop(heap)
        res += 1
        event_days += 1
        while heap and heap[0] < event_days:
            heapq.heappop(heap)
    return res",120
22934140062,find_largest_palindrome,"def find_largest_palindrome(n):
    def is_palindrome(x):
        return str(x) == str(x)[::-1]

    max_num = 10**n - 1
    min_num = 10**(n-1)
    result = 0

    for i in range(max_num, min_num-1, -1):
        for j in range(i, min_num-1, -1):
            product = i * j
            if product <= result:
                break
            if is_palindrome(product):
                result = product
    return result",120
39641276296,calculate_bulls_and_cows,"from collections import defaultdict

def calculate_bulls_and_cows(secret, guess):
    secret_map = defaultdict(int)
    guess_map = defaultdict(int)
    bulls, cows = 0, 0
    for s, g in zip(secret, guess):
        if s == g:
            bulls += 1
        else:
            secret_map[s] += 1
            guess_map[g] += 1
    cows = sum([min(secret_map[k], guess_map[k]) for k in secret_map])

    return '%sA%sB' % (bulls, cows)",120
70962924312,find_longest_substring,"from collections import Counter

def find_longest_substring(s: str, k: int) -> int:
    count = Counter()
    maxCount = 0
    answer = 0
    l = 0 
    
    for r,char in enumerate(s):
            
            count[char] += 1
            
            maxCount = max(maxCount, count[char])
            
            while maxCount + k < r -l + 1:
                count[s[l]] -= 1
                l += 1
            answer = max(answer, r- l + 1)
    return answer",120
14381973549,longestUniqueSubsttr,"def longestUniqueSubsttr(s: str) -> str:
    max_length = 0
    max_substring = ''
    start = 0
    seen_chars = {}

    for end in range(len(s)):
        if s[end] in seen_chars:
            start = max(start, seen_chars[s[end]] + 1)
        if (end - start + 1) > max_length:
            max_length = end - start + 1
            max_substring = s[start:end+1]
        seen_chars[s[end]] = end

    return max_substring",119
71995741551,binary_search_first,"def binary_search_first(arr, target):
    def bsearch(arr, target):
        n = len(arr)
        low, high = 0, n - 1
        res = -1
        
        while low <= high:
            mid = (low + high) // 2
                
            if arr[mid] == target:
                res = mid
                high = mid - 1
            elif arr[mid] < target:
                low = mid + 1
            else:
                high = mid - 1
        
        return res
    
    return bsearch(arr, target)",119
19374649466,nearest_prime,"def nearest_prime(n):
    def is_prime(x):
        if x < 2:
            return False
        for i in range(2, int(x ** 0.5) + 1):
            if x % i == 0:
                return False
        return True

    if is_prime(n):
        return n

    up, down = n + 1, n - 1
    while True:
        if is_prime(up):
            return up
        if is_prime(down):
            return down
        up += 1
        down -= 1",119
5763240474,compress_string,"def compress_string(s):
    compressed = """"
    curr_char = s[0]
    count = 1
    for i in range(1, len(s)):
        if s[i] == curr_char:
            count += 1
        else:
            compressed += curr_char + ("""" if str(count) == ""1"" else str(count))
            count = 1
            curr_char = s[i]
    compressed += curr_char + ("""" if str(count) == ""1"" else str(count))
    return compressed if len(compressed) < len(s) else s",119
42096588667,is_valid_isbn,"def is_valid_isbn(isbn):
    if len(isbn) != 10:
        return False
    sum = 0
    for i in range(9):
        if not isbn[i].isdigit():
            return False
        sum += int(isbn[i])*(i+1)
    if isbn[9].isdigit():
        sum += int(isbn[9])*10
    elif isbn[9] == 'X':
        sum += 10*10
    else:
        return False
    return sum % 11 == 0",119
73058520288,min_path_sum,"def min_path_sum(grid):
    m, n = len(grid), len(grid[0])
    for i in range(1, n):
        grid[0][i] += grid[0][i-1]
    for i in range(1, m):
        grid[i][0] += grid[i-1][0]
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    return grid[-1][-1]",119
30555111811,find_longest_unique_substring,"def find_longest_unique_substring(s: str) -> str:
    start, max_length, max_substring = 0, 0, """"
    used_chars = {}

    for i, char in enumerate(s):
        if char in used_chars and start <= used_chars[char]:
            start = used_chars[char] + 1
        else:
            if i - start + 1 > max_length:
                max_length = i - start + 1
                max_substring = s[start:i+1]

        used_chars[char] = i

    return max_substring",119
2308428784,max_sum_subarray,"def max_sum_subarray(arr,k):
    max_sum = float('-inf')
    window_sum = 0
    window_start = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end] # add the next element
        # slide the window if we've hit the size k
        if window_end >= k-1:
            max_sum = max(max_sum,window_sum)
            window_sum -= arr[window_start] # subtract the element going out
            window_start += 1 # slide the window ahead
    return max_sum",119
11792457772,largest_product_of_three,"def largest_product_of_three(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])

print(largest_product_of_three([1, 10, 2, 6, 5, 3])) # 300
print(largest_product_of_three([-10, -10, 1, 3, 2])) # 300
print(largest_product_of_three([-1, -2, -3, -4])) # -6",119
24453669034,intersection,"def intersection(arr1, arr2):
    i, j = 0, 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] == arr2[j]:
            if not result or result[-1] != arr1[i]:  # Avoid duplicates in the result
                result.append(arr1[i])
            i += 1
            j += 1
        elif arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return result",119
40451214915,min_path_sum,"def min_path_sum(grid):
    m, n = len(grid), len(grid[0])
    for i in range(1, n):
        grid[0][i] += grid[0][i-1]
    for i in range(1, m):
        grid[i][0] += grid[i-1][0]
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    return grid[-1][-1]",119
24063310347,count_pairs_with_sum,"from typing import List


def count_pairs_with_sum(nums: List[int], k: int) -> int:
    nums.sort()
    left, right = 0, len(nums) - 1
    res = set()
    while left < right:
        curr_sum = nums[left] + nums[right]
        if curr_sum == k:
            res.add((nums[left], nums[right]))
            left += 1
            right -= 1
        elif curr_sum < k:
            left += 1
        else:
            right -= 1
    return len(res)",119
34546722110,intersect,"from collections import Counter

def intersect(nums1, nums2):
    """"""
    Calculate the intersection of two arrays. Each element should be counted as many times as it appears in both arrays.
    
    :param nums1: List[int]
    :param nums2: List[int]
    :return: List[int]
    """"""
    counter1 = Counter(nums1)
    counter2 = Counter(nums2)
    res = []
    for num in counter1:
        if num in counter2:
            res.extend([num] * min(counter1[num], counter2[num]))
    return res",119
18735799479,find_longest_substring,"def find_longest_substring(s):
    max_length = 0
    start = 0
    max_substring = """"
    used_char = {}

    for i in range(len(s)):
        if s[i] in used_char and start <= used_char[s[i]]:
            start = used_char[s[i]] + 1
        else:
            if i - start + 1 > max_length:
                max_length = i - start + 1
                max_substring = s[start:i+1]

        used_char[s[i]] = i

    return max_substring",119
9820242109,maxProduct,"def maxProduct(nums):
    if not nums:
        return 0
    prev_max = nums[0]
    prev_min = nums[0]
    max_product = nums[0]
    for i in range(1, len(nums)):
        cur_max = max(prev_max * nums[i], prev_min * nums[i], nums[i])
        cur_min = min(prev_max * nums[i], prev_min * nums[i], nums[i])
        max_product = max(max_product, cur_max)
        prev_max = cur_max
        prev_min = cur_min
    return max_product",119
698278108,min_reduce_to_zero,"def min_reduce_to_zero(nums, x):
    res = -float('inf')
    target = sum(nums)-x
    if target == 0: return len(nums)
    map = {0:-1}
    currSum = 0
    for i in range(len(nums)):
        n = nums[i]
        currSum += n
        if currSum-target in map:
            res = max(res, i-map[currSum-target])
        map[currSum] = i

    if res != -float('inf'):
        return len(nums)-res
    
    return -1",119
4879518101,filter_primes,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def filter_primes(num_list):
    return [num for num in num_list if is_prime(num)]",119
26281747130,numComponents,"from collections import defaultdict

def numComponents(adj_list, nodes):
    graph = defaultdict(list)
    for i, neighbors in enumerate(adj_list):
        for neighbor in neighbors:
            graph[i].append(neighbor)
            graph[neighbor].append(i)
    
    visited = set()
    def dfs(node):
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                dfs(neighbor)
    
    components = 0
    for node in nodes:
        if node not in visited:
            components += 1
            dfs(node)
    return components",119
28850499928,longest_substring_without_repeating_characters,"def longest_substring_without_repeating_characters(s: str) -> str:
    max_len = 0
    max_sub_str = """"
    str_map = {}
    left = 0

    for right in range(len(s)):
        if s[right] in str_map:
            left = max(str_map[s[right]] + 1, left)

        str_map[s[right]] = right

        if right - left + 1 > max_len:
            max_len = right - left + 1
            max_sub_str = s[left:right+1]

    return max_sub_str",119
40251301065,max_distance,"def max_distance(arrays):
    res = 0
    prevMin = arrays[0][0]
    prevMax = arrays[0][-1]
    for i in range(1, len(arrays)):
        arr = arrays[i]
        curMin = arr[0]
        curMax = arr[-1]
        a = abs(curMin-prevMax)
        b = abs(curMax-prevMin)
        res = max(res, a, b)
        prevMin = min(prevMin, curMin)
        prevMax = max(prevMax, curMax)
    return res",119
14077119609,largest_palindrome,"def largest_palindrome(n):
    max_num = int('9' * n)
    min_num = int('1' + '0' * (n - 1))
    max_palindrome = 0

    for i in range(max_num, min_num - 1, -1):
        for j in range(i, min_num - 1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if str(product) == str(product)[::-1]:
                max_palindrome = product
    return max_palindrome",119
4581657350,generate_password,"import string
import random

def generate_password(length=12):
    if length < 4:
        raise ValueError(""Password length must be at least 4."")
    all_chars = string.ascii_letters + string.digits + string.punctuation
    password = []
    password.append(random.choice(string.ascii_lowercase))
    password.append(random.choice(string.ascii_uppercase))
    password.append(random.choice(string.digits))
    password.append(random.choice(string.punctuation))
    for _ in range(length-4):
        password.append(random.choice(all_chars))
    random.shuffle(password)
    return ''.join(password)",119
73471748425,get_primes,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def get_primes(list1):
    return [i for i in list1 if is_prime(i)]",119
27615963986,divide_without_operator,"def divide_without_operator(dividend: int, divisor: int) -> tuple:
    quotient = 0
    remainder = abs(dividend)
    while remainder >= abs(divisor):
        remainder -= abs(divisor)
        quotient += 1
    if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):
        quotient = -quotient
    if dividend < 0:
        remainder = -remainder
    if divisor < 0:
        divisor = -divisor
    return (quotient, remainder)",119
18590163208,max_length_equal,"def max_length_equal(arr):
    n = len(arr)
    count = 0
    max_len = 0
    hash_map = {}
    for i in range(n):
        if arr[i] == 0:
            count -= 1
        elif arr[i] == 1:
            count += 1
        if count == 0:
            max_len = i + 1
        elif count in hash_map:
            max_len = max(max_len, i - hash_map[count])
        else:
            hash_map[count] = i
    return max_len",119
28229817412,longest_substring_with_k_distinct,"def longest_substring_with_k_distinct(s, k):
    if len(s) < k:
        return len(s)

    charset = {}
    left = 0
    right = 0
    res = 0

    while right < len(s):
        charset[s[right]] = right
        right += 1

        if len(charset) == k + 1:
            deleteIndex = min(charset.values())
            del charset[s[deleteIndex]]
            left = deleteIndex + 1

        res = max(res, right - left)
    return res",119
19808653704,is_valid_bst,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_valid_bst(root: TreeNode) -> bool:
    def validate(node, low=-float('inf'), high=float('inf')):
        if not node:
            return True

        if not (low < node.val < high):
            return False

        return (validate(node.right, node.val, high) and
                validate(node.left, low, node.val))

    return validate(root)",119
3204182015,valid_isbn,"def valid_isbn(isbn):
    if len(isbn) != 10:
        return False
    
    total = 0
    for i in range(9):
        if not isbn[i].isdigit():
            return False
        total += int(isbn[i]) * (i+1)
    
    if isbn[9].isdigit():
        total += int(isbn[9]) * 10
    elif isbn[9] == 'X':
        total += 10
    else:
        return False
    
    return total % 11 == 0",119
2513450078,longest_substring_without_repeating,"def longest_substring_without_repeating(s: str) -> str:
    char_index = {}
    start = 0
    max_length = 0
    max_substring = """"

    for i, char in enumerate(s):
        if char in char_index and char_index[char] >= start:
            start = char_index[char] + 1
        char_index[char] = i
        if i - start + 1 > max_length:
            max_length = i - start + 1
            max_substring = s[start:i+1]

    return max_substring",119
20382940614,max_stock_profit,"def max_stock_profit(prices):
    max_profit = 0
    min_price = float('inf')
    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)
    return max_profit

assert max_stock_profit([7,1,5,3,6,4]) == 5
assert max_stock_profit([7,6,4,3,1]) == 0
assert max_stock_profit([1,2,3,4,5]) == 4",119
20063888472,kth_smallest,"import heapq

def kth_smallest(matrix, k):
    minheap = []
    n = len(matrix)
    for i in range(min(k, n)):
        heapq.heappush(minheap, (matrix[i][0], i, 0))

    cnt = 0
    while cnt < k:
        cnt += 1
        x, i, j = heapq.heappop(minheap)
        if j < n - 1: heapq.heappush(minheap, (matrix[i][j + 1], i, j + 1))
    return x",119
33045777259,longest_consecutive_substring,"def longest_consecutive_substring(s):
    if not s:
        return """"
    max_length = 1
    start = 0
    longest_start = 0
    for i in range(1, len(s)):
        if ord(s[i]) == ord(s[i-1]) + 1:
            current_length = i - start + 1
            if current_length > max_length:
                max_length = current_length
                longest_start = start
        else:
            start = i
    return s[longest_start:longest_start + max_length]",119
16341435104,longest_substring_with_k_distinct,"def longest_substring_with_k_distinct(s, k):
    max_len, start = 0, 0
    char_count = {}
    for end in range(len(s)):
        char_count[s[end]] = char_count.get(s[end], 0) + 1
        while len(char_count) > k:
            char_count[s[start]] -= 1
            if char_count[s[start]] == 0:
                del char_count[s[start]]
            start += 1
        max_len = max(max_len, end - start + 1)
    return max_len",119
11908474476,power_set,"def power_set(nums):
    length, rev = len(nums), []
    def combineRecursive(start, pos, tmp, n):
        if pos == n:
            rev.append(list(tmp))
            return
        for i in range(start, length + 1 - n + pos):
            tmp[pos] = nums[i]
            combineRecursive(i + 1, pos + 1, tmp, n)

    for n in range(len(nums) + 1):
        tmp = [0] * n
        combineRecursive(0, 0, tmp, n)
    return rev",119
73965177400,max_product_of_three,"def max_product_of_three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])

assert max_product_of_three([1, 2, 3, 4]) == 24
assert max_product_of_three([0, -1, 3, 100, -70, -5]) == 35000
assert max_product_of_three([-1, -2, -3, -4]) == -6",118
41813593090,intersect_sorted_lists,"def intersect_sorted_lists(list1, list2):
    result = []
    i, j = 0, 0
    while i < len(list1) and j < len(list2):
        if list1[i] == list2[j]:
            if not result or result[-1] != list1[i]:  # Avoid duplicates
                result.append(list1[i])
            i += 1
            j += 1
        elif list1[i] < list2[j]:
            i += 1
        else:
            j += 1
    return result",118
15906159418,min_operations_to_palindrome,"def min_operations_to_palindrome(s: str) -> int:
    n = len(s)
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    
    for i in range(n):
        for j in range(n):
            dp[i + 1][j + 1] = dp[i][j] + 1 if s[i] == s[n - 1 - j] else max(dp[i][j + 1], dp[i + 1][j])
    
    return n - dp[n][n]",118
29116898393,numDistinct,"def numDistinct(s: str, t: str) -> int:
    m, n = len(s), len(t)
    if n > m:
        return 0
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, m + 1):
        for j in range(min(n, i), 0, -1):
            if s[i - 1] == t[j - 1]:
                dp[j] += dp[j - 1]
    return dp[n]",118
72463412468,max_subarray_with_sum,"def max_subarray_with_sum(arr, k):
    max_len = 0
    sum = 0
    start = 0
    sum_map = {}
    for end in range(len(arr)):
        sum += arr[end]
        if sum == k:
            max_len = max(max_len, end - start + 1)
        if (sum - k) in sum_map:
            max_len = max(max_len, end - sum_map[sum - k])
        if sum not in sum_map:
            sum_map[sum] = end
    return max_len",118
24225190928,set_zeroes,"def set_zeroes(matrix):
    row, col = set(), set()
    n_row, n_col = len(matrix), len(matrix[0])
    for i in range(n_row):
        for j in range(n_col):
            if matrix[i][j] == 0:
                row.add(i)
                col.add(j)

    for r in row:
        for c in range(n_col):
            matrix[r][c] = 0

    for c in col:
        for r in range(n_row):
            matrix[r][c] = 0

    return matrix",118
4210016068,find_common,"def find_common(a, b, c):
    i = j = k = 0
    while i < len(a) and j < len(b) and k < len(c):
        if a[i] == b[j] == c[k]:
            return a[i]
        max_val = max(a[i], b[j], c[k])
        if a[i] < max_val:
            i += 1
        if b[j] < max_val:
            j += 1
        if c[k] < max_val:
            k += 1
    return None",118
29545536881,reverse_vowels,"def reverse_vowels(s):
    vowels = ""aeiouAEIOU""
    string_list = list(s)
    i = 0
    j = len(s) - 1
    while i < j:
        if string_list[i] not in vowels:
            i += 1
        elif string_list[j] not in vowels:
            j -= 1
        else:
            string_list[i], string_list[j] = string_list[j], string_list[i]
            i += 1
            j -= 1
    return ''.join(string_list)",118
3479358510,month_days,"def month_days(year,month):
    if month in [1,3,5,7,8,10,12]:
        return 31
    elif month in [4,6,9,11]:
        return 30
    elif month == 2:
        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
            return 29
        else:
            return 28
    else:
        return ""Invalid month""",118
4527575412,count_pattern_occurrences,"def count_pattern_occurrences(text, pattern):
    """"""
    Counts the number of times a pattern occurs in the given text.

    Args:
    text (str): The text to search in.
    pattern (str): The pattern to search for.

    Returns:
    int: The number of times the pattern occurs in the text.
    """"""
    count = 0
    pattern_length = len(pattern)
    for i in range(len(text) - pattern_length + 1):
        if text[i:i + pattern_length] == pattern:
            count += 1
    return count",118
12256826771,combinationSum3,"def combinationSum3(k: int, n: int):
    res = []

    def backtrack(remain, combo, start):
        if len(combo) == k and remain == 0:
            res.append(list(combo))
            return
        elif len(combo) == k or remain < 0:
            return

        for i in range(start, 9):
            combo.append(i + 1)
            backtrack(remain - (i + 1), combo, i + 1)
            combo.pop()

    backtrack(n, [], 0)
    return res",118
38186483162,max_in_btree,"class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def max_in_btree(root):
    if root is None:
        return float('-inf')
    max_val = root.val
    left_max = max_in_btree(root.left)
    right_max = max_in_btree(root.right)
    if left_max > max_val:
        max_val = left_max
    if right_max > max_val:
        max_val = right_max
    return max_val",118
33000834833,shortest_subarray,"from typing import List

def shortest_subarray(nums: List[int], threshold: int) -> int:
    n = len(nums)
    shortest_length = n + 1
    current_sum = 0
    start_index = 0

    for end_index in range(n):
        current_sum += nums[end_index]

        while current_sum >= threshold:
            shortest_length = min(shortest_length, end_index - start_index + 1)
            current_sum -= nums[start_index]
            start_index += 1

    return shortest_length if shortest_length <= n else 0",118
33122099964,n_Queens,"import pdb
answer = 0


def dfs(n, col, q):
    global answer
    if col == n:
        answer += 1
        return
    for i in range(n):
        q[col] = i
        for j in range(col):
            if q[col] == q[j] or abs(q[col]-q[j]) == col - j:
                break
        else:
            dfs(n, col+1, q)
    return answer


def n_Queens(n):
    return dfs(n, 0, [-1]*n)",118
28361482874,decode_string,"def decode_string(s: str) -> str:
    stack = []
    current_num = 0
    current_string = """"
    for c in s:
        if c.isdigit():
            current_num = current_num * 10 + int(c)
        elif c == ""["":
            stack.append((current_string, current_num))
            current_string, current_num = """", 0
        elif c == ""]"":
            prev_string, num = stack.pop()
            current_string = prev_string + num * current_string
        else:
            current_string += c
    return current_string",118
1233811907,staircase,"def staircase(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    elif n == 3:
        return 4
    dp = [0] * (n+1)
    dp[1] = 1
    dp[2] = 2
    dp[3] = 4
    for i in range(4, n+1):
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
    return dp[n]",118
15395246580,longest_string_chain,"import queue
import collections

def longest_string_chain(words):
    words.sort(key=lambda x: len(x))
    chain_lengths = {}
    max_chain = 0

    for word in words:
        current_max = 0
        for i in range(len(word)):
            predecessor = word[:i] + word[i+1:]
            if predecessor in chain_lengths:
                current_max = max(current_max, chain_lengths[predecessor])
        chain_lengths[word] = current_max + 1
        max_chain = max(max_chain, chain_lengths[word])

    return max_chain",118
11244572963,intersection_sorted_arrays,"def intersection_sorted_arrays(arr1, arr2):
    i = 0
    j = 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            i += 1
        elif arr1[i] > arr2[j]:
            j += 1
        else:
            if len(result) == 0 or result[-1] != arr1[i]:
                result.append(arr1[i])
            i += 1
            j += 1
    return result",118
7920988956,find_largest_palindrome,"def find_largest_palindrome(n):
    max_num = 10 ** n - 1
    min_num = 10 ** (n - 1)

    max_palindrome = 0
    for i in range(max_num, min_num - 1, -1):
        for j in range(i, min_num - 1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if str(product) == str(product)[::-1]:
                max_palindrome = product
    return max_palindrome",118
26890087599,get_month_days,"def get_month_days(month_name):
    month_days = {
        ""January"": 31,
        ""February"": 28,
        ""March"": 31,
        ""April"": 30,
        ""May"": 31,
        ""June"": 30,
        ""July"": 31,
        ""August"": 31,
        ""September"": 30,
        ""October"": 31,
        ""November"": 30,
        ""December"": 31
    }
    return month_days.get(month_name)",118
22599718798,longest_unique_substring,"def longest_unique_substring(s):
    start = 0
    max_length = 0
    max_substring = """"
    used_char = {}

    for i in range(len(s)):
        if s[i] in used_char and start <= used_char[s[i]]:
            start = used_char[s[i]] + 1
        else:
            if i - start + 1 > max_length:
                max_length = i - start + 1
                max_substring = s[start:i+1]

        used_char[s[i]] = i

    return max_substring",118
31457315289,get_primes,"def get_primes(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    return [number for number in numbers if is_prime(number)]",118
14851010934,first_occurrence,"def first_occurrence(arr, target):
    # TC: O(log(n))
    # SC: O(1)

    low = 0
    high = len(arr) - 1

    res = -1

    while (low <= high):
        mid = low + (high - low) // 2
        if arr[mid] == target:
            res = mid
            high = mid - 1
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return res",118
10707376690,second_smallest,"def second_smallest(numbers):
    unique_numbers = set(numbers)
    if len(unique_numbers) < 2:
        return None
    return sorted(unique_numbers)[1]

# Test cases
print(second_smallest([1, 2, 3, 4, 5]))  # Should return 2
print(second_smallest([5, 1, 4, 3, 2]))  # Should return 2
print(second_smallest([]))               # Should return None
print(second_smallest([1, 1]))           # Should return None",118
42061423802,count_connected_components,"from collections import defaultdict

def dfs(node, visited, graph):
    visited[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs(neighbor, visited, graph)

def count_connected_components(edges):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    visited = defaultdict(bool)
    count = 0
    for node in graph:
        if not visited[node]:
            dfs(node, visited, graph)
            count += 1
    return count",118
1288156291,find_longest_common_prefix,"def find_longest_common_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs, key=len)
    for i, char in enumerate(shortest):
        for other in strs:
            if other[i] != char:
                return shortest[:i]
    return shortest

# Test cases
print(find_longest_common_prefix([""flower"",""flow"",""flight""])) # ""fl""
print(find_longest_common_prefix([""dog"",""racecar"",""car""])) # """"
print(find_longest_common_prefix([""interspecies"",""interstellar"",""interstate""])) # ""inters""",118
28095413107,max_vowels,"def max_vowels(s: str, k: int) -> int:
    vowels = ""aeiou""
    max_count = 0
    count = 0
    for i in range(k):
        if s[i] in vowels:
            count += 1
    max_count = count
    for i in range(len(s) - k):
        if s[i] in vowels:
            count -= 1
        if s[i + k] in vowels:
            count += 1
        max_count = max(max_count, count)
    return max_count",118
33624783039,integer_break,"class Solution:
    def integer_break(self, n: int) -> int:
        dp = [0] * (n+1)
        dp[2] = 1
        if n >= 3:
            dp[3] = 2
        for i in range(4, n+1):
            dp[i] = max([j * max(dp[i-j], i-j) for j in range(2, i//2 + 1)])
        return dp[-1]

s = Solution()
def integer_break(n):
    return s.integer_break(n)",118
10294423727,is_anagram,"def is_anagram(str1, str2):
    # Remove whitespaces and convert strings to lowercase
    str1 = str1.replace("" "", """").lower()
    str2 = str2.replace("" "", """").lower()
    
    # Check if the sorted characters of both strings are equal
    return sorted(str1) == sorted(str2)

# Test the function with provided test cases
assert is_anagram(""listen"", ""silent"") == True
assert is_anagram(""triangle"", ""integral"") == True
assert is_anagram(""hello"", ""world"") == False",117
31743826660,is_isomorphic,"import collections
def is_isomorphic(s,t):
    if len(s) != len(t):
        return False
    else:
        flag = True
        dic = collections.OrderedDict()
        for j in range(len(s)):
            if t[j] not in dic.keys() and s[j] not in dic.values():
                dic[t[j]] = s[j]
            else:
                if dic.get(t[j]) == s[j]:
                    continue
                else :
                    flag = False
                    break

        if flag:
            return True
        else:
            return False",117
28932026236,largest_palindrome_product,"def largest_palindrome_product(n):
    max_num = 10 ** n - 1
    min_num = 10 ** (n - 1)
    max_palindrome = 0
    for i in range(max_num, min_num - 1, -1):
        for j in range(i, min_num - 1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if str(product) == str(product)[::-1]:
                max_palindrome = product
    return max_palindrome",117
440987911,find_primes,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def find_primes(numbers):
    return [num for num in numbers if is_prime(num)]",117
10077660288,longest_turbulent_subarray,"def longest_turbulent_subarray(arr):
    n = len(arr)
    up, down = 1, 1
    res = 1
    for i in range(1, n):
        if arr[i] > arr[i-1]:
            up = down + 1
            down = 1
        elif arr[i] < arr[i-1]:
            down = up + 1
            up = 1
        else:
            up = down = 1
        res = max(res, max(up, down))
    return res",117
60896775,is_palindrome_permutation,"def is_palindrome_permutation(str1):
    str1 = str1.replace("" "","""").lower()
    d = dict()
    for char in str1:
        if char in d:
            d[char] += 1
        else:
            d[char] = 1
    odd_count = 0
    for k,v in d.items():
        if v%2 != 0 and odd_count == 0:
            odd_count += 1
        elif v%2 != 0 and odd_count != 0:
            return False
    return True",117
671560617,findKthLargest,"import heapq

def findKthLargest(nums, k):
    """"""
    Finds the kth largest element in the given list of numbers using a min-heap.
    
    Args:
    nums: List of integers.
    k: The kth position to find the largest element for.
    
    Returns:
    The kth largest element in the list.
    """"""
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)
    return heapq.heappop(heap)",117
43627718249,reverse_vowels,"def reverse_vowels(s):
    vowels = 'aeiouAEIOU'
    s_list = list(s)
    left, right = 0, len(s) - 1
    while left < right:
        if s_list[left] not in vowels:
            left += 1
        elif s_list[right] not in vowels:
            right -= 1
        else:
            s_list[left], s_list[right] = s_list[right], s_list[left]
            left += 1
            right -= 1
    return ''.join(s_list)",117
1456726881,is_bst,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_bst(root):
    def dfs(node, min_val, max_val):
        if not node:
            return True
        if not (min_val < node.val < max_val):
            return False
        return dfs(node.left, min_val, node.val) and dfs(node.right, node.val, max_val)

    return dfs(root, float('-inf'), float('inf'))",117
36472285910,find_Max_Consecutive_Ones,"def find_Max_Consecutive_Ones(nums):
    max_count = 0
    zero_flag = False
    count = 0
    zero_index = -1
    for i in range(len(nums)):
        if nums[i] == 1:
            count += 1
        else:
            if zero_flag == False:
                zero_index = i
                zero_flag = True
                count += 1
            else:
                count = i - zero_index
                zero_index = i
        max_count = max(max_count, count)
    return max_count",117
38901127701,prime_status,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def prime_status(numbers):
    return [(num, is_prime(num)) for num in numbers]",117
24278079402,missing_positive,"def missing_positive(arr):
    arr = [i for i in arr if i > 0]
    arr_length = len(arr)
    for i in range(arr_length):
        while 1 <= abs(arr[i]) <= arr_length and arr[arr[i] - 1] != arr[i]:
            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]

    for i in range(arr_length):
        if arr[i] != i + 1:
            return i + 1

    return arr_length + 1",117
6962781166,longest_subarray_with_sum_zero,"def longest_subarray_with_sum_zero(arr):
    sum_map = {}
    sum = 0
    max_len = 0
    for i in range(len(arr)):
        sum += arr[i]
        if arr[i] is 0 and max_len == 0:
            max_len = 1
        if sum is 0:
            max_len = i + 1
        if sum in sum_map:
            max_len = max(max_len, i - sum_map[sum])
        else:
            sum_map[sum] = i
    return max_len",117
27983082928,maxlengthofSubstring,"def maxlengthofSubstring(s):
    max_len = 0
    dic = {}
    flag_len = 0
    start = 0
    if s is None or len(s) == 0:
        return 0
    for i in range(len(s)):
        if (s[i] in dic and dic[s[i]] >= start):
            start = dic[s[i]] + 1
        flag_len = i - start + 1
        dic[s[i]] = i
        max_len = max(max_len, flag_len)
    return max_len",117
18821737169,longest_balanced_subarray,"def longest_balanced_subarray(arr):
    balance = 0
    max_length = 0
    balance_dict = {0: -1}
    
    for i, num in enumerate(arr):
        if num > 0:
            balance += 1
        elif num < 0:
            balance -= 1
        
        if balance not in balance_dict:
            balance_dict[balance] = i
        else:
            current_length = i - balance_dict[balance]
            if current_length > max_length:
                max_length = current_length
                
    return max_length",117
14921420172,find132pattern,"def find132pattern(nums):
    stack = []  # pair [num, minLeft], mono decreasing
    curMin = nums[0]

    # skip the first value since it cant be the k value
    for n in nums[1:]:
        while stack and n >= stack[-1][0]:
            stack.pop()
        if stack and n < stack[-1][0] and n > stack[-1][1]:
            return True

        stack.append([n, curMin])
        curMin = min(curMin, n)
    return False",117
74373273810,prime_sum,"def prime_sum(n):
    if n < 2:
        return 0

    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1

    sum_primes = 0
    for p in range(2, n):
        if prime[p]:
            sum_primes += p
    return sum_primes",117
21150924744,is_balanced,"class BinaryTree:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

def is_balanced(root):
    def check(root):
        if root is None:
            return 0
        left = check(root.left)
        right = check(root.right)
        if left == -1 or right == -1 or abs(left - right) > 1:
            return -1
        return max(left, right) + 1
    return check(root) != -1",117
40712593534,largest_palindrome_product,"def largest_palindrome_product(n):
    max_num = 10 ** n - 1
    min_num = 10 ** (n - 1)
    max_palindrome = 0

    for i in range(max_num, min_num - 1, -1):
        for j in range(i, min_num - 1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if str(product) == str(product)[::-1]:
                max_palindrome = product
    return max_palindrome",117
21707134153,maxSubarraySumZero,"def maxSubarraySumZero(nums):
    prefix_sum = {0: -1}
    count = 0
    current_sum = 0
    result = 0
    for i, num in enumerate(nums):
        current_sum += num
        if current_sum not in prefix_sum:
            prefix_sum[current_sum] = i
        else:
            result = max(result, i - prefix_sum[current_sum])
            count += 1
            current_sum = 0
            prefix_sum = {0: -1}
    return count if result else 0",117
12173826,word_segment,"def word_segment(s, wordDict):
    len_dict = len(wordDict)
    len_s = len(s)
    dp = [False] * (len_s + 1)
    dp[0] = True
    for i in range(1, len_s + 1):
        for j in range(len_dict):
            len_j = len(wordDict[j])
            if dp[i - len_j] and i >= len_j and s[i - len_j:i] in wordDict:
                dp[i] = True
                break
    return dp[len_s]",117
13539272225,is_valid_isbn,"def is_valid_isbn(isbn):
    if len(isbn) != 10:
        return False
    total = 0
    for i in range(9):
        if not isbn[i].isdigit():
            return False
        total += int(isbn[i]) * (10 - i)
    last_digit = isbn[-1]
    if last_digit.isdigit():
        total += int(last_digit)
    elif last_digit == 'X':
        total += 10
    else:
        return False
    return total % 11 == 0",117
13282595344,find_longest_common_substring,"def find_longest_common_substring(strings):
    if not strings:
        return """"

    shortest_string = min(strings, key=len)
    longest_common_substring = """"

    for i in range(len(shortest_string)):
        for j in range(i + 1, len(shortest_string) + 1):
            candidate_substring = shortest_string[i:j]
            if all(candidate_substring in string for string in strings):
                if len(candidate_substring) > len(longest_common_substring):
                    longest_common_substring = candidate_substring

    return longest_common_substring",117
28367154551,prime_identifier,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def prime_identifier(numbers):
    return [(num, is_prime(num)) for num in numbers]",117
1186442324,are_anagrams,"def are_anagrams(str1, str2):
    if len(str1) != len(str2):
        return False

    char_count = {}

    for char in str1:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

    for char in str2:
        if char in char_count:
            char_count[char] -= 1
        else:
            return False

    for count in char_count.values():
        if count != 0:
            return False

    return True",117
20855556390,catalan_number,"def catalan_number(n):
    if n == 0 or n == 1:
        return 1
    catalan = 0
    for i in range(n):
        catalan += catalan_number(i) * catalan_number(n-i-1)
    return catalan

# Alternatively, using direct calculation:
def catalan_number_direct(n):
    result = 1
    for i in range(2, n + 1):
        result *= (n + i)
        result /= i
    return int(result / (n + 1))",117
12854214598,largest_palindrome,"def largest_palindrome(n: int) -> int:
    max_num = 10**n - 1
    min_num = 10**(n-1)
    max_palindrome = 0
    for i in range(max_num, min_num-1, -1):
        for j in range(i, min_num-1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if str(product) == str(product)[::-1]:
                max_palindrome = product
    return max_palindrome",117
11368745913,minimumBuckets,"def minimumBuckets(street: str) -> int:
    yes, no, lh = float('inf'), 0, float('inf')
    for h in street:
        if h == 'H':
            yes, no, lh = float('inf'), yes, no
        else:
            yes, no, lh = min(lh, no, yes) + 1, min(yes, no), float('inf')
        
    ans = min(yes, no)
    if ans < float('inf'): return ans
    else: return -1",117
6258425247,longest_substring,"def longest_substring(s):
    max_len = 0
    max_substring = """"
    start = 0
    used_char = {}

    for i in range(len(s)):
        if s[i] in used_char and start <= used_char[s[i]]:
            start = used_char[s[i]] + 1
        else:
            if i - start + 1 > max_len:
                max_len = i - start + 1
                max_substring = s[start:i+1]

        used_char[s[i]] = i

    return max_substring",117
37759356309,filter_prime_numbers,"def is_prime(num):
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True

def filter_prime_numbers(numbers):
    return [num for num in numbers if is_prime(num)]",117
18553272632,intersect_sorted_lists,"def intersect_sorted_lists(list1, list2):
    i, j = 0, 0
    result = []
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            i += 1
        elif list1[i] > list2[j]:
            j += 1
        else:
            if len(result) == 0 or result[-1] != list1[i]:
                result.append(list1[i])
            i += 1
            j += 1
    return result",117
34376197636,filter_prime_numbers,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def filter_prime_numbers(numbers):
    return [num for num in numbers if is_prime(num)]",117
40712999724,remove_element,"def remove_element(lst, element):
    return [x for x in lst if x != element]

def test_remove_element():
    assert remove_element([1, 2, 3, 2, 4], 2) == [1, 3, 4]
    assert remove_element(['apple', 'banana', 'cherry', 'banana'], 'banana') == ['apple', 'cherry']
    assert remove_element([True, False, True, True], True) == [False]
    print(""All test cases passed."")
    
test_remove_element()",117
7054829036,find_primes,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True


def find_primes(numbers):
    return [n for n in numbers if is_prime(n)]",117
38564801427,caesar_cipher,"def caesar_cipher(message, shift):
    result = """"
    for char in message:
        char_code = ord(char)
        if 65 <= char_code <= 90: # uppercase letters
            result += chr((char_code - 65 + shift) % 26 + 65)
        elif 97 <= char_code <= 122: # lowercase letters
            result += chr((char_code - 97 + shift) % 26 + 97)
        else:
            result += char
    return result",117
12259456055,get_prime_numbers,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while(i * i <= n):
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def get_prime_numbers(numbers):
    return [number for number in numbers if is_prime(number)]",117
3096024661,maxLen,"def maxLen(arr):
    hash_map = {}
    cur_sum = 0
    max_len = 0
    for i in range(len(arr)):
        cur_sum += arr[i]
        if arr[i] is 0 and max_len == 0:
            max_len = 1
        if cur_sum == 0:
            max_len = i + 1
        if cur_sum in hash_map:
            max_len = max(max_len, i - hash_map[cur_sum])
        else:
            hash_map[cur_sum] = i
    return max_len",117
14866282067,can_construct_word,"def can_construct_word(tiles, word):
    def dfs(tiles, word):
        if not word:
            return True
        if not tiles:
            return False
        seen = set()
        for i in range(len(tiles)):
            if tiles[i] not in seen:
                if tiles[i] == word[0]:
                    seen.add(tiles[i])
                    if dfs(tiles[:i] + tiles[i+1:], word[1:]):
                        return True
        return False

    tiles = list(tiles)
    return dfs(tiles, word)",117
34535144779,sum_of_primes,"def sum_of_primes(n):
    if n < 2:
        return 0
    primes = [True] * (n+1)
    primes[0] = primes[1] = False
    for p in range(2, int(n**0.5)+1):
        if primes[p] == True:
            for i in range(p*p, n+1, p):
                primes[i] = False
    sum_primes = sum(p for p in range(2, n+1) if primes[p])
    return sum_primes",117
27239444777,largest_palindrome_product,"def largest_palindrome_product(n):
    if n == 1:
        return 9
    start = 10 ** (n-1)
    end = 10 ** n - 1
    max_palindrome = 0
    for i in range(end, start-1, -1):
        for j in range(i, start-1, -1):
            product = i * j
            if str(product) == str(product)[::-1] and product > max_palindrome:
                max_palindrome = product
    return max_palindrome",117
34802806762,pattern_count,"def pattern_count(text, pattern):
    """"""
    Count occurrences of a pattern in a text, including overlapping patterns.

    Args:
    text (str): The main string.
    pattern (str): The pattern to search for.

    Returns:
    int: The number of times the pattern occurs in the text, including overlaps.
    """"""
    count = 0
    pattern_length = len(pattern)
    for i in range(len(text) - pattern_length + 1):
        if text[i:i + pattern_length] == pattern:
            count += 1
    return count",117
10785200775,max_product_of_three,"def max_product_of_three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])

assert max_product_of_three([1, 10, 2, 6, 5, 3]) == 300
assert max_product_of_three([-10, -10, 5, 2]) == 500
assert max_product_of_three([-1, -2, -3, -4]) == -6",117
15466042186,prime_sum,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def prime_sum(lst):
    return sum([i for i in lst if is_prime(i)])",117
39716975234,is_possible_divide,"from collections import defaultdict

def is_possible_divide(nums, k):
    if len(nums) % k != 0:
        return False
    counts = defaultdict(int)
    for n in nums:
        counts[n] += 1
    sorted_nums = sorted(counts.keys())
    for num in sorted_nums:
        if counts[num] > 0:
            min_count = counts[num]
            for i in range(k):
                if counts[num + i] < min_count:
                    return False
                counts[num + i] -= min_count
    return True",116
11964319677,nearest_valid_point,"from collections import defaultdict

def nearest_valid_point(x: int, y: int, points: list) -> int:
    dictionary = defaultdict(list)
    
    for index, point in enumerate(points):
        if x == point[0] or y == point[1]:
            distance = abs(point[0] - x) + abs(point[1] - y)
            dictionary[distance].append(index)
    
    if (len(dictionary.keys()) == 0):
        return -1
    
    min_distance = min(dictionary.keys())
    return dictionary[min_distance][0]",116
21002017896,min_candy_distribution,"def min_candy_distribution(ratings):
    n = len(ratings)
    candies = [1] * n
    for i in range(1, n):
        if ratings[i] > ratings[i-1]:
            candies[i] = candies[i-1] + 1
    for i in range(n-2, -1, -1):
        if ratings[i] > ratings[i+1] and candies[i] <= candies[i+1]:
            candies[i] = candies[i+1] + 1
    return sum(candies)",116
4367464089,check_matrix,"def check_matrix(A):
    flag = True
    N = len(A)
    M = len(A[0])
    n = min(N,M)
    
    for i in range(n):
        row_sum, col_sum = 0,0
        for row_index in range(N):
            row_sum += A[row_index][i]
        for col_index in range(M):
            col_sum += A[i][col_index]
        if row_sum != col_sum:
            flag = False
    if flag:
        return 1
    else:
        return 0",116
31483662613,rename_repeated_strings,"from collections import defaultdict

def rename_repeated_strings(names:list):
    res = []
    d = defaultdict(int)
    for name in names:
        if name not in d:
            d[name] = 0
            res.append(name)
        else:
            d[name] += 1
            temp = name + ""("" + str(d[name]) + "")""
            while temp in d:
                d[name] += 1
                temp = name + ""("" + str(d[name]) + "")""
            d[temp] = 0
            res.append(temp)
    return res",116
17435674950,number_of_unique_paths,"def number_of_unique_paths(m, n):
    # Initialize a 2D array to store the number of unique paths to each cell
    dp = [[1]*n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            # The number of paths to a cell is the sum of the paths to the cell directly above and to the left
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",116
29781136143,catalan_number,"def catalan_number(n):
    if n == 0 or n == 1:
        return 1

    catalan = [0 for i in range(n+1)]
    catalan[0] = 1
    catalan[1] = 1

    for i in range(2, n+1):
        catalan[i] = 0
        for j in range(i):
            catalan[i] = catalan[i] + catalan[j] * catalan[i - j - 1]

    return catalan[n]",116
13001486983,max_element_one_swap,"def max_element_one_swap(arr):
    max_num = int("""".join(map(str, sorted(arr, reverse=True))))
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
            current_num = int("""".join(map(str, arr)))
            if current_num == max_num:
                return current_num
            temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
    return max_num",116
7873464456,are_anagrams,"def are_anagrams(str1, str2):
    if len(str1) != len(str2):
        return False
    d = dict()
    for char in str1:
        if d.get(char, None) is None:
            d[char] = 1
        else:
            d[char] += 1
    for char in str2:
        try:
            d[char] -= 1
        except KeyError:
            return False
    for k, v in d.items():
        if v != 0:
            return False
    return True",116
31140918045,length_longest_substring,"def length_longest_substring(s):
    if len(s) == 0: return 0
    left = 0
    max_len = 0
    cur_len = 0
    new_str = set()
    for i in range(len(s)):
        cur_len += 1
        while s[i] in new_str:
            new_str.remove(s[left])
            left += 1
            cur_len -= 1
        if cur_len > max_len: max_len = cur_len
        new_str.add(s[i])
    return max_len",116
36749122913,word_break,"from collections import deque

def word_break(s, wordDict):
    queue = deque([s])
    visited = set()
    res = []
    
    while queue:
        rem = queue.popleft()
        
        if rem in visited:
            continue
        visited.add(rem)
        
        for word in wordDict:
            if rem.startswith(word):
                if len(rem) == len(word):
                    res.append(rem)
                else:
                    queue.append(rem[len(word):])
                
    return ["" "".join(x.split()[::-1]) for x in res]",116
4100721440,longest_substring_with_k_replacements,"from collections import defaultdict

def longest_substring_with_k_replacements(s, k):
    char_count = defaultdict(int)
    max_count = start = result = 0
    
    for end in range(len(s)):
        char_count[s[end]] += 1
        max_count = max(max_count, char_count[s[end]])
        
        if (end - start + 1) - max_count > k:
            char_count[s[start]] -= 1
            start += 1
            
        result = max(result, end - start + 1)
        
    return result",116
35113014372,longest_substring,"def longest_substring(s: str) -> int:
    max_len = 0
    i = 0
    j = 0
    smap = {}
    while j < len(s):
        if s[j] in smap:
            i = smap[s[j]] if smap[s[j]] > i else i
        max_len = j - i + 1 if j - i + 1 > max_len else max_len
        smap[s[j]] = j + 1
        j += 1
    return max_len",116
9252084211,find_duplicate,"from collections import defaultdict

def find_duplicate(paths):
    hash_map = defaultdict(list)
    for path in paths:
        path_list = path.split("" "")
        n = len(path_list)
        for i in range(1,n):
            idx = path_list[i].index(""("")
            hash_map[path_list[i][idx+1:-1]].append(f""{path_list[0]}/{path_list[i][:idx]}"")
    ans = []
    for key, val in hash_map.items():
        if len(val) >1:
            ans.append(val)
    return ans",116
27402275342,maxConsecutiveOnes,"def maxConsecutiveOnes(nums):
    left = 0
    right = 0
    max_ones = 0
    zero_count = 0
    
    while right < len(nums):
        if nums[right] == 0:
            zero_count += 1
        
        while zero_count > 1:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        
        max_ones = max(max_ones, right - left + 1)
        right += 1
    
    return max_ones",116
14509803289,is_valid_isbn,"def is_valid_isbn(isbn):
    if len(isbn) != 10:
        return False
    sum = 0
    for i in range(9):
        if isbn[i].isdigit():
            sum += (10-i) * int(isbn[i])
        else:
            return False
    if isbn[9].isdigit():
        sum += int(isbn[9])
    elif isbn[9] == 'X':
        sum += 10
    else:
        return False
    return sum % 11 == 0",116
22568335466,reverse_string_stack,"class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return len(self.items) == 0

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        else:
            return None

def reverse_string_stack(input_string):
    stack = Stack()
    for char in input_string:
        stack.push(char)
    reversed_string = """"
    while not stack.is_empty():
        reversed_string += stack.pop()
    return reversed_string",116
19548268338,caesar_cipher,"def caesar_cipher(text, shift):
    result = """"
    for char in text:
        if char.isalpha():
            shift_amount = shift % 26
            if char.islower():
                new_char = chr(((ord(char) - ord('a') + shift_amount) % 26) + ord('a'))
            else:
                new_char = chr(((ord(char) - ord('A') + shift_amount) % 26) + ord('A'))
            result += new_char
        else:
            result += char
    return result",116
33782796876,missing_positive,"def missing_positive(arr):
    arr = list(filter(lambda x: x > 0, arr))
    arr_length = len(arr)
    for i in range(arr_length):
        if abs(arr[i]) - 1 < arr_length and arr[abs(arr[i]) - 1] > 0:
            arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1]
    for i in range(arr_length):
        if arr[i] > 0:
            return i + 1
    return arr_length + 1",116
41029575518,letter_case_permutation,"from typing import List

def letter_case_permutation(s: str) -> List[str]:
    res = []

    def dfs(remain, path):
        if len(path) == len(s):
            res.append(''.join(path))
            return
        if remain[0].isalpha():
            dfs(remain[1:], path + [remain[0].lower()])
            dfs(remain[1:], path + [remain[0].upper()])
        else:
            dfs(remain[1:], path + [remain[0]])

    dfs(s, [])
    return res",116
9753525575,check_password,"import re 

def check_password(password):
    if len(password) < 8 or len(password) > 20:
        return 'Invalid Password'
    elif not re.search(""[a-z]"", password):
        return 'Invalid Password'
    elif not re.search(""[A-Z]"", password):
        return 'Invalid Password'
    elif not re.search(""[0-9]"", password):
        return 'Invalid Password'
    elif not re.search(""[!@#$%^&*()-_=+]"", password):
        return 'Invalid Password'
    else:
        return 'Valid Password'",116
27806024347,num_decodings,"def num_decodings(s: str) -> int:
    a = 0
    b = 1
    c = 0
    for i in range(1, len(s) + 1):
        c = 0
        if s[i - 1] != '0':
            c += b
        if i > 1 and s[i - 2] != '0' and int(s[i - 2: i]) <= 26:
            c += a
        a, b = b, c
    return c",116
21673210700,combination_sum,"from typing import List

def combination_sum(candidates: List[int], target: int) -> List[List[int]]:
    def dfs(candidates, target, idx, record):
        if target == 0:
            result.append(record.copy())
            return
        for i in range(idx, len(candidates)):
            if candidates[i] > target:
                continue
            record.append(candidates[i])
            dfs(candidates, target - candidates[i], i, record)
            record.pop()
    result = []
    dfs(candidates, target, 0, [])
    return result",116
29583673415,solution,"def solution(n, m):
    answer = []
    max1 = max(n,m)
    min1 = min(n,m)
    big=0
    small=0
    for i in range(1,min1+1):
        if max1%i==0 and min1%i==0:
            big=i
    answer.append(big)
    
    while max1>0:
        if max1%m==0 and max1%n==0:
            small=max1
            break
        max1+=1
    answer.append(small)
    return answer",116
9456292352,longest_balanced_parentheses,"def longest_balanced_parentheses(s: str) -> str:
    max_len = 0
    start = 0
    stack = [-1]
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                if i - stack[-1] > max_len:
                    max_len = i - stack[-1]
                    start = stack[-1] + 1
    return s[start:start + max_len]",115
38233389585,base_converter,"def base_converter(num, base):
    """"""
    Convert a number from base 10 to a given base and return it as a string.

    :param num: int, the number in base 10 to be converted.
    :param base: int, the base to convert the number to.
    :return: str, the number in the given base.
    """"""
    result = ''
    while num > 0:
        result = str(num % base) + result
        num = num // base
    return result if result else '0'",115
286227165,longest_substring_with_k_unique,"from collections import defaultdict

def longest_substring_with_k_unique(s, k):
    nums = defaultdict(int)
    max_length = left = right = 0

    n = len(s)
    while right < n:
        nums[s[right]] += 1
        right += 1
        while len(nums) > k:
            nums[s[left]] -= 1
            if nums[s[left]] == 0:
                del nums[s[left]]
            left += 1
        max_length = max(max_length, right - left)
    return max_length",115
36333117285,func,"def func(s):
    start = 0
    max_length = 0
    max_substring = """"
    used_char = {}

    for i in range(len(s)):
        if s[i] in used_char and start <= used_char[s[i]]:
            start = used_char[s[i]] + 1
        else:
            if i - start + 1 > max_length:
                max_length = i - start + 1
                max_substring = s[start:i+1]

        used_char[s[i]] = i

    return max_substring",115
38061912682,count_trees,"from collections import defaultdict

def dfs(node, visited, graph):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(neighbor, visited, graph)

def count_trees(edges):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    visited = set()
    count = 0
    for node in graph:
        if node not in visited:
            dfs(node, visited, graph)
            count += 1
    return count",115
12493327298,max_nonadjacent_sum,"def max_nonadjacent_sum(nums):
    if not nums:
        return 0
    elif len(nums) <= 2:
        return max(0, max(nums))
    
    dp = [0] * len(nums)
    dp[0] = max(0, nums[0])
    dp[1] = max(dp[0], nums[1])
    
    for i in range(2, len(nums)):
        dp[i] = max(dp[i-1], nums[i] + dp[i-2])
    
    return dp[-1]",115
16111090978,is_isomorphic,"def is_isomorphic(s,t):
    if len(s) != len(t):
        return False
    hash_s = {}
    hash_t = {}
    for i in range(len(s)):
        if s[i] in hash_s:
            if hash_s[s[i]] != t[i]:
                return False
        else:
            hash_s[s[i]] = t[i]
        if t[i] in hash_t:
            if hash_t[t[i]] != s[i]:
                return False
        else:
            hash_t[t[i]] = s[i]
    return True",115
6043704195,is_strobogrammatic,"def is_strobogrammatic(num: str) -> bool:
    strobogrammatic_dict = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}
    left, right = 0, len(num) - 1
    while left <= right:
        if num[left] not in strobogrammatic_dict or strobogrammatic_dict[num[left]] != num[right]:
            return False
        left += 1
        right -= 1
    return True",115
33692690284,sum_of_two_cubes,"def sum_of_two_cubes(n):
    cubes = [i**3 for i in range(1, int(n**(1/3)) + 2)]
    for i in range(len(cubes)):
        for j in range(i, len(cubes)):
            for k in range(len(cubes)):
                for l in range(k, len(cubes)):
                    if cubes[i] + cubes[j] == n and cubes[k] + cubes[l] == n and sorted([i, j]) != sorted([k, l]):
                        return True
    return False",115
35398686847,is_happy,"def is_happy(n):
    cycle_members = {4, 16, 37, 58, 89, 145, 42, 20}

    def get_next(number):
        total_sum = 0
        while number > 0:
            number, digit = divmod(number, 10)
            total_sum += digit ** 2
        return total_sum

    while n != 1 and n not in cycle_members:
        n = get_next(n)

    return n == 1",115
73953973289,removeKDigits,"def removeKDigits(num, k):
    if not num or k >= len(num):
        return ""0""
    
    stack = []
    removed = 0
    for digit in num:
        while stack and digit < stack[-1] and removed < k:
            stack.pop()
            removed += 1
        stack.append(digit)
    
    # Remove remaining digits if k > removed
    while removed < k and stack:
        stack.pop()
        removed += 1
    
    return str(int(''.join(stack))) if stack else ""0""",115
4951447596,catalan,"def catalan(n): 
    if n <=1 : 
        return 1
    catalan = [0 for i in range(n + 1)] 
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n + 1): 
        catalan[i] = 0
        for j in range(i): 
            catalan[i] = catalan[i] + catalan[j] * catalan[i-j-1] 
    return catalan[n]",115
72916128024,find_most_frequent_word,"from collections import Counter
import re

def find_most_frequent_word(s: str) -> str:
    words = re.findall(r'\b\w+\b', s)
    word_counts = Counter(words)
    most_common_word = word_counts.most_common(1)[0][0]
    return most_common_word

# Test the function with provided test cases
print(find_most_frequent_word(""hello world hello python hello""))
print(find_most_frequent_word(""python is fun and python is powerful""))
print(find_most_frequent_word(""hello hello hello world""))",115
33351904815,shortestSubarray,"from collections import deque

def shortestSubarray(A, K):
    q = deque([(0, -1)])
    res, cur = float('inf'), 0
    for i, a in enumerate(A):
        cur += a
        while q and cur - q[0][0] >= K:
            res = min(res, i - q.popleft()[1])
        while q and cur <= q[-1][0]:
            q.pop()
        q.append((cur, i))
    return res if res < float('inf') else -1",115
5652401638,min_city_area,"def min_city_area(houses):
    x_coords = [x for x, y in houses]
    y_coords = [y for x, y in houses]
    xLargest = max(x_coords)
    xSmall = min(x_coords)
    yLargest = max(y_coords)
    ySmall = min(y_coords)

    xLength = xLargest - xSmall
    yLength = yLargest - ySmall

    if xLength > yLength:
        return xLength ** 2
    else:
        return yLength ** 2",115
72176723828,count_connected_components,"from collections import deque

def count_connected_components(graph):
    visited = set()
    count = 0
    
    for node in graph:
        if node not in visited:
            count += 1
            bfs(graph, node, visited)
    
    return count

def bfs(graph, node, visited):
    queue = deque([node])
    visited.add(node)
    
    while queue:
        current_node = queue.popleft()
        
        for neighbor in graph[current_node]:
            if neighbor not in visited:
                queue.append(neighbor)
                visited.add(neighbor)",115
26952705538,kdpiaa,"def kdpiaa(lis, k):
    result = 0
    flag = []
    if k == 0:
        for i in lis:
            if i not in flag:
                flag.append(i)
                if lis.count(i) >= 2:
                    result += 1
        return result
    elif k < 0:
        return 0
    else:
        temp = list(set(lis))
        temp.sort()
        for i in temp:
            if i + k in temp:
                result += 1
        return result",115
13789588072,isPermutation,"def isPermutation(str1, str2):
    if len(str1) != len(str2):
        return False
    freq_map1, freq_map2 = [0]*256, [0]*256
    for i in range(len(str1)):
        freq_map1[ord(str1[i])] += 1
        freq_map2[ord(str2[i])] += 1
    for i in range(256):
        if freq_map1[i] != freq_map2[i]:
            return False
    return True",115
15633576658,largest_palindrome_product,"def largest_palindrome_product(n):
    max_num = 10**n - 1
    min_num = 10**(n-1)
    max_palindrome = 0

    for i in range(max_num, min_num - 1, -1):
        for j in range(i, min_num - 1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if str(product) == str(product)[::-1]:
                max_palindrome = product

    return max_palindrome",115
1790474055,largest_subarray,"def largest_subarray(arr):
    max_length = 0
    current_sum = 0
    sum_dict = {}
    for i in range(len(arr)):
        if arr[i] == 0:
            current_sum -= 1
        else:
            current_sum += 1
        if current_sum == 0:
            max_length = i + 1
        if current_sum in sum_dict:
            max_length = max(max_length, i - sum_dict[current_sum])
        else:
            sum_dict[current_sum] = i
    return max_length",115
43709822001,findShortestSubArray,"from collections import defaultdict

def findShortestSubArray(nums):
    if len(nums) <= 1:
        return len(nums)
    
    degree = defaultdict(list)
    for i, num in enumerate(nums):
        if not degree[num]:
            degree[num].append(i)
        degree[num].append(i)
    
    max_freq = max(len(val) for val in degree.values())
    lengths = [val[-1] - val[0] + 1 for val in degree.values() if len(val) == max_freq]
    
    return min(lengths)",115
985722960,third_largest,"def third_largest(lst):
    unique_lst = list(set(lst))
    if len(unique_lst) < 3:
        return ""List should have at least 3 unique elements""
    unique_lst.sort()
    return unique_lst[-3]

# Test cases
assert third_largest([1,2,3,4,5]) == 3
assert third_largest([10,20,30,40,50]) == 30
assert third_largest([5,1,2,3,4]) == 3",115
22572422057,segment_string,"def segment_string(s, dictionary):
    d = set(dictionary)
    res = []
    def backtrack(temp,pos):
        if pos == len(s):
            res.append(' '.join(temp))
            return 
        for i in range(1,len(s)+1):
            if s[pos:i] in d:
                temp.append(s[pos:i])
                backtrack(temp,i)
                temp.pop()
        return
    backtrack([],0)
    if res:
        for item in res:
            print(item)
        return True
    else:
        print(-1)
        return False",115
43512826938,max_length_subarray,"def max_length_subarray(A):
    count = 0
    max_length = 0
    count_dict = {}
    for i in range(len(A)):
        if A[i] == 0:
            count -= 1
        elif A[i] == 1:
            count += 1

        if count == 0:
            max_length = i + 1
        elif count in count_dict:
            max_length = max(max_length, i - count_dict[count])
        else:
            count_dict[count] = i
    return max_length",115
7504272411,findSmallestSetOfVertices,"from collections import defaultdict

def findSmallestSetOfVertices(n, edges):
    nodes_set = set([i for i in range(n)])
    graph = defaultdict(set)

    for edge in edges:
        graph[edge[0]].add(edge[1])

    graph_values = graph.values()
    g_values = set()
    for v in graph_values:
        if len(v) == 1:
            g_values.add(list(v)[0])
        else:
            g_values.update(v)

    answer_set = nodes_set - g_values
    return list(answer_set)",115
19863872328,max_subset_sum,"import collections

def max_subset_sum(nums, k):
    N = len(nums)
    dp, dq = nums[:], collections.deque()
    
    for i in range(N):
        dp[i] = max(nums[i], nums[i] + dq[0][0]) if dq else nums[i]
        
        while dq and dq[0][1] <= i - k: dq.popleft()
        while dq and dq[-1][0] <= dp[i]: dq.pop()
            
        dq.append((dp[i], i))
        
    return max(dp)",115
22151823866,find_max_crossing_subarray,"def find_max_crossing_subarray(arr, low, mid, high):
    left_sum = float('-inf')
    sum = 0
    for i in range(mid, low-1, -1):
        sum += arr[i]
        if sum > left_sum:
            left_sum = sum

    right_sum = float('-inf')
    sum = 0
    for i in range(mid+1, high+1):
        sum += arr[i]
        if sum > right_sum:
            right_sum = sum

    return left_sum + right_sum",115
3141989294,max_overlaps,"def max_overlaps(intervals):
    events = []
    for start, end in intervals:
        events.append((start, 'start'))
        events.append((end, 'end'))
    events.sort()

    max_overlaps, current_overlaps = 0, 0
    for _, event_type in events:
        if event_type == 'start':
            current_overlaps += 1
            max_overlaps = max(max_overlaps, current_overlaps)
        elif event_type == 'end':
            current_overlaps -= 1

    return max_overlaps",115
11891045088,find_pair_sum,"def find_pair_sum(numbers, target):
    num_map = {}
    pair_count = 0

    for i, num in enumerate(numbers):
        complement = target - num
        if complement in num_map:
            pair_count += len(num_map[complement])
            if num in num_map:
                num_map[num].append(i)
            else:
                num_map[num] = [i]
        else:
            if num in num_map:
                num_map[num].append(i)
            else:
                num_map[num] = [i]

    return pair_count",115
18367612202,count_parentheses_combinations,"from math import factorial

def count_parentheses_combinations(n):
    """"""
    Calculate the number of valid parentheses combinations for a given number of pairs.

    Args:
    n (int): The number of pairs of parentheses.

    Returns:
    int: The number of valid combinations.
    """"""
    # The number of valid combinations is given by the nth Catalan number
    # C(n) = (2n)! / ((n+1)! * n!)
    return factorial(2 * n) // (factorial(n + 1) * factorial(n))",115
29666426894,unique_strings,"def unique_strings(strings):
    return sorted(set(strings))

assert unique_strings([""apple"", ""banana"", ""apple"", ""cherry"", ""banana"", ""date""]) == [""apple"", ""banana"", ""cherry"", ""date""]
assert unique_strings([""dog"", ""cat"", ""dog"", ""bird"", ""cat"", ""fish""]) == [""bird"", ""cat"", ""dog"", ""fish""]
assert unique_strings([""red"", ""blue"", ""green"", ""red"", ""yellow"", ""blue""]) == [""blue"", ""green"", ""red"", ""yellow""]",115
40220287022,find_kth_smallest,"import heapq

def find_kth_smallest(nums, k):
    """"""
    Find the kth smallest element in an unsorted list using a min heap.
    :param nums: List of integers
    :param k: The kth position to find the smallest element for
    :return: The kth smallest element in the list
    """"""
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
    for _ in range(k-1):
        heapq.heappop(heap)
    return heapq.heappop(heap)",115
3009849017,generate_pascals_triangle,"def generate_pascals_triangle(row_num):
    if row_num <= 0:
        return []
    elif row_num == 1:
        return [[1]]
    else:
        triangle = [[1], [1, 1]]
        for k in range(2, row_num):
            curr = [1]
            for i in range(1, len(triangle[k-1])):
                curr.append(triangle[k-1][i] + triangle[k-1][i-1])
            curr.append(1)
            triangle.append(curr)
        return triangle",115
36912095566,longest_nonrepeating_substring,"def longest_nonrepeating_substring(s):
    start = 0
    max_length = 0
    max_substring = """"
    visited = {}

    for i in range(len(s)):
        if s[i] in visited and start <= visited[s[i]]:
            start = visited[s[i]] + 1
        else:
            if i - start + 1 > max_length:
                max_length = i - start + 1
                max_substring = s[start:i+1]

        visited[s[i]] = i

    return max_substring",115
22962605942,find_third_largest,"def find_third_largest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 3:
        return None

    max1 = max2 = max3 = float('-inf')
    for num in unique_numbers:
        if num > max1:
            max3 = max2
            max2 = max1
            max1 = num
        elif num > max2:
            max3 = max2
            max2 = num
        elif num > max3:
            max3 = num

    return max3",114
72470818367,longest_subarray_with_equal_zero_and_one,"def longest_subarray_with_equal_zero_and_one(arr):
    sum = 0
    max_length = 0
    sum_map = {}
    sum_map[0] = -1
    for i in range(0, len(arr)):
        if (arr[i] == 0):
            sum += -1
        else:
            sum += 1
        if (sum in sum_map):
            max_length = max(max_length, i - sum_map[sum])
        else:
            sum_map[sum] = i
    return max_length",114
41913379819,is_three_colorable,"def is_three_colorable(graph):
    colors = [0] * len(graph)
    def dfs(node, color):
        colors[node] = color
        for i, adjacent in enumerate(graph[node]):
            if adjacent and colors[i] == color:
                return False
            if adjacent and colors[i] == 0 and not dfs(i, 3 - color):
                return False
        return True
    for i in range(len(graph)):
        if colors[i] == 0 and not dfs(i, 1):
            return False
    return True",114
70180626105,find_smallest_missing,"def find_smallest_missing(arr):
    i = 0
    while i < len(arr):
        correct_index = arr[i] - 1
        if 0 < arr[i] <= len(arr) and arr[i] != arr[correct_index]:
            arr[i], arr[correct_index] = arr[correct_index], arr[i]
        else:
            i += 1

    for i in range(len(arr)):
        if arr[i] != i + 1:
            return i + 1

    return len(arr) + 1",114
12916934473,longest_unique_substring,"def longest_unique_substring(s):
    char_map = {}
    left = 0
    max_len = 0
    max_start = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        if right - left + 1 > max_len:
            max_len = right - left + 1
            max_start = left
    return s[max_start: max_start + max_len]",114
14500995807,max_sum_non_adjacent,"def max_sum_non_adjacent(arr):
    if not arr:
        return 0
    elif len(arr) <= 2:
        return max(arr)
    else:
        max_sum = [0] * len(arr)
        max_sum[0] = arr[0]
        max_sum[1] = max(arr[0], arr[1])
        for i in range(2, len(arr)):
            max_sum[i] = max(max_sum[i-1], max_sum[i-2] + arr[i])
        return max_sum[-1]",114
12069256261,count_pairs_with_diff_k,"def count_pairs_with_diff_k(arr, k):
    arr.sort()
    count = 0
    left = 0
    right = 1
    n = len(arr)

    while right < n:
        diff = arr[right] - arr[left]
        if diff == k:
            count += 1
            left += 1
            right += 1
        elif diff < k:
            right += 1
        else:
            left += 1
            if left == right:
                right += 1

    return count",114
12234842050,is_mountain_array,"def is_mountain_array(arr):
    if len(arr) < 3:
        return False
    peak = 0
    for i in range(1, len(arr)):
        if arr[i] > arr[i - 1]:
            peak = i
        else:
            break
    if peak == 0 or peak == len(arr) - 1:
        return False
    for i in range(peak, len(arr) - 1):
        if arr[i] <= arr[i + 1]:
            return False
    return True",114
44157427646,valid_mountain_array,"def valid_mountain_array(arr):
    if len(arr) < 3:
        return False
    peak = 0
    for i in range(1, len(arr)):
        if arr[i] > arr[i - 1]:
            peak = i
        else:
            break
    if peak == 0 or peak == len(arr) - 1:
        return False
    for i in range(peak, len(arr) - 1):
        if arr[i] <= arr[i + 1]:
            return False
    return True",114
36161184667,longest_unique_substring,"def longest_unique_substring(s):
    char_index = {}
    start = 0
    max_length = 0
    max_start = 0
    for i, char in enumerate(s):
        if char in char_index and char_index[char] >= start:
            start = char_index[char] + 1
        char_index[char] = i
        if i - start + 1 > max_length:
            max_length = i - start + 1
            max_start = start
    return s[max_start:max_start + max_length]",114
2699319075,generate_subsequences,"def generate_subsequences(nums):
    def recurse(currSeq, index, out):
        if index > len(nums):
            return out
        for i in range(index, len(nums)):
            seq = currSeq + [nums[i]]
            out.append(seq)
            out = recurse(seq, i+1, out)
        return out
    output = []
    output.append([])
    for i in range(0, len(nums)):
        seq = [nums[i]]
        output.append(seq)
        output = recurse(seq, i+1, output)
    return output",114
16206507316,are_anagrams,"def are_anagrams(s1, s2):
    if len(s1) != len(s2):
        return False
    dic1 = {}
    dic2 = {}
    for i in s1:
        if i not in dic1:
            dic1[i] = 1
        else:
            dic1[i] += 1
    for i in s2:
        if i not in dic2:
            dic2[i] = 1
        else:
            dic2[i] += 1
    return dic1 == dic2",114
2511849528,max_Product,"def max_Product(nums):
    max1 = max2 = float('-inf')
    min1 = min2 = float('inf')
    for num in nums:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2:
            max2 = num
        if num < min1:
            min2 = min1
            min1 = num
        elif num < min2:
            min2 = num
    return max(max1 * max2, min1 * min2)",114
20436574455,word_pattern_match,"def word_pattern_match(pattern, str):
    """"""
    :type pattern: str
    :type str: str
    :rtype: bool
    """"""
    ans = dict()
    str_list = str.split(' ')
    if len(pattern) != len(str_list):
        return False
    for p, s in zip(pattern, str_list):
        if p not in ans:
            if s in ans.values():
                return False
            ans[p] = s
        else:
            if ans[p] != s:
                return False
    return True",114
25950195745,is_isomorphic,"def is_isomorphic(s, t):
    if len(s) != len(t):
        return False

    mapping_s_t = {}
    mapping_t_s = {}

    for c1, c2 in zip(s, t):
        if (c1 in mapping_s_t and mapping_s_t[c1] != c2) or (c2 in mapping_t_s and mapping_t_s[c2] != c1):
            return False
        mapping_s_t[c1] = c2
        mapping_t_s[c2] = c1
    return True",114
29096881470,distinct_subsequences,"def distinct_subsequences(s):
    if not s:
        return 0
    dp = [0] * (len(s) + 1)
    dp[0] = 1
    last_occurrence = {}
    for i in range(len(s)):
        dp[i + 1] = dp[i] * 2
        if s[i] in last_occurrence:
            dp[i + 1] -= dp[last_occurrence[s[i]]]
        last_occurrence[s[i]] = i
    return dp[-1] - 1",114
37282701798,find_repeated,"def find_repeated(arr):
    tortoise = hare = arr[0]
    # Phase 1: Finding the intersection point of the two runners.
    while True:
        tortoise = arr[tortoise]
        hare = arr[arr[hare]]
        if tortoise == hare:
            break

    # Phase 2: Finding the entrance to the cycle (the repeated number).
    tortoise = arr[0]
    while tortoise != hare:
        tortoise = arr[tortoise]
        hare = arr[hare]

    return tortoise",114
73982189100,countWays,"def countWays(n):
    if n == 1 or n == 2:
        return 1
    if n == 3:
        return 2
    ways = [0] * (n + 1)
    ways[1], ways[2], ways[3] = 1, 1, 2
    for i in range(4, n + 1):
        ways[i] = ways[i - 1] + ways[i - 3] + ways[i - 4]
    return ways[n]",114
75280901486,is_isomorphic,"def is_isomorphic(s, t):
    if len(s) != len(t):
        return False
    mapping_s_t = {}
    mapping_t_s = {}

    for c1, c2 in zip(s, t):
        if (c1 in mapping_s_t and mapping_s_t[c1] != c2) or (c2 in mapping_t_s and mapping_t_s[c2] != c1):
            return False
        mapping_s_t[c1] = c2
        mapping_t_s[c2] = c1
    return True",114
11509780845,reverse,"def reverse(x: int) -> int:
    ex = str(x)
    if ex[0] == ""-"":
        ex2 = ex[1:]
        rev = int(ex2[::-1])
        if (-2)**31 <= rev < 2**31:
            return int(""-"" + ex2[::-1])
        else:
            return 0
    else:
        rev = int(ex[::-1])
        if (-2)**31 <= rev < 2**31:
            return rev
        else:
            return 0",114
1611313857,find_longest_substring,"def find_longest_substring(s: str) -> str:
    char_set = set()
    left = 0
    max_length = 0
    longest_substring = """"

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1

        char_set.add(s[right])

        if right - left + 1 > max_length:
            max_length = right - left + 1
            longest_substring = s[left:right+1]

    return longest_substring",114
18704270378,move_zeros,"def move_zeros(nums):
    """"""
    Rearranges the given list such that all the zeros are moved to the end while maintaining the order of the non-zero elements.
    """"""
    n = len(nums)
    p = 0
    count = 0
    for i in range(n):
        if nums[i] != 0:
            nums[p] = nums[i]
            p += 1
        else:
            count += 1
    for i in range(n - count, n):
        nums[i] = 0
    return nums",114
42384316873,max_substring_replacement,"from collections import defaultdict

def max_substring_replacement(s: str, k: int) -> int:
    l = 0
    hashMap = defaultdict(int)
    left = right = 0
    
    while right < len(s):
        hashMap[s[right]] += 1
        right += 1
        if right - left - max(hashMap.values()) > k:
            hashMap[s[left]] -= 1
            if hashMap[s[left]] == 0:
                hashMap.pop(s[left])
            left += 1
        
    return right - left",114
25998789881,nth_look_and_say,"def nth_look_and_say(n):
    if n == 1:
        return '1'
    previous_term = nth_look_and_say(n - 1)
    result = ''
    count = 1
    for i in range(1, len(previous_term)):
        if previous_term[i] == previous_term[i - 1]:
            count += 1
        else:
            result += str(count) + previous_term[i - 1]
            count = 1
    result += str(count) + previous_term[-1]
    return result",114
18988111676,unique_bst,"def unique_bst(n: int) -> int:
    if n == 0:
        return 0
    elif n == 1:
        return 1
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2, n + 1):
        for j in range(1, i + 1):
            dp[i] += dp[j - 1] * dp[i - j]
    return dp[n]",114
31829641491,reverse_integer,"def reverse_integer(n):
    s = str(n)
    r = []
    if s[0] == ""-"": 
        r.append(""-"")
        s = s[1:]
    slen = len(s)
    for i in range(slen):
        r.append(s[slen - i - 1])
    out = 0
    if r!= []: out = int("""".join(r))
    if out > (2**31 - 1) or out < (-2**31): out = 0
    return out",114
33323181053,count_unique_words,"from collections import Counter

def count_unique_words(words):
    word_counts = Counter(words)
    unique_words_count = sum(1 for word, count in word_counts.items() if count == 1)
    return unique_words_count

# Test cases
assert count_unique_words([""apple"", ""banana"", ""cherry"", ""apple"", ""date""]) == 3
assert count_unique_words([""hello"", ""world"", ""hello""]) == 1
assert count_unique_words([""one"", ""two"", ""three"", ""four"", ""five""]) == 5",114
15277914351,decodeString,"def decodeString(s: str) -> str:
    stack = []
    for val in s:
        if val != ""]"":
            stack.append(val)
        else:
            substr = """"
            while stack[-1] != ""["":
                substr = stack.pop() + substr  # get the substring
            stack.pop()  # pop the [
            num = """"
            while stack and stack[-1].isdigit():  # get the number
                num = stack.pop() + num
            stack.append(int(num) * substr)
    return """".join(stack)",114
44811309324,max_subsequence_sum,"def max_subsequence_sum(lst, k):
    dp = [[0 for _ in range(len(lst))] for _ in range(k+1)]
    for i in range(1, k+1):
        dp[i][0] = lst[0] if i == 1 else dp[i-1][0]
        for j in range(1, len(lst)):
            dp[i][j] = max(dp[i][j-1], dp[i-1][j-1] + lst[j])
    return dp[k][len(lst)-1]",114
24822262965,convert_base,"def convert_base(num, to_base):
    # Create an empty string to store the result
    result = ''
    # While the number is greater than 0
    while num > 0:
        # Get the remainder when the number is divided by the base
        remainder = num % to_base
        # Add the remainder to the result
        result = str(remainder) + result
        # Update the number to be the quotient when divided by the base
        num = num // to_base
    # Return the result
    return result",114
34139504880,is_rectangle_overlap,"def is_rectangle_overlap(rec1, rec2):
    max_x1 = max(rec1[0], rec2[0])
    max_y1 = max(rec1[1], rec2[1])
    min_x2 = min(rec1[2], rec2[2])
    min_y2 = min(rec1[3], rec2[3])
        
    if (min_x2 - max_x1) > 0 and (min_y2 - max_y1) > 0:
        return True
    else:
        return False",113
42457954189,contains_zero_sum_triplet,"def contains_zero_sum_triplet(nums):
    if len(nums) < 3:
        return False

    nums.sort()

    for i in range(len(nums) - 2):
        left, right = i + 1, len(nums) - 1

        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]

            if current_sum == 0:
                return True

            elif current_sum < 0:
                left += 1

            else:
                right -= 1

    return False",113
32160055493,calculate_determinant,"def calculate_determinant(matrix):
    n = len(matrix)
    if n == 2:
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]
    det = 0
    for j in range(n):
        sub_matrix = [row[:j] + row[j+1:] for row in matrix[1:]]
        det += ((-1) ** j) * matrix[0][j] * calculate_determinant(sub_matrix)
    return det",113
29920597671,merge_sorted_arrays,"def merge_sorted_arrays(arr1, arr2):
    result = []
    i, j = 0, 0
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            result.append(arr1[i])
            i += 1
        else:
            result.append(arr2[j])
            j += 1
    if i < len(arr1):
        result.extend(arr1[i:])
    if j < len(arr2):
        result.extend(arr2[j:])
    return result",113
4239450119,caesar_cipher,"def caesar_cipher(string, shift):
    cipher = ''
    for char in string: 
        ascii_code = ord(char)
        if 97 <= ascii_code <= 122: 
            cipher += chr(((ascii_code - 97 + shift) % 26) + 97)
        elif 65 <= ascii_code <= 90:
            cipher += chr(((ascii_code - 65 + shift) % 26) + 65)
        else:
            cipher += char
    return cipher",113
17542375683,largest_Palindrome,"def largest_Palindrome(n):
    max_num = 10**n - 1
    min_num = 10**(n-1)
    max_palindrome = 0
    for i in range(max_num, min_num-1, -1):
        for j in range(i, min_num-1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if str(product) == str(product)[::-1]:
                max_palindrome = product
    return max_palindrome",113
28203502914,can_partition,"def can_partition(nums):
    total = sum(nums)
    if total % 2 != 0:
        return False
    bag = total // 2
    M = max(nums)
    if bag < M:
        return False
    n = len(nums)
    dp = [True] + [False] * bag
    for i, num in enumerate(nums):
        for j in range(bag, num - 1, -1):
            dp[j] = dp[j] | dp[j - num]
    return dp[bag]",113
14026258727,topKFrequent,"def topKFrequent(arr, k):
    count = {}
    freq = [[] for i in range(len(arr) + 1)]
    for i in range(len(arr)):
        count[arr[i]] = 1 + count.get(arr[i], 0)
    for value, cnt in count.items():
        freq[cnt].append(value)
    ans = []
    for i in range(len(freq) - 1, 0, -1):
        for j in freq[i]:
            ans.append(j)
            if len(ans) == k:
                return ans",113
3473529104,sortColors,"def sortColors(nums):
    low = 0
    mid = 0
    high = len(nums) - 1

    while mid <= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1
    return nums",113
2433017285,max_ones,"def max_ones(nums, k):
    low = 0
    high = 0
    max_len = 0
    zero_count = 0
    while high < len(nums):
        if nums[high] == 0:
            zero_count += 1
        while zero_count > k:
            if nums[low] == 0:
                zero_count -= 1
            low += 1
        max_len = max(max_len, high - low + 1)
        high += 1
    return max_len",113
29395381957,Largest_Palindrome,"def Largest_Palindrome(n):
    max_num = 10**n - 1
    min_num = 10**(n-1)

    max_palindrome = 0

    for i in range(max_num, min_num-1, -1):
        for j in range(i, min_num-1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if str(product) == str(product)[::-1]:
                max_palindrome = product

    return max_palindrome",113
10788474872,find_substring,"def find_substring(haystack, needle):
    if haystack is None or needle is None:
        return 0
    lenh = len(haystack)
    lenn = len(needle)
    
    if lenn == 0:
        return 0
            
    for i in range(lenh - lenn + 1):
        j = 0
        while(j < lenn and haystack[i + j] == needle[j]):
            j += 1
        if j == lenn:
            return i;
    return -1",113
12236663180,is_palindrome_linked_list,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def create_linked_list(lst):
    head = ListNode(lst[0])
    current = head
    for i in range(1, len(lst)):
        current.next = ListNode(lst[i])
        current = current.next
    return head

def is_palindrome_linked_list(head):
    values = []
    while head:
        values.append(head.val)
        head = head.next
    return values == values[::-1]",113
74840261312,longest_nonrepeating_substring,"def longest_nonrepeating_substring(s):
    char_map = {}
    left = 0
    max_length = 0
    max_substring = """"
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        if right - left + 1 > max_length:
            max_length = right - left + 1
            max_substring = s[left:right+1]
    return max_substring",113
15731748283,largest_palindrome_product,"def largest_palindrome_product(n):
    max_num = 10**n - 1
    min_num = 10**(n-1)
    max_palindrome = 0
    for i in range(max_num, min_num-1, -1):
        for j in range(i, min_num-1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if str(product) == str(product)[::-1]:
                max_palindrome = product
    return max_palindrome",113
43434728159,sort_even,"def sort_even(lst):
    return sorted([x for x in lst if x % 2 == 0])

assert sort_even([5, 3, 2, 8, 1, 4]) == [2, 4, 8]
assert sort_even([10, 23, 4, 16, 6, 1]) == [4, 6, 10, 16]
assert sort_even([9, 7, 5, 3, 1]) == []",113
24485467682,max_product_subarray,"def max_product_subarray(nums):
    if not nums:
        return 0

    max_product = nums[0]
    min_product = nums[0]
    result = nums[0]

    for i in range(1, len(nums)):
        if nums[i] < 0:
            max_product, min_product = min_product, max_product

        max_product = max(nums[i], max_product * nums[i])
        min_product = min(nums[i], min_product * nums[i])

        result = max(result, max_product)

    return result",113
23794367080,find_longest_subarray,"def find_longest_subarray(A, n):
    sum = 0
    max_len = 0
    sum_dict = {}
    for i in range(n):
        if A[i] == 0:
            sum -= 1
        else:
            sum += 1
        if sum == 0:
            max_len = i + 1
        if sum in sum_dict:
            max_len = max(max_len, i - sum_dict[sum])
        else:
            sum_dict[sum] = i
    return max_len",113
35160773228,max_unique_subarray_sum,"from typing import List

def max_unique_subarray_sum(nums: List[int]) -> int:
    max_sum = 0
    current_sum = 0
    seen = {}
    start = 0
    for end, num in enumerate(nums):
        current_sum += num
        if num in seen and seen[num] >= start:
            start = seen[num] + 1
            current_sum = sum(nums[start:end+1])
        seen[num] = end
        max_sum = max(max_sum, current_sum)
    return max_sum",113
35537290363,intersect_sorted_lists,"def intersect_sorted_lists(list1, list2):
    i, j = 0, 0
    result = []
    while i < len(list1) and j < len(list2):
        if list1[i] == list2[j]:
            if not result or result[-1] != list1[i]:
                result.append(list1[i])
            i += 1
            j += 1
        elif list1[i] < list2[j]:
            i += 1
        else:
            j += 1
    return result",113
25544426821,find_longest_consecutive_subsequence,"def find_longest_consecutive_subsequence(nums):
    if not nums:
        return 0
    nums_set = set(nums)
    longest_streak = 0
    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1
            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1
            longest_streak = max(longest_streak, current_streak)
    return longest_streak",113
20734780567,minJumps,"def minJumps(arr):
    n = len(arr)
    if n <= 1:
        return 0
    jumps = [0] * n
    jumps[0] = 0
    for i in range(1, n):
        jumps[i] = float('inf')
        for j in range(i):
            if i <= j + arr[j] and jumps[j] != float('inf'):
                jumps[i] = min(jumps[i], jumps[j] + 1)
                break
    return jumps[n-1]",113
71067323191,num_ways,"def num_ways(n, m):
    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
    for i in range(m+1):
        dp[0][i] = 1
    for i in range(1, n+1):
        for j in range(1, m+1):
            dp[i][j] = dp[i][j-1]
            if i >= j:
                dp[i][j] += dp[i-j][j]
    return dp[n][m]",113
33286389461,all_elements_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def all_elements_prime(arr):
    return all(map(is_prime, arr))",113
20685553828,maximum_product,"def maximum_product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])

def check_function():
    assert maximum_product([1, 2, 3, 4]) == 24
    assert maximum_product([-1, -2, -3, 4]) == 24
    assert maximum_product([-1, -2, 1, 2]) == 4
    print(""All test cases passed."")

check_function()",113
19070992118,intersection_sorted_arrays,"def intersection_sorted_arrays(arr1, arr2):
    i, j = 0, 0
    intersection = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] == arr2[j]:
            if not intersection or arr1[i] != intersection[-1]:
                intersection.append(arr1[i])
            i += 1
            j += 1
        elif arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return intersection",113
17944505748,moving_average,"def moving_average(nums, k):
    if k <= 0 or len(nums) < k:
        return []
    res = [0] * (len(nums) - k + 1)
    for i in range(k):
        res[0] += nums[i]
    res[0] /= k
    for i in range(1, len(nums) - k + 1):
        res[i] = res[i-1] + (nums[i + k - 1] - nums[i-1]) / k
    return res",113
3478615496,max_length_subarray_sum,"def max_length_subarray_sum(arr, k):
    """"""Return the maximum length of a subarray that sums to k.""""""
    sum_indices = {0: -1}
    max_length = 0
    current_sum = 0
    for i, num in enumerate(arr):
        current_sum += num
        if current_sum - k in sum_indices:
            max_length = max(max_length, i - sum_indices[current_sum - k])
        if current_sum not in sum_indices:
            sum_indices[current_sum] = i
    return max_length",113
21204566204,decode_variations,"def decode_variations(s):
    if not s or s[0] == '0':
        return 0
    first, second = 1, 1
    for i in range(1, len(s)):
        current = 0
        if s[i] > '0':
            current = second
        if s[i-1] == '1' or (s[i-1] == '2' and s[i] < '7'):
            current += first
        first, second = second, current
    return second",113
8993654785,max_consecutive_ones,"def max_consecutive_ones(nums, k):
    left = 0
    right = 0
    max_length = 0
    zero_count = 0
    while right < len(nums):
        if nums[right] == 0:
            zero_count += 1
        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        max_length = max(max_length, right - left + 1)
        right += 1
    return max_length",113
32333182670,pick_coins,"def pick_coins(coins):
    if len(coins) == 0:
        return 0
    elif len(coins) <= 2:
        return max(coins)
    dp = [0] * len(coins)
    dp[0] = coins[0]
    dp[1] = max(coins[0], coins[1])
    for i in range(2, len(coins)):
        dp[i] = max(dp[i-1], dp[i-2] + coins[i])
    return dp[-1]",113
5828463060,decode_message,"def decode_message(s):
    memo = {}

    def dfs(s):
        if s in memo:
            return memo[s]
        if len(s) == 0:
            return 1
        if s[0] == '0':
            return 0
        if len(s) == 1:
            return 1

        count = dfs(s[1:])
        if (int(s[:2]) <= 26):
            count += dfs(s[2:])
        memo[s] = count
        return count

    return dfs(s)",113
71921106904,find_max_min,"def find_max_min(arr):
    if len(arr) == 1:
        return (arr[0], arr[0])
    elif len(arr) == 2:
        return (max(arr[0], arr[1]), min(arr[0], arr[1]))
    else:
        mid = len(arr) // 2
        left_max, left_min = find_max_min(arr[:mid])
        right_max, right_min = find_max_min(arr[mid:])
        return (max(left_max, right_max), min(left_min, right_min))",113
41440450852,min_sub_array_len,"from typing import List

def min_sub_array_len(target: int, nums: List[int]) -> int:
    n = len(nums)
    min_len = float('inf')
    left = 0
    curr_sum = 0

    for right in range(n):
        curr_sum += nums[right]
        while curr_sum >= target:
            min_len = min(min_len, right - left + 1)
            curr_sum -= nums[left]
            left += 1

    return min_len if min_len != float('inf') else 0",113
36706256870,decode_string,"def decode_string(s):
    stack = []
    current_num = 0
    current_string = """"
    for char in s:
        if char.isdigit():
            current_num = current_num * 10 + int(char)
        elif char == '[':
            stack.append((current_string, current_num))
            current_string, current_num = """", 0
        elif char == ']':
            prev_string, num = stack.pop()
            current_string = prev_string + num * current_string
        else:
            current_string += char
    return current_string",113
74188217126,max_product_of_subarray,"def max_product_of_subarray(nums):
    if not nums:
        return 0

    max_product = nums[0]
    min_product = nums[0]
    result = nums[0]

    for i in range(1, len(nums)):
        temp = max_product
        max_product = max(nums[i], max_product * nums[i], min_product * nums[i])
        min_product = min(nums[i], temp * nums[i], min_product * nums[i])
        if max_product > result:
            result = max_product

    return result",113
27438640071,longest_substring_without_repeating,"def longest_substring_without_repeating(s):
    char_map = {}
    start = 0
    max_length = 0
    max_substring = """"

    for end in range(len(s)):
        if s[end] in char_map:
            start = max(start, char_map[s[end]] + 1)

        char_map[s[end]] = end
        if end - start + 1 > max_length:
            max_length = end - start + 1
            max_substring = s[start:end+1]

    return max_substring",113
1777091503,chessboard_paths,"def chessboard_paths(m, n):
    dp = [[0 for x in range(n)] for y in range(m)]
    for i in range(m):
        dp[i][0] = 1
    for j in range(n):
        dp[0][j] = 1
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[m-1][n-1]",113
30343582047,find_longest_unique_substring,"def find_longest_unique_substring(s):
    char_dict = {}
    start = 0
    max_len = 0
    max_substring = """"
    for end in range(len(s)):
        if s[end] in char_dict:
            start = max(start, char_dict[s[end]] + 1)
        char_dict[s[end]] = end
        if end - start + 1 > max_len:
            max_len = end - start + 1
            max_substring = s[start:end+1]
    return max_substring",113
44289869161,longest_substring_without_repeating_characters,"def longest_substring_without_repeating_characters(s):
    char_set = set()
    left = 0
    max_length = 0
    max_substring = """"
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        if (right - left + 1) > max_length:
            max_length = right - left + 1
            max_substring = s[left:right+1]
    return max_substring",113
35186557851,beautiful_arrangements,"def beautiful_arrangements(n):
    def backtrack(index):
        if index == n + 1:
            return 1
        count = 0
        for i in range(1, n + 1):
            if not visited[i] and (i % index == 0 or index % i == 0):
                visited[i] = True
                count += backtrack(index + 1)
                visited[i] = False
        return count

    visited = [False] * (n + 1)
    return backtrack(1)",113
38854151063,areFollowingPatterns,"def areFollowingPatterns(strings, patterns):
    hlist = {strings[0]:patterns[0]}
    if len(patterns) == 1:
        return True
    for i in range(len(patterns)):
        if strings[i] not in hlist and patterns[i] in hlist.values():
            return False
        if strings[i] not in hlist:
            hlist[strings[i]] = patterns[i]
        if strings[i] in hlist and hlist[strings[i]] != patterns[i]:
            return False
    return True",113
74960764345,shortest_Rep_substring,"def shortest_Rep_substring(s):
    length = len(s)
    for i in range(1, length//2 + 1):
        if length % i == 0:
            if s[:i]*(length//i) == s:
                return i
    return length

if __name__ == '__main__':
    assert shortest_Rep_substring(""abab"") == 2
    assert shortest_Rep_substring(""abcabcabcabc"") == 3
    assert shortest_Rep_substring(""abcdabcd"") == 4",113
24756450148,find_connected_components,"from collections import defaultdict

def find_connected_components(edges):
    graph = defaultdict(list)
    visited = set()
    components = 0
    
    for edge in edges:
        graph[edge[0]].append(edge[1])
        graph[edge[1]].append(edge[0])
        
    def dfs(node):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)
                
    for node in graph:
        if node not in visited:
            dfs(node)
            components += 1
                
    return components",113
8252861979,find_max_product,"def find_max_product(nums):
    if not nums:
        return 0

    max_product = nums[0]
    min_product = nums[0]
    result = nums[0]

    for i in range(1, len(nums)):
        if nums[i] < 0:
            max_product, min_product = min_product, max_product

        max_product = max(nums[i], max_product * nums[i])
        min_product = min(nums[i], min_product * nums[i])

        result = max(result, max_product)

    return result",112
30838582102,find_kth_divisor,"import math

def find_kth_divisor(n: int, k: int) -> int:
    start = [1]
    end = [n]
    for i in range(2, math.ceil(math.sqrt(n)) + 1):
        if n % i == 0:
            start.append(i)
            if i != n // i:
                end.append(n // i)
    start = sorted(set(start).union(set(end)))
    if k <= len(start):
        return start[k - 1]
    else:
        return -1",112
828776392,max_length_1s,"def max_length_1s(nums, k):
    left, right = 0, 0
    zero_count = 0
    max_len = 0

    while right < len(nums):
        if nums[right] == 0:
            zero_count += 1

        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1

        max_len = max(max_len, right - left + 1)
        right += 1

    return max_len",112
16164236098,divisors_count,"from math import sqrt

def divisors_count(A):
    def count_divisors(n):
        if n == 1:
            return 1
        divisors = 2  # 1 and n itself
        for i in range(2, int(sqrt(n)) + 1):
            if n % i == 0:
                if n // i == i:
                    divisors += 1
                else:
                    divisors += 2
        return divisors

    return [count_divisors(a) for a in A]",112
33325366696,is_valid_bst,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_valid_bst(root):
    def validate(node, low, high):
        if not node:
            return True
        if not (low < node.val < high):
            return False
        return validate(node.left, low, node.val) and validate(node.right, node.val, high)

    return validate(root, float('-inf'), float('inf'))",112
5345934912,length_of_LIS,"def length_of_LIS(nums):
    if not nums:
        return 0
    tails = [0] * len(nums)
    size = 0
    for x in nums:
        i, j = 0, size
        while i != j:
            m = (i + j) // 2
            if tails[m] < x:
                i = m + 1
            else:
                j = m
        tails[i] = x
        size = max(i + 1, size)
    return size",112
38719822634,is_bst,"class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_bst(node, min_val=float('-inf'), max_val=float('inf')):
    if node is None:
        return True
    if node.val <= min_val or node.val >= max_val:
        return False
    return (is_bst(node.left, min_val, node.val) and
            is_bst(node.right, node.val, max_val))",112
28130498894,count_ways_to_climb,"def count_ways_to_climb(n):
    if n == 0 or n == 1:
        return 1
    if n == 2:
        return 2

    dp = [0] * (n+1)
    dp[0], dp[1], dp[2] = 1, 1, 2

    for i in range(3, n+1):
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

    return dp[n]",112
74281171224,min_operations_palindrome,"def min_operations_palindrome(s):
    n = len(s)
    dp = [[0] * (n+1) for _ in range(n+1)]
    for i in range(1, n+1):
        for j in range(1, n+1):
            dp[i][j] = dp[i-1][j-1] + 1 if s[i-1] == s[n-j] else max(dp[i-1][j], dp[i][j-1])
    return n - dp[n][n]",112
70044975746,find_duplicate,"def find_duplicate(nums):
    tortoise = nums[0]
    hare = nums[0]
    
    # Find the intersection point of the two runners.
    while True:
        tortoise = nums[tortoise]
        hare = nums[nums[hare]]
        if tortoise == hare:
            break
    
    # Find the ""entrance"" to the cycle.
    tortoise = nums[0]
    while tortoise != hare:
        tortoise = nums[tortoise]
        hare = nums[hare]
    
    return tortoise",112
71759412595,count_arithmetic_slices,"from typing import List
from collections import defaultdict

def count_arithmetic_slices(nums: List[int]) -> int:
    N = len(nums)
    if N < 3:
        return 0

    dp = [defaultdict(int) for _ in range(N)]
    result = 0

    for i in range(N):
        for j in range(i):
            diff = nums[i] - nums[j]
            dp[i][diff] += dp[j][diff] + 1
            result += dp[j][diff]

    return result",112
34679620954,unique_paths,"def unique_paths(m, n):
    """"""
    :type m: int
    :type n: int
    :rtype: int
    """"""
    if n == 1 or m == 1:
        return 1
    dp = [[1] * n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",112
37648635634,intersection,"def intersection(arr1, arr2):
    i, j = 0, 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] == arr2[j]:
            if result == [] or result[-1] != arr1[i]:
                result.append(arr1[i])
            i += 1
            j += 1
        elif arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return result",112
11356836612,sorted_intersection,"def sorted_intersection(arr1, arr2):
    i, j = 0, 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            i += 1
        elif arr1[i] > arr2[j]:
            j += 1
        else:
            if not result or result[-1] != arr1[i]:
                result.append(arr1[i])
            i += 1
            j += 1
    return result",112
20407255780,binary_gap,"def binary_gap(N: int) -> int:
    binaryString = format(N, ""b"")
    longestDistance = 0
    last1Idx = -1

    for idx in range(len(binaryString)):
        if binaryString[idx] == ""1"":
            if last1Idx == -1:
                last1Idx = idx
            else:
                if longestDistance < (idx - last1Idx - 1):
                    longestDistance = idx - last1Idx - 1
            last1Idx = idx

    return longestDistance",112
13049151629,intersection_sorted,"def intersection_sorted(arr1, arr2):
    i, j = 0, 0
    intersection = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            i += 1
        elif arr1[i] > arr2[j]:
            j += 1
        else:
            if not intersection or arr1[i] != intersection[-1]:
                intersection.append(arr1[i])
            i += 1
            j += 1
    return intersection",112
28701711480,intersect,"def intersect(nums1, nums2):
    nums1.sort()
    nums2.sort()

    resultList = []

    while len(nums1) > 0 and len(nums2) > 0:
        if nums1[0] == nums2[0]:
            resultList.append(nums1.pop(0))
            nums2.pop(0)
        elif nums1[0] > nums2[0]:
            nums2.pop(0)
        elif nums1[0] < nums2[0]:
            nums1.pop(0)

    return resultList",112
2881753867,decode_Ways,"def decode_Ways(s):
    if not s or s[0] == '0': return 0
    prev, curr = 1, 1
    for i in range(1, len(s)):
        nextt = 0
        if s[i] != '0':
            nextt += curr
        if s[i-1] != '0' and int(s[i-1:i+1]) <= 26:
            nextt += prev
        prev, curr = curr, nextt
    return curr",112
17593090259,find_most_frequent,"from collections import Counter

def find_most_frequent(lst):
    count = Counter(lst)
    return max(count.keys(), key=(lambda k: count[k]))

print(find_most_frequent([1,2,3,3,2,2,1])) # should return 2
print(find_most_frequent([1,1,2,2,3,3,4,4,4])) # should return 4
print(find_most_frequent(['a','b','a','c','b','b'])) # should return 'b'",112
5149565819,max_sum_non_adjacent,"def max_sum_non_adjacent(arr):
    if len(arr) == 0:
        return 0
    elif len(arr) == 1:
        return arr[0]
    elif len(arr) == 2:
        return max(arr)
    else:
        incl = arr[0]
        excl = 0
        for i in range(1, len(arr)):
            new_excl = max(incl, excl)
            incl = excl + arr[i]
            excl = new_excl
        return max(incl, excl)",112
37283775108,jump_min,"def jump_min(nums, start):
    if start >= len(nums) - 1:
        return 0
    jump, maxReach, steps = 0, start + nums[start], 1
    for i in range(start + 1, maxReach + 1):
        if i >= len(nums) - 1:
            return steps
        newReach = i + nums[i]
        if newReach > maxReach:
            maxReach = newReach
            jump = i
    return steps + jump_min(nums, jump)",112
70047027955,rotate_string,"def rotate_string(s, n):
    if n == 0:
        return s
    elif n > 0:
        return s[n:] + s[:n]
    else:
        return s[n+len(s):] + s[:n+len(s)]

# Test cases
print(rotate_string(""hello"", 2)) # Expected output: ""llohe""
print(rotate_string(""world"", -1)) # Expected output: ""dworl""
print(rotate_string(""python"", 0)) # Expected output: ""python""",112
21680504291,smallest_number,"def smallest_number(numbers):
    result = """"
    numbers = custom_sort(numbers)

    for item in numbers:
        result +=  str(item)
    return result

def custom_sort(numbers):
    for i in range(len(numbers) -1):
        temp = i
        for j in range(i+1, len(numbers)):
            if int(str(numbers[temp]) +str( numbers[j])) > int(str(numbers[j]) + str(numbers[temp])):
                temp = j
        numbers[i], numbers[temp] = numbers[temp], numbers[i]
    return numbers",112
72839777482,most_common_char,"def most_common_char(s):
    char_freq = {}
    for char in s:
        if char in char_freq:
            char_freq[char] += 1
        else:
            char_freq[char] = 1

    max_char = max(char_freq, key=char_freq.get)
    max_freq = char_freq[max_char]
    common_chars = [char for char, freq in char_freq.items() if freq == max_freq]
    
    if len(common_chars) > 1:
        return -1
    else:
        return max_char",112
24423164869,find_longest_consecutive_sequence,"def find_longest_consecutive_sequence(nums):
    if not nums:
        return 0
    num_set = set(nums)
    longest_streak = 0
    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1
            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1
            longest_streak = max(longest_streak, current_streak)
    return longest_streak",112
22874496555,max_consecutive_ones,"def max_consecutive_ones(nums, k):
    left, right = 0, 0
    max_length = 0
    zero_count = 0

    while right < len(nums):
        if nums[right] == 0:
            zero_count += 1

        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1

        max_length = max(max_length, right - left + 1)
        right += 1

    return max_length",112
3472773214,is_mountain_array,"def is_mountain_array(arr):
    if len(arr) < 3:
        return False
    peak = 0
    for i in range(1, len(arr)):
        if arr[i] > arr[i-1]:
            peak = i
        else:
            break
    if peak == 0 or peak == len(arr) - 1:
        return False
    for i in range(peak, len(arr) - 1):
        if arr[i] <= arr[i+1]:
            return False
    return True",112
8577386004,largest_palindrome,"def largest_palindrome(n):
    max_num = 10**n - 1
    min_num = 10**(n-1)
    max_palindrome = 0
    for i in range(max_num, min_num-1, -1):
        for j in range(i, min_num-1, -1):
            product = i * j
            if product <= max_palindrome:
                break
            if str(product) == str(product)[::-1]:
                max_palindrome = product
    return max_palindrome",112
6475100752,count_unique_prime_factors,"def count_unique_prime_factors(n):
    factors = set()
    if n % 2 == 0:
        factors.add(2)
        while n % 2 == 0:
            n //= 2
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            factors.add(i)
            while n % i == 0:
                n //= i
    if n > 2:
        factors.add(n)
    return len(factors)",112
15951946541,find_intersection,"def find_intersection(list1, list2):
    result = []
    i, j = 0, 0
    while i < len(list1) and j < len(list2):
        if list1[i] == list2[j]:
            if not result or result[-1] != list1[i]:
                result.append(list1[i])
            i += 1
            j += 1
        elif list1[i] < list2[j]:
            i += 1
        else:
            j += 1
    return result",112
3938189772,days_in_month,"def days_in_month(month, year):
    if month in [1, 3, 5, 7, 8, 10, 12]:
        return 31
    elif month in [4, 6, 9, 11]:
        return 30
    else:
        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
            return 29
        else:
            return 28",112
21558673122,is_valid_solution,"def is_valid_solution(board):
    n = len(board)
    cols = set()
    posDiag = set()
    negDiag = set()
    for r in range(n):
        for c in range(n):
            if board[r][c] == ""Q"":
                if c in cols or (r + c) in posDiag or (r - c) in negDiag:
                    return False
                cols.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
    return True",112
39321555331,sorted_squares,"def sorted_squares(nums):
    n = len(nums)
    new_list = [0] * n
    start = 0
    index = n - 1
    end = n - 1
    while start <= end:
        if abs(nums[start]) > abs(nums[end]):
            new_list[index] = nums[start] * nums[start]
            start += 1
        else:
            new_list[index] = nums[end] * nums[end]
            end -= 1
        index -= 1
    return new_list",112
5268511178,intersection,"def intersection(arr1, arr2):
    i, j = 0, 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] == arr2[j]:
            if result == [] or result[-1] != arr1[i]:
                result.append(arr1[i])
            i += 1
            j += 1
        elif arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return result",112
24543929972,catalan,"def catalan(n: int) -> int:
    if (n == 0 or n == 1):
        return 1
    dp = [0 for i in range(n + 1)]
    dp[0] = 1
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = 0
        for j in range(i):
            dp[i] = dp[i] + dp[j] * dp[i-j-1]
    return dp[n]",112
4134520890,find_max_product,"def find_max_product(nums):
    if not nums:
        return 0

    max_product = nums[0]
    min_product = nums[0]
    result = nums[0]

    for i in range(1, len(nums)):
        if nums[i] < 0:
            max_product, min_product = min_product, max_product

        max_product = max(nums[i], max_product * nums[i])
        min_product = min(nums[i], min_product * nums[i])

        result = max(result, max_product)

    return result",112
19669402800,sort_strings,"def sort_strings(strings):
    return sorted(strings, key=lambda s: (-len(s), s))

# Test cases
assert sort_strings([""apple"", ""banana"", ""pear"", ""orange""]) == [""banana"", ""orange"", ""apple"", ""pear""]
assert sort_strings([""dog"", ""cat"", ""elephant"", ""tiger""]) == [""elephant"", ""tiger"", ""cat"", ""dog""]
assert sort_strings([""hello"", ""world"", ""python"", ""code""]) == [""python"", ""hello"", ""world"", ""code""]",112
18180524081,has_cycle,"def has_cycle(graph):
    visited = set()
    rec_stack = set()

    def is_cyclic_util(v):
        visited.add(v)
        rec_stack.add(v)

        for neighbour in graph[v]:
            if neighbour not in visited:
                if is_cyclic_util(neighbour):
                    return True
            elif neighbour in rec_stack:
                return True

        rec_stack.remove(v)
        return False

    for v in graph:
        if v not in visited:
            if is_cyclic_util(v):
                return True

    return False",111
36161480567,min_operations_to_palindrome,"def min_operations_to_palindrome(s):
    n = len(s)
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(n):
        for j in range(n):
            dp[i + 1][j + 1] = dp[i][j] + 1 if s[i] == s[n - 1 - j] else max(dp[i][j + 1], dp[i + 1][j])
    return n - dp[n][n]",111
6878970289,longest_consecutive_subsequence,"def longest_consecutive_subsequence(nums):
    if not nums:
        return 0
    
    nums_set = set(nums)
    longest_streak = 0
    
    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",111
31080263785,valid_path,"from collections import deque

def valid_path(n, edges, source, destination):
    graph = [[] for _ in range(n)]
    
    for u,v in edges:
        graph[u].append(v)
        graph[v].append(u)
        
    q = deque([source])
    visited = set()
        
    while q:
        node = q.popleft()
        if node == destination:
            return True
        
        visited.add(node)
            
        for adj in graph[node]:
            if adj not in visited:
                q.append(adj)
    return False",111
37883147099,largest_subarray,"from collections import defaultdict

def largest_subarray(arr):
    max_len = 0
    sum = 0
    sum_dict = defaultdict(int)
    sum_dict[0] = -1
    for i in range(len(arr)):
        if arr[i] == 0:
            sum += -1
        else:
            sum += 1
        if sum in sum_dict:
            max_len = max(max_len, i - sum_dict[sum])
        else:
            sum_dict[sum] = i
    return max_len",111
4412387590,find_target_pairs,"from collections import Counter

def find_target_pairs(nums, target):
    """"""
    Finds the number of unique pairs in the list that sum up to the target value.
    """"""
    seen = Counter()
    output = set()
    
    for num in nums:
        complement = target - num
        if complement in seen and (num, complement) not in output and (complement, num) not in output:
            output.add((min(num, complement), max(num, complement)))
        seen[num] += 1
    
    return len(output)",111
3748949330,find_min_max,"def find_min_max(arr):
    if len(arr) == 1:
        return arr[0], arr[0]
    elif len(arr) == 2:
        return (min(arr[0], arr[1]), max(arr[0], arr[1]))
    else:
        mid = len(arr) // 2
        left_min, left_max = find_min_max(arr[:mid])
        right_min, right_max = find_min_max(arr[mid:])
        return min(left_min, right_min), max(left_max, right_max)",111
30024888198,quadratic_roots,"import math

def quadratic_roots(a, b, c):
    discriminant = b**2 - 4*a*c
    if discriminant < 0:
        return None
    elif discriminant == 0:
        root = -b / (2*a)
        return (root, root)
    else:
        root1 = (-b + math.sqrt(discriminant)) / (2*a)
        root2 = (-b - math.sqrt(discriminant)) / (2*a)
        return (root1, root2)",111
21760811250,is_almost_palindrome,"def is_almost_palindrome(str):
    left, right = 0, len(str) - 1
    while left < right:
        if str[left] != str[right]:
            # Check if removing str[left] or str[right] will make a palindrome
            return str[left + 1:right + 1] == str[left + 1:right + 1][::-1] or str[left:right] == str[left:right][::-1]
        left, right = left + 1, right - 1
    return True",111
40711947934,longest_consecutive_subsequence,"def longest_consecutive_subsequence(arr):
    if not arr:
        return 0

    num_set = set(arr)
    longest_streak = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",111
27598815306,isomorphic_strings,"def isomorphic_strings(a, b):
    da = {}   # item_name:a[i];item_value:b[i]
    db = {}   # item_name:b[i];item_value:a[i]
    for t in range(len(a)):
        aa, bb = da.get(a[t]), db.get(b[t])
        if aa == None and bb == None:
            da[a[t]] = b[t]
            db[b[t]] = a[t]
        elif aa != b[t] or bb != a[t]:
            return False
    return True",111
70248724341,smallest_Subsequence,"from collections import defaultdict

def smallest_Subsequence(s: str) -> str:
    last = defaultdict(int)
    for i, c in enumerate(s):
        last[c] = i
    
    stack = []
    seen = set()
    for i, c in enumerate(s):
        while stack and c < stack[-1] and i < last[stack[-1]] and c not in seen:
            seen.remove(stack.pop())
        if c not in seen:
            seen.add(c)
            stack.append(c)
    
    return ''.join(stack)",111
501997900,is_palindrome_removal,"def is_palindrome_removal(s):
    def check_palindrome(s, left, right, removed):
        while left < right:
            if s[left] != s[right]:
                if removed:
                    return False
                return check_palindrome(s, left + 1, right, True) or check_palindrome(s, left, right - 1, True)
            left += 1
            right -= 1
        return True

    return check_palindrome(s, 0, len(s) - 1, False)",111
40836475907,validate_ip,"def validate_ip(s: str) -> bool:
    def is_valid_part(s):
        # Judge if s is a valid part of IPv4 address
        return len(s) == 1 or (s[0] != '0' and int(s) <= 255)

    parts = s.split('.')
    if len(parts) != 4 or any(len(part) == 0 for part in parts):
        return False
    for part in parts:
        if not is_valid_part(part):
            return False
    return True",111
71651112200,is_valid_mountain_array,"def is_valid_mountain_array(arr):
    if len(arr) < 3:
        return False
    peak = 0
    for i in range(1, len(arr)):
        if arr[i] > arr[i-1]:
            peak = i
        else:
            break
    if peak == len(arr) - 1 or peak == 0:
        return False
    for i in range(peak, len(arr)-1):
        if arr[i] <= arr[i+1]:
            return False
    return True",111
646022271,is_valid_isbn,"def is_valid_isbn(isbn):
    if len(isbn) != 10 or (isbn[-1] != 'X' and not isbn[-1].isdigit()) or not isbn[:-1].isdigit():
        return False
    total = 0
    for i, digit in enumerate(isbn):
        if digit == 'X':
            total += 10 * (i + 1)
        else:
            total += int(digit) * (i + 1)
    return total % 11 == 0",111
25544395878,valid_palindrome,"def is_palindrome(s: str) -> bool:
    return s == s[::-1]

def valid_palindrome(s: str) -> bool:
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            one, two = s[left:right], s[left + 1:right + 1]
            return is_palindrome(one) or is_palindrome(two)
        left, right = left + 1, right - 1
    return True",111
27136044302,num_ways,"def num_ways(target):
    if target == 1 or target == 2:
        return 1
    dp = [0] * (target + 1)
    dp[1] = 1
    dp[2] = 1
    dp[3] = 2
    dp[4] = 3
    for i in range(5, target+1):
        dp[i] = dp[i-1] + dp[i-3] + dp[i-4]
    return dp[target]",111
31474204970,sort_colors,"def sort_colors(nums):
    low, mid, high = 0, 0, len(nums) - 1
    while mid <= high:
        if nums[mid] == 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1
    return nums",111
23822751309,smallest_sub_with_given_sum,"def smallest_sub_with_given_sum(arr, target_sum):
    window_sum = 0
    min_length = float('inf')
    window_start = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end] 
        while window_sum >= target_sum:
            min_length = min(min_length, window_end - window_start + 1)
            window_sum -= arr[window_start]
            window_start += 1
    if min_length == float('inf'):
        return 0
    return min_length",111
33038202888,smallest_subarray_with_given_sum,"def smallest_subarray_with_given_sum(arr, target_sum):
    window_sum = 0
    window_start = 0
    min_length = float('inf')
    for window_end in range(len(arr)):
        window_sum += arr[window_end]
        while window_sum >= target_sum:
            min_length = min(min_length, window_end - window_start + 1)
            window_sum -= arr[window_start]
            window_start += 1
    if min_length == float('inf'):
        return 0
    return min_length",111
20269226929,find_longest_consecutive,"def find_longest_consecutive(nums):
    if not nums:
        return 0
    nums_set = set(nums)
    longest_streak = 0
    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1
            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1
            longest_streak = max(longest_streak, current_streak)
    return longest_streak",111
33182777361,longestConcatenatedString,"from functools import lru_cache

def longestConcatenatedString(words):
    @lru_cache(None)
    def dfs(a, i):
        if i == len(words):
            return 0
        word = words[i]
        if any(word.count(c) > 1 or c in a for c in word):
            return dfs(a, i+1)
        ans = max(dfs(a, i+1), dfs(a+word, i+1) + len(word))
        return ans
    return dfs("""", 0)",111
6272644470,count_pairs,"def count_pairs(nums, k):
    num_dict = {}
    count = 0
    for num in nums:
        if num in num_dict:
            num_dict[num] += 1
        else:
            num_dict[num] = 1
    for num in num_dict:
        if num + k in num_dict:
            count += num_dict[num] * num_dict[num + k]
        if num - k in num_dict:
            count += num_dict[num] * num_dict[num - k]
    return count // 2",111
20605729620,find_longest_consecutive,"def find_longest_consecutive(nums):
    if not nums:
        return 0
    nums_set = set(nums)
    longest_streak = 0
    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1
            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1
            longest_streak = max(longest_streak, current_streak)
    return longest_streak",111
71575860345,longest_unique_substring,"def longest_unique_substring(str):
  start, max_length = 0, 0
  visited = [False] * 256
  for i in range(len(str)):
    if visited[ord(str[i])]:
      while str[i] != str[start]:
        visited[ord(str[start])] = False
        start += 1
      start += 1
    else:
      visited[ord(str[i])] = True
    max_length = max(max_length, i - start + 1)
  return max_length",111
29100335426,min_operations_to_palindrome,"def min_operations_to_palindrome(s):
    n = len(s)
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(n):
        for j in range(n):
            dp[i + 1][j + 1] = dp[i][j] + 1 if s[i] == s[n - 1 - j] else max(dp[i][j + 1], dp[i + 1][j])
    return n - dp[n][n]",111
2432968865,isNStraightHand,"from collections import Counter
def isNStraightHand(hand, groupSize):
    if len(hand) % groupSize != 0:
        return False
    hand.sort()
    card_counts = Counter(hand)
    while card_counts:
        start_card = min(card_counts.keys())
        for i in range(start_card, start_card + groupSize):
            if i not in card_counts:
                return False
            card_counts[i] -= 1
            if card_counts[i] == 0:
                del card_counts[i]
    return True",111
37568004443,generate_pascals_triangle,"def generate_pascals_triangle(n):
    if n == 0:
        return []
    result = [[1]]
    for i in range(2, n + 1):
        row = [0] * i
        row[0] = result[-1][0]
        row[-1] = result[-1][-1]
        for j in range(1, i - 1):
            row[j] = result[-1][j-1] + result[-1][j]
        result.append(row)
    return result",111
17627188529,largest_subarray_equal_0s_1s,"def largest_subarray_equal_0s_1s(arr):
    max_len = 0
    sum = 0
    sum_map = {}
    sum_map[0] = -1
    for i in range(len(arr)):
        if arr[i] == 0:
            sum -= 1
        else:
            sum += 1
        if sum in sum_map:
            max_len = max(max_len, i - sum_map[sum])
        else:
            sum_map[sum] = i
    return max_len",111
2279500046,shortest_subarray,"def shortest_subarray(nums, target):
    if not nums:
        return 0
    l, r = 0, 0
    length = float('inf')
    current_sum = 0

    while r < len(nums):
        current_sum += nums[r]
        r += 1

        while current_sum >= target:
            if r - l < length:
                length = r - l
            current_sum -= nums[l]
            l += 1
    return length if length != float('inf') else 0",111
12917128153,subarray_sum,"from typing import List

def subarray_sum(nums: List[int], k: int) -> int:
    count = 0
    sum_ = 0
    sum_dict = {0: 1}
    for num in nums:
        sum_ += num
        if sum_ - k in sum_dict:
            count += sum_dict[sum_ - k]
        if sum_ in sum_dict:
            sum_dict[sum_] += 1
        else:
            sum_dict[sum_] = 1
    return count",111
34480227828,longest_consecutive_subseq,"def longest_consecutive_subseq(nums):
    if not nums:
        return 0

    nums_set = set(nums)
    longest_streak = 0

    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",111
36472272460,catalan_number,"def catalan_number(n):
    if n == 0 or n == 1:
        return 1

    catalan = [0 for _ in range(n + 1)]
    catalan[0] = 1
    catalan[1] = 1

    for i in range(2, n + 1):
        catalan[i] = 0
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]

    return catalan[n]",111
2522331157,find_subarrays,"def find_subarrays(arr, k):
    count = 0
    prefix_sum = 0
    sum_counts = {0: 1}  # Dictionary to store the count of prefix sums
    for num in arr:
        prefix_sum += num
        if prefix_sum - k in sum_counts:
            count += sum_counts[prefix_sum - k]
        if prefix_sum in sum_counts:
            sum_counts[prefix_sum] += 1
        else:
            sum_counts[prefix_sum] = 1
    return count",111
33446888991,find_middle_element,"class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def linked_list(arr):
    head = ListNode(arr[0])
    current = head
    for i in range(1, len(arr)):
        current.next = ListNode(arr[i])
        current = current.next
    return head

def find_middle_element(head):
    slow = head
    fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow.val",111
17460860009,is_catalan,"def is_catalan(n):
    if n <= 1:
        return 1

    catalan = [0 for _ in range(n+1)]
    catalan[0] = 1
    catalan[1] = 1

    for i in range(2, n + 1):
        catalan[i] = 0
        for j in range(i):
            catalan[i] = catalan[i] + catalan[j] * catalan[i-j-1]

    return catalan[n]",111
16557899745,is_strict_palindrome,"def is_strict_palindrome(s):
    return s == s[::-1]

def test_strict_palindrome():
    test_cases = [
        (""A man, a plan, a canal: Panama"", False),
        (""race a car"", False),
        (""madam"", True),
        (""step on no pets"", True),
    ]
    for s, expected in test_cases:
        assert is_strict_palindrome(s) == expected, f""Failed for {s}""
    print(""All test cases passed."")

test_strict_palindrome()",111
26828993618,has_cycle,"def has_cycle(graph):
    visited = set()
    rec_stack = set()

    def is_cyclic_util(vertex):
        visited.add(vertex)
        rec_stack.add(vertex)

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                if is_cyclic_util(neighbor):
                    return True
            elif neighbor in rec_stack:
                return True

        rec_stack.remove(vertex)
        return False

    for vertex in graph:
        if vertex not in visited:
            if is_cyclic_util(vertex):
                return True
    return False",111
42497118495,binary_search_index,"def binary_search_index(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            if mid == 0 or arr[mid - 1] < target:
                return mid
            else:
                right = mid - 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1",111
23492821407,bfs_tra,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

from collections import deque

def bfs_tra(root):
    if not root:
        return []
    res = []
    q = deque([root])
    
    while q:
        node = q.popleft()
        res.append(node.val)
        if node.left:
            q.append(node.left)
        if node.right:
            q.append(node.right)
    
    return res",111
35129407643,top_k_frequent_elements,"import heapq
from collections import defaultdict

def top_k_frequent_elements(nums, k):
    freqDict = defaultdict(int)
    for num in nums:
        freqDict[num] += 1

    ans = []
    maxheap = [ (-freq, num) for num, freq in freqDict.items() ]
    heapq.heapify(maxheap)

    while heapq and k > 0:
        nfreq, curnum = heapq.heappop(maxheap)
        ans.append(curnum)
        k -= 1
    return ans",111
16341553464,count_pairs_with_diff,"def count_pairs_with_diff(arr, diff):
    arr.sort()
    count = 0
    left, right = 0, 1
    while right < len(arr):
        current_diff = arr[right] - arr[left]
        if current_diff == diff:
            count += 1
            left += 1
            right += 1
        elif current_diff < diff:
            right += 1
        else:
            left += 1
            if left == right:
                right += 1
    return count",110
11252338932,reorder_log_files,"def reorder_log_files(logs):
    alphas = []
    digits = []
        
    for log in logs:
        split_arr = log.split("" "")
        head, tail = split_arr[0], "" "".join(split_arr[1:])
            
        if tail[0].isalpha():
            alphas.append([tail, head])
        else:
            digits.append("" "".join([head, tail]))
    alphas.sort()
    alphas = ["" "".join(elem[::-1]) for elem in alphas]
    return alphas + digits",110
34917908314,findMaxConsecutiveOnes,"def findMaxConsecutiveOnes(nums):
    n = len(nums)
    count = 0
    start = 0
    max_length = 0
    zero_index = -1

    for i in range(n):
        if nums[i] == 0:
            count += 1
        if count > 1:
            if nums[start] == 0:
                count -= 1
            start += 1
        max_length = max(max_length, i - start)
    return max_length + 1",110
36844403138,smallest_subarray_with_given_sum,"def smallest_subarray_with_given_sum(arr, target):
    window_sum = 0
    min_length = float('inf')
    window_start = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end] 
        while window_sum >= target:
            min_length = min(min_length, window_end - window_start + 1)
            window_sum -= arr[window_start]
            window_start += 1
    if min_length == float('inf'):
        return 0
    return min_length",110
74061146306,recursive_sum,"def recursive_sum(numbers):
    if len(numbers) == 0:
        return 0
    else:
        return numbers[0] + recursive_sum(numbers[1:])

# Test cases
print(recursive_sum([1, 2, 3, 4, 5]))  # 15
print(recursive_sum([10, 20, 30]))  # 60
print(recursive_sum([1, 1, 1, 1, 1]))  # 5",110
22605432021,longest_unique_substring,"def longest_unique_substring(s: str) -> str:
    char_map = {}
    left = 0
    result = """"
    max_length = 0

    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)

        char_map[s[right]] = right

        if right - left + 1 > max_length:
            max_length = right - left + 1
            result = s[left:right+1]

    return result",110
70408068919,min_sub_array_len,"def min_sub_array_len(x, nums):
    if not nums:
        return 0
    n = len(nums)
    min_len = float('inf')
    i = 0
    current_sum = 0
    for j in range(n):
        current_sum += nums[j]
        while current_sum >= x:
            min_len = min(min_len, j - i + 1)
            current_sum -= nums[i]
            i += 1
    return 0 if min_len == float('inf') else min_len",110
1160494117,isStrobogrammatic,"def isStrobogrammatic(num):
    for c in num:
        if c in '23457':
            return False
    nmap = {'6':'9', '9':'6', '0':'0', '1':'1', '8':'8'}
    i = 0
    j = len(num) - 1
    while i <= j:
        if nmap[num[i]] != num[j]:
            return False
        i += 1
        j -= 1
    return True",110
8539110076,longest_consecutive_sequence,"def longest_consecutive_sequence(nums):
    if not nums:
        return 0

    num_set = set(nums)
    longest_streak = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",110
16312238561,n_queens,"def n_queens(n):
    def dfs(queens, xy_diff, xy_sum):
        p = len(queens)
        if p==n:
            result.append(queens)
            return None
        for q in range(n):
            if q not in queens and p-q not in xy_diff and p+q not in xy_sum: 
                dfs(queens+[q], xy_diff+[p-q], xy_sum+[p+q])  
    result = []
    dfs([], [], [])
    return len(result)",110
18586935364,days_in_month,"def is_leap_year(year: int) -> bool:
    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)

def days_in_month(year: int, month: int) -> int:
    if month in [4, 6, 9, 11]:
        return 30
    if month == 2:
        return 29 if is_leap_year(year) else 28
    return 31",110
34881820792,replace_vowels,"def replace_vowels(s):
    vowel_map = {'a': 'e', 'e': 'i', 'i': 'o', 'o': 'u', 'u': 'a', 'A': 'E', 'E': 'I', 'I': 'O', 'O': 'U', 'U': 'A'}
    new_str = """"
    for char in s:
        if char in vowel_map:
            new_str += vowel_map[char]
        else:
            new_str += char
    return new_str",110
26844956698,find_largest_sum_of_squares,"def find_largest_sum_of_squares(nums):
    def is_sum_of_squares(n):
        i = 0
        while i * i <= n:
            j = int((n - i * i) ** 0.5)
            if i * i + j * j == n:
                return True
            i += 1
        return False

    largest = -1
    for num in nums:
        if is_sum_of_squares(num) and num > largest:
            largest = num
    return largest",110
70758449156,reverse_integer,"def reverse_integer(x):
    reversed_int = 0
    sign = -1 if x < 0 else 1
    x *= sign

    while x != 0:
        digit = x % 10
        x = x // 10
        reversed_int = reversed_int * 10 + digit

    reversed_int *= sign

    if reversed_int < -2**31 or reversed_int > 2**31 - 1:
        return 0
    else:
        return reversed_int",110
70848162298,is_rectangle_intersect,"from typing import List


def is_rectangle_intersect(rect1: List[int], rect2: List[int]) -> bool:
    # Check if one rectangle is to the left of the other
    if rect1[2] <= rect2[0] or rect2[2] <= rect1[0]:
        return False
    
    # Check if one rectangle is above the other
    if rect1[3] <= rect2[1] or rect2[3] <= rect1[1]:
        return False
    
    return True",110
40709187994,longest_consecutive_sequence,"def longest_consecutive_sequence(nums):
    if not nums:
        return 0

    nums_set = set(nums)
    longest_streak = 0

    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",110
74951088760,can_form_word,"from collections import defaultdict

def can_form_word(word, letters):
    """"""
    :type word: str
    :type letters: str
    :rtype: bool
    """"""
    
    letters_char = defaultdict(int)
    for char in letters: 
        letters_char[char] += 1
    for letter in word: 
        if letter not in letters_char: 
            return False
        letters_char[letter] -= 1
        if letters_char[letter] < 0:
            return False
          
    return True",110
41186076069,find_largest_palindrome,"def find_largest_palindrome(min_limit, max_limit):
    def is_palindrome(num):
        return str(num) == str(num)[::-1]
    
    largest_palindrome = 0
    for i in range(max_limit, min_limit - 1, -1):
        for j in range(i, min_limit - 1, -1):
            product = i * j
            if product <= largest_palindrome:
                break
            if is_palindrome(product):
                largest_palindrome = product
    return largest_palindrome",110
32876131211,ways_to_express,"def ways_to_express(target):
    ways = [0] * (target + 1)
    ways[0] = 1
    for i in range(1, target + 1):
        if i - 1 >= 0:
            ways[i] += ways[i - 1]
        if i - 3 >= 0:
            ways[i] += ways[i - 3]
        if i - 4 >= 0:
            ways[i] += ways[i - 4]
    return ways[target]",110
294584959,max_product_three,"def max_product_three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])

assert max_product_three([1, 2, 3, 4]) == 24
assert max_product_three([1, 10, 2, 6, 5, 3]) == 300
assert max_product_three([-1, -2, -3, 1]) == 6",110
14674494150,look_and_say,"def look_and_say(n):
    term = '1'
    for _ in range(n - 1):
        seq_arr = [[term[0], 1]]
        for i in range(1, len(term)):
            if term[i] == term[i-1]: seq_arr[-1][1] += 1
            else: seq_arr.append([term[i], 1])
        term = ''
        for ele in seq_arr:
            term += (str(ele[1]) + str(ele[0]))
    return term",110
2290929849,longest_unique_subarray,"def longest_unique_subarray(arr):
    """"""
    Finds the length of the longest subarray with all unique elements.

    :param arr: list[int]
    :return: int
    """"""
    start = 0
    max_len = 0
    seen = {}
    for end, value in enumerate(arr):
        if value in seen:
            start = max(start, seen[value] + 1)
        seen[value] = end
        max_len = max(max_len, end - start + 1)
    return max_len",110
71473578678,max_product_pair,"def max_product_pair(arr):
    arr.sort()
    return max(arr[0] * arr[1], arr[-1] * arr[-2])

# Testing the function
assert max_product_pair([1, 5, 3, 4, 7, 2]) == 35
assert max_product_pair([0, -1, -2, -3, -4]) == 12
assert max_product_pair([1, 2, 3, 4, 5]) == 20",110
30122662948,unique_pairs,"from collections import defaultdict

def unique_pairs(nums, k):
    if k < 0:
        return 0

    store = defaultdict(list)

    for index, num in enumerate(nums):
        store[num].append(index)

    result = set()

    for num in store:
        needle = k + num

        if needle in store:
            for i in store[num]:
                for j in store[needle]:
                    if i != j:
                        result.add((min(num, needle), max(num, needle)))

    return len(result)",110
35415357114,first_missing_positive,"def first_missing_positive(nums):
    if not nums:
        return 1
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",110
34057456368,string_compression,"def string_compression(s):
    if len(s) <= 1:
        return s
    result = []
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            count += 1
        else:
            result.append(s[i-1] + str(count))
            count = 1
    result.append(s[-1] + str(count))
    compressed = ''.join(result)
    return compressed if len(compressed) < len(s) else s",110
23136609361,min_max,"def min_max(arr):
    if len(arr) == 1:
        return (arr[0], arr[0])
    elif len(arr) == 2:
        return (min(arr[0], arr[1]), max(arr[0], arr[1]))
    else:
        mid = len(arr) // 2
        left_min, left_max = min_max(arr[:mid])
        right_min, right_max = min_max(arr[mid:])
        return (min(left_min, right_min), max(left_max, right_max))",110
35673734388,merge_sorted_arrays,"def merge_sorted_arrays(arr1, arr2):
    merged = []
    i = j = 0
    while i < len(arr1) and j < len(arr2):
        if arr1[i] <= arr2[j]:
            merged.append(arr1[i])
            i += 1
        else:
            merged.append(arr2[j])
            j += 1
    if i < len(arr1):
        merged.extend(arr1[i:])
    if j < len(arr2):
        merged.extend(arr2[j:])
    return merged",110
20504948225,levenshtein_distance,"def levenshtein_distance(s, t):
    if s == """":
        return len(t)
    if t == """":
        return len(s)
    if s[-1] == t[-1]:
        cost = 0
    else:
        cost = 1
       
    res = min([levenshtein_distance(s[:-1], t)+1,
               levenshtein_distance(s, t[:-1])+1, 
               levenshtein_distance(s[:-1], t[:-1]) + cost])
    return res",110
27046921032,max_overlap,"from typing import List

def max_overlap(intervals: List[tuple]) -> int:
    events = []
    for start, end in intervals:
        events.append((start, 1))  # 1 for start of an interval
        events.append((end, -1))   # -1 for end of an interval

    events.sort()
    max_overlap = current_overlap = 0
    for _, delta in events:
        current_overlap += delta
        max_overlap = max(max_overlap, current_overlap)

    return max_overlap",110
8545737511,largest_palindrome_product,"def largest_palindrome_product(n):
    def is_palindrome(x):
        return str(x) == str(x)[::-1]

    largest = 0
    for i in range(10**n - 1, 10**(n-1) - 1, -1):
        for j in range(i, 10**(n-1) - 1, -1):
            product = i * j
            if is_palindrome(product) and product > largest:
                largest = product
    return largest",110
5975058792,longest_subarray,"def longest_subarray(arr):
    sum = 0
    max_length = 0
    sum_map = {}
    for i in range(len(arr)):
        if arr[i] == 0:
            sum -= 1
        else:
            sum += 1
        if sum == 0:
            max_length = i + 1
        if sum in sum_map:
            max_length = max(max_length, i - sum_map[sum])
        else:
            sum_map[sum] = i
    return max_length",110
11634659738,longest_consecutive_sequence,"def longest_consecutive_sequence(nums):
    if not nums:
        return 0

    num_set = set(nums)
    longest_streak = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",110
22935755140,find_missing_positive,"def find_missing_positive(nums):
    if not nums:
        return 1

    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",110
11643927208,countAndSay,"def countAndSay(n):
    if n == 1:
        return ""1""
    previous_term = countAndSay(n - 1)
    result = """"
    count = 1
    for i in range(1, len(previous_term)):
        if previous_term[i] == previous_term[i - 1]:
            count += 1
        else:
            result += str(count) + previous_term[i - 1]
            count = 1
    result += str(count) + previous_term[-1]
    return result",110
15863513490,count_subarrays_with_sum,"def count_subarrays_with_sum(nums, k):
    count, current_sum = 0, 0
    sum_dict = {0: 1}  # Initialize with sum 0 having count 1

    for num in nums:
        current_sum += num

        if current_sum - k in sum_dict:
            count += sum_dict[current_sum - k]

        if current_sum in sum_dict:
            sum_dict[current_sum] += 1
        else:
            sum_dict[current_sum] = 1

    return count",110
4043395996,search_insert,"class Solution:
    def searchInsert(self, nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left

def search_insert(nums, target):
    solution = Solution()
    return solution.searchInsert(nums, target)",110
29545617581,decode_string,"def decode_string(s):
    stack = []
    cur_num = 0
    res = []
    for c in s:
        if c.isdigit():
            cur_num = 10 * cur_num + int(c)
        elif c == '[':
            stack.append( (cur_num, len(res)))
            cur_num = 0
        elif c == ']':
            rep, pos = stack.pop()
            res.extend(res[pos:] * (rep - 1))
        else:
            res.append(c)

    return ''.join(res)",110
16514017668,find_combinations,"def find_combinations(candidates, target):
    res = []
    path = []
    candidates.sort()

    def backtracking(candidates, target, start_idx):
        if target == 0:
            res.append(path[:])
            return
        for i in range(start_idx, len(candidates)):
            if candidates[i] > target:
                return
            path.append(candidates[i])
            backtracking(candidates, target - candidates[i], i)
            path.pop()

    backtracking(candidates, target, 0)
    return res",110
16314248878,is_valid_password,"import re

def is_valid_password(password: str) -> bool:
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%^&*()-_=+\\[\\]{}|;:'\"",./<>?]"", password):
        return False
    return True",110
44737925629,firstMissingPositive,"def firstMissingPositive(nums):
    if not nums:
        return 1
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",110
73900212269,max_product_subarray,"def max_product_subarray(nums):
    if not nums:
        return 0
    max_prod = nums[0]
    min_prod = nums[0]
    result = nums[0]
    for i in range(1, len(nums)):
        curr = nums[i]
        temp_max = max(curr, max_prod * curr, min_prod * curr)
        min_prod = min(curr, max_prod * curr, min_prod * curr)
        max_prod = temp_max
        result = max(result, max_prod)
    return result",110
39659112840,count_pairs_with_diff_k,"def count_pairs_with_diff_k(arr, k):
    count = 0
    arr.sort()
    i, j = 0, 1
    while j < len(arr):
        if arr[j] - arr[i] == k:
            count += 1
            i += 1
            j += 1
        elif arr[j] - arr[i] < k:
            j += 1
        else:
            i += 1
            if i == j:
                j += 1
    return count",110
9306142587,levenshtein_distance,"def levenshtein_distance(s, t):
    if s == """":
        return len(t)
    if t == """":
        return len(s)
    if s[-1] == t[-1]:
        cost = 0
    else:
        cost = 1
       
    res = min([levenshtein_distance(s[:-1], t)+1,
               levenshtein_distance(s, t[:-1])+1, 
               levenshtein_distance(s[:-1], t[:-1]) + cost])
    return res",110
32538172175,maxSubarrayLength,"def maxSubarrayLength(nums, k):
    max_length = 0
    current_sum = 0
    sum_index = {}
    for i in range(len(nums)):
        current_sum += nums[i]
        if current_sum == k:
            max_length = i + 1
        if (current_sum - k) in sum_index:
            max_length = max(max_length, i - sum_index[current_sum - k])
        if current_sum not in sum_index:
            sum_index[current_sum] = i
    return max_length",110
70848189818,next_permutation,"def next_permutation(nums):
    n = len(nums)
    i = n - 2
    while i >= 0 and nums[i] >= nums[i + 1]:
        i -= 1
    if i >= 0:
        j = n - 1
        while j >= 0 and nums[i] >= nums[j]:
            j -= 1
        nums[i], nums[j] = nums[j], nums[i]
    nums[i + 1:] = reversed(nums[i + 1:])
    return nums",110
9077144624,Levenshtein_distance,"def Levenshtein_distance(s, t):
    if s == """":
        return len(t)
    if t == """":
        return len(s)
    if s[-1] == t[-1]:
        cost = 0
    else:
        cost = 1
       
    res = min([Levenshtein_distance(s[:-1], t)+1,
               Levenshtein_distance(s, t[:-1])+1, 
               Levenshtein_distance(s[:-1], t[:-1]) + cost])
    return res",110
26281650290,longest_consecutive_sequence,"def longest_consecutive_sequence(nums):
    if not nums:
        return 0

    nums_set = set(nums)
    longest_streak = 0

    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",110
71230420086,longest_unique_substtr,"def longest_unique_substtr(s):
    seen = {}
    start = 0
    max_length = 0
    max_substring = """"
    for end, char in enumerate(s):
        if char in seen and start <= seen[char]:
            start = seen[char] + 1
        else:
            if end - start + 1 > max_length:
                max_length = end - start + 1
                max_substring = s[start:end+1]
        seen[char] = end
    return max_substring",110
44176877540,calculate_combinations,"def calculate_combinations(n, k):
    if k == 0 or k == n:
        return 1
    if k > n:
        return 0
    # Using the formula for combinations with repetition: C(n+k-1, k)
    numerator = 1
    for i in range(n+k-1, n-1, -1):
        numerator *= i
    denominator = 1
    for i in range(1, k+1):
        denominator *= i
    return numerator // denominator",109
6962748886,first_non_repeating_char,"def first_non_repeating_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return """"

assert first_non_repeating_char(""programming"") == ""p""
assert first_non_repeating_char(""leetcode"") == ""l""
assert first_non_repeating_char(""aabbcc"") == """"",109
70271678266,findLongestConsecutiveSubsequence,"def findLongestConsecutiveSubsequence(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",109
30505781581,unique_paths,"def unique_paths(m, n):
    if not m and not n:
        return 0

    dp = [[0 for _ in range(m)] for _ in range(n)]

    for i in range(n):
        for j in range(m):
            if i == 0 or j == 0:
                dp[i][j] = 1
            else:
                dp[i][j] = dp[i-1][j] + dp[i][j-1]

    return dp[n-1][m-1]",109
71011145029,month_name,"def month_name(month_num):
    months = {
        1: 'January',
        2: 'February',
        3: 'March',
        4: 'April',
        5: 'May',
        6: 'June',
        7: 'July',
        8: 'August',
        9: 'September',
        10: 'October',
        11: 'November',
        12: 'December'
    }
    return months.get(month_num, 'Invalid')",109
23986424167,find_fibonacci,"def find_fibonacci(n):
    fib = [0, 1, 1]
    if n < 3:
        return fib[n]
    for i in range(3, n+1):
        fib.append(fib[i-1] + fib[i-2])
    return fib[n]

if __name__ == '__main__':
    assert find_fibonacci(1) == 1
    assert find_fibonacci(2) == 1
    assert find_fibonacci(5) == 5",109
32684558111,countPaths,"def countPaths(m,n):
    dp = [[0 for i in range(n)] for j in range(m)]
    for i in range(m):
        dp[i][0] = 1
    for i in range(n):
        dp[0][i] = 1
    for i in range(1,m):
        for j in range(1,n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[m-1][n-1]",109
1759514412,findCircleNum,"from collections import deque

def findCircleNum(M):
    def bfs(node):
        queue = deque([node])
        while queue:
            current = queue.popleft()
            for neighbor in range(len(M)):
                if M[current][neighbor] == 1 and neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)

    visited = set()
    count = 0
    for i in range(len(M)):
        if i not in visited:
            bfs(i)
            count += 1
    return count",109
14159274632,isHappy,"def isHappy(n):
    def get_next(n):
        total_sum = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total_sum += digit ** 2
        return total_sum
    slow_runner = n
    fast_runner = get_next(n)
    while fast_runner != 1 and slow_runner != fast_runner:
        slow_runner = get_next(slow_runner)
        fast_runner = get_next(get_next(fast_runner))
    return fast_runner == 1",109
13354979460,lengthLongestPath,"def lengthLongestPath(input: str) -> int:
    max_len = 0
    path_len = {0: 0}
    for line in input.splitlines():
        name = line.lstrip('\t')
        depth = len(line) - len(name)
        if '.' in name:
            max_len = max(max_len, path_len[depth] + len(name))
        else:
            path_len[depth + 1] = path_len[depth] + len(name) + 1
    return max_len",109
27655519710,ways_to_sum,"def ways_to_sum(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        if i - 1 >= 0:
            dp[i] += dp[i - 1]
        if i - 3 >= 0:
            dp[i] += dp[i - 3]
        if i - 4 >= 0:
            dp[i] += dp[i - 4]
    return dp[n]",109
20696385097,find_pair_for_sum,"def find_pair_for_sum(arr, target):
    """"""
    Check if there exists two elements in the list that add up to the target integer.
    Parameters:
    arr (list): a list of integers.
    target (int): target integer.
    Returns:
    bool: True if there exists two elements that add up to the target integer, otherwise False.
    """"""
    seen_numbers = set()
    for number in arr:
        if target - number in seen_numbers:
            return True
        seen_numbers.add(number)
    return False",109
22827862497,max_non_overlapping_intervals,"def max_non_overlapping_intervals(intervals):
    """"""
    Finds the maximum number of non-overlapping intervals.

    :param intervals: List of intervals represented as [start, end]
    :return: Maximum number of non-overlapping intervals
    """"""
    intervals.sort(key=lambda x: x[1])
    count = 0
    end_time = float('-inf')
    for interval in intervals:
        if interval[0] >= end_time:
            count += 1
            end_time = interval[1]
    return count",109
16069959428,uniqueNames,"def uniqueNames(names):
    uniqueNames = set()
    orderedNames = []
    for name in names:
        if name in uniqueNames:
            i = 1
            currentName = f'{name}({i})'
            while currentName in uniqueNames:
                i += 1
                currentName = f'{name}({i})'
            uniqueNames.add(currentName)
            orderedNames.append(currentName)
        else:
            uniqueNames.add(name)
            orderedNames.append(name)
    return list(orderedNames)",109
25367545562,is_valid_bracket_sequence,"def is_valid_bracket_sequence(s: str) -> bool:
    bracket_map = {')': '(', '}': '{', ']': '['}
    open_brackets = set(['(', '{', '['])
    stack = []

    for char in s:
        if char in open_brackets:
            stack.append(char)
        elif char in bracket_map:
            if stack == [] or bracket_map[char] != stack.pop():
                return False
        else:
            # Ignore non-bracket characters
            continue

    return stack == []",109
31042072920,find_longest_substring,"def find_longest_substring(s):
    char_set = set()
    left = 0
    max_length = 0
    longest_substring = """"

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        if right - left + 1 > max_length:
            max_length = right - left + 1
            longest_substring = s[left:right+1]

    return longest_substring",109
29756880447,largest_divisible_by_5,"def largest_divisible_by_5(N):
    if N < 5:
        return -1
    else:
        return N - (N % 5)

# check function to test the solution with the given data points
def check_solution():
    assert largest_divisible_by_5(20) == 20
    assert largest_divisible_by_5(5) == 5
    assert largest_divisible_by_5(3) == -1
    print(""All test cases passed"")

check_solution()",109
2365549161,is_valid_ipv4,"import re
def is_valid_ipv4(ip):
  ip_fetch = re.compile(r""""""^(?:
                            (?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
                            (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)
                          )$"""""")
  result = ip_fetch.search(ip)
  return bool(result)",109
74124773606,find_largest_palindrome,"def find_largest_palindrome(max_num, min_num):
    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    largest_palindrome = 0
    for i in range(max_num, min_num - 1, -1):
        for j in range(i, min_num - 1, -1):
            product = i * j
            if product <= largest_palindrome:
                break
            if is_palindrome(product):
                largest_palindrome = product
    return largest_palindrome",109
16591931751,length_of_longest_zero_sum_subarray,"def length_of_longest_zero_sum_subarray(arr):
    max_length = 0
    sum_map = {0: -1}
    current_sum = 0
    
    for i in range(len(arr)):
        current_sum += arr[i]
        
        if current_sum in sum_map:
            start_index = sum_map[current_sum] + 1
            length = i - start_index + 1
            max_length = max(max_length, length)
        else:
            sum_map[current_sum] = i
            
    return max_length",109
29168942455,maxSubarraySumCircular,"def maxSubarraySumCircular(nums):
    max_sum = current_max = current_min = min_sum = total_sum = nums[0]
    for num in nums[1:]:
        current_max = max(current_max + num, num)
        max_sum = max(max_sum, current_max)
        current_min = min(current_min + num, num)
        min_sum = min(min_sum, current_min)
        total_sum += num
    return max(max_sum, total_sum - min_sum) if total_sum != min_sum else max_sum",109
43578806948,is_mountain_array,"def is_mountain_array(arr):
    if len(arr) < 3:
        return False
    peak = 0
    for i in range(len(arr)-1):
        if arr[i] < arr[i+1]:
            peak = i+1
        else:
            break
    if peak == 0 or peak == len(arr)-1:
        return False
    for i in range(peak, len(arr)-1):
        if arr[i] <= arr[i+1]:
            return False
    return True",109
21290986707,longest_unique_substring,"def longest_unique_substring(s):
    char_map = {}
    left = 0
    max_len = 0
    start = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        if right - left + 1 > max_len:
            max_len = right - left + 1
            start = left
    return s[start:start + max_len]",109
131021030,smallest_subarray_with_given_sum,"def smallest_subarray_with_given_sum(arr, target_sum):
    window_sum = 0
    min_length = float('inf')
    window_start = 0
    
    for window_end in range(len(arr)):
        window_sum += arr[window_end]
        
        while window_sum >= target_sum:
            min_length = min(min_length, window_end - window_start + 1)
            window_sum -= arr[window_start]
            window_start += 1
    
    return min_length if min_length != float('inf') else 0",109
4121230533,longest_consec,"def longest_consec(nums):
    if not nums:
        return 0
    num_set = set(nums)
    longest_streak = 0
    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1
            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1
            longest_streak = max(longest_streak, current_streak)
    return longest_streak",109
10235044787,find_longest_substring,"def find_longest_substring(s):
    char_set = set()
    left = 0
    max_length = 0
    max_substring = """"
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        if right - left + 1 > max_length:
            max_length = right - left + 1
            max_substring = s[left:right+1]
    return max_substring",109
40717231615,longest_consecutive,"def longest_consecutive(nums):
    if not nums:
        return 0

    nums_set = set(nums)
    longest_streak = 0

    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",109
35090863589,find_triplets,"def find_triplets(nums):
    nums.sort()
    for i in range(len(nums)-2):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        left, right = i+1, len(nums)-1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                return True
    return False",109
70928300026,top_k_frequent_elements,"import collections
def top_k_frequent_elements(nums, k):
    res = []
    # 用字典存储出现的频率
    dic = {}
    for i in nums:
        if i not in dic:
            dic[i]=1
        else:
            dic[i]+=1
    kd = collections.OrderedDict(sorted(dic.items(),key=lambda x:x[1],reverse=True))
    for key in kd.keys():
        if len(res)<k:
            res.append(key)
        else:
            break
    return res",109
43619286168,countSubarraysWithSum,"from typing import List

def countSubarraysWithSum(nums: List[int], k: int) -> int:
    count = 0
    sum = 0
    hash_map = {0:1}
    
    for i in range(len(nums)):
        sum += nums[i]
        if sum-k in hash_map:
            count += hash_map[sum-k]
        if sum in hash_map:
            hash_map[sum] += 1
        else:
            hash_map[sum] = 1
            
    return count",109
39697952709,romanToInt,"def romanToInt(s):
    values = {""I"":1, ""V"":5, ""X"":10, ""L"":50, ""C"":100, ""D"":500, ""M"":1000}
    total = 0
    prev = 0
    for letter in s:
        curr = values[letter]
        if curr > prev:
            total += curr - 2*prev
        else:
            total += curr
        prev = curr
    return total",109
9656640831,min_subarray_len,"def min_subarray_len(target: int, nums: list[int]) -> int:
    l = 0
    r = 0
    total = 0
    minSize = float('inf')
    
    while r < len(nums):
        total += nums[r]
        while total >= target:
            minSize = min(minSize, r-l+1)
            total -= nums[l]
            l += 1
        r += 1

    return minSize if minSize != float('inf') else 0",109
36663300179,longestConsecutive,"def longestConsecutive(nums):
    if not nums:
        return 0

    nums_set = set(nums)
    longest_streak = 0

    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",109
27343207936,number_to_month,"def number_to_month(num):
    months = {
        1: ""January"",
        2: ""February"",
        3: ""March"",
        4: ""April"",
        5: ""May"",
        6: ""June"",
        7: ""July"",
        8: ""August"",
        9: ""September"",
        10: ""October"",
        11: ""November"",
        12: ""December"",
    }
    return months.get(num, ""Invalid month"")",109
22531664355,reverse_vowels,"def reverse_vowels(s):
    vowels = 'aeiouAEIOU'
    s = list(s)
    i, j = 0, len(s) - 1
    while i < j:
        if s[i] not in vowels:
            i += 1
        elif s[j] not in vowels:
            j -= 1
        else:
            s[i], s[j] = s[j], s[i]
            i += 1
            j -= 1
    return ''.join(s)",109
5201783259,is_latin_square,"def is_latin_square(matrix):
    n = len(matrix)
    for row in range(n):
        seen = [None] * (n + 1)
        seen_c = [None] * (n + 1)
        for column in range(n):
            v = matrix[row][column]
            vc = matrix[column][row]
            if seen[v] is True or seen_c[vc] is True:
                return False
            seen[v] = True
            seen_c[vc] = True
    return True",109
17978546967,bank_savings,"def bank_savings(n):
    weeks = n // 7
    days = n % 7
    first_week = (1 + 2 + 3 + 4 + 5 + 6 + 7)
    result = 0
    result += weeks * first_week
    for i in range(weeks):
        result += 7 * i
    for i in range(1, days + 1):
        result += i + weeks
    return result

print(bank_savings(7))",109
74305976760,max_consecutive_ones,"def max_consecutive_ones(nums):
    left, right, zeroCount, maxCount = 0, 0, 0, 0
    while right < len(nums):
        if nums[right] == 0:
            zeroCount += 1
        while zeroCount > 1:
            if nums[left] == 0:
                zeroCount -= 1
            left += 1
        maxCount = max(maxCount, right - left + 1)
        right += 1
    return maxCount",109
7469424143,minimum_moves_to_palindrome,"def minimum_moves_to_palindrome(numbers):
    n = len(numbers)
    left, right = 0, n - 1
    moves = 0
    while left < right:
        moves += abs(numbers[left] - numbers[right])
        if numbers[left] > numbers[right]:
            numbers[left] -= numbers[right]
            numbers[right] = 0
        else:
            numbers[right] -= numbers[left]
            numbers[left] = 0
        left += 1
        right -= 1
    return moves",109
34758510492,word_break,"from collections import deque

def word_break(s, wordDict):
    queue = deque([s])
    word_set = set(wordDict)
    seen = set()
        
    while queue:
        word = queue.popleft()
        if word in word_set or len(word) == 0:
            return True
            
        for i in range(1, len(word)+1):
            if word[:i] in word_set and word[i:] not in seen:
                queue.append(word[i:])
                seen.add(word[i:])
                    
    return False",109
32284727255,number_of_ways,"def number_of_ways(n):
    if n == 0 or n == 1:
        return 1
    elif n == 2:
        return 1
    elif n == 3:
        return 2
    else:
        a, b, c, d = 1, 1, 1, 2
        for i in range(4, n+1):
            d = a + b + c
            a, b, c = b, c, d
        return d",109
74795245705,max_length_equal,"def max_length_equal(arr):
    max_len = 0
    sum = 0
    n = len(arr)
    sum_map = {}
    sum_map[0] = -1
    for i in range(n):
        if arr[i] == 0:
            sum -= 1
        else:
            sum += 1
        if sum in sum_map:
            max_len = max(max_len, i - sum_map[sum])
        else:
            sum_map[sum] = i
    return max_len",109
34655279334,is_repeated_substring,"def is_repeated_substring(s):
    """"""
    Check if the string can be formed by concatenating two identical substrings.
    
    :param s: Input string
    :return: Boolean True if s can be formed by concatenating two identical substrings, else False.
    """"""
    for i in range(1, len(s)//2 + 1):
        if len(s) % i == 0:
            if s[:i] * (len(s)//i) == s:
                return True
    return False",109
24190942406,uncommonWords,"from typing import List
from collections import Counter

def uncommonWords(A: str, B: str) -> List[str]:
    a = A.split()
    b = B.split()
    
    arr = []
    ca = Counter(a)
    cb = Counter(b)
    
    for i in a:
        if i not in b and ca[i] == 1:
            arr.append(i)
    for i in b:
        if i not in a and cb[i] == 1:
            arr.append(i)
    return arr",108
35570004392,max_product_subarray,"def max_product_subarray(nums):
    if not nums:
        return 0

    max_product = nums[0]
    min_product = nums[0]
    result = nums[0]

    for i in range(1, len(nums)):
        temp = max_product
        max_product = max(nums[i], max_product * nums[i], min_product * nums[i])
        min_product = min(nums[i], temp * nums[i], min_product * nums[i])
        result = max(result, max_product)

    return result",108
1924591730,find_pairs,"def find_pairs(nums, k):
    if k < 0:
        return 0
    pairs = 0
    counts = {}
    for num in nums:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1
    for num in counts:
        if k == 0:
            if counts[num] > 1:
                pairs += 1
        else:
            if num + k in counts:
                pairs += 1
    return pairs",108
71456096884,largest_product_consecutive,"def largest_product_consecutive(nums):
    if not nums:
        return 0
    max_product = nums[0]
    min_product = nums[0]
    result = nums[0]
    for i in range(1, len(nums)):
        temp = max_product
        max_product = max(nums[i], max_product * nums[i], min_product * nums[i])
        min_product = min(nums[i], temp * nums[i], min_product * nums[i])
        result = max(result, max_product)
    return result",108
13069217722,find_repeated_dna_sequences,"def find_repeated_dna_sequences(s):
    if len(s) <= 10:
        return []
    dna_dict = {}
    result = []
    for i in range(len(s) - 9):
        sequence = s[i:i+10]
        if sequence in dna_dict:
            dna_dict[sequence] += 1
        else:
            dna_dict[sequence] = 1
    for key, value in dna_dict.items():
        if value > 1:
            result.append(key)
    return result",108
13336112288,intersect_lists,"from collections import Counter

def intersect_lists(nums1, nums2):
    # Count the occurrences of each number in both lists
    counter1 = Counter(nums1)
    counter2 = Counter(nums2)
    
    # Find the intersection of the two lists
    result = []
    for num in nums1:
        if counter2[num] > 0 and counter1[num] > 0:
            result.append(num)
            counter2[num] -= 1
            counter1[num] -= 1

    return result",108
2279830916,find_longest_consecutive_sequence,"def find_longest_consecutive_sequence(nums):
    if not nums:
        return 0
    
    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",108
37415637690,connected_components,"def connected_components(n, computers):
    visited = set()
    count = 0

    def dfs(node):
        stack = [node]
        while stack:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                for neighbor, isConnected in enumerate(computers[current]):
                    if isConnected == 1 and neighbor not in visited:
                        stack.append(neighbor)

    for node in range(n):
        if node not in visited:
            count += 1
            dfs(node)
    return count",108
38743099473,count_sublists_with_sum,"def count_sublists_with_sum(nums, target):
    count = 0
    prefix_sum = 0
    prefix_sum_count = {0: 1}
    for num in nums:
        prefix_sum += num
        if prefix_sum - target in prefix_sum_count:
            count += prefix_sum_count[prefix_sum - target]
        if prefix_sum in prefix_sum_count:
            prefix_sum_count[prefix_sum] += 1
        else:
            prefix_sum_count[prefix_sum] = 1
    return count",108
14310968018,max_subarray_length,"def max_subarray_length(nums, k):
    max_length = 0
    current_sum = 0
    sum_index = {}
    for i, num in enumerate(nums):
        current_sum += num
        if current_sum == k:
            max_length = i + 1
        if current_sum - k in sum_index:
            max_length = max(max_length, i - sum_index[current_sum - k])
        if current_sum not in sum_index:
            sum_index[current_sum] = i
    return max_length",108
34655144834,countTriplets,"from collections import defaultdict

def countTriplets(arr, r):
    count = 0
    before = defaultdict(int)
    after = defaultdict(int)
    
    for num in arr:
        after[num] += 1
    
    for num in arr:
        after[num] -= 1
        if num % r == 0:
            left_num = num // r
            right_num = num * r
            count += before[left_num] * after[right_num]
        before[num] += 1
    
    return count",108
10743092043,blackjack,"def blackjack(player_score, dealer_score):
    if player_score == 0 or dealer_score == 0:
        return ""Game Over""
    elif player_score > 21:
        return ""Bust! You went over, you lose""
    elif dealer_score > 21:
        return ""Dealer busts! You win""
    elif player_score == dealer_score:
        return ""It's a draw""
    elif player_score > dealer_score:
        return ""You win""
    else:
        return ""You lose""",108
13097223845,smallest_subarray_with_given_sum,"def smallest_subarray_with_given_sum(arr, target_sum):
    window_sum = 0
    min_length = float('inf')
    window_start = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end]
        while window_sum >= target_sum:
            min_length = min(min_length, window_end - window_start + 1)
            window_sum -= arr[window_start]
            window_start += 1
    return min_length if min_length != float('inf') else 0",108
1291311224,findLongestConsecutive,"def findLongestConsecutive(nums):
    if not nums:
        return 0
        
    nums = set(nums)
    longest_streak = 0
    
    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1
            
            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1
                
            longest_streak = max(longest_streak, current_streak)
            
    return longest_streak",108
30721266939,fibfib,"def fibfib(n):
    if n == 0 or n == 1:
        return 0
    elif n == 2:
        return 1
    dp = [0] * (n+1)
    dp[0], dp[1], dp[2] = 0, 0, 1
    for i in range(3, n+1):
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
    return dp[n]",108
24201925798,max_average,"def max_average(nums, k):
    if not nums or k <= 0 or k > len(nums):
        return 0.0

    max_avg = float('-inf')
    window_sum = sum(nums[:k])
    max_sum = window_sum

    for i in range(len(nums) - k):
        window_sum = window_sum - nums[i] + nums[i + k]
        if window_sum > max_sum:
            max_sum = window_sum

    max_avg = max_sum / k
    return max_avg",108
42279433686,longest_unique_substring,"def longest_unique_substring(s: str) -> int:
    if not s:
        return 0

    answer = 0
    distinct = 0
    release = 0

    cache = {}

    for acquire in range(len(s)):

        currentChar = s[acquire]

        if currentChar in cache:
            release = max(release, cache[currentChar] + 1)

        cache[currentChar] = acquire
        answer = max(answer, acquire - release + 1)

    return answer",108
19146797289,find_Longest_Substring,"def find_Longest_Substring(s: str) -> int:
    if not s:
        return 0

    start = 0
    max_length = 0
    used_char = {}

    for i in range(len(s)):
        if s[i] in used_char and start <= used_char[s[i]]:
            start = used_char[s[i]] + 1
        else:
            max_length = max(max_length, i - start + 1)

        used_char[s[i]] = i

    return max_length",108
42011505856,longest_substring_without_repeating_characters,"def longest_substring_without_repeating_characters(s):
    char_map = {}
    left = 0
    result = """"
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        if right - left + 1 > max_length:
            max_length = right - left + 1
            result = s[left:right+1]
    return result",108
71788986996,find_largest_binary_gap,"def find_largest_binary_gap(N):
    binary_representation = bin(N)[2:]
    max_gap = 0
    current_gap = 0

    # Skip the initial '1' if exists
    if binary_representation[0] == '1':
        binary_representation = binary_representation[1:]

    for bit in binary_representation:
        if bit == '0':
            current_gap += 1
        else:
            max_gap = max(max_gap, current_gap)
            current_gap = 0

    return max_gap",108
32976705825,smallest_subarray_with_given_sum,"def smallest_subarray_with_given_sum(arr, target_sum):
    window_sum = 0
    min_length = float('inf')
    window_start = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end]
        while window_sum >= target_sum:
            min_length = min(min_length, window_end - window_start + 1)
            window_sum -= arr[window_start]
            window_start += 1
    return min_length if min_length != float('inf') else 0",108
28965217108,sieve_primes,"def sieve_primes(n):
    sieve = [True] * (n + 1)
    sieve[0:2] = [False, False]  # 0 and 1 are not prime numbers
    for i in range(2, int(n ** 0.5) + 1):
        if sieve[i]:
            for j in range(i*i, n + 1, i):
                sieve[j] = False
    return [i for i in range(n + 1) if sieve[i]]",108
74052162073,check_capitalization,"def check_capitalization(word: str) -> bool:
    # If the word is empty or all lowercase or all uppercase, it follows the capitalization rules.
    if not word or word.islower() or word.isupper(): return True
    # If the first letter is uppercase and the rest are lowercase, it also follows the capitalization rules.
    if word[0].isupper() and word[1:].islower(): return True
    # Otherwise, it doesn't follow the capitalization rules.
    return False",108
71036576636,find_dominant_index,"def find_dominant_index(nums):
    # find the max value and second maximum, then compare max value > 2 * sec max value

    m1, m2, index = -1, -1, 0

    for i, num in enumerate(nums):
        if num > m1:
            m1, m2, index = num, m1, i
        elif num > m2:
            m2 = num
    return index if m1 >= m2 * 2 else -1",108
41450397721,smallest_subarray_with_given_sum,"def smallest_subarray_with_given_sum(s, arr):
    windowSize = len(arr) + 1
    windowSum = 0
    windowStart = 0
    for windowEnd in range(len(arr)):
        windowSum += arr[windowEnd]
        while windowSum >= s:
            windowSize = min(windowSize, windowEnd - windowStart + 1)
            windowSum -= arr[windowStart]
            windowStart += 1
    return windowSize if windowSize <= len(arr) else 0",108
71801729335,maxSubArrayLen,"def maxSubArrayLen(nums, target):
    max_length = 0
    sum_dict = {}
    current_sum = 0
    for i in range(len(nums)):
        current_sum += nums[i]
        if current_sum == target:
            max_length = i + 1
        if current_sum - target in sum_dict:
            max_length = max(max_length, i - sum_dict[current_sum - target])
        if current_sum not in sum_dict:
            sum_dict[current_sum] = i
    return max_length",108
36736502977,numTilePossibilities,"def numTilePossibilities(n):
    """"""
    :type n: int
    :rtype: int
    """"""
    if n == 0 :return 1
    elif n==1 or n==2: return n
    ways = [0 for _ in range(n)]
    ways[0] = 1
    ways[1] = 2
    for i in range(2,n):
        ways[i] = ways[i-1] + ways[i-2]
    return ways[-1]",108
73725812312,max_product_subarray,"def max_product_subarray(nums):
    if not nums:
        return 0

    max_product = nums[0]
    min_product = nums[0]
    result = nums[0]

    for i in range(1, len(nums)):
        temp = max_product
        max_product = max(nums[i], max_product * nums[i], min_product * nums[i])
        min_product = min(nums[i], temp * nums[i], min_product * nums[i])
        result = max(result, max_product)
    return result",108
44290375460,count_ways_to_climb,"def count_ways_to_climb(n, steps):
    dp = [0] * (n + 1)
    dp[0] = 1  # Base case: there's one way to reach the top if you don't have to climb any steps (i.e., you're already there).
    
    for i in range(1, n + 1):
        for s in steps:
            if i - s >= 0:
                dp[i] += dp[i - s]
    
    return dp[n]",108
18927203317,bell_number,"def bell_number(n):
    bell = [[0 for i in range(n+1)] for j in range(n+1)]
    bell[0][0] = 1
    for i in range(1, n+1):
        bell[i][0] = bell[i-1][i-1]
        for j in range(1, i+1):
            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]
    return bell[n][0]",108
41748818251,min_jumps,"def min_jumps(arr):
    if len(arr) <= 1:
        return 0
    jumps = 0
    current_jump_end = 0
    farthest = 0
    for i in range(len(arr) - 1):
        farthest = max(farthest, i + arr[i])
        if i == current_jump_end:
            jumps += 1
            current_jump_end = farthest
            if current_jump_end >= len(arr) - 1:
                break
    return jumps",108
70642941436,valid_mountain_array,"def valid_mountain_array(A):
    _index_peak = A.index(max(A)) if len(A) else 0

    if not _index_peak or _index_peak is len(A) - 1:
        return False

    for i, num in enumerate(A[:_index_peak]):
        if num >= A[i + 1]:
            return False

    for i, num in enumerate(A[_index_peak + 1:]):
        if num >= A[i + _index_peak]:
            return False

    return True",108
2261877182,is_valid_number,"def is_valid_number(s: str) -> bool:
    try:
        float(s)
        return True
    except ValueError:
        try:
            if s.lower().count('e') == 1:
                integer, exponent = s.lower().split('e')
                if integer[0] in ('-', '+'):
                    integer = integer[1:]
                if not integer or not exponent:
                    return False
                float(integer)
                int(exponent)
                return True
        except ValueError:
            return False
    return False",108
30547220910,find_common,"def find_common(list1, list2):
    p1 = p2 = 0
    result = []
    while p1 < len(list1) and p2 < len(list2):
        if list1[p1] == list2[p2]:
            result.append(list1[p1])
            p1 += 1
            p2 += 1
        elif list1[p1] < list2[p2]:
            p1 += 1
        else:
            p2 += 1
    return result",108
74091332184,smallest_subarray_with_given_sum,"def smallest_subarray_with_given_sum(arr, target_sum):
    window_sum = 0
    min_length = float(""inf"")
    window_start = 0

    for window_end in range(len(arr)):
        window_sum += arr[window_end]

        while window_sum >= target_sum:
            min_length = min(min_length, window_end - window_start + 1)
            window_sum -= arr[window_start]
            window_start += 1

    return min_length if min_length != float(""inf"") else 0",108
73153237487,count_pairs_with_diff_k,"def count_pairs_with_diff_k(arr, k):
    arr.sort()
    count = 0
    left, right = 0, 1

    while right < len(arr):
        diff = arr[right] - arr[left]
        if diff == k:
            count += 1
            left += 1
            right += 1
        elif diff < k:
            right += 1
        else:
            left += 1
            if left == right:
                right += 1

    return count",108
19119155931,num_rabbits,"from math import ceil

def num_rabbits(answers):
    same_answer = dict()
    for answer in answers:
        if answer not in same_answer.keys():
            same_answer[answer] = 1
        else:
            same_answer[answer] += 1
    total = 0
    for answer in same_answer:
        group_size = answer + 1
        num_groups = int(ceil(same_answer[answer] / group_size))
        total += group_size * num_groups
    return total",108
32042566209,shortest_subarray_length,"from typing import List

def shortest_subarray_length(nums: List[int], target: int) -> int:
    min_len = float('inf')
    start = 0
    current_sum = 0
    for end in range(len(nums)):
        current_sum += nums[end]
        while current_sum >= target:
            min_len = min(min_len, end - start + 1)
            current_sum -= nums[start]
            start += 1
    return min_len if min_len != float('inf') else 0",108
70452281492,max_prime_diff,"def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True


def max_prime_diff(lst):
    primes = [x for x in lst if is_prime(x)]
    if not primes:
        return None
    primes.sort()
    return max(primes[i] - primes[0] for i in range(1, len(primes)))",108
1368008670,longest_subarray_with_sum,"def longest_subarray_with_sum(arr, target_sum):
    max_length = 0
    current_sum = 0
    start_index = 0
    sum_index = {0: -1}
    for i, num in enumerate(arr):
        current_sum += num
        if current_sum - target_sum in sum_index:
            max_length = max(max_length, i - sum_index[current_sum - target_sum])
        if current_sum not in sum_index:
            sum_index[current_sum] = i
    return max_length",108
8687288000,distinct_subsequences,"def distinct_subsequences(s: str) -> int:
    MOD = 10 ** 9 + 7
    count = 0
    dp = [0] * 26
    dp[ord(s[0]) - ord('a')] = 1
    for i in range(1, len(s)):
        total = sum(dp) % MOD
        dp[ord(s[i]) - ord('a')] = (total + 1) % MOD
    return sum(dp) % MOD",107
15552521116,closest_element,"def closest_element(arr, target):
    left, right = 0, len(arr) - 1
    while left < right - 1:
        mid = (left + right) // 2
        if arr[mid] == target:
            return arr[mid]
        elif arr[mid] < target:
            left = mid
        else:
            right = mid
    if abs(arr[left] - target) <= abs(arr[right] - target):
        return arr[left]
    else:
        return arr[right]",107
17333916968,second_largest,"def second_largest(lst):
    if len(lst) < 2:
        return None
    largest = max(lst[0], lst[1])
    second_largest = min(lst[0], lst[1])
    for num in lst[2:]:
        if num > largest:
            second_largest = largest
            largest = num
        elif num > second_largest and num != largest:
            second_largest = num
    if second_largest == largest:
        return None
    return second_largest",107
33402303133,longest_consecutive_subsequence,"def longest_consecutive_subsequence(nums):
    if not nums:
        return 0
    nums = set(nums)
    longest_streak = 0
    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",107
13873792259,count_unique_substrings,"def count_unique_substrings(s):
    unique_substrings = set()
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            unique_substrings.add(s[i:j])
    return len(unique_substrings)

print(count_unique_substrings(""abc""))  # 6
print(count_unique_substrings(""aaa""))  # 3
print(count_unique_substrings(""abcd""))  # 10
print(count_unique_substrings(""a""))  # 1",107
4583451580,largest_substring,"def largest_substring(s):
    char_set = set()
    left = 0
    max_length = 0
    max_substring = """"
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        if right - left + 1 > max_length:
            max_length = right - left + 1
            max_substring = s[left:right+1]
    return max_substring",107
20272119925,distinct_subsequences,"def distinct_subsequences(s):
    dp = [1] * (len(s) + 1)
    last_occurrence = {}
    for i in range(1, len(s) + 1):
        dp[i] = dp[i-1] * 2
        if s[i-1] in last_occurrence:
            dp[i] -= dp[last_occurrence[s[i-1]]]
        last_occurrence[s[i-1]] = i - 1
    return dp[-1] - 1",107
15906794258,calculate_catalan_number,"def calculate_catalan_number(n):
    if n <= 1:
        return 1
    catalan_numbers = [0] * (n + 1)
    catalan_numbers[0] = 1
    catalan_numbers[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            catalan_numbers[i] += catalan_numbers[j] * catalan_numbers[i - j - 1]
    return catalan_numbers[n]",107
71449632154,count_target_occurrences,"def count_target_occurrences(nums, target):
    """"""
    Counts the number of occurrences of a target value in a list of unsorted integers.

    Args:
    nums: List[int] - A list of unsorted integers.
    target: int - The target value to find in the list.

    Returns:
    int - The number of occurrences of the target value in the list.
    """"""
    count = 0
    for num in nums:
        if num == target:
            count += 1
    return count",107
41914170679,smallest_subarray,"def smallest_subarray(arr, S):
    window_sum = 0
    min_length = float('inf')
    window_start = 0

    for window_end in range(len(arr)):
        window_sum += arr[window_end] 
        while window_sum >= S:
            min_length = min(min_length, window_end - window_start + 1)
            window_sum -= arr[window_start]
            window_start += 1

    if min_length == float('inf'):
        return 0
    return min_length",107
5780865353,find_first_duplicate,"def find_first_duplicate(arr):
    n = len(arr)
    for i in range(n):
        while arr[i] != i + 1:
            # Check if the current number is already at its correct position or not
            if arr[i] == arr[arr[i] - 1]:
                return arr[i]
            # Swap the current number with the number at its correct position
            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]
    return -1",107
19119172071,bucket_sort,"def bucket_sort(nums):
    max_num = max(nums)
    min_num = min(nums)
    bucket_range = (max_num - min_num) / len(nums)
    buckets = [[] for _ in range(len(nums))]
    for num in nums:
        index = int((num - min_num) / bucket_range)
        if index == len(nums):
            index -= 1
        buckets[index].append(num)
    sorted_nums = []
    for bucket in buckets:
        sorted_nums.extend(sorted(bucket))
    return sorted_nums",107
32525868748,minimum_coins,"from collections import deque

def minimum_coins(coins, amount):
    coins.sort(reverse=True)
    queue = deque([(0, amount)])
    visited = {amount}
    
    while queue:
        depth, remainder = queue.popleft()
        if remainder == 0:
            return depth
        for coin in coins:
            if remainder - coin >= 0 and remainder - coin not in visited:
                visited.add(remainder - coin)
                queue.append((depth + 1, remainder - coin))
    return -1",107
31688331710,canFormString,"def canFormString(s, t):
    if len(s) > len(t):
        return False
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in t:
        if char in char_count:
            char_count[char] -= 1
            if char_count[char] == 0:
                del char_count[char]
    return len(char_count) == 0",107
8353081906,find_longest_consecutive,"def find_longest_consecutive(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",107
30362823714,sieve_of_eratosthenes,"def sieve_of_eratosthenes(n):
    primes = [True for i in range(n + 1)]
    p = 2
    while(p * p <= n):
        if (primes[p] == True):
            for i in range(p * p, n + 1, p):
                primes[i] = False
        p += 1
    prime_numbers = []
    for p in range(2, n):
        if primes[p]:
            prime_numbers.append(p)
    return prime_numbers",107
37216182761,find_longest_consecutive,"def find_longest_consecutive(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",107
7238997037,find_missing_positive,"def find_missing_positive(nums):
    nums = [num for num in nums if num > 0]
    nums = list(set(nums))
    nums.sort()
    if len(nums) == 0:
        return 1
    if nums[0] > 1:
        return 1
    for i in range(1, len(nums)):
        if nums[i] - nums[i-1] > 1:
            return nums[i-1] + 1
    return nums[-1] + 1",107
17087262955,min_arrows,"def min_arrows(balloons):
    balloons.sort()
    n = len(balloons)
    ans=0
    common = balloons[0]
    for i in range(1, n):
        if balloons[i][0] <= common[1]:
            common[0] = max(common[0], balloons[i][0])
            common[1] = min(common[1], balloons[i][1])
        else:
            ans += 1
            common = balloons[i]
    
    return ans+1",107
41029599728,longest_consecutive_subsequence,"def longest_consecutive_subsequence(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",107
4133850265,longest_consequtive_sequence,"def longest_consequtive_sequence(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",107
25201086377,is_permutation,"def is_permutation(str1, str2):
    # Convert strings to lists
    list1 = list(str1.replace("" "", """").lower())
    list2 = list(str2.replace("" "", """").lower())

    # Check if lengths are equal
    if len(list1) != len(list2):
        return False

    # Sort the lists
    list1.sort()
    list2.sort()

    # Compare the sorted lists
    if list1 == list2:
        return True
    else:
        return False",107
23255935159,reverse_and_check_prime,"def reverse_and_check_prime(num):
    reversed_num = int(str(num)[::-1])
    if reversed_num < 2:
        return False
    for i in range(2, int(reversed_num**0.5) + 1):
        if reversed_num % i == 0:
            return False
    return True

print(reverse_and_check_prime(123)) #False
print(reverse_and_check_prime(131)) #True
print(reverse_and_check_prime(789)) #False",107
73244428224,longest_substring,"def longest_substring(s):
    char_set = set()
    left = 0
    max_length = 0
    max_substring = """"

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        if right - left + 1 > max_length:
            max_length = right - left + 1
            max_substring = s[left:right+1]
    return max_substring",107
32610351204,binary_gap,"def binary_gap(N):
  b = bin(N)[2:]
  clear = False
  count = 0
  maxCount = 0
  for c in b:
    if (c == '1' and count != 0 and clear != False):
      if (count > maxCount):
        maxCount = count
      count = 0
    if (c == '1' and count == 0):
      clear = True
    else:
      count += 1
  return maxCount",107
13613969170,max_ones,"def max_ones(nums):
    left, right, zero_count, max_length = 0, 0, 0, 0
    while right < len(nums):
        if nums[right] == 0:
            zero_count += 1
        while zero_count > 1:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        max_length = max(max_length, right - left + 1)
        right += 1
    return max_length",107
40824710816,longest_consecutive_subsequence,"def longest_consecutive_subsequence(arr):
    if not arr:
        return 0
    arr = set(arr)
    longest_streak = 0
    for num in arr:
        if num - 1 not in arr:
            current_num = num
            current_streak = 1

            while current_num + 1 in arr:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",107
28109779327,find_longest_consecutive,"def find_longest_consecutive(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",107
10673281082,can_form_string,"def can_form_string(str1, str2):
    if len(str1) != len(str2):
        return False
    lookup = {}
    for n in str1:
        if n not in lookup:
            lookup[n] = 1
        else:
            lookup[n] += 1
    for n in str2:
        if n not in lookup:
            return False
        elif lookup[n] == 0:
            return False
        else:
            lookup[n] -= 1
    return True",107
6506200865,smallest_subarray,"from typing import List

def smallest_subarray(arr: List[int], k: int) -> int:
    min_length = float('inf')
    current_sum = 0
    start = 0
    for end in range(len(arr)):
        current_sum += arr[end]
        while current_sum >= k:
            min_length = min(min_length, end - start + 1)
            current_sum -= arr[start]
            start += 1
    return 0 if min_length == float('inf') else min_length",107
26837301233,majority_element,"def majority_element(arr):
    potential_majority_element = None
    vote = 0
    for num in arr:
        if vote == 0:
            potential_majority_element = num
            vote = 1
        elif num == potential_majority_element:
            vote += 1
        else:
            vote -= 1
    if vote > 0 and arr.count(potential_majority_element) > len(arr) / 2:
        return potential_majority_element
    else:
        return None",107
12233569680,longest_consecutive_sequence,"def longest_consecutive_sequence(nums):
    if not nums:
        return 0
    
    nums = set(nums)
    longest_streak = 0
    
    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1
            
            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1
                
            longest_streak = max(longest_streak, current_streak)
            
    return longest_streak",107
6774989185,find_largest_smaller,"def find_largest_smaller(nums, target):
    nums.sort()
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] < target:
            if mid == len(nums) - 1 or nums[mid + 1] >= target:
                return nums[mid]
            else:
                left = mid + 1
        else:
            right = mid - 1
    return None",107
1451616382,spell_out_to_num,"def spell_out_to_num(spell_out_list):
    alpha = {""zero"": 0, ""one"": 1, ""two"": 2, ""three"": 3, ""four"": 4, ""five"": 5, ""six"": 6, ""seven"": 7, ""eight"": 8, ""nine"": 9, ""ten"": 10}
    num_list = []
    
    for word in spell_out_list:
        num_list.append(alpha[word])
    
    return sorted(num_list)",107
10784791895,longest_substring,"def longest_substring(s):
    char_set = set()
    left = 0
    max_length = 0
    max_substring = """"
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        if right - left + 1 > max_length:
            max_length = right - left + 1
            max_substring = s[left:right+1]
    return max_substring",107
5233722215,max_ones,"def max_ones(nums):
    left, right, max_count, zero_count = 0, 0, 0, 0
    while right < len(nums):
        if nums[right] == 0:
            zero_count += 1
        while zero_count > 1:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        max_count = max(max_count, right - left + 1)
        right += 1
    return max_count",107
37104859565,find_max_sum_subarray,"from typing import List

def find_max_sum_subarray(nums: List[int], k: int) -> int:
    if not nums or k <= 0 or k > len(nums): return 0
    window_sum = 0
    max_sum = 0
    for i in range(len(nums)):
        window_sum += nums[i]
        if i >= k - 1:
            max_sum = max(max_sum, window_sum)
            window_sum -= nums[i - k + 1]
    return max_sum",107
42259011108,generate_balanced_parentheses,"def generate_balanced_parentheses(n):
    def backtrack(S = [], left = 0, right = 0):
        if len(S) == 2 * n:
            ans.append(''.join(S))
            return
        if left < n:
            S.append('(')
            backtrack(S, left+1, right)
            S.pop()
        if right < left:
            S.append(')')
            backtrack(S, left, right+1)
            S.pop()
    ans = []
    backtrack()
    return ans",107
72463377588,find_longest_consecutive,"def find_longest_consecutive(nums):
    if not nums:
        return 0
    nums = set(nums)
    longest_streak = 0
    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1
            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1
            longest_streak = max(longest_streak, current_streak)
    return longest_streak",107
18988558216,longest_subarray_with_sum,"def longest_subarray_with_sum(nums, k):
    sum_index = {0: -1}
    sum_so_far = 0
    max_length = 0
    
    for i, num in enumerate(nums):
        sum_so_far += num
        if sum_so_far not in sum_index:
            sum_index[sum_so_far] = i
        if sum_so_far - k in sum_index:
            max_length = max(max_length, i - sum_index[sum_so_far - k])
    
    return max_length",107
14125321516,count_subarrays,"def count_subarrays(arr, target):
    count = 0
    prefix_sum = 0
    prefix_sum_counts = {0: 1}
    
    for num in arr:
        prefix_sum += num
        if prefix_sum - target in prefix_sum_counts:
            count += prefix_sum_counts[prefix_sum - target]
        if prefix_sum in prefix_sum_counts:
            prefix_sum_counts[prefix_sum] += 1
        else:
            prefix_sum_counts[prefix_sum] = 1
            
    return count",107
43553059264,longest_balanced_parentheses,"def longest_balanced_parentheses(s):
    stack = [-1]
    longest = 0
    start = 0
    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                if longest < i - stack[-1]:
                    longest = i - stack[-1]
                    start = stack[-1] + 1
    return s[start:start+longest]",107
14117359116,primes_up_to,"def primes_up_to(limit):
    sieve = [True] * (limit + 1)
    sieve[0:2] = [False, False]
    for current in range(2, int(limit ** 0.5) + 1):
        if sieve[current]:
            sieve[current*current:limit+1:current] = [False] * len(sieve[current*current:limit+1:current])
    return [num for num in range(2, limit + 1) if sieve[num]]",107
74960698745,length_longest_sequence,"def length_longest_sequence(nums):
    if not nums:
        return 0
    nums = set(nums)
    longest_streak = 0
    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",106
34070704292,longest_consecutive_sequence,"def longest_consecutive_sequence(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",106
4255845194,second_max,"def second_max(lst):
    if (len(lst)<2):
        return
    first_max = second_max = float('-inf')
    for i in range(0, len(lst)):
        if (lst[i] > first_max):
            second_max = first_max
            first_max = lst[i]
        elif (lst[i] > second_max and lst[i] != first_max):
            second_max = lst[i]
    if (second_max == float('-inf')):
        return
    else:
        return second_max",106
36094372711,caesar_cipher,"def caesar_cipher(text, shift):
    result = ''
    for char in text:
        if char.isalpha():
            shift_amount = shift % 26
            if char.islower():
                result += chr((ord(char) - ord('a') + shift_amount) % 26 + ord('a'))
            else:
                result += chr((ord(char) - ord('A') + shift_amount) % 26 + ord('A'))
        else:
            result += char
    return result",106
37694043024,max_consecutive_sequence,"def max_consecutive_sequence(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",106
12570539737,count_negatives,"def count_negatives(grid):
    cols = len(grid[0])
    rows = len(grid)
    count = 0
    for i in range(rows - 1, -1, -1):
        if grid[i][-1] >= 0:
            break
        for j in range(cols - 1, -1, -1):
            if grid[i][j] < 0:
                count += 1
            if grid[i][j] >= 0:
                break
    return count",106
39636220247,password_validation,"import re

def password_validation(password):
    if len(password) < 6 or len(password) > 16:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[_@$]"", password):
        return False
    if re.search(""\s"", password):
        return False
    return True",106
73725854232,smallest_subarray_with_given_sum,"def smallest_subarray_with_given_sum(s, arr):
  window_sum = 0
  min_length = float('inf')
  window_start = 0
  for window_end in range(len(arr)):
    window_sum += arr[window_end]
    while window_sum >= s:
      min_length = min(min_length, window_end - window_start + 1)
      window_sum -= arr[window_start]
      window_start += 1
  return min_length if min_length != float('inf') else 0",106
17989082649,second_largest,"def second_largest(nums):
    if len(nums) < 2:
        return None
    largest = max(nums[0], nums[1])
    second_largest = min(nums[0], nums[1])
    for i in range(2, len(nums)):
        if nums[i] > largest:
            second_largest = largest
            largest = nums[i]
        elif nums[i] > second_largest and nums[i] != largest:
            second_largest = nums[i]
    return second_largest",106
42025297790,look_and_say,"def look_and_say(n):
    if n == 1:
        return ""1""
    previous = look_and_say(n - 1)
    result = """"
    count = 1
    for i in range(1, len(previous)):
        if previous[i] == previous[i - 1]:
            count += 1
        else:
            result += str(count) + previous[i - 1]
            count = 1
    result += str(count) + previous[-1]
    return result",106
72607384109,find_unique_number,"def find_unique_number(numbers):
    """"""
    Finds the first unique integer in a list of integers.
    
    Parameters:
    numbers (list): A list of integers.
    
    Returns:
    int or None: The first unique integer, or None if all integers repeat.
    """"""
    seen = set()
    unique = set()
    for num in numbers:
        if num in seen:
            unique.discard(num)
        else:
            seen.add(num)
            unique.add(num)
    return next(iter(unique), None)",106
35024815045,left_right_difference,"def left_right_difference(nums):
    pref = [nums[0]]
    prefRev = [nums[-1]]
    ans = []
    for i, j in zip(range(1, len(nums)), range(len(nums)-2, -1, -1)):
        pref.append(pref[-1]+nums[i])
        prefRev.append(prefRev[-1]+nums[j])
    prefRev = prefRev[::-1]
    for i in range(len(pref)):
        ans.append(abs(prefRev[i]-pref[i]))
    return ans",106
73183405002,max_length_subarray_sum,"def max_length_subarray_sum(nums, k):
    max_length = 0
    current_sum = 0
    start_index = 0
    sum_index = {0: -1}
    
    for i, num in enumerate(nums):
        current_sum += num
        if current_sum - k in sum_index:
            max_length = max(max_length, i - sum_index[current_sum - k])
        if current_sum not in sum_index:
            sum_index[current_sum] = i
    
    return max_length",106
74240138327,count_subarrays_with_sum,"from collections import defaultdict

def count_subarrays_with_sum(arr, target_sum):
    subarray_count = 0
    prefix_sum = 0
    prefix_sum_counts = defaultdict(int)
    prefix_sum_counts[0] = 1
    
    for num in arr:
        prefix_sum += num
        if prefix_sum - target_sum in prefix_sum_counts:
            subarray_count += prefix_sum_counts[prefix_sum - target_sum]
        prefix_sum_counts[prefix_sum] += 1

    return subarray_count",106
74154307597,count_and_say,"def count_and_say(n):
    if n == 1:
        return ""1""
    prev = count_and_say(n - 1)
    result = """"
    count = 1
    for i in range(1, len(prev)):
        if prev[i] == prev[i - 1]:
            count += 1
        else:
            result += str(count) + prev[i - 1]
            count = 1
    result += str(count) + prev[-1]
    return result",106
73980102290,min_meeting_rooms,"from heapq import heappush,heappop

def min_meeting_rooms(intervals):
    if not intervals:
        return 0
    intervals.sort(key=lambda x : x[0])
    minheap = []
    rooms_needed = 0
    for interval in intervals[:]:
        if minheap and minheap[0] <= interval[0]:
            heappop(minheap)
        else:
            rooms_needed += 1
        heappush(minheap,interval[1])
    return rooms_needed",106
31457361019,sieve_of_eratosthenes,"def sieve_of_eratosthenes(n):
    sieve = [True] * (n+1)
    sieve[0:2] = [False, False]
    for current in range(2, int(n**0.5) + 1):
        if sieve[current]:
            for multiple in range(current**2, n + 1, current):
                sieve[multiple] = False
    primes = [num for num in range(2, n+1) if sieve[num]]
    return primes",106
10193185631,jump,"def jump(nums):
    n = len(nums)
    if n <= 1:
        return 0

    jumps = 0
    current_jump_end = 0
    farthest = 0

    for i in range(n - 1):
        farthest = max(farthest, i + nums[i])
        if i == current_jump_end:
            jumps += 1
            current_jump_end = farthest
            if current_jump_end >= n - 1:
                break

    return jumps",106
34817516235,evaluate_rpn_expression,"def evaluate_rpn_expression(tokens):
    stack = []
    for token in tokens:
        if token in ['+', '-', '*', '/']:
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            elif token == '/':
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    return stack.pop()",106
6536870388,max_product,"from typing import List

def max_product(nums: List[int]) -> int:
    # Sort the list in ascending order
    nums.sort()
    # The maximum product can be either:
    # (1) The product of the three largest numbers
    # or (2) The product of the two smallest numbers (which could be negative) and the largest number
    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])",106
42713972052,find_subarrays_with_sum,"def find_subarrays_with_sum(arr, target_sum):
    num_subarrays = 0
    current_sum = 0
    sums = {0: 1}  # To handle the case when the target sum is 0

    for num in arr:
        current_sum += num
        if current_sum - target_sum in sums:
            num_subarrays += sums[current_sum - target_sum]
        sums[current_sum] = sums.get(current_sum, 0) + 1

    return num_subarrays",106
6588263883,longestConsecutiveSequence,"def longestConsecutiveSequence(nums):
    if not nums:
        return 0
    nums = set(nums)
    longest_streak = 0
    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1
            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1
            longest_streak = max(longest_streak, current_streak)
    return longest_streak",106
71447708188,longest_subsequence,"def longest_subsequence(s):
    if not s:
        return """"
    
    longest = [s[0]]
    current = [s[0]]

    for i in range(1, len(s)):
        if s[i] >= current[-1]:
            current.append(s[i])
        else:
            if len(current) > len(longest):
                longest = current
            current = [s[i]]
    
    if len(current) > len(longest):
        longest = current

    return """".join(longest)",106
35081888741,smallest_subarray_with_given_sum,"def smallest_subarray_with_given_sum(arr, target):
    window_sum = 0
    min_length = float('inf')
    window_start = 0

    for window_end in range(len(arr)):
        window_sum += arr[window_end]

        while window_sum >= target:
            min_length = min(min_length, window_end - window_start + 1)
            window_sum -= arr[window_start]
            window_start += 1

    return min_length if min_length != float('inf') else 0",106
13049124729,find_index,"def find_index(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            if mid == 0 or nums[mid-1] < target:
                return mid
            right = mid - 1
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1",106
36112285502,second_min,"def second_min(nums):
    min1, min2 = None, None
    for i in range(len(nums)):
        if nums[i] in [min1, min2]:
            continue
        if min1 is None or nums[i] < min1:
            min2 = min1
            min1 = nums[i]
        elif min2 is None or nums[i] < min2:
            min2 = nums[i]
    if min2 is not None:
        return min2
    return min1",106
14180891995,nth_gray_code,"def nth_gray_code(n: int) -> int:
    """"""
    Returns the nth number in the Gray Code sequence.
    :param n: The position in the Gray Code sequence.
    :return: The nth Gray Code number.
    """"""
    return n ^ (n >> 1)

# Test cases
assert nth_gray_code(0) == 0
assert nth_gray_code(1) == 1
assert nth_gray_code(2) == 3
assert nth_gray_code(3) == 2",106
40677007626,strange_sort_list,"def strange_sort_list(lst):
    sorted_lst = []
    while lst:
        # Alternate between appending the minimum and maximum remaining values
        if len(lst) % 2 == 0:
            # If even, append the minimum value
            min_val = min(lst)
            lst.remove(min_val)
            sorted_lst.append(min_val)
        else:
            # If odd, append the maximum value
            max_val = max(lst)
            lst.remove(max_val)
            sorted_lst.append(max_val)
    return sorted_lst",106
33624774969,length_of_longest_substring_k_distinct,"from collections import OrderedDict


def length_of_longest_substring_k_distinct(s: str, k: int) -> int:
    l = res = 0
    chars = OrderedDict()
    for r, c in enumerate(s):
        if c in chars:
            del chars[c]
        chars[c] = r
        if len(chars) > k:
            _, l = chars.popitem(last=False)
            l += 1
        res = max(res, r - l + 1)
    return res",106
29415906424,min_eat_time,"def min_eat_time(piles, h):
    def is_possible(mid):
        total_hours = 0
        for pile in piles:
            total_hours += (pile + mid - 1) // mid
        return total_hours <= h

    left, right = 1, max(piles)
    while left < right:
        mid = (left + right) // 2
        if is_possible(mid):
            right = mid
        else:
            left = mid + 1
    return left",106
39960339529,count_triangles,"def count_triangles(sides):
    if len(sides) < 3:
        return 0

    sides.sort()
    res = 0
    length = len(sides)
    for i in range(0, length - 2):
        for j in range(i + 1, length - 1):
            for k in range(j + 1, length):
                if sides[i] + sides[j] > sides[k]:
                    res += 1
                else: break
    return res",106
72588282618,isPerfectCube,"def isPerfectCube(num):
    if num == 0:
        return True
    if num < 0:
        num = -num
    low, high = 0, num
    while low <= high:
        mid = low + (high - low) // 2
        if mid * mid * mid == num:
            return True
        elif mid * mid * mid > num:
            high = mid - 1
        else:
            low = mid + 1
    return False",106
30343374917,decode_message,"def decode_message(s, mapping):
    cache = {len(s): 1}
    def dfs(i):
        if i in cache:
            return cache[i]
        if s[i] == ""0"":
            return 0
        res = dfs(i + 1)
        if (i + 1 < len(s) and int(s[i:i+2]) <= 26):
            res += dfs(i + 2)
        cache[i] = res
        return res
    return dfs(0)",106
71156956286,remove_evens,"def remove_evens(nums):
    """"""
    :type nums: List[int]
    :rtype: List[int]
    """"""
    def swap(x, y):
        nums[x], nums[y] = nums[y], nums[x]

    L = len(nums)

    idx = 0
    idx2 = 0

    while idx < L:
        if nums[idx] % 2 == 0:
            nums.pop(idx)
            L -= 1
        else:
            idx += 1

    return nums",106
17808085395,rotate_array,"def rotate_array(A, K):
    n = len(A)
    K = K % n
    if K == 0:
        return A
    reverse(A, 0, n-1)
    reverse(A, 0, K-1)
    reverse(A, K, n-1)
    return A

def reverse(A, start, end):
    while start < end:
        A[start], A[end] = A[end], A[start]
        start += 1
        end -= 1",106
34180996165,smallest_subarray_with_given_sum,"def smallest_subarray_with_given_sum(arr, target):
    window_sum = 0
    min_length = float('inf')
    window_start = 0

    for window_end in range(len(arr)):
        window_sum += arr[window_end]
        while window_sum >= target:
            min_length = min(min_length, window_end - window_start + 1)
            window_sum -= arr[window_start]
            window_start += 1

    return min_length if min_length != float('inf') else 0",106
38044836940,first_missing_positive,"def first_missing_positive(nums):
    if not nums:
        return 1
    for i in range(len(nums)):
        while 1 <= nums[i] <= len(nums) and nums[nums[i] - 1] != nums[i]:
            nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
    for i in range(len(nums)):
        if nums[i] != i + 1:
            return i + 1
    return len(nums) + 1",106
21558151262,max_Product,"def max_Product(arr):
    arr.sort()
    return max(arr[0]*arr[1]*arr[-1], arr[-1]*arr[-2]*arr[-3])

# Test cases
assert max_Product([1, 2, 3]) == 6
assert max_Product([0, -1, 3, 100, -70, -5]) == 35000
assert max_Product([-1, -2, -3, -4]) == -6",106
20352002067,checkPermutation,"def checkPermutation(s1: str, s2: str) -> bool:
    if len(s1) != len(s2):
        return False
    
    count = [0] * 256

    for i in range(len(s1)):
        count[ord(s1[i])] += 1

    for i in range(len(s2)):
        count[ord(s2[i])] -= 1
        if count[ord(s2[i])] < 0:
            return False

    return True",106
69878240107,least_num_squares,"def least_num_squares(n):
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    for i in range(1, n + 1):
        j = 1
        min_value = float('inf')
        while j * j <= i:
            min_value = min(min_value, dp[i - j * j] + 1)
            j += 1
        dp[i] = min_value
    return dp[-1]",105
15520372019,max_substring_length,"from collections import Counter

def max_substring_length(s, k):
    maxf, i = 0, 0
    cnt = Counter()

    for j in range(len(s)):
        cnt[s[j]] += 1
        maxf = max(maxf, cnt[s[j]])

        if (j - i + 1) * maxf > k * len(s[i:j+1]):
            cnt[s[i]] -= 1
            i += 1

    return len(s) - i",105
16299455296,longest_consecutive_ones,"def longest_consecutive_ones(binary_array):
    max_len = 0
    left = 0
    zero_count = 0
    for right in range(len(binary_array)):
        if binary_array[right] == 0:
            zero_count += 1
        while zero_count > 1:
            if binary_array[left] == 0:
                zero_count -= 1
            left += 1
        max_len = max(max_len, right - left + 1)
    return max_len",105
36427401719,find_subarrays_with_sum,"def find_subarrays_with_sum(arr, target_sum):
    count = 0
    current_sum = 0
    sum_frequency = {0: 1}

    for i in range(len(arr)):
        current_sum += arr[i]

        if current_sum - target_sum in sum_frequency:
            count += sum_frequency[current_sum - target_sum]

        if current_sum in sum_frequency:
            sum_frequency[current_sum] += 1
        else:
            sum_frequency[current_sum] = 1

    return count",105
42614762531,max_Profit,"def max_Profit(prices, k):
    if not prices:
        return 0
    profits = [0 for _ in range(len(prices))]
    for trade in range(1, k+1):
        max_diff = -prices[0]
        for i in range(1, len(prices)):
            profits[i] = max(profits[i-1], prices[i] + max_diff)
            max_diff = max(max_diff, profits[i] - prices[i])
    return profits[-1]",105
18836663082,check_pattern,"def check_pattern(pattern: str, s: str) -> bool:
    words = s.split()

    if len(pattern) != len(words):
        return False

    if len(set(pattern)) != len(set(words)):
        return False

    word_map = {}

    for i in range(len(words)):
        p = pattern[i]
        w = words[i]

        if w not in word_map:
            word_map[w] = p

        elif word_map[w] != p:
            return False

    return True",105
73083298716,smallest_multiple,"def smallest_multiple(divisor, threshold):
    """"""
    Finds the smallest multiple of divisor that is greater than or equal to threshold.

    Parameters:
    divisor (int): The divisor to find the multiple of.
    threshold (int): The threshold value.

    Returns:
    int: The smallest multiple of divisor greater than or equal to threshold.
    """"""
    # Calculate the smallest multiple using the ceiling division operator (//)
    multiple = ((threshold + divisor - 1) // divisor) * divisor
    return multiple",105
26719235895,equal_partition,"def equal_partition(arr):
    total = sum(arr)
    # If total is odd, partition not possible
    if total % 2 != 0:
        return False
    target = total // 2
    dp = [False] * (target + 1)
    dp[0] = True
    for num in arr:
        for i in range(target, num - 1, -1):
            dp[i] = dp[i] or dp[i - num]
    return dp[target]",105
14088178246,nth_catalan,"def nth_catalan(n):
    if n <= 1:
        return 1
    catalan = [0] * (n + 1)
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n+1):
        catalan[i] = 0
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]
    return catalan[n]",105
69878192747,longest_consecutive,"def longest_consecutive(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",105
11249589825,find_unique_number,"from collections import Counter

def find_unique_number(nums):
    count = Counter(nums)
    for num, freq in count.items():
        if freq == 1:
            return num

# Test cases
assert find_unique_number([2,2,3,2]) == 3
assert find_unique_number([0,1,0,1,0,1,99]) == 99
assert find_unique_number([1,1,1,2,2,2,3]) == 3",105
18314732943,max_sub_array_len,"import collections

def max_sub_array_len(nums, k):
    hash_map = collections.defaultdict(list) 
    cum_sum = 0
    hash_map[0].append(-1)
    max_len = 0
    for i in range(len(nums)):
        cum_sum += nums[i]
        hash_map[cum_sum].append(i)
        if cum_sum-k in hash_map:
            for j in hash_map[cum_sum-k]:
                max_len = max(max_len,i-j)
    return max_len",105
30829656186,findAllMissingNumber,"def findAllMissingNumber(array):
    i, n = 0, len(array)
    while i < n:
        correct = array[i] - 1
        if array[i] != array[correct]:
            array[i], array[correct] = array[correct], array[i]
        else:
            i += 1
    missingArray = []
    for i in range(len(array)):
        if array[i] != i + 1:
            missingArray.append(i + 1)
    return missingArray",105
71022235771,count_subarrays_with_sum,"def count_subarrays_with_sum(nums, k):
    count = 0
    current_sum = 0
    sum_occurrences = {0: 1}
    for num in nums:
        current_sum += num
        if current_sum - k in sum_occurrences:
            count += sum_occurrences[current_sum - k]
        if current_sum in sum_occurrences:
            sum_occurrences[current_sum] += 1
        else:
            sum_occurrences[current_sum] = 1
    return count",105
31743587250,longestConsecutiveSequence,"def longestConsecutiveSequence(nums):
    if not nums:
        return 0
    nums_set = set(nums)
    max_len = 0
    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1
            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1
            max_len = max(max_len, current_streak)
    return max_len",105
35114380315,maxSubArrayLength,"def maxSubArrayLength(arr):
    max_len = 0
    sum = 0
    d = {}
    for i in range(len(arr)):
        if arr[i] == 0:
            sum -= 1
        else:
            sum += 1
        if sum == 0:
            max_len = i+1
        elif sum in d:
            max_len = max(max_len, i-d[sum])
        else:
            d[sum] = i
    return max_len",105
23945095251,largest_number,"import functools


def largest_number(numbers):
    def comparator(n1, n2):
        number_1 = int(n1 + n2)
        number_2 = int(n2 + n1)

        return (number_1 > number_2) - (number_1 < number_2)

    numbers = list(map(str, numbers))
    numbers = sorted(numbers, key=functools.cmp_to_key(comparator), reverse=True)

    answer = str(int("""".join(numbers)))
    return answer",105
34908942416,longest_subarray_sum,"def longest_subarray_sum(nums, target):
    max_length = 0
    current_sum = 0
    start = 0
    sum_dict = {0: -1}
    
    for end in range(len(nums)):
        current_sum += nums[end]
        if current_sum not in sum_dict:
            sum_dict[current_sum] = end
        if current_sum - target in sum_dict:
            max_length = max(max_length, end - sum_dict[current_sum - target])
    
    return max_length",105
73504019992,longest_consecutive,"def longest_consecutive(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",105
1208641695,longest_Consecutive,"def longest_Consecutive(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",105
2613860768,smallestMissingPositive,"def smallestMissingPositive(nums):
    max_size = len(nums)
    for i in range(max_size):
        while 1 <= nums[i] <= max_size and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(max_size):
        if nums[i] != i + 1:
            return i + 1
    return max_size + 1",105
32383887072,can_form_string,"from typing import List

def can_form_string(s: str, word_list: List[str]) -> bool:
    word_set = set(word_list)
    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break

    return dp[len(s)]",105
39586271929,check_dates,"def check_dates(date1, date2):
    answer = 0
    if date1[0]!=date2[0]:
        if date1[0]<date2[0]:
            return 1
    elif date1[1]!=date2[1]:
        if date1[1]<date2[1]:
            return 1
    elif date1[2]!=date2[2]:
        if date1[2]<date2[2]:
            return 1
    return answer",105
28419153457,max_product_of_three,"def max_product_of_three(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])

assert max_product_of_three([-10, -10, 1, 3, 2]) == 300
assert max_product_of_three([1, 2, 3]) == 6
assert max_product_of_three([1, 2, 3, 4]) == 24",105
18246448068,longest_consecutive,"def longest_consecutive(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",105
30798399161,min_triangle_path,"def min_triangle_path(triangle):

	
	table = []

	m = len(triangle)

	n = len(triangle[m-1])

	

	for i in range(n):

		table.append(triangle[m-1][i])

	

	for i in range(m-2,-1,-1): #from the 2nd last to first row

		for j in range(len(triangle[i])):

			table[j] = triangle[i][j] + min(table[j],table[j+1])

		

	return table[0]",105
33785290243,longest_consecutive,"def longest_consecutive(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",105
73782761811,nth_prime_fibonacci,"from sympy import isprime

def nth_prime_fibonacci(n):
    fib_sequence = [0, 1]
    prime_fibs = []
    
    i = 2
    while len(prime_fibs) < n:
        fib_number = fib_sequence[i-1] + fib_sequence[i-2]
        fib_sequence.append(fib_number)
        if isprime(fib_number):
            prime_fibs.append(fib_number)
        i += 1
    
    return prime_fibs[-1]",105
34467119550,valid_bracket_sequence,"def valid_bracket_sequence(s: str) -> bool:
    bracket_map = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}
    open_brackets = set([""("", ""{"", ""[""])
    stack = []
    
    for char in s:
        if char in open_brackets:
            stack.append(char)
        elif char in bracket_map:
            if not stack or stack.pop() != bracket_map[char]:
                return False
        else:
            # Invalid character
            return False
    
    return not stack",105
20432503859,longest_consecutive,"def longest_consecutive(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",105
29750821606,combination_sum,"from typing import List

def combination_sum(candidates: List[int], target: int) -> List[List[int]]:
    def dfs(remaining, start, path):
        if remaining == 0:
            result.append(path)
            return
        for i in range(start, len(candidates)):
            if candidates[i] > remaining:
                break
            dfs(remaining - candidates[i], i, path + [candidates[i]])

    candidates.sort()
    result = []
    dfs(target, 0, [])
    return result",105
19875598149,longest_consecutive,"def longest_consecutive(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",105
36484140010,partition_palindromes,"def partition_palindromes(s: str):
    def isPalindrome(sub):
        return sub == sub[::-1]

    def dfs(cur_index):
        if cur_index >= len(s):
            res.append(part.copy())
            return

        for j in range(cur_index, len(s)):
            if isPalindrome(s[cur_index:j+1]):
                part.append(s[cur_index:j+1])
                dfs(j+1)
                part.pop()

    res = []
    part = []
    dfs(0)
    return res",105
2798236803,find_occurrences,"def find_occurrences(L, x):
    a=L
    answer=[]
    cp=0
    
    while x in a:
        if len(answer)==0:
            p=a.index(x)
            answer.append(p)
            a=a[p+1:]
            cp=p+1
        else:
            p=a.index(x)
            answer.append(p+cp)
            a=a[p+1:]
            cp=cp+p+1
    
    if len(answer)==0:
        answer=[-1]
        
    return answer",105
70228160956,max_number,"def compare(n1, n2):
    return int(str(n1) + str(n2)) > int(str(n2) + str(n1))

def max_number(nums):
    for i in range(len(nums)):
        for j in range(len(nums) - 1, i, -1):
            if not compare(nums[j - 1], nums[j]):
                nums[j - 1], nums[j] = nums[j], nums[j - 1]

    return int(''.join(map(str, nums)))",105
71118655224,change_making,"def change_making(money, coins):
    """"""
    This function takes an integer representing the amount of money and a list of coins and returns the number of ways
    to make change for the given amount using the coins.
    """"""
    ways = [0] * (money + 1)
    ways[0] = 1
    for coin in coins:
        for i in range(coin, money + 1):
            ways[i] += ways[i - coin]
    return ways[money]",105
6907832456,find_longest_subarray,"def find_longest_subarray(A):
    max_len = 0
    count = 0
    hash_map = {0: -1}
    for i in range(len(A)):
        if A[i] == 0:
            count -= 1
        elif A[i] == 1:
            count += 1
        
        if count in hash_map:
            max_len = max(max_len, i - hash_map[count])
        else:
            hash_map[count] = i
    return max_len",105
1825282418,canRearrange,"def canRearrange(s1, s2):
    m = {}
    for c in s1:
        if c in m:
            m[c] += 1
        else:
            m[c] = 1
    for c in s2:
        if c not in m or m[c] == 0:
            return False
        else:
            m[c] -= 1
    for key in m:
        if m[key] != 0:
            return False
    return True",105
69805992408,longest_Consecutive,"def longest_Consecutive(nums):
    if not nums:
        return 0
    nums = set(nums)
    longest_streak = 0
    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1
            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1
            longest_streak = max(longest_streak, current_streak)
    return longest_streak",105
34013713154,longest_subarray_with_zero_sum,"def longest_subarray_with_zero_sum(A):
    d = {}
    preSum = [0]
    maxLen = 0
    d[0] = -1
    
    for i in range(len(A)):
        preSum.append(A[i] + preSum[-1])
        
        if preSum[-1] not in d:
            d[preSum[-1]] = i
        else:
            maxLen = max(maxLen, i - d[preSum[-1]])
            
    return maxLen",105
6531931525,longest_balanced_parentheses,"def longest_balanced_parentheses(s):
    stack = []
    max_length = 0
    start = -1

    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            if not stack:
                start = i
            else:
                stack.pop()
                if not stack:
                    max_length = max(max_length, i - start)
                else:
                    max_length = max(max_length, i - stack[-1])
    return max_length",105
6511369845,is_valid_isbn,"def is_valid_isbn(isbn):
    if len(isbn) != 10:
        return False
    total = 0
    for i, char in enumerate(isbn):
        if char == 'X':
            if i != 9:
                return False
            total += 10 * (10 - i)
        elif char.isdigit():
            total += int(char) * (10 - i)
        else:
            return False
    return total % 11 == 0",105
31121337026,days_until_birthday,"from datetime import datetime

def days_until_birthday(current_date: str, birth_date: str) -> int:
    current = datetime.strptime(current_date, ""%Y-%m-%d"")
    birth = datetime.strptime(birth_date, ""%Y-%m-%d"")
    next_birthday = datetime(current.year, birth.month, birth.day)
    if next_birthday < current:
        next_birthday = datetime(current.year + 1, birth.month, birth.day)
    return (next_birthday - current).days",105
15952785821,subarrays_with_given_sum,"def subarrays_with_given_sum(arr, target_sum):
    sum_map = {0: 1}
    current_sum = 0
    count = 0
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum - target_sum in sum_map:
            count += sum_map[current_sum - target_sum]
        if current_sum in sum_map:
            sum_map[current_sum] += 1
        else:
            sum_map[current_sum] = 1
    return count",105
15952231681,max_consecutive_occurrence,"def max_consecutive_occurrence(s: str) -> int:
    if s is None or not (1 <= len(s) <= 500):
        return 0
    max_count, current_count = 1, 1
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 1
    return max_count",105
21291102377,is_bipartite_dfs,"def is_bipartite_dfs(graph):
    color = {}
    for node in range(len(graph)):
        if node not in color:
            stack = [node]
            color[node] = 0
            while stack:
                node = stack.pop()
                for neighbor in graph[node]:
                    if neighbor in color:
                        if color[neighbor] == color[node]:
                            return False
                    else:
                        color[neighbor] = 1 - color[node]
                        stack.append(neighbor)
    return True",104
2536539666,count_BST,"def count_BST(n): 
    catalan = [0 for i in range(n + 1)] 
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n + 1): 
        catalan[i] = 0
        for j in range(i): 
            catalan[i] = catalan[i] + catalan[j] * catalan[i-j-1] 
    return catalan[n]",104
23744308032,can_be_palindrome,"def can_be_palindrome(s: str) -> bool:
    if s == s[::-1]:
        return True
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            one, two = s[left:right], s[left+1:right+1]
            return one == one[::-1] or two == two[::-1]
        left, right = left + 1, right - 1
    return True",104
20298124412,is_permutation_of_palindrome,"def is_permutation_of_palindrome(phrase):
    char_dict = {}
    phrase = phrase.lower().replace(' ', '') # ignore case and spaces
    for char in phrase:
        if char in char_dict:
            char_dict[char] += 1
        else:
            char_dict[char] = 1
    odd_counts = 0
    for count in char_dict.values():
        if count % 2 != 0:
            odd_counts += 1
    return odd_counts <= 1",104
26125538406,max_xor_subarray,"from typing import List
from functools import reduce
from operator import xor

def max_xor_subarray(nums: List[int]) -> int:
    prefix_xor = [0]
    for num in nums:
        prefix_xor.append(prefix_xor[-1] ^ num)
    max_xor = 0
    for i in range(len(prefix_xor)):
        for j in range(i + 1, len(prefix_xor)):
            max_xor = max(max_xor, prefix_xor[j] ^ prefix_xor[i])
    return max_xor",104
24446542150,max_prime_diff,"def is_prime(n):
  if n < 2:
    return False
  for i in range(2, int(n ** 0.5) + 1):
    if n % i == 0:
      return False
  return True

def max_prime_diff(nums):
  primes = [num for num in nums if is_prime(num)]
  if not primes:
    return -1
  primes.sort()
  max_diff = primes[-1] - primes[0]
  return max_diff",104
29439784774,unique_words,"from collections import Counter

def unique_words(words):
    word_counts = Counter(words)
    return [word for word in words if word_counts[word] == 1]

print(unique_words([""apple"", ""orange"", ""banana"", ""apple"", ""kiwi"", ""banana""]))
print(unique_words([""hello"", ""world"", ""hello"", ""python"", ""world"", ""again""]))
print(unique_words([""this"", ""is"", ""a"", ""test"", ""test"", ""of"", ""a"", ""test""]))",104
19969831235,consecutive_length,"def consecutive_length(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",104
27856681654,is_valid_isbn,"def is_valid_isbn(isbn):
    if len(isbn) != 10:
        return False

    isbn = isbn.upper()
    total = 0
    for i, char in enumerate(isbn):
        if i == 9 and char == 'X':
            total += 10 * 10
        elif not char.isdigit():
            return False
        else:
            total += int(char) * (i + 1)

    return total % 11 == 0",104
21379531724,word_segment,"from typing import List, Set


def word_segment(s: str, wordDict: List[str]) -> bool:
    words = set(wordDict)
    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in words:
                dp[i] = True
                break
    return dp[len(s)]",104
18760460566,max_in_sliding_window,"from typing import List
import collections

def max_in_sliding_window(nums: List[int], k: int) -> List[int]:
    d = collections.deque()
    out = []
    for i, n in enumerate(nums):
        while d and nums[d[-1]] < n:
            d.pop()
        d += i,
        if d[0] == i - k:
            d.popleft()
        if i >= k - 1:
            out += nums[d[0]],
    return out",104
24491396334,length_of_longest_substring,"def length_of_longest_substring(s):
    if not s:
        return 0
    left = 0
    max_length = 0
    used_char = {}

    for right in range(len(s)):
        if s[right] in used_char and left <= used_char[s[right]]:
            left = used_char[s[right]] + 1
        else:
            max_length = max(max_length, right - left + 1)

        used_char[s[right]] = right

    return max_length",104
30874975762,is_confusing_number,"def is_confusing_number(n: int) -> bool:
    valid_dict={'0':'0','1':'1','6':'9','8':'8','9':'6'}
    invalid_dict={'2':'0','3':'0','4':'0','5':'0','7':'0'}
    new_num=""""
    for i in str(n):
        if i in invalid_dict:
            return False
        new_num+=valid_dict[i]
    return True if int(new_num[::-1])!=n else False",104
4099710000,is_palindrome_permutation,"def is_palindrome_permutation(s):
    s = s.replace("" "", """").lower()
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
        if odd_count > 1:
            return False
    return True",104
74002493246,find_triplet,"def find_triplet(arr, target_sum):
    arr.sort()
    n = len(arr)
    for i in range(n - 2):
        left = i + 1
        right = n - 1
        while left < right:
            current_sum = arr[i] + arr[left] + arr[right]
            if current_sum == target_sum:
                return True
            elif current_sum < target_sum:
                left += 1
            else:
                right -= 1
    return False",104
26624127079,find_longest_unique_substring,"def find_longest_unique_substring(s):
    if not s:
        return 0
    start = 0
    max_length = 0
    used_chars = {}
    for i in range(len(s)):
        if s[i] in used_chars and start <= used_chars[s[i]]:
            start = used_chars[s[i]] + 1
        else:
            max_length = max(max_length, i - start + 1)
        used_chars[s[i]] = i
    return max_length",104
70573610949,smallest_subsequence,"from collections import Counter

def smallest_subsequence(text):
    last_occurrence = {char: idx for idx, char in enumerate(text)}
    result = []
    in_result = set()
    stack = []

    for i, char in enumerate(text):
        if char not in in_result:
            while stack and stack[-1] > char and i < last_occurrence[stack[-1]]:
                in_result.remove(stack.pop())
            stack.append(char)
            in_result.add(char)

    return ''.join(stack)",104
36878101998,findMaxLength,"def findMaxLength(nums):
    left, right, max_len = 0, 0, 0
    zero_count = 0

    while right < len(nums):
        if nums[right] == 0:
            zero_count += 1

        while zero_count > 1:
            if nums[left] == 0:
                zero_count -= 1
            left += 1

        max_len = max(max_len, right - left)
        right += 1

    return max_len",104
9542809871,longest_sequence,"def longest_sequence(nums):
    if not nums:
        return 0
    nums = set(nums)
    longest_streak = 0
    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",104
18918669375,nth_prime,"def nth_prime(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    prime_count = 0
    num = 2
    while True:
        if is_prime(num):
            prime_count += 1
            if prime_count == n:
                return num
        num += 1",104
18367499222,is_palindrome_number,"def is_palindrome_number(num):
    num_str = str(num)
    return num_str == num_str[::-1]

assert is_palindrome_number(12321) == True
assert is_palindrome_number(123456) == False
assert is_palindrome_number(1111) == True
assert is_palindrome_number(1234321) == True
assert is_palindrome_number(123456789) == False",104
71298091410,time_conversion,"def time_conversion(s):
    if s[-2:] == ""AM"" and s[:2] == ""12"": 
        return ""00"" + s[2:-2]
    elif s[-2:] == ""AM"":
        return s[:-2]
    elif s[-2:] == ""PM"" and s[:2] == ""12"":
        return s[:-2]
    else:
        return str(int(s[:2]) + 12) + s[2:8]",104
30811612162,merge_lists,"def merge_lists(list1, list2):
    merged_list = []
    i, j = 0, 0
    while i < len(list1) and j < len(list2):
        merged_list.append(list1[i])
        merged_list.append(list2[j])
        i += 1
        j += 1
    if i < len(list1):
        merged_list.extend(list1[i:])
    if j < len(list2):
        merged_list.extend(list2[j:])
    return merged_list",104
37879878749,largest_subarray,"def largest_subarray(arr):
    hashmap = {}
    max_length = 0
    count = 0
    for i in range(len(arr)):
        if arr[i] == 0:
            count -= 1
        else:
            count += 1
        if count == 0:
            max_length = i + 1
        elif count in hashmap:
            max_length = max(max_length, i - hashmap[count])
        else:
            hashmap[count] = i
    return max_length",104
12189077003,count_valid_parentheses,"def count_valid_parentheses(n):
    if n % 2 != 0:
        return 0
    n = n // 2
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        for j in range(i - 1, -1, -1):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",104
5374555810,isPerfectSquare,"def isPerfectSquare(num) :
    if num < 0:
        return False
    if num == 0 or num == 1:
        return True
    left, right = 0, num
    while left <= right:
        mid = (left + right) // 2
        if mid * mid == num:
            return True
        elif mid * mid < num:
            left = mid + 1
        else:
            right = mid - 1
    return False",104
20224494908,nth_prime,"def nth_prime(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    prime_count = 0
    number = 2
    while True:
        if is_prime(number):
            prime_count += 1
            if prime_count == n:
                return number
        number += 1",104
70023172247,isPerfectSquare,"def isPerfectSquare(num):
    if num < 0:
        return False
    if num == 1:
        return True
    start = 1
    end = num//2
    while start <= end:
        mid = (start + end) // 2
        square = mid * mid
        if square == num:
            return True
        elif square < num:
            start = mid + 1
        else:
            end = mid - 1
    return False",104
42020539860,catalan_number,"def catalan_number(n):
    if n == 0 or n == 1:
        return 1
    catalan = [0 for i in range(n + 1)]
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i - j - 1]
    return catalan[n]",104
9880825531,wordBreak,"from typing import List

def wordBreak(s: str, wordDict: List[str]) -> bool:
    wordSet = set(wordDict)
    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordSet:
                dp[i] = True
                break

    return dp[len(s)]",104
25804902994,find_target_positions,"from typing import List

def find_target_positions(nums: List[int], target: int) -> List[int]:
    none_result = [-1, -1]
    if not nums:
        return none_result
    result = []
    for index, num in enumerate(nums):
        if num == target:
            if not result or index != result[-1]:
                result.append(index)
    if len(result) > 1:
        return [result[0], result[-1]]
    else:
        return none_result",104
10283747413,combination_sum3,"def combination_sum3(k, n):
    def helper(k, n, start, current_combination):
        if k == 0 and n == 0:
            result.append(current_combination)
            return
        if k > 0 and n > 0:
            for i in range(start, 10):
                helper(k-1, n-i, i+1, current_combination + [i])
    
    result = []
    helper(k, n, 1, [])
    return result",104
16164209198,minSwapToSort,"def minSwapToSort(arr):
  n = len(arr)
  pos = {a:i for i, a in enumerate(arr)}
  ans = 0
  for i in range(n):
    if arr[i] != i+1:
      ans += 1
      t = arr[i]
      arr[i], arr[pos[i+1]] = arr[pos[i+1]], arr[i]
      pos[t] = pos[i+1]
      pos[i+1] = i
  return ans",104
72392179036,longest_sequence,"def longest_sequence(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",104
34197569657,countAndSay,"def countAndSay(n):
    if n == 1:
        return ""1""
    prev = countAndSay(n - 1)
    result = """"
    count = 1
    for i in range(1, len(prev)):
        if prev[i] == prev[i - 1]:
            count += 1
        else:
            result += str(count) + prev[i - 1]
            count = 1
    result += str(count) + prev[-1]
    return result",104
23266309763,find_max_consecutive_ones,"def find_max_consecutive_ones(nums, k):
    left = 0
    max_len = 0
    zero_count = 0
    
    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1
        
        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        
        max_len = max(max_len, right - left + 1)
    
    return max_len",104
14174695550,largest_palindrome,"def largest_palindrome(n):
    max_num = 10**n - 1
    min_num = 10**(n-1)
    result = 0
    for i in range(max_num, min_num-1, -1):
        for j in range(i, min_num-1, -1):
            product = i * j
            if product <= result:
                break
            if str(product) == str(product)[::-1]:
                result = product
    return result",104
10514526011,longest_Substring,"def longest_Substring(s):
    charSet = set()
    l = 0
    res = ''
    resLen = 0
    for r in range(len(s)):
        while s[r] in charSet:
            charSet.remove(s[l])
            l += 1
        charSet.add(s[r])
        if (r - l + 1) > resLen:
            resLen = (r - l + 1)
            res = s[l:r+1]
    return res",104
42535632906,count_bsts,"def count_bsts(n):
    count = [0] * (n + 1)
    count[0] = 1
    count[1] = 1
    for nodes in range(2, n + 1):
        for root in range(1, nodes + 1):
            left_subtrees = count[root - 1]
            right_subtrees = count[nodes - root]
            count[nodes] += left_subtrees * right_subtrees
    return count[n]",104
14149152592,max_non_overlapping_intervals,"def max_non_overlapping_intervals(intervals):
    if not intervals:
        return 0

    intervals.sort(key=lambda x: x[1])  # Sort intervals based on end time

    count = 1  # Count of non-overlapping intervals
    end_time = intervals[0][1]

    for i in range(1, len(intervals)):
        if intervals[i][0] >= end_time:
            count += 1
            end_time = intervals[i][1]

    return count",104
10665916591,sequentialDigits,"def sequentialDigits(low: int, high: int) -> list[int]:
    low_power = len(str(low))
    high_power = len(str(high))
    candidates = []

    for power in range(low_power, high_power + 1):
        for i in range(1,11-power):
            candidate = """"
            for j in range(i, i + power):
                candidate += str(j)
            candidates.append(int(candidate))
    
    return [c for c in candidates if low <= c <= high]",104
34253349278,remove_occurrences,"def remove_occurrences(nums, val):
    if len(nums) == 0:
        return 0
    k = len(nums)
    for i in range(len(nums) - 1, -1, -1):
        if nums[i] == val:
            nums[i] = None
            k -= 1
    i = 0
    while None in nums:
        if nums[i] is None:
            nums.pop(i)
        else:
            i += 1
    return k",104
13775319486,catalan_number,"def catalan_number(n):
    if n <= 1:
        return 1

    catalan = [0 for i in range(n+1)]
    catalan[0] = 1
    catalan[1] = 1

    for i in range(2, n+1):
        catalan[i] = 0
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]

    return catalan[n]",104
72042630047,pig_latin,"def pig_latin(word):
    vowels = ['a', 'e', 'i', 'o', 'u']
    if word[0] in vowels:
        return word + ""way""
    else:
        first_consonant_cluster = """"
        for letter in word:
            if letter not in vowels:
                first_consonant_cluster += letter
                word = word[len(first_consonant_cluster):]
            else:
                break
        return word + first_consonant_cluster + ""ay""",104
32907098546,length_of_longest_substring,"def length_of_longest_substring(s):
    """"""
    :type s: str
    :rtype: int
    """"""
    char_map = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",104
11016596596,count_distinct_subsequences,"def count_distinct_subsequences(s, t):
    m, n = len(s), len(t)
    dp = [0] * (n + 1)
    dp[0] = 1
    
    for i in range(1, m + 1):
        for j in range(min(i, n), 0, -1):
            if s[i - 1] == t[j - 1]:
                dp[j] += dp[j - 1]
    
    return dp[n]",104
74960677945,max_sum_non_adjacent,"def max_sum_non_adjacent(nums):
    if not nums:
        return 0
    elif len(nums) <= 2:
        return max(nums)
    else:
        dp = [0]*len(nums)
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])
        return dp[-1]",104
4913974881,generate_parentheses,"from typing import List

def generate_parentheses(n: int) -> List[str]:
    def backtrack(s, left, right, res):
        if len(s) == 2 * n:
            res.append(s)
            return
        if left < n:
            backtrack(s+'(', left+1, right, res)
        if right < left:
            backtrack(s+')', left, right+1, res)

    result = []
    backtrack('', 0, 0, result)
    return result",104
19863283218,are_lists_similar,"from collections import defaultdict

def are_lists_similar(words1, words2, pairs):
    if len(words1) != len(words2): return False
        
    similar = defaultdict(list)
        
    for first, sec in pairs:
        similar[first].append(sec)
        similar[sec].append(first)
        
    for i in range(len(words1)):
        if words1[i] != words2[i]:
            if words2[i] not in similar[words1[i]]: return False
    
    return True",104
20856021760,find_max_diff,"def find_max_diff(arr):
    if len(arr) < 2:
        return 0
    min_val = arr[0]
    max_diff = arr[1] - arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_val > max_diff:
            max_diff = arr[i] - min_val
        if arr[i] < min_val:
            min_val = arr[i]
    return max_diff if max_diff > 0 else 0",104
27866159296,is_valid_number,"def is_valid_number(s: str) -> bool:
    s = s.strip()
    try:
        if 'e' in s or 'E' in s:
            if s.count('e') + s.count('E') > 1:
                return False
            if '.' in s:
                float(s)
            else:
                int(s.split('e')[0])
            int(s.split('e')[1])
        else:
            float(s)
        return True
    except ValueError:
        return False",104
9164730539,longest_sequence,"def longest_sequence(nums):
    if not nums:
        return 0

    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",104
34466869380,find_subarray_count,"from typing import List

def find_subarray_count(nums: List[int], k: int) -> int:
    prefixsum = {}
    prefixsum[0] = 1

    acc = 0
    result = 0
    for i in range(len(nums)):
        acc += nums[i]
        if acc - k in prefixsum:
            result += prefixsum[acc - k]
        prefixsum[acc] = prefixsum.get(acc, 0) + 1

    return result",104
28850610218,find_min_fibonacci_numbers,"def find_min_fibonacci_numbers(k):
    if k <= 1:
        return k
    fib = [1, 1]
    while fib[-1] < k:
        fib.append(fib[-1] + fib[-2])
    
    count = 0
    i = len(fib) - 1
    while k > 0:
        if k >= fib[i]:
            k -= fib[i]
            count += 1
        i -= 1
    return count",104
72465066868,longest_subarray_with_equal_zeros_ones,"def longest_subarray_with_equal_zeros_ones(arr):
    sum = 0
    max_len = 0
    sum_dict = {0: -1}
    for i in range(len(arr)):
        if arr[i] == 0:
            sum -= 1
        else:
            sum += 1
        
        if sum in sum_dict.keys():
            max_len = max(max_len, i-sum_dict[sum])
        else:
            sum_dict[sum] = i
    return max_len",104
3472646784,num_trees,"def num_trees(n):
    dp = [0 for _ in range(n + 1)]
    dp[0] = 1
    dp[1] = 1
    for nodes in range(2, n + 1):
        for root in range(1, nodes + 1):
            left_subtrees = dp[root - 1]
            right_subtrees = dp[nodes - root]
            dp[nodes] += left_subtrees * right_subtrees
    return dp[n]",104
2309028654,caesar_cipher,"def caesar_cipher(text, shift):
    encrypted_text = """"
    for char in text:
        if char.isalpha():
            shifted = ord(char) + shift
            if char.islower():
                encrypted_text += chr(shifted) if shifted <= ord('z') else chr(shifted - 26)
            else:
                encrypted_text += chr(shifted) if shifted <= ord('Z') else chr(shifted - 26)
        else:
            encrypted_text += char
    return encrypted_text",104
18203533758,grid_traversal,"def grid_traversal(m, n):
    dp = [[0 for _ in range(n)] for _ in range(m)]
    dp[0][0] = 1
    for i in range(m):
        for j in range(n):
            if i > 0:
                dp[i][j] += dp[i-1][j]
            if j > 0:
                dp[i][j] += dp[i][j-1]
    return dp[m-1][n-1]",103
1425741826,product_Of_Primes,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def product_Of_Primes(nums):
    product = 1
    prime_found = False
    for num in nums:
        if is_prime(num):
            product *= num
            prime_found = True
    return product if prime_found else -1",103
39659314590,most_frequent_elements,"def most_frequent_elements(nums):
    count_dict = {}
    for num in nums:
        if num in count_dict:
            count_dict[num] += 1
        else:
            count_dict[num] = 1
    max_count = 0
    for count in count_dict.values():
        if count > max_count:
            max_count = count
    result = []
    for key, value in count_dict.items():
        if value == max_count:
            result.append(key)
    return result",103
70183216665,find_smallest_missing_positive,"def find_smallest_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",103
26528104432,pairCounter,"def pairCounter(nums):
    if len(nums) == 1:
        return [0, 1]
    d = {}
    for i in range(len(nums)):
        d[nums[i]] = d.get(nums[i], 0) + 1
    count1 = 0
    count2 = 0
    for k, v in d.items():
        count1 += v // 2
        count2 += v % 2
    return [count1, count2]",103
33309172265,is_permutation_palindrome,"def is_permutation_palindrome(s):
    """"""
    Check if the input string is a permutation of a palindrome.
    """"""
    char_map = {}
    for char in s:
        if char in char_map:
            char_map[char] += 1
        else:
            char_map[char] = 1
    odd_count = 0
    for count in char_map.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1",103
40220042232,max_product_subarray,"def max_product_subarray(nums):
    if not nums:
        return 0

    max_product = min_product = result = nums[0]

    for i in range(1, len(nums)):
        if nums[i] < 0:
            max_product, min_product = min_product, max_product

        max_product = max(nums[i], max_product * nums[i])
        min_product = min(nums[i], min_product * nums[i])

        result = max(result, max_product)

    return result",103
11254264901,unique_paths,"def unique_paths(m, n):
    # Initialize a 2D array to store the number of ways to reach each cell
    dp = [[1 for _ in range(n)] for _ in range(m)]

    # Fill the dp array
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]

    return dp[m-1][n-1]",103
28483222834,find_most_frequent_char,"def find_most_frequent_char(s):
    if not s:
        return """"
    char_count = {}
    max_count = 0
    for c in s:
        if c in char_count:
            char_count[c] += 1
        else:
            char_count[c] = 1
        if char_count[c] > max_count or (char_count[c] == max_count and c not in char_count):
            max_count = char_count[c]
            result = c
    return result",103
8868953196,sub_arrays,"def sub_arrays(arr, k):
    count = 0
    curr_sum = 0
    sum_dict = {0:1}
    
    for i in range(len(arr)):
        curr_sum += arr[i]
        
        if (curr_sum - k) in sum_dict:
            count += sum_dict[curr_sum - k]
            
        if curr_sum in sum_dict:
            sum_dict[curr_sum] += 1
        else:
            sum_dict[curr_sum] = 1
            
    return count",103
24078030040,smallest_subarray,"def smallest_subarray(arr, target):
    window_sum = 0
    min_length = float('inf')
    window_start = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end]
        while window_sum >= target:
            min_length = min(min_length, window_end - window_start + 1)
            window_sum -= arr[window_start]
            window_start += 1
    return min_length if min_length != float('inf') else 0",103
14383122329,grid_ways,"def grid_ways(m, n):
    dp = [[0 for _ in range(n)] for _ in range(m)]
    dp[0][0] = 1
    for i in range(m):
        for j in range(n):
            if i > 0:
                dp[i][j] += dp[i-1][j]
            if j > 0:
                dp[i][j] += dp[i][j-1]
    return dp[m-1][n-1]",103
10575600661,max_subarray_length,"def max_subarray_length(nums, k):
    max_length = 0
    sum = 0
    sum_index = {}
    for i in range(len(nums)):
        sum += nums[i]
        if sum == k:
            max_length = i + 1
        elif sum - k in sum_index:
            max_length = max(max_length, i - sum_index[sum - k])
        if sum not in sum_index:
            sum_index[sum] = i
    return max_length",103
71230472886,max_number,"from collections import deque

def max_number(number, k):
    que = deque()
    le = len(number) - k
    
    for i in range(len(number)):
        if que:
            while que and que[-1] < number[i] and k != 0:
                que.pop()
                k -= 1
        que.append(number[i])
        if k == 0:
            break
    
    answer = ''.join(list(que)) + number[i+1:]
    return answer[:le]",103
71960414929,longest_Consecutive_subsequence,"def longest_Consecutive_subsequence(s: str) -> str:
    max_len = 1
    start = 0
    max_start = 0
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            if i - start + 1 > max_len:
                max_len = i - start + 1
                max_start = start
        else:
            start = i
    return s[max_start:max_start + max_len]",103
34106917873,max_distinct_subarray,"def max_distinct_subarray(arr):
    n = len(arr)
    distinct_subarray = []
    max_len = 0
    for i in range(n):
        distinct_set = set()
        for j in range(i, n):
            if arr[j] not in distinct_set:
                distinct_set.add(arr[j])
                distinct_subarray.append(arr[i:j+1])
                max_len = max(max_len, len(distinct_subarray[-1]))
            else:
                break
    return max_len",103
41128786143,sum_of_primes_below,"def sum_of_primes_below(n):
    if n <= 2:
        return 0
    sieve = [True] * n
    sieve[0] = sieve[1] = False
    for i in range(2, int(n**0.5) + 1):
        if sieve[i]:
            for j in range(i*i, n, i):
                sieve[j] = False
    return sum(i for i, is_prime in enumerate(sieve) if is_prime)",103
12187933753,validate_isbn,"def validate_isbn(isbn):
    if len(isbn) != 10:
        return False
    sum = 0
    for i in range(9):
        if not isbn[i].isdigit():
            return False
        sum += int(isbn[i]) * (10 - i)
    if isbn[9] == 'X':
        sum += 10
    elif not isbn[9].isdigit():
        return False
    return sum % 11 == 0",103
41186059929,largest_product_subarray,"def largest_product_subarray(nums):
    if not nums:
        return 0

    max_product = min_product = result = nums[0]

    for i in range(1, len(nums)):
        if nums[i] < 0:
            max_product, min_product = min_product, max_product

        max_product = max(nums[i], max_product * nums[i])
        min_product = min(nums[i], min_product * nums[i])

        result = max(result, max_product)

    return result",103
73874283516,max_overlapping_intervals,"def max_overlapping_intervals(intervals):
    events = []
    for start, end in intervals:
        events.append((start, 'start'))
        events.append((end, 'end'))
    events.sort()
    max_overlap, current_overlap = 0, 0
    for _, event_type in events:
        if event_type == 'start':
            current_overlap += 1
            max_overlap = max(max_overlap, current_overlap)
        else:
            current_overlap -= 1
    return max_overlap",103
38901598451,find_longest_increasing_subsequence,"def find_longest_increasing_subsequence(arr):
    n = len(arr)
    lis = [1]*n

    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1

    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])

    return maximum",103
33322470893,max_product_subarray,"def max_product_subarray(nums):
    if not nums:
        return 0
    max_product = min_product = result = nums[0]
    for i in range(1, len(nums)):
        if nums[i] < 0:
            max_product, min_product = min_product, max_product
        max_product = max(nums[i], max_product * nums[i])
        min_product = min(nums[i], min_product * nums[i])
        result = max(result, max_product)
    return result",103
12213810663,max_product_subarray,"def max_product_subarray(nums):
  if not nums:
    return 0
  cur_max, cur_min = nums[0], nums[0]
  res = nums[0]
  for i in range(1, len(nums)):
    temp = cur_max * nums[i]
    cur_max = max(nums[i], temp, cur_min * nums[i])
    cur_min = min(nums[i], temp, cur_min * nums[i])
    res = max(res, cur_max)
  return res",103
42370484149,set,"def permutations(s):
    if len(s) == 0:
        return ['']
    prev_list = permutations(s[1:len(s)])
    next_list = []
    for i in range(0, len(prev_list)):
        for j in range(0, len(s)):
            new_str = prev_list[i][0:j] + s[0] + prev_list[i][j:len(s)-1]
            if new_str not in next_list:
                next_list.append(new_str)
    return next_list",103
20382738864,longest_Subarray,"def longest_Subarray(arr):
    sum = 0
    max_length = 0
    sum_to_index = {0: -1}
    for i in range(len(arr)):
        if arr[i] == 0:
            sum -= 1
        else:
            sum += 1
        if sum in sum_to_index:
            max_length = max(max_length, i - sum_to_index[sum])
        else:
            sum_to_index[sum] = i
    return max_length",103
17479795935,longest_substring_length,"def longest_substring_length(s: str) -> int:
    n = len(s)
    if n <= 1:
        return n
    max_len = 0
    left = 0
    char_set = set()
    for right in range(n):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_len = max(max_len, right - left + 1)
    return max_len",103
16149760297,max_product_subarray,"def max_product_subarray(nums):
    if not nums:
        return 0

    max_product = min_product = result = nums[0]

    for i in range(1, len(nums)):
        if nums[i] < 0:
            max_product, min_product = min_product, max_product

        max_product = max(nums[i], max_product * nums[i])
        min_product = min(nums[i], min_product * nums[i])

        result = max(result, max_product)

    return result",103
28130552694,max_overlapping_intervals,"def max_overlapping_intervals(intervals):
    endpoints = []
    for start, end in intervals:
        endpoints.append((start, 'start'))
        endpoints.append((end, 'end'))
    endpoints.sort()
    max_overlap = 0
    current_overlap = 0
    for point, kind in endpoints:
        if kind == 'start':
            current_overlap += 1
            max_overlap = max(max_overlap, current_overlap)
        else:
            current_overlap -= 1
    return max_overlap",103
23637030244,maxDiff,"def maxDiff(nums):
    if len(nums) == 1:
        return 0
    minNum = nums[0]
    maxDiff = nums[1] - nums[0]
    for i in range(1, len(nums)):
        if nums[i] - minNum > maxDiff:
            maxDiff = nums[i] - minNum
        if nums[i] < minNum:
            minNum = nums[i]
    return maxDiff if maxDiff > 0 else 0",103
43534143185,consecutive_sequence,"def consecutive_sequence(nums):
    if len(nums) == 0:
        return False
    min_val = min(nums)
    max_val = max(nums)
    if max_val - min_val + 1 != len(nums):
        return False
    frequency = [0] * (max_val - min_val + 1)
    for num in nums:
        if frequency[num - min_val] > 0:
            return False
        frequency[num - min_val] += 1
    return True",103
32659533255,find_max_consecutive_ones,"def find_max_consecutive_ones(nums):
    left = 0
    max_len = 0
    zero_count = 0
    
    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1
        
        while zero_count > 1:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        
        max_len = max(max_len, right - left + 1)
    
    return max_len",103
18735492819,check_triplet_sum,"def check_triplet_sum(arr, target_sum):
    arr.sort()
    for i in range(len(arr) - 2):
        left = i + 1
        right = len(arr) - 1
        while left < right:
            current_sum = arr[i] + arr[left] + arr[right]
            if current_sum == target_sum:
                return True
            elif current_sum < target_sum:
                left += 1
            else:
                right -= 1
    return False",103
19310549736,intersect_lists,"def intersect_lists(list1, list2):
    return [value for value in list1 if value in list2]

# Testing the function
print(intersect_lists([1, 2, 2, 4], [2, 2, 4, 6]))
print(intersect_lists(['apple', 'banana', 'cherry'], ['banana', 'cherry', 'date']))
print(intersect_lists([1, 2, 3], [4, 5, 6]))",103
32320571339,two_sum,"def two_sum(nums, target):
    # Create a dictionary to store the numbers and their indices
    num_dict = {}
    for i, num in enumerate(nums):
        # Calculate the complement of the current number
        complement = target - num
        # Check if the complement exists in the dictionary
        if complement in num_dict:
            return [num_dict[complement], i]
        # Store the number and its index in the dictionary
        num_dict[num] = i
    return []",103
31152450126,count_and_say,"def count_and_say(n):
    if n == 1:
        return ""1""
    prev = count_and_say(n-1)
    result = """"
    count = 1
    for i in range(1, len(prev)):
        if prev[i] == prev[i-1]:
            count += 1
        else:
            result += str(count) + prev[i-1]
            count = 1
    result += str(count) + prev[-1]
    return result",103
8765021766,least_num_squares,"from math import sqrt

def least_num_squares(n):
    root = sqrt(n)
    squares = [x*x for x in range(int(root) + 1)]
    
    if n in squares:
        return 1
    
    for n1 in squares:
        if n - n1 in squares:
            return 2
            
    for n1 in squares:
        for n2 in squares:
            if n - n1 - n2 in squares:
                return 3
        
    return 4",103
42091708632,lcm,"from math import gcd

def lcm(numbers):
    def lcm_pair(a, b):
        return a * b // gcd(a, b)
    result = numbers[0]
    for num in numbers[1:]:
        result = lcm_pair(result, num)
    return result

print(lcm([2, 6, 8, 14]))
print(lcm([1, 2, 3]))
print(lcm([10, 15, 20, 25]))",103
16130880967,max_difference,"def max_difference(lst):
    if len(lst) < 2:
        return 0
    min_val = lst[0]
    max_diff = lst[1] - lst[0]
    for i in range(1, len(lst)):
        if lst[i] - min_val > max_diff:
            max_diff = lst[i] - min_val
        if lst[i] < min_val:
            min_val = lst[i]
    return max_diff if max_diff > 0 else 0",103
72241257742,firstMissingPositive,"def firstMissingPositive(nums):
    if not nums:
        return 1
    nums = list(set(nums))
    nums.sort()
    if nums[0] > 1:
        return 1
    for i in range(len(nums)-1):
        if nums[i+1] - nums[i] > 1 and nums[i] > 0:
            return nums[i] + 1
    return nums[-1] + 1 if nums[-1] > 0 else 1",103
29336084051,find_common_elements,"def find_common_elements(arr1, arr2):
    i, j = 0, 0
    common_elements = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] == arr2[j]:
            common_elements.append(arr1[i])
            i += 1
            j += 1
        elif arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return common_elements",102
37377964119,is_leap_year,"def is_leap_year(year):
    # Check if year is divisible by 4
    if year % 4 == 0:
        # Check if year is divisible by 100
        if year % 100 == 0:
            # Check if year is divisible by 400
            if year % 400 == 0:
                return True
            else:
                return False
        else:
            return True
    else:
        return False",102
26524052139,prime_sieve,"def prime_sieve(n):
    sieve = [True] * (n+1)
    sieve[0:2] = [False, False]
    for current in range(2, int(n**0.5) + 1):
        if sieve[current]:
            sieve[current*current:n+1:current] = [False] * len(sieve[current*current:n+1:current])
    return [x for x in range(2, n+1) if sieve[x]]",102
73183411082,first_Missing_Positive,"def first_Missing_Positive(nums):
    for i in range(len(nums)):
        while 1 <= nums[i] <= len(nums) and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(len(nums)):
        if nums[i] != i + 1:
            return i + 1
    return len(nums) + 1",102
33755110804,find_longest_subarray,"def find_longest_subarray(arr, k):
    left = 0
    max_length = 0
    zero_count = 0
    for right in range(len(arr)):
        if arr[right] == 0:
            zero_count += 1
        while zero_count > k:
            if arr[left] == 0:
                zero_count -= 1
            left += 1
        max_length = max(max_length, right - left + 1)
    return max_length",102
5930711682,is_bipartite,"def is_bipartite(graph):
    color = {}
    for node in range(len(graph)):
        if node not in color:
            stack = [node]
            color[node] = 0
            while stack:
                node = stack.pop()
                for neighbor in graph[node]:
                    if neighbor in color:
                        if color[neighbor] == color[node]:
                            return False
                    else:
                        color[neighbor] = 1 - color[node]
                        stack.append(neighbor)
    return True",102
2851535477,romanToInt,"def romanToInt(s):
    roman = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}
    res = 0
    for i in range(len(s)):
        if i + 1 < len(s) and roman[s[i]] < roman[s[i+1]]:
            res -= roman[s[i]]
        else:
            res += roman[s[i]]
    return res",102
74118154104,rotate,"def rotate(A, K):
    if len(A) == 0 or K == 0:
        return A
    if K % len(A) == 0:
        rotations = 1
    else:
        rotations = K % len(A)
    old = A
    new = [0]*len(A)
    for i in range(rotations):
        new[0]=old[-1]
        new[1:] = old[:-1]
        old = new.copy()
    return new",102
41906451061,find_missing_positive,"def find_missing_positive(A):
    n = len(A)
    for i in range(n):
        while A[i] > 0 and A[i] <= n and A[A[i] - 1] != A[i]:
            A[A[i] - 1], A[i] = A[i], A[A[i] - 1]
    
    for i in range(n):
        if A[i] != i + 1:
            return i + 1
    return n + 1",102
26088713665,min_moves,"def min_moves(nums):
    nums.sort()
    n = len(nums) 
    prefix = 0
    suffix = sum(nums)
    min_moves = float(""inf"")
    for i in range(n):
        suffix -= nums[i]
        moves_before = abs(prefix - (nums[i]*i))
        moves_after = suffix - ((n-i-1)*nums[i])
        min_moves = min(min_moves, (moves_before+moves_after))
        prefix += nums[i]
    return min_moves",102
14851605834,sieve_of_eratosthenes,"def sieve_of_eratosthenes(n):
    sieve = [True] * (n+1)
    sieve[0:2] = [False, False]
    for current in range(2, int(n**0.5) + 1):
        if sieve[current]:
            for multiple in range(current*current, n + 1, current):
                sieve[multiple] = False
    return [num for num in range(2, n+1) if sieve[num]]",102
41642391895,findMaxConsecutiveOnes,"def findMaxConsecutiveOnes(nums):
    left = 0
    zero_count = 0
    max_len = 0
    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1
        while zero_count > 1:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        max_len = max(max_len, right - left + 1)
    return max_len",102
43297797000,wordBreak,"def wordBreak(s, wordDict):
    wordDict = set(wordDict)
    dp = [False]*(len(s)+1)
    dp[0] = True  # have to set to True, otherwise can't find any word
        
    for i in range(1, len(s)+1):
        for j in range(0, i):
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break
    return dp[len(s)]",102
72464178548,count_ways,"def count_ways(n, k):
    if n == 0:
        return 0
    if n == 1:
        return k
    same = k
    diff = k * (k - 1)
    total_ways = same + diff
    for i in range(3, n + 1):
        same, diff = diff, (same + diff) * (k - 1)
        total_ways = same + diff
    return total_ways",102
42302223322,min_subarray_diff,"def min_subarray_diff(nums):
    # Initialize the minimum difference to the maximum possible value
    min_diff = float('inf')
    
    # Sort the list to easily find minimum differences between elements
    nums.sort()

    # Iterate through the list to find the minimum difference between consecutive elements
    for i in range(len(nums) - 1):
        diff = nums[i + 1] - nums[i]
        if diff < min_diff:
            min_diff = diff

    return min_diff",102
25827181626,leastBricks,"from collections import Counter

def leastBricks(wall):
    if not wall or not wall[0]:
        return 0
    freqMap = Counter()
    maxCross = 0
    for row in wall:
        sum = 0
        for i in range(len(row) - 1):
            sum += row[i]
            freqMap[sum] += 1
            maxCross = max(maxCross, freqMap[sum])
    return len(wall) - maxCross",102
26739043690,count_misplaced_students,"def count_misplaced_students(heights):
    counter = [0] * 101
    for height in heights:
        counter[height] += 1

    result = 0
    curHeight = 0
    for i in range(len(heights)):
        while(counter[curHeight] == 0):
            curHeight += 1

        if (curHeight != heights[i]):
            result += 1
        counter[curHeight] -= 1

    return result",102
38286999476,count_stair_ways,"def count_stair_ways(n):
    if n <= 1:
        return 1
    a, b = 1, 1
    for _ in range(n):
        a, b = b, a + b
    return a

# Alternative Recursive Solution
def count_stair_ways_recursive(n):
    if n <= 1:
        return 1
    return count_stair_ways_recursive(n-1) + count_stair_ways_recursive(n-2)",102
21585561439,find_missing_positive,"def find_missing_positive(nums):
    nums = [num for num in nums if num > 0]
    nums = list(set(nums))
    nums.sort()
    if not nums:
        return 1
    if nums[0] > 1:
        return 1
    for i in range(len(nums) - 1):
        if nums[i+1] > nums[i] + 1:
            return nums[i] + 1
    return nums[-1] + 1",102
177010020,get_lucas,"def get_lucas(n):
    if n == 0:
        return 2
    if n == 1:
        return 1
    lucas_0 = 2
    lucas_1 = 1
    for _ in range(2, n + 1):
        lucas_n = lucas_0 + lucas_1
        lucas_0 = lucas_1
        lucas_1 = lucas_n
    return lucas_n",102
38854003113,find_first_occurrence,"def find_first_occurrence(arr, target):
    low = 0
    high = len(arr) - 1
    result = -1
    while low <= high:
        mid = low + (high - low) // 2
        if arr[mid] == target:
            result = mid
            high = mid - 1
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return result",102
42072743774,count_unique_char_substrings,"def count_unique_char_substrings(s: str) -> int:
    count = 0
    left = 0
    n = len(s)
    
    for right in range(n):
        if s[right] != s[left]:
            length = right - left
            count += (length * (length + 1)) // 2
            left = right
    length = n - left
    count += (length * (length + 1)) // 2
    return count",102
3064069034,nth_prime,"def nth_prime(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True

    count = 0
    num = 2
    while True:
        if is_prime(num):
            count += 1
            if count == n:
                return num
        num += 1",102
40709059324,max_product_of_three,"def max_product_of_three(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])

assert max_product_of_three([-10, -10, 5, 2]) == 500
assert max_product_of_three([1, 2, 3]) == 6
assert max_product_of_three([1, 2, 3, 4]) == 24",102
31042016430,pascal_row,"def pascal_row(n):
    if n==0:
        return [1]
    if n==1:
        return [1,1]

    last = [1,1]
    for _ in range(2, n + 1):
        row = []
        for i in range(len(last) - 1):
            row.append(last[i] + last[i + 1])
        row.insert(0, 1)
        row.append(1)
        last=row

    return last",102
35708896080,climb_Stairs,"def climb_Stairs(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    elif n == 3:
        return 4
    else:
        first = 1
        second = 2
        third = 4
        for i in range(4, n+1):
            total = first + second + third
            first = second
            second = third
            third = total
        return total",102
16864964048,max_product,"def max_product(nums):
    nums.sort()
    return max(nums[0] * nums[1], nums[-1] * nums[-2])

assert max_product([1, 5, 2, -7, 3]) == 15
assert max_product([10, 20, 30, 40, 50]) == 2000
assert max_product([-1, -2, -3, -4]) == 12",102
10989567541,min_diff_subsets,"def min_diff_subsets(arr):
    total_sum = sum(arr)
    n = len(arr)
    half_sum = total_sum // 2

    dp = [0] * (half_sum + 1)
    for i in range(n):
        for j in range(half_sum, arr[i] - 1, -1):
            dp[j] = max(dp[j], dp[j - arr[i]] + arr[i])

    return total_sum - 2 * dp[half_sum]",102
25993782958,find_missing_positive,"def find_missing_positive(arr):
    arr_len = len(arr)
    for i in range(arr_len):
        while 1 <= arr[i] <= arr_len and arr[arr[i] - 1] != arr[i]:
            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]
    for i in range(arr_len):
        if arr[i] != i + 1:
            return i + 1
    return arr_len + 1",102
34047523320,find_smallest_missing_positive,"def find_smallest_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",102
74404692295,length_longest_substring,"def length_longest_substring(s: str) -> int:
    if not s:
        return 0
    char_map = {}
    start = 0
    max_length = 0
    for end, char in enumerate(s):
        if char in char_map and char_map[char] >= start:
            start = char_map[char] + 1
        char_map[char] = end
        max_length = max(max_length, end - start + 1)
    return max_length",102
28374894492,find_first_missing_positive,"def find_first_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",102
14129690076,max_elements_with_sum,"def max_elements_with_sum(list1, target_sum):
    max_length = 0
    current_sum = 0
    start_index = 0
    for end_index, value in enumerate(list1):
        current_sum += value
        while current_sum > target_sum:
            current_sum -= list1[start_index]
            start_index += 1
        if current_sum == target_sum:
            max_length = max(max_length, end_index - start_index + 1)
    return max_length",102
12234408960,maximum_swap,"def maximum_swap(num: int) -> int:
    num = list(str(num))
    last = {int(digit): i for i, digit in enumerate(num)}
    for i, digit in enumerate(num):
        for d in range(9, int(digit), -1):
            if d in last and last[d] > i:
                num[i], num[last[d]] = num[last[d]], num[i]
                return int("""".join(num))
    return int("""".join(num))",102
37847093007,findMaxLength,"def findMaxLength(nums):
    count = 0
    max_length = 0
    count_dict = {0: -1}
    for i in range(len(nums)):
        if nums[i] == 0:
            count -= 1
        elif nums[i] == 1:
            count += 1
        if count in count_dict:
            max_length = max(max_length, i - count_dict[count])
        else:
            count_dict[count] = i
    return max_length",102
17126405057,shortest_path,"from collections import deque

def shortest_path(graph, start, end):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    queue = deque([start])
    while queue:
        node = queue.popleft()
        for neighbor, distance in graph[node].items():
            if distances[neighbor] > distances[node] + distance:
                distances[neighbor] = distances[node] + distance
                queue.append(neighbor)
    return distances[end]",102
26890706299,find_smallest_missing_positive,"def find_smallest_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",102
39557476053,compress_string,"def compress_string(s):
  compressed = []
  count = 1
  for i in range(1, len(s)):
    if s[i] == s[i - 1]:
      count += 1
    else:
      compressed.append(s[i - 1] + str(count))
      count = 1
  compressed.append(s[-1] + str(count))
  compressed_str = ''.join(compressed)
  return compressed_str if len(compressed_str) < len(s) else s",102
13285640307,find_smallest_missing_positive,"def find_smallest_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",102
27426771697,common_strings,"def common_strings(list1, list2):
    return [string for string in list1 if string in list2]

# Test cases
assert common_strings([""apple"", ""banana"", ""orange""], [""orange"", ""grape"", ""banana""]) == [""banana"", ""orange""]
assert common_strings([""hello"", ""world""], [""world"", ""python"", ""code""]) == [""world""]
assert common_strings([""one"", ""two"", ""three""], [""four"", ""five"", ""six""]) == []",102
25105052297,max_consecutive_ones,"def max_consecutive_ones(nums, k):
    left = 0
    max_length = 0
    zero_count = 0

    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1

        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1

        max_length = max(max_length, right - left + 1)

    return max_length",102
29545515361,has_increasing_triplet,"class Solution:
    def has_increasing_triplet(self, nums):
        cur_min = float(""inf"")
        cur_increasing_min = float(""inf"")
        for v in nums:
            if v <= cur_min:
                cur_min = v
            elif v <= cur_increasing_min:
                cur_increasing_min = v
            else:
                return True
        return False

def has_increasing_triplet(nums):
    solution = Solution()
    return solution.has_increasing_triplet(nums)",102
73301752986,find_longest_consecutive_sequence,"def find_longest_consecutive_sequence(nums):
    num_set = set(nums)
    longest_streak = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",102
8839577541,count_unique_pairs,"def count_unique_pairs(numbers, target):
    num_count = {}
    pair_count = 0
    for num in numbers:
        if target - num in num_count and (target - num, num) not in num_count and (num, target - num) not in num_count:
            pair_count += 1
            num_count[(num, target - num)] = 1
        num_count[num] = num_count.get(num, 0) + 1
    return pair_count",102
71392117950,searchMatrix,"def searchMatrix(matrix, target):
    if len(matrix) == 0 or len(matrix[0]) == 0:
        return False
    row = 0
    col = len(matrix[0]) - 1
    while row < len(matrix) and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            row += 1
        else:
            col -= 1
    return False",102
18815481028,word_break,"from functools import lru_cache

def word_break(s, wordDict):
    wordDict, n = set(wordDict), len(s)

    @lru_cache(None)
    def recursion(i, j):
        if j==n: return i==j
        if s[i:j+1] in wordDict and recursion(j+1, j+1): return True
        if recursion(i, j+1): return True
        return False
    
    return recursion(0, 0)",102
28143549233,is_permutation_of_palindrome,"def is_permutation_of_palindrome(s):
    s = s.replace("" "", """").lower()
    d = {}
    for c in s:
        if c in d:
            d[c] += 1
        else:
            d[c] = 1
    odd_count = 0
    for k, v in d.items():
        if v % 2 != 0:
            odd_count += 1
        if odd_count > 1:
            return False
    return True",102
32352975079,find_smallest_missing_positive,"def find_smallest_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",102
27345308746,max_non_adjacent_sum,"def max_non_adjacent_sum(nums):
    if not nums:
        return 0
    if len(nums) <= 2:
        return max(nums)
    dp = [0] * len(nums)
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    return dp[-1]",102
2308834974,word_pattern,"def word_pattern(pattern: str, string: str) -> bool:
    dict_ = {}
    string = string.split("" "")
    if len(pattern) != len(string):
        return False
    for i in range(len(pattern)):
        if pattern[i] not in dict_:
            if string[i] in dict_.values():
                return False
            dict_[pattern[i]] = string[i]
        else:
            if dict_[pattern[i]] != string[i]:
                return False
    return True",102
30089326544,isTriangle,"def isTriangle(points):
    points.sort(key=lambda x:x[0])
    x1 = points[2][0] - points[1][0]
    y1 = points[2][1] - points[1][1]
    x0 = points[1][0] - points[0][0]
    y0 = points[1][1] - points[0][1]

    if x1*y0 == y1*x0:
        return False
    return True",102
70658046709,find_longest_consecutive_sequence,"def find_longest_consecutive_sequence(nums):
    num_set = set(nums)
    longest_streak = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",102
4997252410,sliding_window_max,"from collections import deque
def sliding_window_max(nums, k):
    window = deque([])
    windowLen = 0
    result = []
    for i,num in enumerate(nums):
        while window and window[-1][0]<num:
            window.pop()
        window.append([num,i])
        if window and i>=k and window[0][1]<=i-k:
            window.popleft()
        if i>=k-1:
            result.append(window[0][0])
    return result",102
71876985128,is_permutation,"def is_permutation(str1: str, str2: str) -> bool:
    if len(str1) != len(str2):
        return False
    hash = {}
    for char in str1:
        hash[char] = 1 if char not in hash else hash[char] + 1

    for char in str2:
        if char not in hash or hash[char] == 0:
            return False
        else:
            hash[char] -= 1

    return True",102
22488261717,valid_parentheses_sequence,"def valid_parentheses_sequence(s: str) -> bool:
    stack = []
    dic = {"")"": ""("", ""]"": ""["", ""}"": ""{""}
    for pa in s:
        if pa == '(' or pa == '[' or pa == '{':
            stack.append(pa)
        elif pa == ')' or pa == ']' or pa == '}':
            if len(stack) == 0 or stack.pop() != dic[pa]:
                return False
    return len(stack) == 0",102
38646181918,count_subarrays_with_given_sum,"def count_subarrays_with_given_sum(arr, target):
    count, current_sum = 0, 0
    sum_dict = {0: 1}
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum - target in sum_dict:
            count += sum_dict[current_sum - target]
        if current_sum in sum_dict:
            sum_dict[current_sum] += 1
        else:
            sum_dict[current_sum] = 1
    return count",102
34279497269,is_valid_isbn,"def is_valid_isbn(isbn):
    isbn = isbn.replace(""-"", """")
    if len(isbn) != 10:
        return False
    if isbn[-1] == 'X':
        isbn = isbn[:-1] + '10'
    if not isbn.isdigit():
        return False
    total = 0
    for i in range(10):
        total += (i + 1) * int(isbn[i])
    return total % 11 == 0",102
73459949624,missing_positive,"def missing_positive(nums):
    nums = [num for num in nums if num > 0]
    nums = list(set(nums))
    nums.sort()
    if not nums:
        return 1
    if nums[0] != 1:
        return 1
    for i in range(len(nums) - 1):
        if nums[i + 1] - nums[i] > 1:
            return nums[i] + 1
    return nums[-1] + 1",102
71333943892,longest_consecutive_sequence,"def longest_consecutive_sequence(nums):
    if not nums:
        return 0

    num_set = set(nums)
    max_length = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_length = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_length += 1

            max_length = max(max_length, current_length)

    return max_length",102
74351499238,shortest_palindrome,"def shortest_palindrome(s: str) -> str:
    """"""
    Finds the shortest palindrome by appending characters in front of the given string.
    :param s: The input string.
    :return: The shortest palindrome formed by appending the least number of characters.
    """"""
    n = len(s)
    rev_s = s[::-1]
    for i in range(n):
        if s.startswith(rev_s[i:]):
            return rev_s[:i] + s
    return rev_s + s",102
40557563627,find_longest_equal_subarray,"def find_longest_equal_subarray(arr): 
    max_length = 0
    count = 0
    sum_dict = {0: -1}
    for i in range(len(arr)):
        if arr[i] == 0:
            count -= 1
        else:
            count += 1
        if count in sum_dict:
            max_length = max(max_length, i - sum_dict[count])
        else:
            sum_dict[count] = i
    return max_length",101
12401697455,most_common_char,"def most_common_char(s):
    if not s:
        return None
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    max_count = 0
    max_char = None
    for char in s:
        if char_count[char] > max_count:
            max_count = char_count[char]
            max_char = char
    return max_char",101
2221625637,is_valid_ipv4_address,"import re

def is_valid_ipv4_address(ip):
    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    if re.match(pattern, ip):
        return True
    else:
        return False",101
11964066817,min_abs_diff,"def min_abs_diff(arr):
    arr.sort()
    smalldiff = float('inf')
    for i in range(1, len(arr)):
        smalldiff = min(arr[i] - arr[i - 1], smalldiff)
    answer = []
    for i in range(1, len(arr)):
        if arr[i] - arr[i - 1] == smalldiff:
            answer.append([arr[i-1],arr[i]])
    return answer",101
10493352966,first_occurrence,"def first_occurrence(arr, x):
    start = 0
    end = len(arr) - 1
    result = -1
    while start <= end:
        mid = start + (end - start) // 2
        if arr[mid] == x:
            result = mid
            end = mid - 1
        elif arr[mid] < x:
            start = mid + 1
        else:
            end = mid - 1
    return result",101
71921118424,find_longest_subarray,"def find_longest_subarray(nums):
    count = 0
    result = 0
    map = {}
    for i in range(len(nums)):
        if nums[i] == 0:
            count -= 1
        else:
            count += 1
        if count == 0:
            result = i + 1
        if count in map:
            result = max(result, i - map[count])
        else:
            map[count] = i
    return result",101
41695677364,domino_tiling,"def domino_tiling(n):
    if n <= 1:
        return 1
    # Initialize dp array
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    # Fill the dp array using the recurrence relation
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]",101
72042652127,string_compression,"def string_compression(s):
    compressed = []
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            count += 1
        else:
            compressed.append(s[i-1] + str(count))
            count = 1
    compressed.append(s[-1] + str(count))
    compressed_str = ''.join(compressed)
    return compressed_str if len(compressed_str) < len(s) else s",101
813161013,find_longest_subarray,"def find_longest_subarray(arr):
    max_len = 0
    sum = 0
    sum_index = {0: -1}
    for i in range(len(arr)):
        if arr[i] == 0:
            sum -= 1
        else:
            sum += 1
        if sum in sum_index:
            max_len = max(max_len, i - sum_index[sum])
        else:
            sum_index[sum] = i
    return max_len",101
39659150500,count_valid_parentheses,"def count_valid_parentheses(n: int) -> int:
    if n % 2 != 0:
        return 0
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(2, n + 1, 2):
        for j in range(0, i, 2):
            dp[i] += dp[j] * dp[i - j - 2]
    return dp[n]",101
27872083821,lucasNumber,"def lucasNumber(n): 
    if n == 0: 
        return 2
    if n == 1: 
        return 1
    lucasPrevPrev = 2
    lucasPrev = 1
    for _ in range(2, n + 1):
        currentLucas = lucasPrevPrev + lucasPrev
        lucasPrevPrev = lucasPrev
        lucasPrev = currentLucas
    return currentLucas",101
26972468666,number_of_subarrays_with_sum,"from collections import defaultdict

def number_of_subarrays_with_sum(nums, k):
    count = 0
    sum = 0
    sum_dict = defaultdict(int) 
    sum_dict[0] = 1

    for i in range(0, len(nums)):
        sum = sum + nums[i]

        if sum_dict[sum - k] > 0:
            count += sum_dict[sum - k]

        sum_dict[sum] += 1

    return count",101
8545635291,find_first_occurrence,"def find_first_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            result = mid
            right = mid - 1
        elif arr[mid] > target:
            right = mid - 1
        else:
            left = mid + 1
    return result",101
21289103707,can_be_equal,"def can_be_equal(str1: str, str2: str) -> bool:
    if len(str1) != len(str2):
        return False
    diff = [i for i in range(len(str1)) if str1[i] != str2[i]]
    if len(diff) != 2:
        return False
    return str1[diff[0]] == str2[diff[1]] and str1[diff[1]] == str2[diff[0]]",101
20000815549,min_cost_connect_sticks,"import heapq

def min_cost_connect_sticks(sticks):
    """"""
    :type sticks: List[int]
    :rtype: int
    """"""
    cost = 0
    heapq.heapify(sticks)
    while len(sticks) > 1:
        stick1 = heapq.heappop(sticks)
        stick2 = heapq.heappop(sticks)
        cost += stick1 + stick2
        heapq.heappush(sticks, stick1 + stick2)
    return cost",101
19559846684,first_missing_positive,"def first_missing_positive(nums):
    size = len(nums)
    for i in range(size):
        while 1 <= nums[i] <= size and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    
    for i in range(size):
        if nums[i] != i + 1:
            return i + 1
    return size + 1",101
72679286006,count_and_say,"def count_and_say(n):
    result = '1'
    for _ in range(n-1):
        prev = result
        result = ''
        j = 0
        while j < len(prev):
            cur = prev[j]
            cnt = 1
            j += 1
            while j < len(prev) and prev[j] == cur:
                cnt += 1
                j += 1
            result += str(cnt) + str(cur)
    return result",101
16150427579,find_longest_consecutive,"def find_longest_consecutive(nums):
    longest_streak = 0
    num_set = set(nums)

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",101
39776737118,distinct_substring,"def distinct_substring(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)

if __name__ == ""__main__"":
    assert distinct_substring(""abc"") == 6
    assert distinct_substring(""aaa"") == 3
    assert distinct_substring(""abcd"") == 10
    print(""All test cases passed!"")",101
39730455502,find_longest_subsequence,"def find_longest_subsequence(nums):
    num_set = set(nums)
    longest_streak = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",101
41339457032,maxConsecutiveOnes,"def maxConsecutiveOnes(nums):
    max_length = 0
    left = 0
    zero_count = 0
    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1
        while zero_count > 1:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        max_length = max(max_length, right - left + 1)
    return max_length",101
9120489689,find_smallest_missing,"def find_smallest_missing(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",101
539568217,max_overlap,"def max_overlap(intervals):
    endpoints = []
    for start, end in intervals:
        endpoints.append((start, 'start'))
        endpoints.append((end, 'end'))
    endpoints.sort()
    max_overlap = 0
    current_overlap = 0
    for endpoint, status in endpoints:
        if status == 'start':
            current_overlap += 1
            max_overlap = max(max_overlap, current_overlap)
        else:
            current_overlap -= 1
    return max_overlap",101
13589119914,multiply_except_self,"def multiply_except_self(l):
    if len(l) == 0:
        return []
    products = [1] * len(l)
    left_products = 1
    for i in range(len(l)):
        products[i] *= left_products
        left_products *= l[i]
    right_products = 1
    for i in range(len(l) - 1, -1, -1):
        products[i] *= right_products
        right_products *= l[i]
    return products",101
26972431006,max_ones_flipping,"def max_ones_flipping(arr):
    start = 0
    max_length = 0
    zero_count = 0

    for end in range(len(arr)):
        if arr[end] == 0:
            zero_count += 1

        while zero_count > 1:
            if arr[start] == 0:
                zero_count -= 1
            start += 1

        max_length = max(max_length, end - start + 1)

    return max_length",101
21457594578,majority_search,"def majority_search(stream: list) -> int:
    current_count = 0
    current_val = None
    
    for item in stream:
        if current_val is None:
            current_count += 1
            current_val = item
        else:
            if current_count == 0:
                current_val = item
                current_count += 1
            elif current_val == item:
                current_count += 1
            else:
                current_count -= 1
            
    return current_val",101
18293081547,num_special_equivalent_groups,"from collections import defaultdict

def num_special_equivalent_groups(words):
    d = defaultdict(list)
    for word in words:
        odd , even = """",''
        for idx,char in enumerate(word):
            if idx%2 == 0:
                even += char
            else:
                odd+= char

        odd = sorted(odd)
        even = sorted(even)
        final = """".join(odd+even)
        
        d[final].append(word)

    return len(d.values())",101
5814826427,find_largest_palindrome,"def find_largest_palindrome(n):
    def is_palindrome(x):
        return str(x) == str(x)[::-1]
    max_palindrome = 0
    for i in range(10 ** (n-1), 10 ** n):
        for j in range(i, 10 ** n):
            product = i * j
            if is_palindrome(product) and product > max_palindrome:
                max_palindrome = product
    return max_palindrome",101
8843026161,zeroSumSubarray,"def zeroSumSubarray(nums):
    max_count = 0
    count = 0
    sum = 0
    sum_map = {0: 1}
    
    for num in nums:
        sum += num
        if sum in sum_map:
            count += sum_map[sum]
            sum_map[sum] += 1
        else:
            sum_map[sum] = 1
        max_count = max(max_count, count)
        
    return max_count",101
24756587338,find_longest_consecutive,"def find_longest_consecutive(nums):
    nums_set = set(nums)
    longest_streak = 0

    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",101
7663754752,has_all_codes,"def has_all_codes(s: str, k: int) -> bool:
        arr = set()
        i = 0
        x = int( ('1'*k), 2)
        while(i < len(s)-k+1):
            new = int(s[i:i+k], 2)
            out = new ^ x
            arr.add(out)
            i += 1
        if len(arr) == 2**k:
            return True
        else:
            return False",101
37648955744,check_isbn,"def check_isbn(isbn):
    if len(isbn) != 10:
        return False
    total = 0
    for i, char in enumerate(isbn):
        if char.isdigit():
            total += int(char) * (i+1)
        elif char == 'X':
            if i != 9:
                return False
            total += 10 * 10
        else:
            return False
    return total % 11 == 0",101
11235205169,longest_increasing_subsequence,"def longest_increasing_subsequence(arr):
    n = len(arr)
    lis = [1]*n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum",101
32300311390,find_first_missing_positive,"def find_first_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",101
29032193385,largest_subarray_equal_zeros_ones,"def largest_subarray_equal_zeros_ones(arr):
    count = 0
    max_length = 0
    sum_map = {0: -1}
    for i in range(len(arr)):
        if arr[i] == 0:
            count -= 1
        else:
            count += 1
        if count in sum_map:
            max_length = max(max_length, i - sum_map[count])
        else:
            sum_map[count] = i
    return max_length",101
69992904156,lastStoneWeight,"import heapq

def lastStoneWeight(stones):
    stones = [-s for s in stones]
    heapq.heapify(stones)
    while len(stones) > 1:
        h1 = heapq.heappop(stones)
        h2 = heapq.heappop(stones)
        if h1 != h2:
            heapq.heappush(stones, h1-h2)

    if len(stones) == 1:
        return -stones[0]
    return 0",101
33565417551,max_consecutive_sequence,"def max_consecutive_sequence(nums):
    if not nums:
        return 0

    nums = set(nums)
    max_length = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            max_length = max(max_length, current_streak)

    return max_length",101
16248205841,can_rearrange_to_palindrome,"def can_rearrange_to_palindrome(s: str) -> bool:
    char_count = {}
    odd_count = 0
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for count in char_count.values():
        if count % 2 == 1:
            odd_count += 1
            if odd_count > 1:
                return False
    return True",101
9267166349,permutations,"def permutations(string):
    if len(string) <= 1:
        return set([string])

    # Get all permutations of length N-1
    perms = permutations(string[1:])
    char = string[0]
    result = set()

    # Iterate over each permutation and insert the first character at every position
    for perm in perms:
        for i in range(len(perm) + 1):
            result.add(perm[:i] + char + perm[i:])
    return result",101
29120131230,can_jump,"def can_jump(nums):
    CanJumpList = [0]*len(nums) 
    for ind in reversed(range(len(nums))):
        if ((ind+nums[ind] )>= len(nums)-1 ): 
            CanJumpList[ind] =1
            continue
        for pot in reversed(range(nums[ind]+1)): 
            if (CanJumpList[ind+pot] ==1):
                CanJumpList[ind] =1
                break
    return bool(CanJumpList[0])",101
19393113178,count_unique_bsts,"def count_unique_bsts(n):
    if n == 0:
        return 1

    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1

    for i in range(2, n + 1):
        total = 0
        for j in range(i):
            total += dp[j] * dp[i - j - 1]
        dp[i] = total

    return dp[n]",101
43824982183,sieve_of_eratosthenes,"def sieve_of_eratosthenes(n):
    sieve = [True] * (n+1)
    sieve[0:2] = [False, False]
    for current in range(2, int(n**0.5) + 1):
        if sieve[current]:
            for multiple in range(current*current, n+1, current):
                sieve[multiple] = False
    return [num for num in range(2, n+1) if sieve[num]]",101
23520902457,min_subarray_len,"def min_subarray_len(nums, target):
    n = len(nums)
    min_len = float('inf')
    curr_sum = 0
    start = 0
    
    for end in range(n):
        curr_sum += nums[end]
        
        while curr_sum >= target:
            min_len = min(min_len, end - start + 1)
            curr_sum -= nums[start]
            start += 1
            
    return 0 if min_len == float('inf') else min_len",101
15071894351,max_value_in_windows,"from collections import deque

def max_value_in_windows(nums, k):
    if not nums: return []
    window, res = deque(), []
    for i, x in enumerate(nums):
        while window and nums[window[-1]] <= x:
            window.pop()
        window.append(i)
        if i >= k and window[0] <= i - k:
            window.popleft()
        if i >= k - 1:
            res.append(nums[window[0]])
    return res",101
37213046563,longest_palindromic_substring,"def longest_palindromic_substring(s):
    if not s:
        return """"
    n = len(s)
    start, max_len = 0, 1
    for i in range(n):
        for j in range(i):
            if s[j:i+1] == s[j:i+1][::-1] and (i-j+1) > max_len:
                start, max_len = j, i-j+1
    return s[start:start+max_len]",101
26626054092,find_smallest_missing,"def find_smallest_missing(nums):
    size = len(nums)
    for i in range(size):
        while 1 <= nums[i] <= size and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(size):
        if nums[i] != i + 1:
            return i + 1
    return size + 1",101
10576620171,count_distinct_bsts,"def count_distinct_bsts(n):
    """"""
    Returns the number of structurally unique BST's (binary search trees)
    that store values 1 ... n
    """"""
    f = [0 for _ in range(n+1)]
    f[0] = 1
    for tot in range(1, n+1):
        for left in range(tot):
            f[tot] += f[left] * f[tot-1-left]
    return f[-1]",101
71856244569,min_size_subarray_sum,"def min_size_subarray_sum(target, nums):
    n = len(nums)
    min_len = float('inf')
    left = 0
    current_sum = 0

    for right in range(n):
        current_sum += nums[right]
        while current_sum >= target:
            min_len = min(min_len, right - left + 1)
            current_sum -= nums[left]
            left += 1

    return min_len if min_len != float('inf') else 0",101
20898555625,balanced_strings,"from math import factorial

def balanced_strings(n):
    if n < 3:
        return 0
    total = 0
    for i in range(n//3 + 1):
        for j in range(i + 1):
            k = n - 2*i - j
            if k < 0 or k > j + 1:
                continue
            total += factorial(n) // (factorial(i) * factorial(j) * factorial(k))
    return total",101
1142730724,filter_prime_numbers,"def is_prime(n: int) -> bool:
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def filter_prime_numbers(numbers: list[int]) -> list[int]:
    """"""Filter prime numbers from a list.""""""
    return [number for number in numbers if is_prime(number)]",101
38282408409,common_sorted,"def common_sorted(list1, list2):
    common_elements = []
    i, j = 0, 0
    while i < len(list1) and j < len(list2):
        if list1[i] == list2[j]:
            common_elements.append(list1[i])
            i += 1
            j += 1
        elif list1[i] < list2[j]:
            i += 1
        else:
            j += 1
    return common_elements",101
26380386972,is_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while (i * i <= n):
        if (n % i == 0 or n % (i + 2) == 0):
            return False
        i = i + 6
    return True",101
26956671414,longest_consecutive_subseq,"def longest_consecutive_subseq(nums):
    num_set = set(nums)
    longest_streak = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",101
35745401290,max_ones,"def max_ones(nums, k):
    left = 0
    max_len = 0
    zero_count = 0
    
    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1
        
        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
            
        max_len = max(max_len, right - left + 1)
    
    return max_len",101
37284181298,max_subarrays,"def max_subarrays(nums, k):
    count = 0
    start = 0
    current_sum = 0
    subarrays = 0
    for end in range(len(nums)):
        current_sum += nums[end]
        while current_sum > k:
            current_sum -= nums[start]
            start += 1
        if current_sum == k:
            subarrays += 1
            count = max(count, end - start + 1)
    return subarrays",100
70034082307,max_ones,"def max_ones(arr, k):
    left = 0
    max_len = 0
    zero_count = 0

    for right in range(len(arr)):
        if arr[right] == 0:
            zero_count += 1

        while zero_count > k:
            if arr[left] == 0:
                zero_count -= 1
            left += 1

        max_len = max(max_len, right - left + 1)

    return max_len",100
31383693244,first_missing_positive,"def first_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
72128912554,max_Overlapping,"def max_Overlapping(intervals):
    events = []
    for start, end in intervals:
        events.append((start, 'start'))
        events.append((end, 'end'))
    events.sort()
    max_overlap = current_overlap = 0
    for _, event_type in events:
        if event_type == 'start':
            current_overlap += 1
            max_overlap = max(max_overlap, current_overlap)
        else:
            current_overlap -= 1
    return max_overlap",100
27738033872,find_Last_Position,"def find_Last_Position(nums, target):
    left, right = 0, len(nums) - 1
    result = -1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            result = mid
            left = mid + 1
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return result",100
29878883933,reverseWords,"def reverseWords(s):
    return ' '.join(word[::-1] for word in s.split(' '))

# Testing the function
print(reverseWords(""This is a test"")) # Should Print: ""sihT si a tset""
print(reverseWords(""Let's take LeetCode contest"")) # Should Print: ""s'teL ekat edoCteeL tsetnoc""
print(reverseWords(""Hello World!"")) # Should Print: ""olleH !dlroW""",100
30966740816,smallest_positive_missing,"def smallest_positive_missing(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
41831128891,missing_positive,"def missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
71653590608,subarraysDivByK,"def subarraysDivByK(A, K):
    count = 0
    sum = 0
    freq = {0:1}
    for i in range(len(A)):
        sum += A[i]
        mod = sum % K
        if mod < 0:
            mod += K
        if mod in freq:
            count += freq[mod]
            freq[mod] += 1
        else:
            freq[mod] = 1
    return count",100
19875630429,merge_sorted_lists,"def merge_sorted_lists(list1, list2):
    i = j = 0
    merged_list = []
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            merged_list.append(list1[i])
            i += 1
        else:
            merged_list.append(list2[j])
            j += 1
    merged_list.extend(list1[i:])
    merged_list.extend(list2[j:])
    return merged_list",100
41485361260,smallest_sum,"def smallest_sum(arr1, arr2):
    arr1.sort()
    arr2.sort()
    min_sum = float('inf')
    i, j = 0, 0
    while i < len(arr1) and j < len(arr2):
        min_sum = min(min_sum, arr1[i] + arr2[j])
        if arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return min_sum",100
28476088819,merge_sorted_lists,"def merge_sorted_lists(list1, list2):
    merged_list = []
    i = j = 0
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            merged_list.append(list1[i])
            i += 1
        else:
            merged_list.append(list2[j])
            j += 1
    merged_list += list1[i:]
    merged_list += list2[j:]
    return merged_list",100
19736417087,smallest_missing_positive,"def smallest_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
72464212788,check_overlap,"def check_overlap(rect1_bottom_left, rect1_top_right, rect2_bottom_left, rect2_top_right):
  if rect1_top_right[0] <= rect2_bottom_left[0] or rect1_bottom_left[0] >= rect2_top_right[0]:
    return False
  if rect1_top_right[1] <= rect2_bottom_left[1] or rect1_bottom_left[1] >= rect2_top_right[1]:
    return False
  return True",100
702031796,longest_consecutive_sequence,"def longest_consecutive_sequence(nums):
    nums_set = set(nums)
    longest_streak = 0

    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",100
2011221608,first_occurrence,"def first_occurrence(nums, target):
    left, right = 0, len(nums) - 1
    result = -1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            result = mid
            right = mid - 1
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return result",100
329262203,second_largest_number,"def second_largest_number(arr):
    if len(arr) < 2:
        return None
    first_largest = second_largest = float('-inf')
    for num in arr:
        if num > first_largest:
            second_largest = first_largest
            first_largest = num
        elif num > second_largest and num != first_largest:
            second_largest = num
    return second_largest if second_largest != float('-inf') else None",100
38750284064,max_ones,"def max_ones(nums, k):
    left = 0
    max_len = 0
    zero_count = 0

    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1

        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1

        max_len = max(max_len, right - left + 1)

    return max_len",100
44155810956,find_first_missing,"def find_first_missing(nums):
    n = len(nums)
    for i in range(n):
        while 0 < nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
15733924488,find_subarrays_with_sum,"def find_subarrays_with_sum(arr, target_sum):
    count = 0
    current_sum = 0
    start = 0
    sum_dict = {0: 1}
    for end in range(len(arr)):
        current_sum += arr[end]
        if current_sum - target_sum in sum_dict:
            count += sum_dict[current_sum - target_sum]
        sum_dict[current_sum] = sum_dict.get(current_sum, 0) + 1
    return count",100
33760549988,longest_subarray_with_sum,"def longest_subarray_with_sum(nums, target):
    max_len = 0
    sum_map = {0: -1}
    current_sum = 0
    for i, num in enumerate(nums):
        current_sum += num
        if current_sum not in sum_map:
            sum_map[current_sum] = i
        if (current_sum - target) in sum_map:
            max_len = max(max_len, i - sum_map[current_sum - target])
    return max_len",100
6571423905,min_len_sub,"def min_len_sub(arr, target):
    n = len(arr)
    min_len = float('inf')
    start = 0
    curr_sum = 0
    
    for i in range(n):
        curr_sum += arr[i]
        
        while curr_sum >= target:
            min_len = min(min_len, i - start + 1)
            curr_sum -= arr[start]
            start += 1
    
    return min_len if min_len != float('inf') else 0",100
12714704895,find_last_position,"def find_last_position(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            result = mid
            left = mid + 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return result",100
46466496325,find_components,"def DFS(graph, vertex, visited):
    visited[vertex] = True
    for neighbor in range(len(graph[vertex])):
        if graph[vertex][neighbor] == 1 and not visited[neighbor]:
            DFS(graph, neighbor, visited)

def find_components(graph):
    visited = [False] * len(graph)
    count = 0
    for vertex in range(len(graph)):
        if not visited[vertex]:
            DFS(graph, vertex, visited)
            count += 1
    return count",100
21564976423,most_common_letter,"def most_common_letter(s):
    s = s.replace("" "", """") # remove spaces
    letter_frequency = {}
    for letter in s:
        if letter in letter_frequency:
            letter_frequency[letter] += 1
        else:
            letter_frequency[letter] = 1
    sorted_frequency = sorted(letter_frequency.items(), key=lambda x: (-x[1], x[0])) # sort by frequency first, then alphabetically
    return sorted_frequency[0][0]",100
4027349806,smallest_missing_positive,"def smallest_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
39458002240,second_largest,"def second_largest(lst):
    max_num = max(lst)
    lst.remove(max_num)
    return max(lst)

# Test cases
assert second_largest([1,2,3,4,5]) == 4
assert second_largest([5,4,3,2,1]) == 4
assert second_largest([10,20]) == 10
assert second_largest([-5,-4,-3,-2,-1]) == -2",100
28403324182,is_valid_palindrome_permutation,"def is_valid_palindrome_permutation(s: str) -> bool:
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
            if odd_count > 1:
                return False
    return True",100
69878188907,smallest_missing_positive,"def smallest_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
74472341199,can_complete_circuit,"def can_complete_circuit(gas, cost):
    if sum(gas) < sum(cost):
        return -1
    
    rest = 0
    station = None
    
    for i in range(len(gas)):
        if rest + gas[i] - cost[i] >= 0:
            rest = rest + gas[i] - cost[i]
            if station is None:
                station = i
        else:
            rest = 0
            station = None

    return station",100
34790513882,word_break,"def word_break(s, wordDict):
    wordSet = set(wordDict)
    flags = [False] * len(s)
    flags.insert(0,True)
    for i in range(len(s)):
        for size in range(20):
            if i-size <0:
                continue
            if not flags[i-size]:
                continue
            if s[i-size:i+1] in wordSet:
                flags[i+1]=True
                continue
    return flags[-1]",100
34656503284,is_palindrome_permutation,"def is_palindrome_permutation(s):
    s = s.replace("" "", """").lower()
    d = dict()
    for char in s:
        if char in d:
            d[char] += 1
        else:
            d[char] = 1
    odd_count = 0
    for val in d.values():
        if val % 2 != 0:
            odd_count += 1
        if odd_count > 1:
            return False
    return True",100
6240458737,find_longest_substring,"def find_longest_substring(s):
    stack = []
    max_length = 0
    max_pos = 0
    for i, ch in enumerate(s):
        if ch == '(':
            stack.append(i)
        elif ch == ')' and stack:
            pos = stack.pop()
            length = i - pos + 1
            if length > max_length:
                max_length = length
                max_pos = pos
    return '', max_pos, max_pos + max_length",100
1158501267,find_missing_positive,"def find_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
39027630389,first_occurrence,"def first_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            result = mid
            right = mid - 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return result",100
33686533135,intersect_sorted_lists,"def intersect_sorted_lists(list1, list2):
    i = 0
    j = 0
    result = []
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            i += 1
        elif list1[i] > list2[j]:
            j += 1
        else:
            result.append(list1[i])
            i += 1
            j += 1
    return result",100
13672580262,max_ones,"def max_ones(nums, k):
    left = 0
    max_len = 0
    zero_count = 0
    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1
        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        max_len = max(max_len, right - left + 1)
    return max_len",100
33869386133,max_subarray_length,"def max_subarray_length(arr, target_sum):
    max_length = 0
    current_sum = 0
    start = 0
    for end in range(len(arr)):
        current_sum += arr[end]
        while current_sum > target_sum:
            current_sum -= arr[start]
            start += 1
        if current_sum == target_sum:
            current_length = end - start + 1
            max_length = max(max_length, current_length)
    return max_length",100
32566203437,smallest_missing_positive,"def smallest_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1

    return n + 1",100
26281930050,min_subarray_len,"def min_subarray_len(nums, target):
    n = len(nums)
    min_len = float('inf')
    start = 0
    current_sum = 0
    for i in range(n):
        current_sum += nums[i]
        while current_sum >= target:
            min_len = min(min_len, i - start + 1)
            current_sum -= nums[start]
            start += 1
    return 0 if min_len == float('inf') else min_len",100
73001638169,nth_fibonacci,"class Solution(object):
    def nth_fibonacci(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        cur, nxt = 1, 1
        for _ in range(n-1):
            cur, nxt = nxt, cur + nxt
        return cur % 1000000007

def nth_fibonacci(n):
    solution = Solution()
    return solution.nth_fibonacci(n)",100
41879188640,last_position,"def last_position(arr, x):
    low = 0
    high = len(arr) - 1
    result = -1
    while low <= high:
        mid = low + (high - low) // 2
        if arr[mid] == x:
            result = mid
            low = mid + 1
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1
    return result",100
3914871196,subarray_sum,"def subarray_sum(arr, k):
    count = 0
    current_sum = 0
    sum_dict = {0: 1}
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum - k in sum_dict:
            count += sum_dict[current_sum - k]
        if current_sum in sum_dict:
            sum_dict[current_sum] += 1
        else:
            sum_dict[current_sum] = 1
    return count",100
12367690833,compress_string,"def compress_string(s):
    rez = []
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            count += 1
        else:
            rez.append(s[i-1])
            if count > 1:
                rez.append(str(count))
            count = 1
    rez.append(s[-1])
    if count > 1:
        rez.append(str(count))
    return ''.join(rez)",100
71064749437,count_pairs_with_diff_k,"from collections import Counter

def count_pairs_with_diff_k(nums, k):
    count = 0
    freq = Counter(nums)
    if k == 0:
        for num in freq:
            if freq[num] > 1:
                count += freq[num] * (freq[num] - 1) // 2
    else:
        for num in freq:
            if num + k in freq:
                count += freq[num] * freq[num + k]
    return count",100
15123246066,frequent_element,"def frequent_element(arr):
    frequency = {}
    for element in arr:
        if element in frequency:
            frequency[element] += 1
        else:
            frequency[element] = 1

    max_freq = 0
    most_frequent = None
    for element, freq in frequency.items():
        if freq > max_freq or (freq == max_freq and most_frequent == None):
            max_freq = freq
            most_frequent = element

    return most_frequent",100
10576313511,compress_string,"def compress_string(s):
    compressed = []
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            count += 1
        else:
            compressed.append(s[i-1] + (str(count) if count > 1 else ''))
            count = 1
    compressed.append(s[-1] + (str(count) if count > 1 else ''))
    return ''.join(compressed)",100
28731718364,sum_of_primes,"def sum_of_primes(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True

    sum_of_primes = 0
    for num in range(2, n):
        if is_prime(num):
            sum_of_primes += num
    return sum_of_primes",100
36886514616,first_missing_positive,"def first_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
3123163302,subarray_sum,"def subarray_sum(nums, k):
    res = 0
    sum_dict = {0: 1}
    total_sum = 0
    for num in nums:
        total_sum += num
        if total_sum - k in sum_dict:
            res += sum_dict[total_sum - k]
        if total_sum in sum_dict:
            sum_dict[total_sum] += 1
        else:
            sum_dict[total_sum] = 1
    return res",100
41039938089,first_missing_positive,"def first_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
74301105945,find_possible_sums,"def find_possible_sums(nums, target):
    def Recu(target,nums,result,path,index=0):
        if target < 0:
            return
        if target  == 0:
            result.append(list(path))
            return
        else:
            for i in range(index,len(nums)):
                Recu(target-nums[i],nums,result,path+[nums[i]],i)
    result, path = [],[]
    Recu(target,nums,result, path,0)
    return result",100
8309082322,max_ones,"def max_ones(nums, k):
    left = 0
    max_length = 0
    zero_count = 0

    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1

        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1

        max_length = max(max_length, right - left + 1)

    return max_length",100
10143590688,primes_up_to,"def primes_up_to(limit):
    sieve = [True] * (limit + 1)
    sieve[0] = sieve[1] = False
    for i in range(2, int(limit ** 0.5) + 1):
        if sieve[i]:
            for j in range(i * i, limit + 1, i):
                sieve[j] = False
    return [i for i in range(2, limit + 1) if sieve[i]]",100
40499380934,prime_sieve,"def prime_sieve(n):
    sieve = [True] * (n+1)
    sieve[0:2] = [False, False]
    for current_prime in range(2, int(n**0.5) + 1):
        if sieve[current_prime]:
            for multiple in range(current_prime * current_prime, n + 1, current_prime):
                sieve[multiple] = False
    return [prime for prime, checked in enumerate(sieve) if checked]",100
104505095,min_sub_array_len,"def min_sub_array_len(target, nums):
    n = len(nums)
    min_len = float('inf')
    left = 0
    curr_sum = 0
    
    for right in range(n):
        curr_sum += nums[right]
        while curr_sum >= target:
            min_len = min(min_len, right - left + 1)
            curr_sum -= nums[left]
            left += 1
            
    return 0 if min_len == float('inf') else min_len",100
20298366512,generate_primes,"def generate_primes(n: int):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    primes = []
    num = 2
    while len(primes) < n:
        if is_prime(num):
            primes.append(num)
        num += 1
    return primes",100
10673130442,merge_sorted_lists,"def merge_sorted_lists(list1, list2):
    merged_list = []
    i = j = 0
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            merged_list.append(list1[i])
            i += 1
        else:
            merged_list.append(list2[j])
            j += 1
    merged_list.extend(list1[i:])
    merged_list.extend(list2[j:])
    return merged_list",100
38282470279,days_in_month,"def days_in_month(month, year_type):
    if month in ['January', 'March', 'May', 'July', 'August', 'October', 'December']:
        return 31
    elif month in ['April', 'June', 'September', 'November']:
        return 30
    elif month == 'February':
        if year_type == 'leap year':
            return 29
        else:
            return 28
    else:
        return None",100
2777979907,countWays,"def countWays(n): 
    if n <= 1: 
        return n 
    res = [0] * (n+1) 
    res[0] = 1
    res[1] = 1
    res[2] = 2
    for i in range(3, n+1): 
        res[i] = res[i-1] + res[i-2] + res[i-3] 
    return res[n]",100
70461334226,least_number_of_squares,"import math

def least_number_of_squares(n):
    dp = [0] * (n+1)
    square = [i**2 for i in range(1, int(math.sqrt(n))+1)]
    
    for i in range(1, n+1):
        dp[i] = float('inf')
        for s in square:
            if i >= s:
                dp[i] = min(dp[i], dp[i-s] + 1)
    return dp[n]",100
17542381063,missing_positive_integer,"def missing_positive_integer(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
28644559698,smallest_positive_missing,"def smallest_positive_missing(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
28358437794,find_missing_intervals,"def find_missing_intervals(nums, lower, upper):
    def get_interval_str(start, end):
        return str(start) if start == end else f""{start}->{end}""

    missing_intervals = []
    start = lower

    for num in nums:
        if num > start:
            missing_intervals.append(get_interval_str(start, num - 1))
        start = num + 1

    if start <= upper:
        missing_intervals.append(get_interval_str(start, upper))

    return missing_intervals",100
72383529989,next_permutation,"def next_permutation(nums):
    i = len(nums) - 2
    while i >= 0 and nums[i] >= nums[i+1]:
        i -= 1
    if i >= 0:
        j = len(nums) - 1
        while nums[j] <= nums[i]:
            j -= 1
        nums[i], nums[j] = nums[j], nums[i]
    nums[i+1:] = reversed(nums[i+1:])
    return nums",100
31370519581,find_missing_integer,"def find_missing_integer(nums):
    for i in range(len(nums)):
        while 1 <= nums[i] <= len(nums) and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(len(nums)):
        if nums[i] != i + 1:
            return i + 1
    return len(nums) + 1",100
36426933659,minimum_abs_difference,"def minimum_abs_difference(arr):
    arr = sorted(arr)
    min_diff = float('inf')
    result = []

    for i in range(len(arr) - 1):
        diff = abs(arr[i + 1] - arr[i])
        if diff < min_diff:
            min_diff = diff
            result = [[arr[i], arr[i + 1]]]
        elif diff == min_diff:
            result.append([arr[i], arr[i + 1]])

    return result",100
21290166257,first_missing_positive,"def first_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
32830810603,is_anagram,"def is_anagram(s1, s2):
    # First, check if the lengths of the two strings match
    if len(s1) != len(s2):
        return False

    # Convert strings to lists for easy manipulation
    list_s1 = list(s1)
    list_s2 = list(s2)

    # Sort both lists
    list_s1.sort()
    list_s2.sort()

    # Compare sorted lists
    return list_s1 == list_s2",100
12537178951,coin_combinations,"def coin_combinations(coins, amount):
    # dp[i] represents the number of combinations to make up the amount i
    dp = [0] * (amount + 1)
    dp[0] = 1  # Base case: there is 1 way to make up the amount 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]

    return dp[amount]",100
30353013488,combination_sum,"from typing import List

def combination_sum(candidates: List[int], target: int) -> List[List[int]]:
    results = []
    
    def backtrack(start, path, target):
        if target == 0:
            results.append(path)
            return
        elif target < 0:
            return
        
        for i in range(start, len(candidates)):
            backtrack(i, path + [candidates[i]], target - candidates[i])
    
    backtrack(0, [], target)
    return results",100
40317816264,is_anagram_of_palindrome,"def is_anagram_of_palindrome(s: str) -> bool:
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

    odd_counts = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_counts += 1
        if odd_counts > 1:
            return False

    return True",100
5368694438,valid_mountain_array,"def valid_mountain_array(A):
    n = len(A)
    if n < 3: return False
    inc = A[0] < A[1]
    k = 0
    for i in range(1, n):
        if inc and A[i-1] >= A[i]: 
            k += 1
            inc = False
        if not inc and A[i-1] <= A[i]:
            return False
    return k == 1",100
17479713511,longest_consecutive_sequence,"def longest_consecutive_sequence(nums):
    num_set = set(nums)
    longest_streak = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",100
1790315345,sieve_of_eratosthenes,"def sieve_of_eratosthenes(n):
    primes = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (primes[p] == True):
            for i in range(p * p, n + 1, p):
                primes[i] = False
        p += 1
    prime_numbers = [p for p in range(2, n) if primes[p]]
    return prime_numbers",100
25886016399,is_anagram_of_palindrome,"def is_anagram_of_palindrome(s: str) -> bool:
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_counts = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_counts += 1
        if odd_counts > 1:
            return False
    return True",100
73459909944,first_missing_positive,"def first_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",100
21380551234,frequent_elements,"from typing import List

def frequent_elements(nums: List[int]) -> List[int]:
    frequency = {}
    max_freq = 0
    for num in nums:
        if num in frequency:
            frequency[num] += 1
        else:
            frequency[num] = 1
        max_freq = max(max_freq, frequency[num])
    
    most_frequent = [num for num, freq in frequency.items() if freq == max_freq]
    return sorted(most_frequent)",100
6948689774,intersect_sorted_lists,"def intersect_sorted_lists(list1, list2):
    i = 0
    j = 0
    result = []
    while i < len(list1) and j < len(list2):
        if list1[i] == list2[j]:
            result.append(list1[i])
            i += 1
            j += 1
        elif list1[i] < list2[j]:
            i += 1
        else:
            j += 1
    return result",100
71108204692,subarraySum,"def subarraySum(nums, k):
    count = 0
    sum_ = 0
    sum_dict = {0:1}
    for i in range(len(nums)):
        sum_ += nums[i]
        if sum_ - k in sum_dict:
            count += sum_dict[sum_ - k]
        if sum_ in sum_dict:
            sum_dict[sum_] += 1
        else:
            sum_dict[sum_] = 1
    return count",100
18795334897,reconstruct_queue,"def reconstruct_queue(people):
    # 先按照p[0]降序、p[1]升序排列数对
    people = sorted(people, key=lambda p: (-p[0], p[1]))
    res = []
    # 再根据p[1]重排序
    for p in people:
        if len(res) <= p[1]:
            res.append(p)
        else:
            res.insert(p[1], p)
    return res",100
38444149516,find_first_occurrence,"def find_first_occurrence(arr, target):
    left = 0
    right = len(arr) - 1
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            result = mid
            right = mid - 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return result",100
40857622757,smallest_subarray_length,"def smallest_subarray_length(target, arr):
    n = len(arr)
    min_length = float('inf')
    start = 0
    current_sum = 0

    for end in range(n):
        current_sum += arr[end]

        while current_sum >= target:
            min_length = min(min_length, end - start + 1)
            current_sum -= arr[start]
            start += 1

    return min_length if min_length != float('inf') else 0",100
33759909768,is_valid_serialization,"def is_valid_serialization(preorder: str) -> bool:
    preorder = preorder.split(',')
    stack = []
    for node in preorder:
        stack.append(node)
        while len(stack) > 2 and stack[-2:] == [""#""] * 2 and stack[-3] != ""#"":
            stack.pop(-3)
            stack.pop(-2)
            stack.pop(-1)
            stack.append(""#"")
    return len(stack) == 1 and stack.pop() == ""#""",99
1372294423,find_smallest_missing_positive,"def find_smallest_missing_positive(arr):
    n = len(arr)
    for i in range(n):
        while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]:
            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]

    for i in range(n):
        if arr[i] != i + 1:
            return i + 1
    return n + 1",99
25993855587,intersection_sorted_lists,"def intersection_sorted_lists(list1,list2):
    i = 0
    j = 0
    result = []
    while i < len(list1) and j < len(list2):
        if list1[i] == list2[j]:
            result.append(list1[i])
            i += 1
            j += 1
        elif list1[i] < list2[j]:
            i += 1
        else:
            j += 1
    return result",99
25886909479,shortest_sublist_sum,"def shortest_sublist_sum(nums, target):
    n = len(nums)
    shortest_len = n + 1
    left = 0
    current_sum = 0

    for right in range(n):
        current_sum += nums[right]

        while current_sum >= target:
            shortest_len = min(shortest_len, right - left + 1)
            current_sum -= nums[left]
            left += 1

    return shortest_len if shortest_len <= n else 0",99
24447121648,find_smallest_missing_positive,"def find_smallest_missing_positive(arr):
    n = len(arr)
    for i in range(n):
        while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]:
            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]
    for i in range(n):
        if arr[i] != i + 1:
            return i + 1
    return n + 1",99
38556166190,find_first_occurrence,"def find_first_occurrence(arr, target):
    low, high = 0, len(arr) - 1
    result = -1

    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            result = mid
            high = mid - 1
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return result",99
28601389970,max_length_subarray,"def max_length_subarray(arr):
    max_len = 0
    sum = 0
    sum_dict = {0: -1}
    for i in range(len(arr)):
        if arr[i] == 0:
            sum -= 1
        else:
            sum += 1
        if sum in sum_dict:
            max_len = max(max_len, i-sum_dict[sum])
        else:
            sum_dict[sum] = i
    return max_len",99
13881689944,rotate_matrix,"def rotate_matrix(matrix):
    return [list(x) for x in zip(*matrix[::-1])]

# Test cases
assert rotate_matrix([[1,2,3],[4,5,6],[7,8,9]]) == [[7,4,1],[8,5,2],[9,6,3]]
assert rotate_matrix([[1,2],[3,4]]) == [[3,1],[4,2]]
assert rotate_matrix([[1]]) == [[1]]",99
71921797007,smallest_missing,"def smallest_missing(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",99
1924677019,majority_element,"def majority_element(arr):
    count = 0
    candidate = None

    for i in arr:
        if count == 0:
            candidate = i
            count = 1
        elif candidate == i:
            count += 1
        else:
            count -= 1

    if count > 0:
        if arr.count(candidate) > len(arr) // 2:
            return candidate
        else:
            return None
    else:
        return None",99
29149501580,sum_of_primes,"def sum_of_primes(num):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    
    sum_primes = 0
    for i in range(2, num + 1):
        if is_prime(i):
            sum_primes += i
    return sum_primes",99
73503859628,unique_robot_paths,"def unique_robot_paths(m, n):
    """"""
    :type m: int
    :type n: int
    :rtype: int
    Time complexity O(mn)
    Space complexity O(n)
    """"""
    curr_row = [1] * n

    for j in range(1, m):
        for i in range(1, n):
            curr_row[i] = curr_row[i] + curr_row[i-1]

    return curr_row[-1]",99
597544222,sorted_arrays_intersection,"def sorted_arrays_intersection(arr1, arr2):
    i, j = 0, 0
    intersection = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] == arr2[j]:
            intersection.append(arr1[i])
            i += 1
            j += 1
        elif arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return intersection",99
23795090690,find_largest_subarray,"def find_largest_subarray(arr):
    count = 0
    max_size = 0
    sum_map = {0: -1}
    for i in range(len(arr)):
        if arr[i] == 0:
            count -= 1
        else:
            count += 1

        if count in sum_map:
            max_size = max(max_size, i - sum_map[count])
        else:
            sum_map[count] = i

    return max_size",99
5981544749,length_of_longest_subarray,"def length_of_longest_subarray(arr):
    max_length = 0
    current_sum = 0
    sum_dict = {}
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum == 0:
            max_length = i + 1
        if current_sum in sum_dict:
            max_length = max(max_length, i - sum_dict[current_sum])
        else:
            sum_dict[current_sum] = i
    return max_length",99
29713270468,max_length_of_subarray,"def max_length_of_subarray(nums):
    count = 0
    max_length = 0
    count_dict = {0: -1}
    for i in range(len(nums)):
        if nums[i] == 0:
            count -= 1
        else:
            count += 1
        if count in count_dict:
            max_length = max(max_length, i - count_dict[count])
        else:
            count_dict[count] = i
    return max_length",99
2513931588,max_average_subarray,"def max_average_subarray(nums, k):
    if not nums or k <= 0 or k > len(nums):
        raise ValueError(""Invalid input"")

    max_sum = float('-inf')
    curr_sum = 0
    for i in range(len(nums)):
        curr_sum += nums[i]
        if i >= k - 1:
            max_sum = max(max_sum, curr_sum)
            curr_sum -= nums[i - k + 1]

    return max_sum / k",99
36975105688,check_password_validity,"import re

def check_password_validity(password):
    if len(password) < 8 or len(password) > 20:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%^&*]"", password):
        return False
    return True",99
23579174679,count_valid_subarrays,"def count_valid_subarrays(nums):
    if nums == None or len(nums) == 0:
        return 0

    prev, sumT = 0,0

    for x in range(len(nums)-3, -1, -1):
        if nums[x]-nums[x+1] == nums[x+1] - nums[x+2]:
            prev += 1
            sumT += prev
        else:
            prev = 0

    return sumT",99
29178043754,catalan_number,"def catalan_number(n):
    if n <= 1:
        return 1
    catalan = [0 for i in range(n + 1)]
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i - j - 1]
    return catalan[n]",99
21541851983,max_subarray_length,"def max_subarray_length(nums, k):
    seen_sum = {0: -1}
    total_sum = 0
    max_len = 0
    for i, num in enumerate(nums):
        total_sum += num
        if total_sum not in seen_sum:
            seen_sum[total_sum] = i
        if total_sum - k in seen_sum:
            max_len = max(max_len, i - seen_sum[total_sum - k])
    return max_len",99
15355901648,is_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while (i * i <= n):
        if (n % i == 0 or n % (i + 2) == 0):
            return False
        i += 6
    return True",99
39512499375,intersect_sorted,"def intersect_sorted(arr1, arr2):
    i = 0
    j = 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            i += 1
        elif arr1[i] > arr2[j]:
            j += 1
        else:
            result.append(arr1[i])
            i += 1
            j += 1
    return result",99
72679277686,find_subarrays_with_sum,"def find_subarrays_with_sum(nums, k):
    count = 0
    current_sum = 0
    sum_frequency = {0: 1}

    for num in nums:
        current_sum += num

        if current_sum - k in sum_frequency:
            count += sum_frequency[current_sum - k]

        if current_sum in sum_frequency:
            sum_frequency[current_sum] += 1
        else:
            sum_frequency[current_sum] = 1

    return count",99
42675038992,generate_primes,"def generate_primes(n):
    primes = []
    for possiblePrime in range(2, n + 1):
        # Assume number is prime until shown it is not. 
        isPrime = True
        for num in range(2, int(possiblePrime ** 0.5) + 1):
            if possiblePrime % num == 0:
                isPrime = False
                break
        if isPrime:
            primes.append(possiblePrime)
    return primes",99
18478990692,intersect_sorted_arrays,"def intersect_sorted_arrays(arr1, arr2):
    i, j = 0, 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            i += 1
        elif arr1[i] > arr2[j]:
            j += 1
        else:
            result.append(arr1[i])
            i += 1
            j += 1
    return result",99
552613261,doRectanglesIntersect,"def doRectanglesIntersect(bottom_left1, top_right1, bottom_left2, top_right2):
    x1, y1 = bottom_left1
    x2, y2 = top_right1
    x3, y3 = bottom_left2
    x4, y4 = top_right2

    if x3 < x2 and x1 < x4 and y3 < y2 and y1 < y4:
        return True
    return False",99
72981437651,sieve_of_eratosthenes,"def sieve_of_eratosthenes(n):
    primes = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (primes[p] == True):
            for i in range(p * p, n+1, p):
                primes[i] = False
        p += 1
    prime_numbers = [p for p in range(2, n) if primes[p]]
    return prime_numbers",99
21961335918,max_diff,"def max_diff(lst):
    if not lst:
        return 0
    min_element = lst[0]
    max_diff = lst[1] - lst[0]
    for i in range(1, len(lst)):
        if lst[i] - min_element > max_diff:
            max_diff = lst[i] - min_element
        if lst[i] < min_element:
            min_element = lst[i]
    return max_diff if max_diff > 0 else 0",99
3845523814,longestConsecutive,"def longestConsecutive(nums):
    num_set = set(nums)
    longest_streak = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",99
1795109199,longest_non_repeating_substring,"def longest_non_repeating_substring(s: str) -> int:
    max_length = 0
    start = 0
    used_char = {}

    for i in range(len(s)):
        if s[i] in used_char and start <= used_char[s[i]]:
            start = used_char[s[i]] + 1
        else:
            max_length = max(max_length, i - start + 1)

        used_char[s[i]] = i

    return max_length",99
33046279670,longestConsecutive,"def longestConsecutive(nums):
    nums_set = set(nums)
    longest_streak = 0

    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",99
74912167128,longestConsecutive,"def longestConsecutive(nums):
    num_set = set(nums)
    longest_streak = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",99
33211086070,max_unique_substring,"def max_unique_substring(s):
    char_map = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        char_map[s[right]] = char_map.get(s[right], 0) + 1
        while char_map[s[right]] > 1:
            char_map[s[left]] -= 1
            left += 1
        max_length = max(max_length, right - left + 1)
    return max_length",99
37165817314,find_last_occurrence,"def find_last_occurrence(A, x):
    (left, right) = (0, len(A) - 1)
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if x == A[mid]:
            result = mid
            left = mid + 1
        elif x < A[mid]:
            right = mid - 1
        else:
            left = mid + 1
    return result",99
10996690300,prime_sieve,"def prime_sieve(limit):
    sieve = [True] * (limit + 1)
    sieve[0] = sieve[1] = False
    for num in range(2, int(limit ** 0.5) + 1):
        if sieve[num]:
            for multiple in range(num * num, limit + 1, num):
                sieve[multiple] = False
    return [num for num, is_prime in enumerate(sieve) if is_prime]",99
17635218338,shortest_subarray,"def shortest_subarray(nums, target):
    n = len(nums)
    min_len = float(""inf"")
    left = 0
    current_sum = 0

    for right in range(n):
        current_sum += nums[right]

        while current_sum >= target:
            min_len = min(min_len, right - left + 1)
            current_sum -= nums[left]
            left += 1

    return min_len if min_len != float(""inf"") else 0",99
14904460905,sieve_of_eratosthenes,"def sieve_of_eratosthenes(n):
    primes = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (primes[p] == True):
            for i in range(p * p, n+1, p):
                primes[i] = False
        p += 1
    prime_numbers = [p for p in range(2, n) if primes[p]]
    return prime_numbers",99
11600706681,is_valid_ipv4,"import re

def is_valid_ipv4(ip_address):
    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    if re.match(pattern, ip_address):
        return True
    return False",99
42302457352,longest_subarray_with_zero_sum,"def longest_subarray_with_zero_sum(arr):
    max_length = 0
    sum_dict = {}
    current_sum = 0
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum == 0:
            max_length = i + 1
        if current_sum in sum_dict:
            max_length = max(max_length, i - sum_dict[current_sum])
        else:
            sum_dict[current_sum] = i
    return max_length",99
25273392906,missing_positive,"def missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",99
10849237972,sieve_of_eratosthenes,"def sieve_of_eratosthenes(n):
    primes = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (primes[p] == True):
            for i in range(p * p, n+1, p):
                primes[i] = False
        p += 1
    prime_numbers = [p for p in range(2, n) if primes[p]]
    return prime_numbers",99
40469555950,peak_element,"def peak_element(arr):
    n = len(arr)
    if n == 1:
        return arr[0]
    if arr[0] >= arr[1]:
        return arr[0]
    if arr[n-1] >= arr[n-2]:
        return arr[n-1]
    for i in range(1, n-1):
        if arr[i] >= arr[i-1] and arr[i] >= arr[i+1]:
            return arr[i]",99
16482015490,max_ones,"def max_ones(A):
    max_length = 0
    zero_count = 0
    left = 0
    for right in range(len(A)):
        if A[right] == 0:
            zero_count += 1
        while zero_count > 1:
            if A[left] == 0:
                zero_count -= 1
            left += 1
        max_length = max(max_length, right - left + 1)
    return max_length",99
13017060730,intersect_sorted_lists,"def intersect_sorted_lists(list1, list2):
    i, j = 0, 0
    result = []
    while i < len(list1) and j < len(list2):
        if list1[i] == list2[j]:
            result.append(list1[i])
            i += 1
            j += 1
        elif list1[i] < list2[j]:
            i += 1
        else:
            j += 1
    return result",99
16185003472,smallest_subsequence,"from collections import Counter

def smallest_subsequence(s: str) -> str:
    result = []
    stack = []
    char_count = Counter(s)
    for char in s:
        if char not in result:
            while stack and char < stack[-1] and char_count[stack[-1]] > 0:
                result.pop()
                stack.pop()
            result.append(char)
            stack.append(char)
        char_count[char] -= 1
    return ''.join(result)",99
2732292347,find_first_occurrence,"def find_first_occurrence(arr, target):
    lo, hi = 0, len(arr) - 1
    result = -1
    while lo <= hi:
        mid = (lo + hi) // 2
        if arr[mid] == target:
            result = mid
            hi = mid - 1
        elif arr[mid] < target:
            lo = mid + 1
        else:
            hi = mid - 1
    return result",99
3655756945,count_connected_components,"def count_connected_components(n, computers):
    answer = 0
    visited = [0] * n

    def checkNetwork(node):
        for i in range(n):
            if computers[node][i] == 1 and not visited[i]:
                visited[i] = 1
                checkNetwork(i)

    for i in range(n):
        if not visited[i]:
            visited[i] = 1
            checkNetwork(i)
            answer += 1
        
    return answer",99
21289630947,unique_paths,"def unique_paths(m: int, n: int) -> int:
    # Initialize the DP array with 1s
    dp = [[1] * n for _ in range(m)]

    # Fill the DP array
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]

    return dp[m-1][n-1]",99
7746065987,find_smallest_missing_positive,"def find_smallest_missing_positive(arr):
    n = len(arr)
    for i in range(n):
        while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]:
            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]
    for i in range(n):
        if arr[i] != i + 1:
            return i + 1
    return n + 1",99
25328271195,pascal_row,"def pascal_row(n):
    """"""
    Generate the nth row of Pascal's triangle.

    Args:
    n (int): The row number of Pascal's triangle.

    Returns:
    list: The nth row of Pascal's triangle.
    """"""
    row = [1] * (n + 1)
    for i in range(1, n + 1):
        row[i] = row[i-1] * (n-i+1) // i
    return row",99
38615122659,max_of_subarrays,"from collections import deque

def max_of_subarrays(arr, k):
    deq = deque()
    results = []

    for i in range(len(arr)):
        while deq and arr[i] >= arr[deq[-1]]:
            deq.pop()
        deq.append(i)

        if deq[0] == i - k:
            deq.popleft()

        if i >= k - 1:
            results.append(arr[deq[0]])

    return results",99
20228944126,intersect_sorted_arrays,"def intersect_sorted_arrays(arr1, arr2):
    i, j = 0, 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] == arr2[j]:
            result.append(arr1[i])
            i += 1
            j += 1
        elif arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return result",99
38726814531,find_first_occurrence,"def find_first_occurrence(A, x):
    (left, right) = (0, len(A) - 1)
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if x == A[mid]:
            result = mid
            right = mid - 1
        elif x < A[mid]:
            right = mid - 1
        else:
            left = mid + 1
    return result",99
10816528461,length_of_longest_subarray,"def length_of_longest_subarray(arr):
    max_length = 0
    sum_map = {}
    current_sum = 0
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum == 0:
            max_length = i + 1
        if current_sum in sum_map:
            max_length = max(max_length, i - sum_map[current_sum])
        else:
            sum_map[current_sum] = i
    return max_length",99
24755683498,find_first_occurrence,"def find_first_occurrence(arr, target):
    low, high = 0, len(arr) - 1
    result = -1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            result = mid
            high = mid - 1
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return result",99
70938694779,shortest_path,"from collections import deque

def shortest_path(graph, start, end):
    queue = deque([[start]])
    visited = set()
    while queue:
        path = queue.popleft()
        node = path[-1]
        if node == end:
            return path
        if node not in visited:
            visited.add(node)
            for neighbor in graph.get(node, []):
                new_path = list(path)
                new_path.append(neighbor)
                queue.append(new_path)
    return None",99
74601017596,compress_string,"def compress_string(s):
    compressed = []
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            count += 1
        else:
            compressed.append(s[i - 1] + str(count))
            count = 1
    compressed.append(s[-1] + str(count))
    compressed = ''.join(compressed)
    return compressed if len(compressed) < len(s) else s",99
15224512763,longest_consecutive,"def longest_consecutive(nums):
    num_set = set(nums)
    longest_streak = 0
    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",99
17944356403,common_characters,"from collections import defaultdict

def common_characters(str1, str2):
    answer = """"
    d1, d2 = defaultdict(int), defaultdict(int)
    for c1 in str1: d1[c1] += 1
    for c2 in str2: d2[c2] += 1
    for i in sorted(set(str1) & set(str2), reverse=True):
        answer += i * min(d1[i], d2[i])
    return answer",99
32706129190,is_permutation_palindrome,"def is_permutation_palindrome(s):
    s = s.replace("" "", """").lower()
    d = {}
    for char in s:
        if char in d:
            d[char] += 1
        else:
            d[char] = 1
    odd_count = 0
    for count in d.values():
        if count % 2 != 0:
            odd_count += 1
        if odd_count > 1:
            return False
    return True",99
19747803746,count_unique_bst,"def count_unique_bst(n):
    # Initialize the dp array
    dp = [0] * (n + 1)
    # Base cases
    dp[0] = 1
    dp[1] = 1
    # Fill the dp array
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",99
72263032573,longest_consecutive,"def longest_consecutive(nums):
    num_set = set(nums)
    longest_streak = 0
    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",99
7039561375,check_brackets_balance,"def check_brackets_balance(s: str) -> bool:
    if len(s) % 2 == 1:
        return False

    pairs = {
        "")"": ""("",
        ""]"": ""["",
        ""}"": ""{""
    }

    stack = list()

    for c in s:
        if c in pairs:
            if not stack or stack[-1] != pairs[c]:
                return False
            stack.pop()
        else:
            stack.append(c)
    return not stack",99
15648932065,longestConsecutive,"def longestConsecutive(nums):
    num_set = set(nums)
    longest_streak = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",99
2522080987,missing_positive,"def missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",99
7834644810,is_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while (i * i) <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True",99
74802995223,catalan_num,"def catalan_num(n):
    if n <= 1:
        return 1
    catalan = [0 for i in range(n + 1)]
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i - j - 1]
    return catalan[n]",99
3774393779,find_two_element,"def find_two_element(arr, n):
    repeating_number = -1
    missing_number = -1
    for i in arr:
        if arr[abs(i)-1]>0:
            arr[abs(i)-1] *= -1
        else:
            repeating_number = abs(i)
    for i in range(len(arr)):
        if arr[i] > 0:
            missing_number = i+1
            break
    return [repeating_number, missing_number]",99
308493104,find_primes,"def find_primes(n):
    primes = []
    for possiblePrime in range(2, n + 1):
        # Assume number is prime until shown it is not. 
        isPrime = True
        for num in range(2, int(possiblePrime ** 0.5) + 1):
            if possiblePrime % num == 0:
                isPrime = False
                break
        if isPrime:
            primes.append(possiblePrime)
    return primes",99
23950453578,longest_subarray_with_zero_sum,"def longest_subarray_with_zero_sum(arr):
    sum_dict = {}
    max_length = 0
    current_sum = 0
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum == 0:
            max_length = i + 1
        if current_sum in sum_dict:
            max_length = max(max_length, i - sum_dict[current_sum])
        else:
            sum_dict[current_sum] = i
    return max_length",99
8210191098,smallest_integer_with_n_divisors,"def smallest_integer_with_n_divisors(n):
    def count_divisors(num):
        count = 0
        for i in range(1, int(num ** 0.5) + 1):
            if num % i == 0:
                count += 2 if i * i != num else 1
        return count
    i = 1
    while True:
        if count_divisors(i) == n:
            return i
        i += 1",99
33086923501,intersection_sorted_lists,"def intersection_sorted_lists(list1, list2):
    i, j = 0, 0
    result = []
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            i += 1
        elif list1[i] > list2[j]:
            j += 1
        else:
            result.append(list1[i])
            i += 1
            j += 1
    return result",99
29539916133,num_min_squares,"def num_min_squares(target):
    dp = [0] * (target + 1)
    for i in range(1, target + 1):
        dp[i] = i
        for x in range(1, int(i ** 0.5) + 1):
            square = x * x
            if i < square:
                break
            dp[i] = min(dp[i], dp[i - square] + 1)
    return dp[target]",99
35872300682,nth_prime,"def nth_prime(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5)+1):
            if num % i == 0:
                return False
        return True

    count = 0
    num = 2
    while True:
        if is_prime(num):
            count += 1
            if count == n:
                return num
        num += 1",99
70676360777,intersection_sorted_lists,"def intersection_sorted_lists(list1, list2):
    i, j = 0, 0
    result = []
    while i < len(list1) and j < len(list2):
        if list1[i] == list2[j]:
            result.append(list1[i])
            i += 1
            j += 1
        elif list1[i] < list2[j]:
            i += 1
        else:
            j += 1
    return result",99
5222486739,leven_distance,"def leven_distance(s, t):
    if s == """":
        return len(t)
    if t == """":
        return len(s)
    if s[-1] == t[-1]:
        cost = 0
    else:
        cost = 1
       
    res = min([leven_distance(s[:-1], t)+1,
               leven_distance(s, t[:-1])+1, 
               leven_distance(s[:-1], t[:-1]) + cost])
    return res",99
24814687573,longestConsecutive,"def longestConsecutive(nums):
    num_set = set(nums)
    longest_streak = 0
    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",99
13924598273,find_last_occurrence,"def find_last_occurrence(A, x):
    (left, right) = (0, len(A) - 1)
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if x == A[mid]:
            result = mid
            left = mid + 1
        elif x < A[mid]:
            right = mid - 1
        else:
            left = mid + 1
    return result",99
4957083909,ways_to_climb,"def ways_to_climb(n):
    if n == 1:
        return 1
    if n == 2:
        return 2
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]",98
13614004140,merge,"def merge(list1, list2):
    merged_list = []
    i = j = 0
    while i < len(list1) and j < len(list2):
        if list1[i] <= list2[j]:
            merged_list.append(list1[i])
            i += 1
        else:
            merged_list.append(list2[j])
            j += 1
    merged_list.extend(list1[i:])
    merged_list.extend(list2[j:])
    return merged_list",98
18651962904,find_subarray_sum,"def find_subarray_sum(arr, k):
    ans = 0
    s = 0
    d = {}
    for i in range(len(arr)):
        s += arr[i]
        if s == k:
            ans += 1
        if (s - k) in d:
            ans += d[s - k]
        if s not in d:
            d[s] = 1
        else:
            d[s] += 1
    return ans",98
71050035566,intersect_sorted,"def intersect_sorted(arr1, arr2):
    i, j = 0, 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            i += 1
        elif arr1[i] > arr2[j]:
            j += 1
        else:
            result.append(arr1[i])
            i += 1
            j += 1
    return result",98
21292603397,max_subarray,"from collections import deque

def max_subarray(nums, k):
    d = deque()
    max_val = float('-inf')

    for i in range(len(nums)):
        while d and nums[i] >= nums[d[-1]]:
            d.pop()
        d.append(i)

        if d[0] == i - k:
            d.popleft()

        if i >= k - 1:
            max_val = max(max_val, nums[d[0]])

    return max_val",98
11258027071,max_consecutive_sequence,"def max_consecutive_sequence(nums):
    if not nums:
        return 0

    nums = set(nums)
    max_length = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_length = 1

            while current_num + 1 in nums:
                current_num += 1
                current_length += 1

            max_length = max(max_length, current_length)

    return max_length",98
71575845305,find_students,"def find_students(n, lost, reserve):
    _reserve = [r for r in reserve if r not in lost]
    _lost = [l for l in lost if l not in reserve]
    for r in _reserve:
        f = r - 1
        b = r + 1
        if f in _lost:
            _lost.remove(f)
        elif b in _lost:
            _lost.remove(b)
    return n - len(_lost)",98
8667186951,third_max,"def third_max(nums):
    unique_nums = list(set(nums))
    unique_nums.sort()
    if len(unique_nums) < 3:
        return max(unique_nums)
    else:
        return unique_nums[-3]

# Test cases
print(third_max([3, 2, 1])) # 1
print(third_max([1, 2])) # 2
print(third_max([2, 2, 3, 1])) # 1",98
28928396639,validate_password,"import re

def validate_password(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[_@$]"", password):
        return False
    if re.search(""\s"", password):
        return False
    return True",98
71575864185,prime_numbers,"def prime_numbers(n):
    primes = []
    for possiblePrime in range(2, n + 1):
        # Assume number is prime until shown it is not. 
        isPrime = True
        for num in range(2, int(possiblePrime ** 0.5) + 1):
            if possiblePrime % num == 0:
                isPrime = False
                break
        if isPrime:
            primes.append(possiblePrime)
    return primes",98
74626207316,merge_intervals,"def merge_intervals(intervals):
    if len(intervals) == 0:
        return []

    intervals = sorted(intervals, key=lambda x: x[0])

    merged = [intervals[0]]

    for current in intervals:
        last = merged[-1]

        if last[0] <= current[0] <= last[1]:
            last[1] = max(current[1], last[1])
        else:
            merged.append(current)

    return merged",98
69884542398,sort_by_parity,"def sort_by_parity(nums):
    slow = fast = 0
    while fast < len(nums):
        if nums[slow] % 2 == 0:
            slow += 1
        elif nums[slow] % 2 != 0 and nums[fast] % 2 == 0:
            nums[slow], nums[fast] = nums[fast], nums[slow]
            slow += 1
        fast += 1
    return nums",98
140897110,contains_cycle,"def contains_cycle(graph):
    visited = set()
    recursion_stack = set()

    def dfs(node):
        if node in recursion_stack:
            return True
        if node in visited:
            return False

        visited.add(node)
        recursion_stack.add(node)

        for neighbor in graph[node]:
            if dfs(neighbor):
                return True

        recursion_stack.remove(node)
        return False

    for node in graph:
        if dfs(node):
            return True

    return False",98
9465704309,nth_prime,"def nth_prime(n):
    sieve = [True] * (n*10)
    for x in range(2, int(len(sieve)**0.5) + 1):
        if sieve[x]: sieve[2*x::x] = [False] * (((len(sieve)-1)//x) - 1)
    primes = [i for i, x in enumerate(sieve) if x and i >= 2]
    return primes[n-1]",98
21878495336,islandPerimeter,"def islandPerimeter(grid):
    perimeter = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                perimeter += 4
                if i > 0 and grid[i-1][j] == 1:
                    perimeter -= 2
                if j > 0 and grid[i][j-1] == 1:
                    perimeter -= 2
    return perimeter",98
12550637660,longest_equal_subarray,"def longest_equal_subarray(nums):
    count = 0
    max_length = 0
    count_dict = {0: -1}
    for i in range(len(nums)):
        if nums[i] == 0:
            count -= 1
        else:
            count += 1
        if count in count_dict:
            max_length = max(max_length, i - count_dict[count])
        else:
            count_dict[count] = i
    return max_length",98
1368985140,min_subarray_length,"def min_subarray_length(nums, target):
    left, sum_subarray = 0, 0
    min_length = float('inf')
    for right in range(len(nums)):
        sum_subarray += nums[right]
        while sum_subarray >= target:
            min_length = min(min_length, right - left + 1)
            sum_subarray -= nums[left]
            left += 1
    return 0 if min_length == float('inf') else min_length",98
38425776551,largest_prime_factor,"import math

def largest_prime_factor(n):
    max_prime = -1
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            max_prime = i
            n = n // i
    if n > 2:
        max_prime = n
    return max_prime",98
38122810220,maxConsecutiveOnes,"def maxConsecutiveOnes(nums, k):
    left = 0
    zeros = 0
    max_length = 0
    for right in range(len(nums)):
        if nums[right] == 0:
            zeros += 1
        while zeros > k:
            if nums[left] == 0:
                zeros -= 1
            left += 1
        max_length = max(max_length, right - left + 1)
    return max_length",98
1186496124,get_prime_numbers,"def get_prime_numbers(n):
    def is_prime(num):
        if num <= 1:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    primes = []
    num = 2
    while len(primes) < n:
        if is_prime(num):
            primes.append(num)
        num += 1
    return primes",98
19388936338,max_product_three,"def max_product_three(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])

assert max_product_three([-10, -10, 5, 2]) == 500
assert max_product_three([1, 2, 3]) == 6
assert max_product_three([1, 2, 3, 4]) == 24",98
70015659007,catalan,"def catalan(n):
    if n <= 1:
        return 1
    catalan = [0 for _ in range(n + 1)]
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i - j - 1]
    return catalan[n]",98
72631080484,find_min_index,"def find_min_index(nums):
    if not nums:
        return
    frnt, rear = 0, len(nums) - 1
    if nums[frnt] <= nums[rear]:
        return frnt
    while frnt < rear - 1:
        mid = (frnt + rear) // 2
        if nums[frnt] < nums[mid]:
            frnt = mid
        else:
            rear = mid
    return rear",98
17378668426,first_occurrence,"def first_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            result = mid
            right = mid - 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return result",98
6337098951,shortest_subarray,"def shortest_subarray(nums, target):
    n = len(nums)
    min_len = n + 1
    left = 0
    current_sum = 0
    
    for right in range(n):
        current_sum += nums[right]
        
        while current_sum >= target:
            min_len = min(min_len, right - left + 1)
            current_sum -= nums[left]
            left += 1
            
    return min_len if min_len <= n else 0",98
23664452013,count_subarrays,"from collections import defaultdict

def count_subarrays(arr, k):
    count = 0
    n = len(arr)
    sum = 0
    mod = defaultdict(lambda:0)
    mod[0] = 1
    for i in range(n):
        sum += arr[i]
        mod[sum % k] += 1
    for i in mod:
        count += (mod[i]*(mod[i] - 1))//2
    return count",98
21091122482,find_substrings,"from collections import defaultdict

def find_substrings(s):
    count = defaultdict(int)
    res, start = 0, 0
    for end, char in enumerate(s):
        count[char] += 1

        while len(count) == 3:
            res += (len(s) - end)
            count[s[start]] -= 1
            if count[s[start]] == 0:
                del count[s[start]]
            start += 1

    return res",98
40248798094,maxSubArrayLen,"def maxSubArrayLen(nums, k):
    dict = {}
    sum = 0
    max_length = 0
    for i in range(len(nums)):
        sum += nums[i]
        if sum == k:
            max_length = i + 1
        if sum - k in dict:
            max_length = max(max_length, i - dict[sum - k])
        if sum not in dict:
            dict[sum] = i
    return max_length",98
21895661957,find_first_occurrence,"def find_first_occurrence(nums, target):
    left, right = 0, len(nums) - 1
    result = -1
    while left <= right:
        mid = left + (right-left)//2
        if nums[mid] == target:
            result = mid
            right = mid - 1
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return result",98
1368549360,longest_substring_without_repeating,"def longest_substring_without_repeating(s):
    char_map = {}
    start = 0
    longest_substring = """"
    for end in range(len(s)):
        if s[end] in char_map:
            start = max(start, char_map[s[end]] + 1)
        char_map[s[end]] = end
        if end - start + 1 > len(longest_substring):
            longest_substring = s[start:end+1]
    return longest_substring",98
26489273640,move_zeros,"def move_zeros(nums):
    n = len(nums)
    counter = 0
    j = 0
    for i in nums:
        if i != 0:
            counter += 1
    for i in range(n):
        if j < counter:
            if nums[i] != 0:
                nums[j] = nums[i]
                j += 1
    for i in range(j, n):
        nums[i] = 0
    return nums",98
37158501325,longest_equal_subarray,"def longest_equal_subarray(arr):
    count = 0
    max_length = 0
    count_dict = {0: -1}
    for i in range(len(arr)):
        if arr[i] == 0:
            count -= 1
        else:
            count += 1
        
        if count in count_dict:
            max_length = max(max_length, i - count_dict[count])
        else:
            count_dict[count] = i

    return max_length",98
9855688676,count_valid_parentheses,"def count_valid_parentheses(n: int) -> int:
    if n % 2 == 1:
        return 0
    n //= 2
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",98
15310919051,max_sum_subarray_of_size_k,"def max_sum_subarray_of_size_k(arr, k):
    if not arr or k <= 0 or k > len(arr):
        return 0

    max_sum = float('-inf')
    current_sum = 0
    for i in range(len(arr)):
        current_sum += arr[i]
        if i >= k - 1:
            max_sum = max(max_sum, current_sum)
            current_sum -= arr[i - k + 1]
    return max_sum",98
12473345691,maxDiff,"def maxDiff(arr):
  if not arr: return 0
  minVal = arr[0]
  maxDiff = arr[1] - arr[0]
  for i in range(1, len(arr)):
    if arr[i] - minVal > maxDiff:
      maxDiff = arr[i] - minVal
    if arr[i] < minVal:
      minVal = arr[i]
  return maxDiff if maxDiff > 0 else 0",98
40014533548,count_subarrays_with_sum,"def count_subarrays_with_sum(nums, k):
    count = 0
    sum = 0
    hash_map = {0: 1}

    for i in range(len(nums)):
        sum += nums[i]
        if sum - k in hash_map:
            count += hash_map[sum - k]
        if sum in hash_map:
            hash_map[sum] += 1
        else:
            hash_map[sum] = 1

    return count",98
7123639125,min_coins,"from collections import deque

def min_coins(coins, amount):
    queue = deque([(0, 0)])
    visited = {0}

    while queue:
        current, count = queue.popleft()

        if current == amount:
            return count

        for coin in coins:
            if current + coin <= amount and current + coin not in visited:
                visited.add(current + coin)
                queue.append((current + coin, count + 1))

    return -1",98
34825450229,shortestSubarray,"def shortestSubarray(nums, target):
    start = 0
    end = 0
    min_len = float(""inf"")
    res = 0
    while end < len(nums):
        target -= nums[end]
        end += 1
        while target <= 0:
            if end - start < min_len:
                min_len = end - start
                res = min_len
            target += nums[start]
            start += 1
    return res",98
73295358789,get_longest_substring,"def get_longest_substring(s):
    n = len(s)
    max_length = 0
    start = 0
    seen_chars = {}

    for i in range(n):
        if s[i] in seen_chars and start <= seen_chars[s[i]]:
            start = seen_chars[s[i]] + 1
        else:
            max_length = max(max_length, i - start + 1)

        seen_chars[s[i]] = i

    return max_length",98
6348207246,max_consecutive_ones,"def max_consecutive_ones(nums, k):
    left = 0
    zeros = 0
    max_length = 0
    for right in range(len(nums)):
        if nums[right] == 0:
            zeros += 1
        while zeros > k:
            if nums[left] == 0:
                zeros -= 1
            left += 1
        max_length = max(max_length, right - left + 1)
    return max_length",98
70676347977,find_combinations,"def find_combinations(n, r):
    result = 1
    for j in range(r):
        part1 = n - j
        part2 = j + 1
        result *= part1 / part2
    return result

# Test cases
assert find_combinations(6, 2) == 15
assert find_combinations(4, 3) == 4
assert find_combinations(5, 2) == 10",98
28462923210,intersect_sorted,"def intersect_sorted(arr1, arr2):
    i, j = 0, 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            i += 1
        elif arr1[i] > arr2[j]:
            j += 1
        else:
            result.append(arr1[i])
            i += 1
            j += 1
    return result",98
42091084552,generate_primes,"def generate_primes(n):
    primes = []
    for possiblePrime in range(2, n + 1):
        # Assume number is prime until shown it is not.
        isPrime = True
        for num in range(2, int(possiblePrime ** 0.5) + 1):
            if possiblePrime % num == 0:
                isPrime = False
                break
        if isPrime:
            primes.append(possiblePrime)
    return primes",98
74794142454,find_last_occurrence,"def find_last_occurrence(A, x):
    left = 0
    right = len(A) - 1
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if x == A[mid]:
            result = mid
            left = mid + 1
        elif x < A[mid]:
            right = mid - 1
        else:
            left = mid + 1
    return result",98
43430938338,longest_sequence,"def longest_sequence(nums):
    nums_set = set(nums)
    longest_streak = 0

    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",98
71575847225,max_subarray_with_sum,"def max_subarray_with_sum(arr, target):
    max_len = 0
    sum_dict = {0: -1}
    curr_sum = 0
    for i, num in enumerate(arr):
        curr_sum += num
        if curr_sum not in sum_dict:
            sum_dict[curr_sum] = i
        if curr_sum - target in sum_dict:
            max_len = max(max_len, i - sum_dict[curr_sum - target])
    return max_len",98
31035902784,max_pairs,"def max_pairs(arr, target):
    arr.sort()
    left, right = 0, len(arr) - 1
    count = 0
    while left < right:
        if arr[left] + arr[right] < target:
            left += 1
        elif arr[left] + arr[right] > target:
            right -= 1
        else:
            count += 1
            left += 1
            right -= 1
    return count",98
40851618724,merge_sorted_lists,"def merge_sorted_lists(list1, list2):
    result = []
    i, j = 0, 0

    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            result.append(list1[i])
            i += 1
        else:
            result.append(list2[j])
            j += 1

    result.extend(list1[i:])
    result.extend(list2[j:])

    return result",98
25922666360,is_happy_number,"def get_digits(num):
    digits = []
    while num > 0:
        digits.append(num % 10)
        num = num // 10
    return digits[::-1]

def is_happy_number(n):
    seen = set()
    while n not in seen:
        seen.add(n)
        digits = get_digits(n)
        n = sum([d**2 for d in digits])
        if n == 1:
            return True
    return False",98
5682722848,is_poker_straight,"def is_poker_straight(nums):
    nums.sort()
    joker = nums.count(0)
    for i in range(1, len(nums)):
        if nums[i] == 0:
            continue
        diff = nums[i] - nums[i-1]
        if diff == 0:
            return False
        elif diff > 1:
            joker -= diff - 1
            if joker < 0:
                return False
    return True",98
14887672386,longest_seq,"def longest_seq(arr):
    longest_streak = 0
    num_set = set(arr)

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",98
4024874782,look_and_say,"def look_and_say(n):
    if n == 1:
        return ""1""
    prev = look_and_say(n - 1)
    result = """"
    count = 1
    for i in range(len(prev)):
        if i + 1 < len(prev) and prev[i] == prev[i + 1]:
            count += 1
        else:
            result += str(count) + prev[i]
            count = 1
    return result",98
7042256071,count_subarrays_with_sum,"from collections import defaultdict

def count_subarrays_with_sum(arr, target_sum):
    count = 0
    current_sum = 0
    sum_occurrences = defaultdict(int)
    sum_occurrences[0] = 1

    for num in arr:
        current_sum += num
        if current_sum - target_sum in sum_occurrences:
            count += sum_occurrences[current_sum - target_sum]
        sum_occurrences[current_sum] += 1

    return count",98
27357668427,longest_sequence,"def longest_sequence(nums):
    longest_streak = 0
    num_set = set(nums)

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",98
28525851898,third_max,"def third_max(nums):
    unique_nums = list(set(nums)) # Remove the duplicates
    unique_nums.sort() # Sort the list
    if len(unique_nums) < 3:
        return max(unique_nums) # If there are less than 3 unique numbers, return the maximum.
    else:
        unique_nums.pop() # Remove the maximum number
        unique_nums.pop() # Remove the second maximum number
        return unique_nums[-1] # Return the third maximum number",98
72296514033,max_length_subarray_sum,"def max_length_subarray_sum(arr, target):
    sum_indices = {0: -1}
    max_length = 0
    current_sum = 0
    for i, num in enumerate(arr):
        current_sum += num
        if current_sum - target in sum_indices:
            max_length = max(max_length, i - sum_indices[current_sum - target])
        if current_sum not in sum_indices:
            sum_indices[current_sum] = i
    return max_length",98
35466920768,sum_of_divisors,"def sum_of_divisors(n):
    answer = 0
    
    divisors = []

    for i in range(1, int(n**(1/2)) + 1): 
        if (n % i == 0):            
            divisors.append(i)
            if (i != (n // i)): 
                divisors.append(n//i)
    
    set_divisors = set(divisors)
    answer = sum(set_divisors) - n
    
    return answer",98
13998713191,smaller_elements_to_right,"def smaller_elements_to_right(nums):
    sorted_list = []
    result = []
    for num in reversed(nums):
        left, right = 0, len(sorted_list)
        while left < right:
            mid = (left + right) // 2
            if sorted_list[mid] >= num:
                right = mid
            else:
                left = mid + 1
        result.append(left)
        sorted_list.insert(left, num)
    return list(reversed(result))",98
74612462651,find_first_occurrence,"def find_first_occurrence(A, x):
    left = 0
    right = len(A) - 1
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if x == A[mid]:
            result = mid
            right = mid - 1
        elif x < A[mid]:
            right = mid - 1
        else:
            left = mid + 1
    return result",98
9255469450,find_max_consecutive_zeros,"def find_max_consecutive_zeros(N):
    binary_representation = bin(N)[2:]
    max_gap = 0
    current_gap = 0
    found_one = False
    for bit in binary_representation:
        if bit == '1':
            if found_one and current_gap > max_gap:
                max_gap = current_gap
            current_gap = 0
            found_one = True
        elif found_one:
            current_gap += 1
    return max_gap",98
24178248160,is_valid_isbn,"def is_valid_isbn(isbn):
    if len(isbn) != 10:
        return False
    total = 0
    for i, char in enumerate(isbn):
        if i == 9 and char == 'X':
            total += 10 * 10
        elif not char.isdigit():
            return False
        else:
            total += int(char) * (i + 1)
    return total % 11 == 0",98
36296608359,longest_subarray_equal_zeros_ones,"def longest_subarray_equal_zeros_ones(arr):
    max_len = 0
    counts = {0: -1}
    diff = 0
    for i, num in enumerate(arr):
        if num == 0:
            diff -= 1
        else:
            diff += 1
        if diff in counts:
            max_len = max(max_len, i - counts[diff])
        else:
            counts[diff] = i
    return max_len",98
37417475143,max_sum_non_adjacent,"def max_sum_non_adjacent(arr):
    if len(arr) == 0:
        return 0
    dp = [0] * len(arr)
    dp[0] = max(0, arr[0])
    dp[1] = max(dp[0], arr[1])
    for i in range(2, len(arr)):
        dp[i] = max(dp[i-1], dp[i-2] + arr[i])
    return dp[-1]",98
22614773216,shortest_distance_bfs,"from collections import deque

def shortest_distance_bfs(graph):
    distances = {}
    for node in graph:
        distances[node] = -1
    distances[0] = 0
    
    queue = deque([0])
    
    while queue:
        current = queue.popleft()
        for neighbor in graph[current]:
            if distances[neighbor] == -1:
                distances[neighbor] = distances[current] + 1
                queue.append(neighbor)
    
    return distances",98
10787019725,max_operations,"def max_operations(nums, k):
    nums.sort()
    left, right = 0, len(nums) - 1
    operations = 0
    while left < right:
        if nums[left] + nums[right] == k:
            operations += 1
            left += 1
            right -= 1
        elif nums[left] + nums[right] < k:
            left += 1
        else:
            right -= 1
    return operations",98
26222636239,validate_ip,"import re

def validate_ip(ip):
    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    if re.match(pattern, ip):
        return True
    else:
        return False",98
34825538999,find_longest_word_length,"def find_longest_word_length(sentence):
    # Split the sentence into words
    words = sentence.split()
    
    # Initialize the maximum length to 0
    max_length = 0
    
    # Iterate through each word in the sentence
    for word in words:
        # Update the maximum length if the current word is longer
        if len(word) > max_length:
            max_length = len(word)
    
    # Return the maximum length found
    return max_length",98
30976275194,find_index,"def find_index(A, x):
    left = 0
    right = len(A) - 1
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if A[mid] == x:
            result = mid
            right = mid - 1
        elif A[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    return result",98
26125468466,rearrange_array,"def rearrange_array(nums):
  nums.sort()
  N = len(nums)
  ans, l, r = [0] * N, 0, N-1

  for i in range(0, N-1, 2):
    ans[i], ans[i+1] = nums[l],nums[r]
    l+=1
    r-=1

  if N&1 ==1:
       ans[N-1] = nums[l]
  return ans",98
41924348601,is_string_anagram,"def is_string_anagram(s, t):
    """"""
    Check if two strings are anagrams of each other.
    
    :param s: First string
    :param t: Second string
    :return: True if strings are anagrams, False otherwise
    """"""
    s = list(s)
    t = list(t)
    if len(s) != len(t):
        return False
    s = sorted(s)
    t = sorted(t)
    return s == t",98
70167432258,longest_sequence,"def longest_sequence(nums):
    num_set = set(nums)
    longest_streak = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",98
71804498750,max_Product,"def max_Product(arr):
    arr.sort()
    return max(arr[0]*arr[1]*arr[-1], arr[-1]*arr[-2]*arr[-3])

assert max_Product([1, 2, 3]) == 6
assert max_Product([-1, -2, -3, -4]) == -6
assert max_Product([1, 10, 2, 6, 5, 3]) == 300",98
40499070197,longest_balanced_subarray,"def longest_balanced_subarray(arr):
    max_len = 0
    count = 0
    count_dict = {0: -1}
    for index, value in enumerate(arr):
        if value == 0:
            count -= 1
        else:
            count += 1

        if count in count_dict:
            max_len = max(max_len, index - count_dict[count])
        else:
            count_dict[count] = index

    return max_len",98
194821420,length_of_longest_substring,"def length_of_longest_substring(s):
    if not s:
        return 0

    start = 0
    max_length = 0
    char_dict = {}

    for i, char in enumerate(s):
        if char in char_dict and char_dict[char] >= start:
            start = char_dict[char] + 1
        char_dict[char] = i
        max_length = max(max_length, i - start + 1)

    return max_length",98
13540993825,find_repeated_sequences,"from collections import defaultdict

def find_repeated_sequences(seq_list):
    lookup = defaultdict(int)
    result = []
    for seq in seq_list:
        if len(seq) >= 4:
            for ind in range(len(seq) - 3):
                four_letter_seq = seq[ind:ind+4]
                lookup[four_letter_seq] += 1
    for key, value in lookup.items():
        if value > 1:
            result.append(key)
    return result",98
6008912237,peak_of_mountain_array,"def peak_of_mountain_array(arr):
    left, right = 0, len(arr) - 1
    feasible_boundary = -1

    while left <= right:
        mid = (left + right) // 2
        if mid == len(arr) - 1 or arr[mid] > arr[mid + 1]:
            feasible_boundary = mid
            right = mid - 1
        else:
            left = mid + 1
    
    return feasible_boundary",98
73115394164,find_index,"def find_index(arr, num):
    left = 0
    right = len(arr) - 1
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == num:
            result = mid
            right = mid - 1
        elif arr[mid] < num:
            left = mid + 1
        else:
            right = mid - 1
    return result",98
30688698582,min_subarray_length,"def min_subarray_length(nums, target):
    left = 0
    current_sum = 0
    min_length = float('inf')
    
    for right in range(len(nums)):
        current_sum += nums[right]
        
        while current_sum >= target:
            min_length = min(min_length, right - left + 1)
            current_sum -= nums[left]
            left += 1
    
    return 0 if min_length == float('inf') else min_length",97
73096789178,can_partition,"def can_partition(nums):
    total_sum = sum(nums)
    if total_sum % 2 != 0:
        return False
    target = total_sum // 2
    dp = [False] * (target + 1)
    dp[0] = True
    for num in nums:
        for i in range(target, num - 1, -1):
            if dp[i - num]:
                dp[i] = True

    return dp[target]",97
30529273687,length_of_longest_substring,"def length_of_longest_substring(s):
    if not s:
        return 0
    char_dict = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_dict:
            left = max(left, char_dict[s[right]] + 1)
        char_dict[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",97
13662615740,concatenate_words,"def concatenate_words(words):
    word_set = set(words)
    result = []

    def can_form(word):
        for i in range(1, len(word)):
            prefix, suffix = word[:i], word[i:]
            if prefix in word_set and (suffix in word_set or can_form(suffix)):
                return True
        return False

    for word in words:
        if len(word) > 1 and can_form(word):
            result.append(word)

    return result",97
71646733994,convert_to_pig_latin,"def convert_to_pig_latin(word):
    vowels = ['a', 'e', 'i', 'o', 'u']
    if word[0] in vowels:
        return word + 'ay'
    else:
        first_vowel = 0
        for i, char in enumerate(word):
            if char in vowels:
                first_vowel = i
                break
        return word[first_vowel:] + word[:first_vowel] + 'ay'",97
43513922612,strange_sort,"def strange_sort(lst):
    sorted_list = []
    while lst:
        # Remove and append the minimum value
        min_val = min(lst)
        lst.remove(min_val)
        sorted_list.append(min_val)
        
        # If list is empty, break the loop
        if not lst:
            break
        
        # Remove and append the maximum value
        max_val = max(lst)
        lst.remove(max_val)
        sorted_list.append(max_val)
    
    return sorted_list",97
74352603517,xor_binary,"def xor_binary(binary_list):
    result = """"
    max_length = max(len(binary) for binary in binary_list)
    
    # Padding the binary numbers to have the same length
    binary_list = [binary.zfill(max_length) for binary in binary_list]
    
    for i in range(max_length):
        xor_result = 0
        for binary in binary_list:
            xor_result ^= int(binary[i])
        result += str(xor_result)
    
    return result",97
39005727278,combination_sum,"def combination_sum(candidates, target):
    def dfs(candidates, target, start, path, res):
        if target < 0:
            return 
        if target == 0:
            res.append(path)
            return 
        for i in range(start, len(candidates)):
            dfs(candidates, target-candidates[i], i, path+[candidates[i]], res)
    res = []
    dfs(candidates, target, 0, [], res)
    return res",97
25484095133,longest_subarray_with_zero_sum,"def longest_subarray_with_zero_sum(arr):
    # Dictionary to store the sum and its index. 
    sum_dict = {0: -1}
    sum, max_len = 0, 0

    for i, num in enumerate(arr):
        sum += num
        if sum not in sum_dict:
            sum_dict[sum] = i
        else:
            max_len = max(max_len, i - sum_dict[sum])
    
    return max_len",97
38962885266,count_unique_bsts,"def count_unique_bsts(n):
    if n == 0 or n == 1:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n+1):
        for j in range(1, i+1):
            dp[i] += dp[j-1] * dp[i-j]
    return dp[n]",97
21825496603,Unique_Paths,"def Unique_Paths(m, n):
    path = [[0 for _ in range(n)] for _ in range(m)]
    for i in range(m):
        for j in range(n):
            if i == 0 or j == 0:
                path[i][j] = 1
            else:
                path[i][j] = path[i-1][j] + path[i][j-1]
    return path[m-1][n-1]",97
40084952336,max_subarray_length,"def max_subarray_length(arr, k):
    max_length = 0
    current_sum = 0
    sum_indices = {0: -1}
    for i, num in enumerate(arr):
        current_sum += num
        if current_sum - k in sum_indices:
            max_length = max(max_length, i - sum_indices[current_sum - k])
        if current_sum not in sum_indices:
            sum_indices[current_sum] = i
    return max_length",97
5048034209,smallest_k,"import heapq

def smallest_k(arr, k):
    if k == 0:
        return list()
    
    hp = [-x for x in arr[:k]]
    heapq.heapify(hp)
    for i in range(k, len(arr)):
        if -hp[0] > arr[i]:
            heapq.heappop(hp)
            heapq.heappush(hp, -arr[i])
    ans = [-x for x in hp]
    return sorted(ans)",97
32648913722,find_missing_integer,"def find_missing_integer(A):
    spi = 1
    A.sort()
    for n in A:
        if spi == n:
            spi = n + 1
    return spi

print(find_missing_integer([1,3,6,4,1,2])) # Expected output: 5
print(find_missing_integer([1,2,3])) # Expected output: 4
print(find_missing_integer([-1,-3])) # Expected output: 1",97
74002491646,longest_subarray_sum,"def longest_subarray_sum(arr, target):
    sum_indices = {0: -1}
    max_length = 0
    current_sum = 0
    for i, num in enumerate(arr):
        current_sum += num
        if current_sum not in sum_indices:
            sum_indices[current_sum] = i
        if current_sum - target in sum_indices:
            max_length = max(max_length, i - sum_indices[current_sum - target])
    return max_length",97
23477081000,countSubarraysWithSum,"from collections import defaultdict

def countSubarraysWithSum(nums, k):
    count = 0
    sumSoFar = 0
    sums = defaultdict(int)
    sums[0] = 1
    
    for i in range(len(nums)):
        sumSoFar += nums[i]
        if (sumSoFar - k) in sums:
            count += sums[sumSoFar - k]
        sums[sumSoFar] += 1
            
    return count",97
18315988910,find_first_index,"def find_first_index(nums, target):
    if len(nums) == 0:
        return -1
    
    left, right = 0, len(nums)
    while left < right:
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid

    if left != len(nums) and nums[left] == target:
        return left
    return -1",97
20463990293,count_primes,"def count_primes(n):
    if n <= 2:
        return 0

    primes = [1] * (n + 1)
    primes[0] = primes[1] = 0

    for i in range(2, int(n**0.5) + 1):
        if primes[i]:
            for j in range(i*i, n+1, i):
                primes[j] = 0

    return sum(primes)",97
13635150170,catalan_number,"def catalan_number(n):
    result = 1
    for i in range(2, n + 1):
        result *= i
    result1 = 1
    for i in range(2, 2 * n + 1):
        result1 *= i
    result2 = 1
    for i in range(2, n + 2):
        result2 *= i
    return int(result1 / (result2 * result))",97
37170465640,can_partition,"def can_partition(nums):
    total_sum = sum(nums)
    if total_sum % 2 != 0:
        return False
    target = total_sum // 2
    dp = [False] * (target + 1)
    dp[0] = True
    for num in nums:
        for i in range(target, num - 1, -1):
            dp[i] = dp[i] or dp[i - num]
    return dp[target]",97
3108218277,nth_catalan_num,"def nth_catalan_num(n):
    if n <= 1:
        return 1
    catalan = [0 for _ in range(n+1)]
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n+1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]
    return catalan[n]",97
28410463716,waysToExpressAsConsecutiveSum,"def waysToExpressAsConsecutiveSum(n):
    count = 0
    for i in range(1, n):
        sum = 0
        for j in range(i, n):
            sum += j
            if sum == n:
                count += 1
                break
            elif sum > n:
                break
    return count + 1  # Adding 1 for the case when the number itself is a consecutive sum (n = n)",97
10785009785,count_valid_parentheses,"def count_valid_parentheses(n):
    if n % 2 == 1:
        return 0
    dp = [0 for _ in range(n + 1)]
    dp[0] = 1
    for i in range(2, n + 1, 2):
        for j in range(0, i, 2):
            dp[i] += dp[j] * dp[i - j - 2]
    return dp[n]",97
42061612102,run_length_encoding,"def run_length_encoding(input_string):
    if not input_string:
        return """"
    encoded = []
    count = 1
    for i in range(1, len(input_string)):
        if input_string[i] == input_string[i-1]:
            count += 1
        else:
            encoded.append(str(count) + input_string[i-1])
            count = 1
    encoded.append(str(count) + input_string[-1])
    return """".join(encoded)",97
18918693585,count_subarrays,"def count_subarrays(nums, k):
    count = 0
    current_sum = 0
    sum_dict = {0: 1}
    for num in nums:
        current_sum += num
        if current_sum - k in sum_dict:
            count += sum_dict[current_sum - k]
        if current_sum in sum_dict:
            sum_dict[current_sum] += 1
        else:
            sum_dict[current_sum] = 1
    return count",97
35415295244,longest_subarray,"def longest_subarray(nums):
    count = 0
    max_length = 0
    count_map = {0: -1}
    for i in range(len(nums)):
        if nums[i] == 0:
            count -= 1
        else:
            count += 1
        if count in count_map:
            max_length = max(max_length, i - count_map[count])
        else:
            count_map[count] = i
    return max_length",97
36934273201,can_partition,"def can_partition(nums):
    total_sum = sum(nums)
    if total_sum % 2 != 0:
        return False
    target = total_sum // 2
    dp = [False] * (target + 1)
    dp[0] = True

    for num in nums:
        for i in range(target, num - 1, -1):
            dp[i] = dp[i] or dp[i - num]

    return dp[target]",97
13107389802,uniquePaths,"def uniquePaths(m, n):
    dp = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    return dp[m - 1][n - 1]",97
46352362208,mergeIntervals,"def mergeIntervals(intervals):
    if not intervals:
        return []
    intervals.sort()
    merged = [intervals[0]]

    for i in range(1, len(intervals)):
        start = intervals[i][0]
        end = intervals[i][1]
        if start <= merged[-1][-1]:
            merged[-1][-1] = max(merged[-1][-1], end)
        else:
            merged.append(intervals[i])
    return merged",97
15906638238,max_substring_length,"def max_substring_length(s: str) -> int:
    if not s:
        return 0

    start = 0
    max_length = 0
    char_map = {}

    for end, char in enumerate(s):
        if char in char_map:
            start = max(start, char_map[char] + 1)
        char_map[char] = end
        max_length = max(max_length, end - start + 1)

    return max_length",97
11190049223,check_prime,"def check_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True",97
72852712664,find_missing_positive,"def find_missing_positive(arr):
    n = len(arr)
    for i in range(n):
        while 1 <= arr[i] <= n and arr[i] != arr[arr[i] - 1]:
            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]
    for i in range(n):
        if arr[i] != i + 1:
            return i + 1
    return n + 1",97
17177203124,get_Longest_Substring,"def get_Longest_Substring(s):
    sub_str = ''
    max_str = ''
    for i in s:
        if i not in sub_str:
            sub_str += i
        else:
            if len(sub_str) > len(max_str):
                max_str = sub_str
            sub_str = sub_str[sub_str.index(i)+1:] + i
    if len(sub_str) > len(max_str):
        max_str = sub_str
    return max_str",97
27551285275,is_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True",97
24543285989,prime_list,"def prime_list(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    primes = []
    num = 2
    while len(primes) < n:
        if is_prime(num):
            primes.append(num)
        num += 1
    return primes",97
10786949275,is_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True",97
27857095914,jump,"def jump(nums):
    end = len(nums) - 1
    farthest = 0
    jumps = 0
    i = 0
    while i < end:
        jumps += 1
        cur_farthest = farthest
        while i <= cur_farthest:
            farthest = max(farthest, i + nums[i])
            if farthest >= end:
                return jumps
            i += 1
    return jumps",97
40656913491,minimum_coins,"import sys

def minimum_coins(coins, amount):
    dp = [sys.maxsize] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != sys.maxsize else -1",97
6249843668,get_lucas,"def get_lucas(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        lucas_prev = 2
        lucas_curr = 1
        for _ in range(2, n + 1):
            lucas_next = lucas_prev + lucas_curr
            lucas_prev, lucas_curr = lucas_curr, lucas_next
        return lucas_curr",97
16171699938,is_perm_palindrome,"def is_perm_palindrome(str1):
    str1 = str1.replace(' ','').lower()
    d = {}
    for i in str1:
        if i in d:
            d[i] += 1
        else:
            d[i] = 1
    found_odd = False
    for k,v in d.items():
        if v%2 != 0:
            if found_odd:
                return False
            found_odd = True
    return True",97
34370328901,find_longest_consecutive,"def find_longest_consecutive(nums):
    nums = set(nums)
    longest_streak = 0

    for num in nums:
        if num - 1 not in nums:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums:
                current_num += 1
                current_streak += 1

            longest_streak = max(longest_streak, current_streak)

    return longest_streak",97
72967206856,is_bipartite_dfs,"from typing import List

def is_bipartite_dfs(graph: List[List[int]]) -> bool:
    color = {}
    
    def dfs(node, c=0):
        if node in color:
            return color[node] == c
        color[node] = c
        return all(dfs(nei, c ^ 1) for nei in graph[node])
        
    return all(dfs(node) for node in range(len(graph)) if node not in color)",97
18698604162,find_Second_Largest,"def find_Second_Largest(numbers):
    if len(numbers) < 2:
        return None
    first, second = (numbers[0], numbers[1]) if numbers[0] > numbers[1] else (numbers[1], numbers[0])
    for number in numbers[2:]:
        if number > first:
            second = first
            first = number
        elif number > second and number != first:
            second = number
    return second",97
9017904954,smallest_divisor_perfect_square,"def smallest_divisor_perfect_square(N):
    for i in range(2, int(N**0.5) + 1):
        if N % (i*i) == 0:
            return i*i
    return N

print(smallest_divisor_perfect_square(100)) # 4
print(smallest_divisor_perfect_square(40)) # 4
print(smallest_divisor_perfect_square(60)) # 4",97
41853312432,max_water_container,"def max_water_container(height):
    max_area = 0
    left, right = 0, len(height) - 1
    while left < right:
        width = right - left
        if height[left] < height[right]:
            max_area = max(max_area, height[left] * width)
            left += 1
        else:
            max_area = max(max_area, height[right] * width)
            right -= 1
    return max_area",97
23918216794,intersect,"def intersect(list1, list2):
    i, j = 0, 0
    result = []
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            i += 1
        elif list1[i] > list2[j]:
            j += 1
        else:
            result.append(list1[i])
            i += 1
            j += 1
    return result",97
36523639157,find_first_non_repeating_char,"from collections import OrderedDict

def find_first_non_repeating_char(s: str) -> str:
    char_order = OrderedDict()
    char_count = {}
    
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
            char_order[char] = None
    
    for char in char_order:
        if char_count[char] == 1:
            return char
    return ""-""",97
10896326756,compress_string,"def compress_string(s):
    if not s:
        return """"
    compressed = """"
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            count += 1
        else:
            compressed += s[i-1] + str(count)
            count = 1
    compressed += s[-1] + str(count)
    return compressed if len(compressed) < len(s) else s",97
41315072776,reverse_int,"def reverse_int(x):
    sign = -1 if x < 0 else 1
    x *= sign
    
    reversed_x = 0
    while x:
        reversed_x = reversed_x * 10 + x % 10
        x //= 10

    reversed_x *= sign

    if reversed_x < -2**31 or reversed_x > 2**31 - 1:
        return 0
    return reversed_x",97
42424456169,max_product_subarray,"def max_product_subarray(nums):
    if not nums:
        return 0
    max_val = min_val = result = nums[0]
    for i in range(1,len(nums)):
        temp = max_val
        max_val = max(nums[i], max_val * nums[i], min_val * nums[i])
        min_val = min(nums[i], temp * nums[i], min_val * nums[i])
        result = max(result, max_val)
    return result",97
23392443967,last_position,"def last_position(arr, x):
    left, right = 0, len(arr) - 1
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == x:
            result = mid
            left = mid + 1
        elif arr[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    return result",97
22356527170,longest_subarray,"def longest_subarray(nums):
    count = 0
    max_length = 0
    sum_count = {0: -1}
    for i in range(len(nums)):
        if nums[i] == 0:
            count -= 1
        else:
            count += 1
        if count in sum_count:
            max_length = max(max_length, i - sum_count[count])
        else:
            sum_count[count] = i
    return max_length",97
41906599011,lengthOfLongestSubstring,"def lengthOfLongestSubstring(s):
    n = len(s)
    ans = 0
    i = 0
    j = 0
    d = {}
    while i < n and j < n:
        if s[j] not in d:
            d[s[j]] = 1
            j += 1
            ans = max(ans, j-i)
        else:
            del d[s[i]]
            i += 1
    return ans",97
41129216543,topKFrequent,"from collections import defaultdict
import heapq

def topKFrequent(nums, k):
    cnt = defaultdict(int)
    
    for n in nums:
        cnt[n] += 1
            
    min_heap = []
    
    for n, freq in cnt.items():
        min_heap.append((-freq, n))
    
    heapq.heapify(min_heap)
    res = []
    for i in range(k):
        res.append(heapq.heappop(min_heap)[1])
            
    return res",97
29100071806,intersect,"def intersect(list1, list2):
    result = []
    i, j = 0, 0
    while i < len(list1) and j < len(list2):
        if list1[i] == list2[j]:
            result.append(list1[i])
            i += 1
            j += 1
        elif list1[i] < list2[j]:
            i += 1
        else:
            j += 1
    return result",97
37236097230,reshape_list,"def reshape_list(mat, r, c):
    row, col = len(mat), len(mat[0])
    if r * c != row * col:
        return mat

    k = 0
    output = [[0 for _ in range(c)] for _ in range(r)]
    for i in range(row):
        for j in range(col):
            output[k//c][k%c] = mat[i][j]
            k += 1
    return output",97
36299095756,check_anagram,"def check_anagram(str1, str2):
    # Check if both strings have the same length
    if len(str1) != len(str2):
        return False

    # Convert strings to lists for easier manipulation
    str1_list = list(str1)
    str2_list = list(str2)

    # Sort both lists
    str1_list.sort()
    str2_list.sort()

    # Compare sorted lists
    return str1_list == str2_list",97
37881769448,coin_change,"def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        dp[i] = min([dp[i - c] if i - c >= 0 else float('inf') for c in coins]) + 1
    return dp[amount] if dp[amount] != float('inf') else -1",97
12120976763,length_of_longest_substring,"def length_of_longest_substring(s):
    if not s:
        return 0
    char_map = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",97
5219204108,shortest_path_bfs,"def shortest_path_bfs(graph, start, end):
    queue = [[start]]
    visited = set()
    
    while queue:
        path = queue.pop(0)
        node = path[-1]

        if node not in visited:
            if node == end:
                return path

            visited.add(node)
            for neighbor in graph.get(node, []):
                new_path = list(path)
                new_path.append(neighbor)
                queue.append(new_path)
    return None",97
2475140313,min_square_sum,"import math

def min_square_sum(n):
    squares = [i**2 for i in range(1, math.isqrt(n) + 1)]
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    for s in squares:
        for j in range(s, n + 1):
            dp[j] = min(dp[j], 1 + dp[j - s])
    return dp[-1]",97
31240883348,most_frequent_elements,"def most_frequent_elements(arr):
    groupby = list(set(arr))
    result = dict()
    for item in groupby:
        result[item] = arr.count(item)

    answer = []
    
    for v in result.values():
        if v != 1:
            answer.append(v)
    
    if not len(answer):
        return [-1]

    max_freq = max(answer)
    return [k for k, v in result.items() if v == max_freq]",97
34031163387,can_partition,"def can_partition(nums):
    total_sum = sum(nums)
    if total_sum % 2 != 0:
        return False
    target = total_sum // 2
    dp = [False] * (target + 1)
    dp[0] = True
    for num in nums:
        for i in range(target, num - 1, -1):
            dp[i] = dp[i] or dp[i - num]
    return dp[target]",97
34279707089,sieve_of_eratosthenes,"def sieve_of_eratosthenes(n):
    primes = [True for _ in range(n+1)]
    p = 2
    while (p * p <= n):
        if primes[p] == True:
            for i in range(p * p, n+1, p):
                primes[i] = False
        p += 1
    prime_numbers = [p for p in range(2, n) if primes[p]]
    return prime_numbers",97
2521927657,confusing_number,"def confusing_number(n):
    k = n
    def m(x):
        t = [0,1,-1,-1,-1,-1,9,-1,8,6]
        return t[x]
    n = [m(int(i)) for i in list(str(n))][::-1]
    for i in n:
        if i == -1:
            return False
    return int(''.join([str(i) for i in n])) != k",97
25575731447,duplicate_count,"def duplicate_count(text):
    text = text.lower()
    seen = set()
    duplicates = set()
    for char in text:
        if char in seen:
            duplicates.add(char)
        seen.add(char)
    return len(duplicates)

assert duplicate_count(""abcde"") == 0
assert duplicate_count(""aabbcde"") == 2
assert duplicate_count(""aabBcde"") == 2
assert duplicate_count(""indivisibility"") == 1",97
24026370,intersection,"def intersection(arr1, arr2):
    i, j = 0, 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] == arr2[j]:
            result.append(arr1[i])
            i += 1
            j += 1
        elif arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return result",97
32069720999,can_permute_palindrome,"from collections import defaultdict

def can_permute_palindrome(s: str) -> bool:
    if not s:
        return False

    strCntMap = defaultdict(int)

    for ch in s:
        strCntMap[ch] += 1

    oddCnt = 0
    for key, value in strCntMap.items():
        if value % 2 != 0:
            oddCnt += 1

    return False if oddCnt > 1 else True",97
70452303892,is_valid_password,"import re

def is_valid_password(password):
    if len(password) < 8 or len(password) > 20:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%&]"", password):
        return False
    return True",97
19765445271,smallest_missing_positive,"def smallest_missing_positive(arr):
    n = len(arr)
    for i in range(n):
        while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]:
            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]
    for i in range(n):
        if arr[i] != i + 1:
            return i + 1
    return n + 1",97
40123925310,is_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True",97
23776384671,longest_valid_subsequence,"def longest_valid_subsequence(s: str, k: int) -> int:
    dp = [1] * len(s)
    max_len = 1
    for i in range(1, len(s)):
        for j in range(i):
            if abs(ord(s[i]) - ord(s[j])) <= k:
                dp[i] = max(dp[i], dp[j] + 1)
        max_len = max(max_len, dp[i])
    return max_len",97
41699161798,is_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True",97
27153716310,min_coins,"import sys

def min_coins(coins, amount):
    dp = [sys.maxsize] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != sys.maxsize else -1",97
28934915,prime_factorization,"def prime_factorization(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            count = 1
            while n % i == 0:
                n //= i
                count += 1
            factors.append((i, count))
    if n > 1:
        factors.append((n, 1))
    return factors",97
3075883713,is_balanced,"def is_balanced(s: str) -> bool:
    if len(s) % 2 == 1:
        return False
    stack = []
    pairs = {
        ""]"": ""["",
        ""}"": ""{"",
        "")"": ""(""
    }
    for ch in s:
        if ch in pairs:
            if not stack or stack[-1] != pairs[ch]:
                return False
            stack.pop()
        else:
            stack.append(ch)

    return not stack",97
24848779835,check_armstrong,"def check_armstrong(num):
    # convert number to string to get the length (number of digits)
    num_str = str(num)
    num_len = len(num_str)
    
    # calculate the sum of each digit raised to the power of the length of the number
    sum_of_digits = sum([int(digit) ** num_len for digit in num_str])
    
    # check if the sum is equal to the original number
    return sum_of_digits == num",97
25900184423,min_subset_sum_diff,"def min_subset_sum_diff(arr):
    total_sum = sum(arr)
    n = len(arr)
    half_sum = total_sum // 2
    dp = [0] * (half_sum + 1)
    for num in arr:
        for i in range(half_sum, num - 1, -1):
            dp[i] = max(dp[i], dp[i - num] + num)
    return total_sum - 2 * dp[half_sum]",97
5178932173,intersect,"def intersect(list1, list2):
    i, j = 0, 0
    result = []
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            i += 1
        elif list1[i] > list2[j]:
            j += 1
        else:
            result.append(list1[i])
            i += 1
            j += 1
    return result",97
33181905801,kth_largest,"def kth_largest(nums, k):
    nums.sort()
    return nums[-k]

assert kth_largest([3,2,1,5,6,4], 2) == 5
assert kth_largest([3,2,3,1,2,4,5,5,6], 4) == 4
assert kth_largest([1,2,3,4,5], 1) == 5",97
32530691699,smallest_missing_positive,"def smallest_missing_positive(arr):
    n = len(arr)
    for i in range(n):
        while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]:
            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]

    for i in range(n):
        if arr[i] != i + 1:
            return i + 1
    return n + 1",97
16358296743,maxSlidingWindow,"from collections import deque

def maxSlidingWindow(nums, k):
    q = deque()
    result = []
    for i in range(len(nums)):
        while q and q[0][1] <= i-k:
            q.popleft()
        while q and q[-1][0] < nums[i]:
            q.pop()
        q.append((nums[i], i))
        if i >= k-1:
            result.append(q[0][0])
    return result",97
39658171340,reverse_digits,"def reverse_digits(s):
    i = 0
    j = len(s) - 1
    s = list(s)
    while i < j:
        if not s[i].isdigit():
            i += 1
        elif not s[j].isdigit():
            j -= 1
        else:
            s[i], s[j] = s[j], s[i]
            i += 1
            j -= 1
    return ''.join(s)",96
35618371614,spiral_Sum,"def spiral_Sum(matrix):
    if not matrix:
        return 0
    result = 0
    while matrix:
        result += sum(matrix.pop(0))
        if matrix and matrix[0]:
            for row in matrix:
                result += row.pop()
        if matrix:
            result += sum(matrix.pop()[::-1])
        if matrix and matrix[0]:
            for row in matrix[::-1]:
                result += row.pop(0)
    return result",96
38154554814,is_subsequence,"class MyString(str):
    def my_index(self, char):
        if char in self:
            return self.index(char)
        else:
            return -1


def is_subsequence(s: str, t: str) -> bool:
    t = MyString(t)
    for char in s:
        idx = t.my_index(char)
        if idx < 0:
            return False
        else:
            t = MyString(t[idx+1:])
    return True",96
32423038591,subarray_sum,"def subarray_sum(nums, k):
    count = 0
    sum = 0
    hash_map = {0: 1}
    for i in range(len(nums)):
        sum += nums[i]
        if sum - k in hash_map:
            count += hash_map[sum - k]
        if sum in hash_map:
            hash_map[sum] += 1
        else:
            hash_map[sum] = 1
    return count",96
25538525324,find_second_highest,"def find_second_highest(lst):
  if len(lst) < 2:
    return None
  first, second = (lst[0], lst[1]) if lst[0] > lst[1] else (lst[1], lst[0])
  for num in lst[2:]:
    if num > first:
      second = first
      first = num
    elif num > second and num != first:
      second = num
  return second",96
1908224293,password_validity,"import re

def password_validity(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%^&*(),.?\"":{}|<>]"", password):
        return False
    return True",96
37109080309,is_permutation_palindrome,"def is_permutation_palindrome(s):
    s = s.lower().replace("" "", """")
    d = dict()
    for c in s:
        if c in d:
            d[c] += 1
        else:
            d[c] = 1
    found_odd = False
    for k, v in d.items():
        if v%2 != 0:
            if found_odd:
                return False
            found_odd = True
    return True",96
33891838252,sum_of_primes,"def sum_of_primes(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    prime_sum = 0
    for i in range(2, n + 1):
        if is_prime(i):
            prime_sum += i
    return prime_sum",96
17427666777,smallest_divisor,"def smallest_divisor(num: int, greater_than: int) -> int:
    for i in range(greater_than + 1, num + 1):
        if num % i == 0:
            return i

# Test Cases
assert smallest_divisor(120, 5) == 6
assert smallest_divisor(100, 2) == 4
assert smallest_divisor(49, 6) == 7",96
26005983172,smallest_missing,"def smallest_missing(arr):
    n = len(arr)
    for i in range(n):
        while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]:
            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]
    for i in range(n):
        if arr[i] != i + 1:
            return i + 1
    return n + 1",96
2289851159,find_permutations,"def find_permutations(nums):
    def permute(nums, path, res):
        if not nums:
            res.append(path)
            return
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            permute(nums[:i] + nums[i+1:], path + [nums[i]], res)
    nums.sort()
    res = []
    permute(nums, [], res)
    return res",96
2804576921,intersect_sorted_arrays,"def intersect_sorted_arrays(arr1, arr2):
    i = j = 0
    result = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            i += 1
        elif arr1[i] > arr2[j]:
            j += 1
        else:
            result.append(arr1[i])
            i += 1
            j += 1
    return result",96
25042342326,merge_lists,"def merge_lists(list1, list2):
    res = []
    i, j = 0, 0
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            res.append(list1[i])
            i += 1
        else:
            res.append(list2[j])
            j += 1
    res.extend(list1[i:])
    res.extend(list2[j:])
    return res",96
72916118104,coin_change_combinations,"def coin_change_combinations(amount: int, coins) -> int:
    MOD = 1000000007
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = (dp[x] + dp[x - coin]) % MOD
    return dp[amount] % MOD",96
2020675438,is_valid_password,"import re

def is_valid_password(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%^&*(),.?\"":{}|<>]"", password):
        return False
    return True",96
13364764017,first,"def first(arr,x,n):
    low = 0
    high = n - 1
    res = -1  
    while (low <= high):
        mid = (low + high) // 2 
        if arr[mid] > x:
            high = mid - 1
        elif arr[mid] < x:
            low = mid + 1
        else:
            res = mid
            high = mid - 1
    return res",96
6587830793,length_of_longest_subzero,"def length_of_longest_subzero(arr):
    max_length = 0
    sum_to_index = {0: -1}
    current_sum = 0
    for i, num in enumerate(arr):
        current_sum += num
        if current_sum in sum_to_index:
            length = i - sum_to_index[current_sum]
            max_length = max(max_length, length)
        else:
            sum_to_index[current_sum] = i
    return max_length",96
329757163,most_frequent_character,"def most_frequent_character(str1):
  char_frequency = {}
  for c in str1:
    if c in char_frequency:
      char_frequency[c] += 1
    else:
      char_frequency[c] = 1
  
  max_count = 0
  max_char = None
  for c in char_frequency:
    if char_frequency[c] > max_count:
      max_count = char_frequency[c]
      max_char = c
  
  return max_char",96
20137218242,find_maximum_xor,"def find_maximum_xor(nums):
    max_xor = 0
    mask = 0
    for i in range(31, -1, -1):
        mask |= (1 << i)
        prefixes = set([num & mask for num in nums])
        temp_max = max_xor | (1 << i)
        for prefix in prefixes:
            if prefix ^ temp_max in prefixes:
                max_xor = temp_max
                break
    return max_xor",96
35831200005,subarray_divisible_by_k,"def subarray_divisible_by_k(nums, k):
    count = 0
    sum = 0
    hash_map = {0: 1}
    for i in range(len(nums)):
        sum += nums[i]
        if sum % k in hash_map:
            count += hash_map[sum % k]
            hash_map[sum % k] += 1
        else:
            hash_map[sum % k] = 1
    return count",96
23393282195,zero_sum_triplet,"def zero_sum_triplet(arr):
    arr.sort()
    for i in range(len(arr) - 2):
        left, right = i + 1, len(arr) - 1
        while left < right:
            total = arr[i] + arr[left] + arr[right]
            if total == 0:
                return True
            elif total < 0:
                left += 1
            else:
                right -= 1
    return False",96
74267622390,threeSum,"def threeSum(nums, target):
    nums.sort()
    n = len(nums)
    for i in range(n):
        left, right = i + 1, n - 1
        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]
            if current_sum == target:
                return True
            elif current_sum < target:
                left += 1
            else:
                right -= 1
    return False",96
1498530656,longest_subarray,"def longest_subarray(arr):
    max_len = 0
    count = 0
    sum_map = {0: -1}
    for i, num in enumerate(arr):
        if num == 0:
            count -= 1
        else:
            count += 1
        if count in sum_map:
            max_len = max(max_len, i - sum_map[count])
        else:
            sum_map[count] = i
    return max_len",96
71333944852,get_gcd,"def find_gcd(num1, num2):
    while(num2):
        num1, num2 = num2, num1 % num2
    return num1

def get_gcd(l):
  num1 = l[0]
  num2 = l[1]
  gcd = find_gcd(num1, num2)
  for i in range(2, len(l)):
    gcd = find_gcd(gcd, l[i])
  return gcd",96
21786014777,find_primes,"def find_primes(n):
    if n < 2:
        return []
    primes = []
    is_prime = [True] * (n+1)
    is_prime[0] = is_prime[1] = False
    for i in range(2, n+1):
        if is_prime[i]:
            primes.append(i)
            for j in range(i*i, n+1, i):
                is_prime[j] = False
    return primes",96
2331572524,first,"def first(arr,x,n):
    low = 0
    high = n - 1
    res = -1
    while (low <= high):
        mid = (low + high) // 2
        if arr[mid] > x:
            high = mid - 1
        elif arr[mid] < x:
            low = mid + 1
        else:
            res = mid
            high = mid - 1
    return res",96
30284772064,can_be_equal,"def can_be_equal(target, arr):
    cnt1 = [0 for i in range(1001)]
    cnt2 = [0 for i in range(1001)]
    for i in target:
        cnt1[i] += 1
    for i in arr:
        cnt2[i] += 1

    for i, j in zip(cnt1, cnt2):
        if i != j:
            return False

    return True",96
38282526769,find_valid_triangles,"def find_valid_triangles(sticks):
    sticks.sort()
    count = 0
    for i in range(len(sticks) - 2):
        k = i + 2
        for j in range(i + 1, len(sticks) - 1):
            while k < len(sticks) and sticks[i] + sticks[j] > sticks[k]:
                k += 1
            count += k - j - 1
    return count",96
40631276056,findMaxLength,"def findMaxLength(nums):
    count = 0
    max_length = 0
    count_dict = {0: -1}
    for i in range(len(nums)):
        if nums[i] == 0:
            count -= 1
        else:
            count += 1
        if count in count_dict:
            max_length = max(max_length, i - count_dict[count])
        else:
            count_dict[count] = i
    return max_length",96
73602158659,len_longest_substring,"def len_longest_substring(s):
    if not s:
        return 0

    char_map = {}
    left = 0
    max_length = 0

    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)

        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)

    return max_length",96
41838510983,find_subarrays,"def find_subarrays(arr, k):
    count = 0
    sum = 0
    sum_dict = {0: 1}
    for i in range(len(arr)):
        sum += arr[i]
        if sum - k in sum_dict:
            count += sum_dict[sum - k]
        if sum in sum_dict:
            sum_dict[sum] += 1
        else:
            sum_dict[sum] = 1
    return count",96
70896872823,leaf_nodes,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def leaf_nodes(root):
    result = []

    def dfs(current_node):
        if current_node:
            if not current_node.left and not current_node.right:
                result.append(current_node.val)
            dfs(current_node.left)
            dfs(current_node.right)

    dfs(root)
    return result",96
37769322608,catalan,"def catalan(n):
    if n <= 1:
        return 1
    catalan = [0 for i in range(n + 1)]
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]
    return catalan[n]",96
7090214428,min_subarray_length,"def min_subarray_length(target, nums):
    min_length = float('inf')
    current_sum = 0
    
    left = 0
    for right in range(len(nums)):
        current_sum += nums[right]
        
        while current_sum >= target:
            min_length = min(min_length, right - left + 1)
            current_sum -= nums[left]
            left += 1
    
    return 0 if min_length == float('inf') else min_length",96
75136374985,longest_subarray_with_zero_sum,"def longest_subarray_with_zero_sum(arr):
    sum_hash = dict()
    sum_hash[0] = -1
    sum_val = 0
    max_length = 0
    for i in range(len(arr)):
        sum_val += arr[i]
        if sum_val not in sum_hash:
            sum_hash[sum_val] = i
        else:
            max_length = max(max_length, i - sum_hash[sum_val])
    return max_length",96
32032159248,count_common_characters,"from collections import Counter

def count_common_characters(s1, s2):
    """"""
    :type s1: str
    :type s2: str
    :rtype: int
    """"""
    counter1 = Counter(s1)
    counter2 = Counter(s2)
    common_characters = 0
    for char in set(s1):
        if char in counter2:
            common_characters += min(counter1[char], counter2[char])
    return common_characters",96
18204480427,is_valid,"def is_valid(s):
    """"""
    Checks if a string of parentheses is valid.

    :type s: str
    :rtype: bool
    """"""
    brackets = {')': '(', '}': '{', ']': '['}
    stack = []

    for character in s:
        if stack and character in brackets:
            if brackets[character] != stack.pop():
                return False
        else:
            stack.append(character)

    return len(stack) == 0",96
2309289584,max_ones,"def max_ones(nums):
    left = 0
    max_length = 0
    zero_found = False
    for right in range(len(nums)):
        if nums[right] == 0:
            if zero_found:
                while nums[left] != 0:
                    left += 1
                left += 1
            else:
                zero_found = True
        max_length = max(max_length, right - left + 1)
    return max_length",96
23756509206,find_largest_palindrome,"def find_largest_palindrome(start, end):
    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    largest = 0
    for i in range(end, start - 1, -1):
        for j in range(i, start - 1, -1):
            product = i * j
            if product <= largest:
                break
            if is_palindrome(product):
                largest = product
    return largest",96
33782769976,longest_subarray,"def longest_subarray(nums):
    zero_count = 0
    max_len = 0
    left = 0

    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1

        while zero_count > 1:
            if nums[left] == 0:
                zero_count -= 1
            left += 1

        max_len = max(max_len, right - left)

    return max_len",96
4280760996,subarraySum,"def subarraySum(nums, k):
    count, current_sum = 0, 0
    sum_dict = {0: 1}
    for num in nums:
        current_sum += num
        if current_sum - k in sum_dict:
            count += sum_dict[current_sum - k]
        if current_sum in sum_dict:
            sum_dict[current_sum] += 1
        else:
            sum_dict[current_sum] = 1
    return count",96
36880641057,count_unique_bst,"def count_unique_bst(n):
    if n == 0 or n == 1:
        return 1

    dp = [0 for _ in range(n + 1)]
    dp[0], dp[1] = 1, 1

    for node in range(2, n + 1):
        for root in range(node):
            dp[node] += dp[root] * dp[node - root - 1]

    return dp[n]",96
24060777791,remove_odd_numbers,"def remove_odd_numbers(nums):
    L = 0                               # Left pointer starts at 0
    for R in range(0, len(nums)):           
        if nums[R] % 2 == 0:            # If right pointer number is even
            nums[L] = nums[R]           # set left pointer to the right number 
            L += 1                      # move left pointer up
    return nums[:L]                     # return list up to L",96
6991131078,is_narcissistic,"def is_narcissistic(n):
    # Convert the number to string to easily iterate over digits
    num_str = str(n)
    num_len = len(num_str)
    # Calculate the sum of the digits each raised to the power of the number of digits
    sum_of_digits = sum([int(digit) ** num_len for digit in num_str])
    # Check if the calculated sum is equal to the original number
    return sum_of_digits == n",96
7435884546,unique_BSTs,"def unique_BSTs(n):
    if n == 0 or n == 1:
        return 1
    dp = [0 for _ in range(n + 1)]
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",96
72441845232,min_cost_paint,"def min_cost_paint(costs):
    for i in range(1, len(costs)):
        costs[i][0] += min(costs[i-1][1], costs[i-1][2])
        costs[i][1] += min(costs[i-1][0], costs[i-1][2])
        costs[i][2] += min(costs[i-1][0], costs[i-1][1])
    return min(costs[-1])",96
10741493619,find_second_largest,"def find_second_largest(numbers):
    if len(numbers) < 2:
        return None
    largest = max(numbers[0], numbers[1])
    second_largest = min(numbers[0], numbers[1])
    for num in numbers[2:]:
        if num > largest:
            second_largest = largest
            largest = num
        elif num > second_largest and num != largest:
            second_largest = num
    return second_largest",96
29188508290,longestSubarray,"def longestSubarray(nums):
    left = 0
    zero_count = 0
    max_len = 0
    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1
        while zero_count > 1:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        max_len = max(max_len, right - left)
    return max_len",96
23795389280,intersect_sorted_lists,"def intersect_sorted_lists(list1, list2):
    i = j = 0
    intersection = []
    while i < len(list1) and j < len(list2):
        if list1[i] == list2[j]:
            intersection.append(list1[i])
            i += 1
            j += 1
        elif list1[i] < list2[j]:
            i += 1
        else:
            j += 1
    return intersection",96
13125907667,first,"def first(arr,x,n):
    low = 0
    high = n - 1
    res = -1  
    while (low <= high):
        mid = (low + high) // 2 
        if arr[mid] > x:
            high = mid - 1
        elif arr[mid] < x:
            low = mid + 1
        else:
            res = mid
            high = mid - 1
    return res",96
2291634171,sqrt,"def sqrt(x):
    if x == 0 or x == 1:
        return x

    start = 1
    end = x
    while start <= end:
        mid = (start + end) // 2

        if mid * mid == x:
            return mid

        if mid * mid < x:
            start = mid + 1
            result = mid
        else:
            end = mid - 1

    return result",96
11233559872,max_subarray_length,"def max_subarray_length(arr, target):
    max_length = 0
    current_sum = 0
    start_index = 0
    for end_index, value in enumerate(arr):
        current_sum += value
        while current_sum > target:
            current_sum -= arr[start_index]
            start_index += 1
        if current_sum == target:
            max_length = max(max_length, end_index - start_index + 1)
    return max_length",96
14026331357,find_max_recursively,"def find_max_recursively(arr, idx=0):
    # Base case: if the list is empty or we've reached the end of the list
    if idx == len(arr) - 1:
        return arr[idx]
    # Recursive case: compare the current element with the max of the rest of the list
    sub_max = find_max_recursively(arr, idx + 1)
    return arr[idx] if arr[idx] > sub_max else sub_max",96
22135010894,min_subarray_diff,"def min_subarray_diff(arr, k):
    if k == 1:
        return 0
    if k >= len(arr):
        return max(arr) - min(arr)
        
    arr.sort()
    min_diff = float('inf')
    for i in range(len(arr) - k + 1):
        diff = arr[i + k - 1] - arr[i]
        if diff < min_diff:
            min_diff = diff
    return min_diff",96
23069015490,sieve_primes,"def sieve_primes(n):
    sieve = [True] * (n+1)
    sieve[0:2] = [False, False]
    for current in range(2, int(n**0.5) + 1):
        if sieve[current]:
            sieve[current*2::current] = [False] * len(sieve[current*2::current])
    return [x for x in range(2, n+1) if sieve[x]]",96
30138216855,catalan,"def catalan(n):
    if n <= 1:
        return 1
    catalan = [0 for i in range(n + 1)]
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]
    return catalan[n]",96
10856889479,connect_sticks,"import heapq as hq

def connect_sticks(sticks):
    hq.heapify(sticks)
    total_cost = 0
    while len(sticks) > 1:
        first_stick = hq.heappop(sticks)
        second_stick = hq.heappop(sticks)
        cost = first_stick + second_stick
        total_cost += cost
        hq.heappush(sticks, cost)
    return total_cost",96
8800142396,shortest_distance_bfs,"from collections import deque

def shortest_distance_bfs(graph, start, end):
    queue = deque([(start, 0)])
    visited = set()
    
    while queue:
        current, distance = queue.popleft()
        if current == end:
            return distance
        if current not in visited:
            visited.add(current)
            for neighbor in graph[current]:
                if neighbor not in visited:
                    queue.append((neighbor, distance + 1))
    return -1",96
32977138915,is_permutation_of_palindrome,"def is_permutation_of_palindrome(s):
    s = s.lower()
    d = {}
    for c in s:
        if c in d:
            d[c] += 1
        else:
            d[c] = 1
    odd_count = 0
    for count in d.values():
        if count % 2 != 0:
            odd_count += 1
        if odd_count > 1:
            return False
    return True",96
10989634791,find_max_consecutive_zeros,"def find_max_consecutive_zeros(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0
    found_one = False
    for bit in binary:
        if bit == '1':
            if found_one and current_gap > max_gap:
                max_gap = current_gap
            current_gap = 0
            found_one = True
        elif found_one:
            current_gap += 1
    return max_gap",96
72565061314,is_valid_password,"import re

def is_valid_password(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%^&*(),.?\"":{}|<>]"", password):
        return False
    return True",96
11994060700,find_min_subarray_length,"def find_min_subarray_length(nums, target):
    left = 0
    current_sum = 0
    min_length = float('inf')
    for right in range(len(nums)):
        current_sum += nums[right]
        while current_sum >= target:
            min_length = min(min_length, right - left + 1)
            current_sum -= nums[left]
            left += 1
    return 0 if min_length == float('inf') else min_length",96
2485426011,largest_non_decreasing_number,"def largest_non_decreasing_number(N: int) -> int:
    res = list(str(N))
    length = len(res)

    for i in range(length - 1, 0, -1):
        if res[i] < res[i - 1]:
            res[i - 1] = str(int(res[i - 1]) - 1)
            res[i:] = ['9'] * (length - i)
    return int(''.join(res))",96
21373107263,missing_positive,"def missing_positive(arr):
    n = len(arr)
    for i in range(n):
        while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]:
            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]
    for i in range(n):
        if arr[i] != i + 1:
            return i + 1
    return n + 1",96
14866400427,second_largest,"def second_largest(lst):
    if len(lst) < 2:
        return None
    first, second = (lst[0], lst[1]) if lst[0] > lst[1] else (lst[1], lst[0])
    for num in lst[2:]:
        if num > first:
            second = first
            first = num
        elif num > second and num != first:
            second = num
    return second",95
11249552165,is_happy_number,"def is_happy_number(n: int) -> bool:
    def get_next(n):
        total_sum = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total_sum += digit ** 2
        return total_sum

    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)
    
    return n == 1",95
11428061449,count_subarrays_with_sum,"def count_subarrays_with_sum(arr, k):
    count = 0
    sum = 0
    hash_map = {0:1}
    for i in range(len(arr)):
        sum += arr[i]
        if sum-k in hash_map:
            count += hash_map[sum-k]
        if sum in hash_map:
            hash_map[sum] += 1
        else:
            hash_map[sum] = 1
    return count",95
17635519618,min_coins,"def min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",95
25258350564,fizz_buzz,"def fizz_buzz(n):
    result = []
    for i in range(1, n+1):
        if i % 3 == 0 and i % 5 == 0:
            result.append(""FizzBuzz"")
        elif i % 3 == 0:
            result.append(""Fizz"")
        elif i % 5 == 0:
            result.append(""Buzz"")
        else:
            result.append(str(i))
    return ' '.join(result)",95
25200424637,min_Meeting_Rooms,"import heapq

def min_Meeting_Rooms(intervals):
    """"""
        A python function to find the minimum number of meeting rooms required.
        Meetings are represented as lists of start and end times.
    """"""
    
    l = []
    for start, end in sorted(intervals):
        if l and l[0] <= start:
            heapq.heapreplace(l, end)
        else:
            heapq.heappush(l, end)
    return len(l)",95
21208225299,is_unique,"def is_unique(s):
    if len(s) > 26:  # There are only 26 letters in the English alphabet
        return False
    char_set = [False] * 26  # Create a list to store the occurrence of each character
    for char in s:
        index = ord(char) - ord('a')
        if char_set[index]:
            return False
        char_set[index] = True
    return True",95
27106117416,longest_unique_subarray,"def longest_unique_subarray(nums):
    left = 0
    right = 0
    max_length = 0
    unique_elements = set()
    
    while right < len(nums):
        if nums[right] not in unique_elements:
            unique_elements.add(nums[right])
            right += 1
            max_length = max(max_length, right - left)
        else:
            unique_elements.remove(nums[left])
            left += 1
            
    return max_length",95
72392198236,make_change,"def make_change(coins, amount):
    DP = [float('inf') for _ in range(amount+1)]
    DP[0] = 0
    for i in range(1, amount+1):
        for coin in coins:
            if i >= coin:
                DP[i] = min(DP[i], DP[i-coin] + 1)
    return DP[-1] if DP[-1] != float('inf') else -1",95
33345415670,longestConsecutiveSubsequence,"def longestConsecutiveSubsequence(s):
    if len(s) == 0:
        return 0
    max_len = 1
    current_len = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_len += 1
        else:
            max_len = max(max_len, current_len)
            current_len = 1
    return max(max_len, current_len)",95
28375747222,minMatrixOperations,"def minMatrixOperations(grid, x):
    flat_list = []
    for sublist in grid:
        for item in sublist:
            flat_list.append(item)
    flat_list.sort()
    median = flat_list[len(flat_list) // 2]
    operations = 0
    for num in flat_list:
        diff = abs(num - median)
        if diff % x != 0:
            return -1
        operations += diff // x
    return operations",95
42549485466,merge_intervals,"def merge_intervals(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]

    for current in intervals[1:]:
        last_merged = merged[-1]

        if current[0] <= last_merged[1]:
            merged[-1] = (last_merged[0], max(last_merged[1], current[1]))
        else:
            merged.append(current)

    return merged",95
32117385803,subarraySum,"def subarraySum(nums, k):
    count = 0
    sum_ = 0
    hash_map = {0:1}
    for n in nums:
        sum_ += n
        if sum_ - k in hash_map:
            count += hash_map[sum_ - k]
        if sum_ not in hash_map:
            hash_map[sum_] = 0
        hash_map[sum_] += 1
    return count",95
31735513980,has_dominant_number,"def has_dominant_number(A):
    n = len(A)
    L = [-1] + A
    count = 0
    pos = (n + 1) // 2
    candidate = L[pos]
    for i in range(1, n + 1):
        if (L[i] == candidate):
            count = count + 1
    if (2*count > n):
        return candidate
    return -1",95
37119310061,is_anagram_of_palindrome,"def is_anagram_of_palindrome(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_counts = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_counts += 1
        if odd_counts > 1:
            return False
    return True",95
74146296918,longest_subarray_with_sum_zero,"def longest_subarray_with_sum_zero(arr):
    max_length = 0
    sum = 0
    sum_dict = {}
    for i in range(len(arr)):
        sum += arr[i]
        if sum == 0:
            max_length = i + 1
        if sum in sum_dict:
            max_length = max(max_length, i - sum_dict[sum])
        else:
            sum_dict[sum] = i
    return max_length",95
38854137613,is_valid_anagram_palindrome,"def is_valid_anagram_palindrome(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_counts = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_counts += 1
        if odd_counts > 1:
            return False
    return True",95
5310353467,count_subsequence,"def count_subsequence(s, sub):
    count = 0
    i = 0
    while i < len(s):
        found = True
        for j in range(len(sub)):
            if i + j >= len(s) or s[i + j] != sub[j]:
                found = False
                break
        if found:
            count += 1
            i += len(sub)
        else:
            i += 1
    return count",95
71271676208,is_happy_number,"def is_happy_number(n: int) -> bool:
    def get_next(n):
        total_sum = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total_sum += digit ** 2
        return total_sum

    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)
        
    return n == 1",95
24755713088,longest_consecutive_zeros,"def longest_consecutive_zeros(n):
    binary = bin(n)[2:]
    max_gap, current_gap = 0, 0
    found_one = False

    for bit in binary:
        if bit == '1':
            if found_one:
                max_gap = max(max_gap, current_gap)
                current_gap = 0
            else:
                found_one = True
        elif found_one:
            current_gap += 1

    return max_gap",95
10790298325,are_sentences_similar,"def are_sentences_similar(sentence1, sentence2):
    words1 = sentence1.split()
    words2 = sentence2.split()
    if len(words1) != len(words2):
        return False
    mapping = {}
    for word1, word2 in zip(words1, words2):
        if word1 not in mapping:
            mapping[word1] = word2
        elif mapping[word1] != word2:
            return False
    return True",95
74737571444,minimum_coins,"def minimum_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",95
6645995704,count_bst,"def count_bst(n):
    catalan = [0 for _ in range(n+1)]
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n+1):
        catalan[i] = 0
        for j in range(0, i):
            catalan[i] += catalan[j]*catalan[i-j-1]
    return catalan[n]",95
17303802191,count_bst,"def count_bst(n):
    if n == 0 or n == 1:
        return 1
    dp = [0] * (n+1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n+1):
        for j in range(1, i+1):
            dp[i] += dp[j-1] * dp[i-j]
    return dp[n]",95
44052648264,largest_product,"def largest_product(arr):
    arr.sort()
    return max(arr[0] * arr[1], arr[-1] * arr[-2])

assert largest_product([1, 10, 5, 2]) == 50
assert largest_product([0, -1, -2, -3]) == 6
assert largest_product([100, 20, 10, 5]) == 2000",95
4007566671,nth_catalan,"def nth_catalan(n):
    if n <= 1:
        return 1

    catalan = [0] * (n + 1)
    catalan[0] = catalan[1] = 1

    for i in range(2, n + 1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i - j - 1]

    return catalan[n]",95
17480073971,minimum_coins,"def minimum_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",95
34531052676,canVisitAllRooms,"from collections import deque

def canVisitAllRooms(rooms):
    queue = deque([0])
    visited = set([0])
    unvisited = set([i for i in range(len(rooms))])
    while queue:
        curr = queue.popleft()
        unvisited.discard(curr)
        for key in rooms[curr]:
            if key not in visited:
                queue.append(key)
                visited.add(key)
    
    return True if not unvisited else False",95
39679797590,min_subarray_len,"def min_subarray_len(nums, target):
    left = 0
    current_sum = 0
    min_len = float('inf')
    for right in range(len(nums)):
        current_sum += nums[right]
        while current_sum >= target:
            min_len = min(min_len, right - left + 1)
            current_sum -= nums[left]
            left += 1
    return 0 if min_len == float('inf') else min_len",95
44565152055,word_segment,"from typing import List

def word_segment(s: str, wordDict: List[str]) -> bool:
        dp = [False]*(len(s) + 1)
        dp[0] = True # For empty string
        for index in range(1,len(s)+1):
            for word in wordDict:
                if dp[index - len(word)] and s[:index].endswith(word):
                    dp[index] = True
        return dp[-1]",95
27840772229,max_depth,"# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def max_depth(root):
    if root is None:
        return 0
    else:
        left_height = max_depth(root.left)
        right_height = max_depth(root.right)
        return max(left_height, right_height) + 1",95
74572408345,min_coins,"def min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",95
38902932691,catalan_number,"def catalan_number(n: int) -> int:
    if n <= 1:
        return 1
    catalan = [0] * (n+1)
    catalan[0] = catalan[1] = 1
    for i in range(2, n+1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]
    return catalan[n]",95
19795175696,find_mode,"def find_mode(numbers):
    if not numbers:
        return 0
    num_count = {}
    for num in numbers:
        if str(num) in num_count:
            num_count[str(num)] += 1
        else:
            num_count[str(num)] = 1
    max_count = max(num_count.values())
    modes = [int(num) for num, count in num_count.items() if count == max_count]
    return min(modes)",95
5649675608,find_common,"def find_common(list1, list2):
    i = j = 0
    result = []
    while i < len(list1) and j < len(list2):
        if list1[i] == list2[j]:
            result.append(list1[i])
            i += 1
            j += 1
        elif list1[i] < list2[j]:
            i += 1
        else:
            j += 1
    return result",95
1405521647,longest_equal_subarray,"def longest_equal_subarray(arr):
  max_len = 0
  current_len = 1
  if len(arr) == 0:
    return 0
  for i in range(1, len(arr)):
    if arr[i] == arr[i - 1]:
      current_len += 1
      max_len = max(max_len, current_len)
    else:
      current_len = 1
  return max(max_len, current_len)",95
19154582288,valid_mountain_array,"def valid_mountain_array(arr):
    if len(arr)<3:
        return False
    j=1
    while(j<len(arr) and arr[j]>arr[j-1]):
        j+=1
    if j==len(arr):
        return False
    while(j!=1 and j<len(arr) and arr[j]<arr[j-1]):
        j+=1
    if j==len(arr):
        return True
    else:
        return False",95
30919505124,isSubsequences,"from collections import deque


def isSubsequences(s: str, t: str) -> bool:
    hash_s = set(s)
    deque_s = deque(s)
    t = (elem for elem in t if elem in hash_s)
    for elem in t:
        if len(deque_s) == 0:
            return True
        if elem == deque_s[0]:
            deque_s.popleft()
    return len(deque_s) == 0",95
40143622587,find_extremes,"def find_extremes(s):
    array = []
    s_min = 99999999999
    s_max = -99999999999
    
    array.append(list(map(int, s.split())))
    
    for x in array[0]:
        s_min = min(s_min, x)
        s_max = max(s_max, x)
    return (str(s_min), str(s_max))",95
22592261800,findPairs,"from collections import Counter

def findPairs(nums, k):
    num_counts = Counter(nums)
    result = 0
    if k < 0:
        return 0
    elif k == 0:
        for num in num_counts:
            if num_counts[num] > 1:
                result += 1
    else:
        for num in num_counts:
            if num + k in num_counts:
                result += 1
    return result",95
73997585236,longest_consecutive_zeros,"def longest_consecutive_zeros(n):
    binary = bin(n)[2:]
    max_zeros = 0
    current_zeros = 0
    found_one = False

    for bit in binary:
        if bit == '1':
            if found_one and current_zeros > max_zeros:
                max_zeros = current_zeros
            current_zeros = 0
            found_one = True
        elif found_one:
            current_zeros += 1

    return max_zeros",95
44069894411,lengthOfLongestSubstring,"def lengthOfLongestSubstring(s: str) -> int:
    left = 0
    maxLength = 0
    usedChar = {}

    for right in range(len(s)):
        if s[right] in usedChar and left <= usedChar[s[right]]:
            left = usedChar[s[right]] + 1
        else:
            maxLength = max(maxLength, right - left + 1)

        usedChar[s[right]] = right

    return maxLength",95
73725807832,max_water_container,"def max_water_container(height):
    left, right = 0, len(height) - 1
    max_area = 0
    while left < right:
        width = right - left
        if height[left] < height[right]:
            max_area = max(max_area, width * height[left])
            left += 1
        else:
            max_area = max(max_area, width * height[right])
            right -= 1
    return max_area",95
39717378734,max_unique_substring,"def max_unique_substring(s):
    if not s:
        return 0

    max_len = 0
    start = 0
    char_index = {}

    for end in range(len(s)):
        if s[end] in char_index:
            start = max(start, char_index[s[end]] + 1)
        char_index[s[end]] = end
        max_len = max(max_len, end - start + 1)

    return max_len",95
17463522106,perfect_number,"def perfect_number(n):
    sum = 0
    for x in range(1, n):
        if n % x == 0:
            sum += x
    return sum == n

print(perfect_number(6)) # True
print(perfect_number(28)) # True
print(perfect_number(496)) # True
print(perfect_number(12)) # False
print(perfect_number(97)) # False",95
3473362324,next_prime,"def is_prime(n):
  if n <= 1 or (n % 2 == 0 and n > 2): 
    return False
  return all(n % i for i in range(3, int(n**0.5) + 1, 2))

def next_prime(n):
  prime_candidate = n + 1
  while True:
    if is_prime(prime_candidate):
      return prime_candidate
    prime_candidate += 1",95
11321065346,count_subarrays_with_sum,"def count_subarrays_with_sum(nums, target):
    count = 0
    sum = 0
    sum_count = {0: 1}
    for i in nums:
        sum += i
        if sum - target in sum_count:
            count += sum_count[sum - target]
        if sum in sum_count:
            sum_count[sum] += 1
        else:
            sum_count[sum] = 1
    return count",95
70912953491,nth_digit,"def nth_digit(n):
    if n < 10:
        return n
    length = 1
    counts = 9
    while n > length * counts:
        n -= length * counts
        length += 1
        counts *= 10
    num = 10 ** (length - 1) + (n - 1) // length
    return int(str(num)[(n - 1) % length])",95
15950644581,find_len,"def find_len(arr):
    max_len = 0
    curr_sum = 0
    sum_dict = {}
    for i in range(len(arr)):
        curr_sum += arr[i]
        if curr_sum == 0:
            max_len = i + 1
        if curr_sum in sum_dict:
            max_len = max(max_len, i - sum_dict[curr_sum])
        else:
            sum_dict[curr_sum] = i
    return max_len",95
32837088017,max_dungeons,"from itertools import permutations

def max_dungeons(k, dungeons):
    order = list(permutations(dungeons))
    answer = []
    hp = k
    for i in order:
        count = 0
        for j in range(len(i)):
            if hp >= i[j][0]:
                count += 1
                hp -= i[j][1]
            else:
                continue
        answer.append(count)
        hp = k
    return max(answer)",95
20694739232,max_length_zero_sum_subarray,"def max_length_zero_sum_subarray(arr):
    max_length = 0
    sum = 0
    sum_index = {}
    for i in range(len(arr)):
        sum += arr[i]
        if sum == 0:
            max_length = i + 1
        if sum in sum_index:
            max_length = max(max_length, i - sum_index[sum])
        else:
            sum_index[sum] = i
    return max_length",95
74894851518,Length_of_Longest_Substring,"def Length_of_Longest_Substring(s):
    if not s:
        return 0
    char_set = set()
    left = 0
    max_length = 0
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
    return max_length",94
74808337368,minCoins,"def minCoins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",94
13148195339,count_subarray_sum,"def count_subarray_sum(nums, target):
    count = 0
    sum_dict = {0: 1}
    total = 0
    for num in nums:
        total += num
        if total - target in sum_dict:
            count += sum_dict[total - target]
        if total in sum_dict:
            sum_dict[total] += 1
        else:
            sum_dict[total] = 1
    return count",94
13500689714,length_of_longest_subsequence,"def length_of_longest_subsequence(nums):
    nums_set = set(nums)
    longest = 0

    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_streak = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_streak += 1

            longest = max(longest, current_streak)

    return longest",94
30342831537,count_primes,"def count_primes(n):
    if n < 2:
        return 0
    primes = [True] * (n+1)
    primes[0] = primes[1] = False
    for i in range(2, int(n**0.5) + 1):
        if primes[i]:
            for j in range(i*i, n+1, i):
                primes[j] = False
    return sum(primes)",94
73776543637,smallest_subarray,"def smallest_subarray(arr, target):
    min_len = float('inf')
    current_sum = 0
    start = 0
    for end in range(len(arr)):
        current_sum += arr[end]
        while current_sum >= target:
            min_len = min(min_len, end - start + 1)
            current_sum -= arr[start]
            start += 1
    return min_len if min_len != float('inf') else 0",94
3473951434,count_subarray_sum,"def count_subarray_sum(arr, k):
    count = 0
    sum = 0
    sum_dict = {0:1}
    for i in range(len(arr)):
        sum += arr[i]
        if sum-k in sum_dict:
            count += sum_dict[sum-k]
        if sum in sum_dict:
            sum_dict[sum] += 1
        else:
            sum_dict[sum] = 1
    return count",94
18888395827,stone_game,"def stone_game(n):
    """"""
    Determines the winner of the stone game given the initial number of stones.
    
    :param n: Initial number of stones in the pile.
    :return: A string indicating which player wins.
    """"""
    # If the initial number of stones is divisible by 4, Player2 wins. Otherwise, Player1 wins.
    return ""Player2 wins"" if n % 4 == 0 else ""Player1 wins""",94
37379329160,find_subarrays_with_sum,"def find_subarrays_with_sum(nums, k):
    count = 0
    sum_list = [0]
    answer = 0

    for i in range(len(nums)):
        sum_list.append(sum_list[-1]+nums[i])

    for i in range(len(sum_list)):
        for j in range(i+1, len(sum_list)):
            if sum_list[j] - sum_list[i] == k:
                count += 1
    return count",94
12276590580,find_intersection,"def find_intersection(arr1,arr2):
    i = j = 0
    intersection = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            i += 1
        elif arr1[i] > arr2[j]:
            j += 1
        else:
            intersection.append(arr1[i])
            i += 1
            j += 1
    return intersection",94
4582633820,canSplit,"def canSplit(nums):
    total = sum(nums)
    if total % 2 != 0:
        return False
    
    target = total // 2
    dp = [False] * (target + 1)
    dp[0] = True

    for num in nums:
        for i in range(target, num - 1, -1):
            dp[i] = dp[i] or dp[i - num]

    return dp[target]",94
9625837577,merge_sorted_lists,"def merge_sorted_lists(list1, list2):
    result = []
    i = j = 0
    while i < len(list1) and j < len(list2):
        if list1[i] < list2[j]:
            result.append(list1[i])
            i += 1
        else:
            result.append(list2[j])
            j += 1
    result += list1[i:]
    result += list2[j:]
    return result",94
26845409085,generate_parentheses,"from typing import List

def generate_parentheses(n: int) -> List[str]:
    def backtrack(s='', left=0, right=0):
        if len(s) == 2 * n:
            res.append(s)
            return
        if left < n:
            backtrack(s+'(', left+1, right)
        if right < left:
            backtrack(s+')', left, right+1)

    res = []
    backtrack()
    return res",94
37694497634,longest_arithmetic_subsequence,"from collections import defaultdict

def longest_arithmetic_subsequence(arr, n):
    dp = defaultdict(int)
    result = 1
    for i in range(n):
        for j in range(i+1, n):
            dp[(j, arr[j]-arr[i])] = dp[(i, arr[j]-arr[i])] + 1
            result = max(result, dp[(j, arr[j]-arr[i])])
    return result + 1",94
20884866212,catalan,"def catalan(n):
    if n <= 1:
        return 1
    catalan = [0 for i in range(n+1)]
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n+1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]
    return catalan[n]",94
72056582006,count_prime,"def count_prime(start, end):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

    count = 0
    for num in range(start, end + 1):
        if is_prime(num):
            count += 1
    return count",94
1000233681,calculate_total_price,"def calculate_total_price(quantity, unit_price):
    total_price = quantity * unit_price
    if quantity >= 10 and quantity <= 19:
        total_price = total_price * 0.9
    elif quantity >= 20 and quantity <= 49:
        total_price = total_price * 0.8
    elif quantity >= 50:
        total_price = total_price * 0.7
    return total_price",94
25042447236,count_pattern,"def count_pattern(string, pattern):
    count = 0
    index = 0
    while index < len(string):
        found = True
        for i in range(len(pattern)):
            if index + i >= len(string) or string[index + i] != pattern[i]:
                found = False
                break
        if found:
            count += 1
            index += len(pattern)
        else:
            index += 1
    return count",94
40219840482,can_partition,"def can_partition(nums):
    total = sum(nums)
    if total % 2 != 0:
        return False

    target = total // 2
    dp = [False] * (target + 1)
    dp[0] = True

    for num in nums:
        for i in range(target, num - 1, -1):
            dp[i] = dp[i] or dp[i - num]

    return dp[target]",94
29080252121,transpose_matrix,"def transpose_matrix(matrix):
    rows = len(matrix)
    cols = len(matrix[0])

    # Create a new matrix with the dimensions swapped
    transposed = [[0 for _ in range(rows)] for _ in range(cols)]
    
    # Fill in the new matrix with the transposed values
    for i in range(rows):
        for j in range(cols):
            transposed[j][i] = matrix[i][j]
    
    return transposed",94
41343520716,subarray_Sum,"def subarray_Sum(nums, k):
    count = 0
    sum = 0
    hash_map = {0: 1}
    for num in nums:
        sum += num
        if sum - k in hash_map:
            count += hash_map[sum - k]
        if sum in hash_map:
            hash_map[sum] += 1
        else:
            hash_map[sum] = 1
    return count",94
41178767316,length_longest_substring,"def length_longest_substring(s):
    if not s:
        return 0
    seen = {}
    start = 0
    max_len = 0
    for i, char in enumerate(s):
        if char in seen and start <= seen[char]:
            start = seen[char] + 1
        else:
            max_len = max(max_len, i - start + 1)
        seen[char] = i
    return max_len",94
33441632815,next_prime,"def next_prime(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    prime = n
    found = False
    while not found:
        prime += 1
        if is_prime(prime):
            found = True
    return prime",94
17129141062,longest_palindrome_subsequence,"def longest_palindrome_subsequence(lst):
    def helper(start, end):
        if start >= end:
            return lst[start:end+1]
        if lst[start] == lst[end]:
            return lst[start:end+1]
        else:
            left = helper(start+1, end)
            right = helper(start, end-1)
            return left if len(left) > len(right) else right
    
    return helper(0, len(lst)-1)",94
38044063066,max_dungeons,"from itertools import permutations

def max_dungeons(k, dungeons):
    answer = 0
    len_dungeons = len(dungeons)
    for permu in permutations(dungeons, len_dungeons):
        temp_k = k
        count = 0
        for p in permu:
            if temp_k >= p[0]:
                temp_k -= p[1]
                count += 1
        answer = max(answer, count)
    return answer",94
15279331981,max_sum_of_pairs,"def max_sum_of_pairs(arr, k):
    n = len(arr)
    max_sum = float('-inf')

    for i in range(n//2):
        sm = 0
        for j in range(k):
            currIndex = i+j
            oppositeIndex = (currIndex+(n//2)) % n
            sm += arr[currIndex] + arr[oppositeIndex]
        max_sum = max(max_sum, sm)

    return max_sum",94
503311507,count_Lucky_Triples,"def is_divisible(a, b):
    return a % b == 0

def count_Lucky_Triples(arr):
    count = 0
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            for k in range(j+1, len(arr)):
                if is_divisible(arr[j], arr[i]) and is_divisible(arr[k], arr[j]):
                    count += 1
    return count",94
17619772854,longestConsecutive,"def longestConsecutive(nums):
    if not nums:
        return 0
    nums = set(nums)
    longest = 0
    for n in nums:
        if n - 1 not in nums:
            current = n
            currentStreak = 1
            while current + 1 in nums:
                current += 1
                currentStreak += 1
            longest = max(longest, currentStreak)
    return longest",94
24813998791,largestRectangleArea,"def largestRectangleArea(heights):
    stack = []
    max_area = 0
    heights.append(0)
    for i, h in enumerate(heights):
        while stack and heights[stack[-1]] > h:
            height = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, height * width)
        stack.append(i)
    return max_area",94
39659268860,min_meeting_rooms,"def min_meeting_rooms(intervals):
    starts = sorted([i[0] for i in intervals])
    ends = sorted([i[1] for i in intervals])
    i, j = 0, 0
    res = 0
    while i < len(starts):
        if ends[j] <= starts[i]:
            j += 1
        else:
            res += 1
        i += 1
    return res",94
22525520127,longest_substring_without_repeating_characters,"def longest_substring_without_repeating_characters(s: str) -> int:
    n = len(s)
    result = 0
    char_map = {}
    left = 0
    for right in range(n):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        result = max(result, right - left + 1)
    return result",94
21557831152,unique_pairs_sum,"def unique_pairs_sum(nums, target):
    res, pairs = set(), set()

    for num in nums:
        complement = target - num
        if num > complement:
            pair = (complement, num)
        else:
            pair = (num, complement)

        if pair not in pairs:
            pairs.add(pair) # 见了一次
        else: 
            res.add(pair) # 见了第二次

    return len(res)",94
19070954458,longest_sequence,"def longest_sequence(nums):
    num_set = set(nums)
    max_count = 0
    for num in num_set:
        if (num - 1) not in num_set:
            cur_num = num
            cur_count = 1
            while (cur_num + 1) in num_set:
                cur_num += 1
                cur_count += 1
            max_count = max(max_count, cur_count)
    return max_count",94
74815755326,length_of_LIS,"def length_of_LIS(nums):
    if len(nums) <= 1:
        return len(nums)
    
    hashmap = {}
    res = 1
    
    for i in range(len(nums)):
        hashmap[i] = 1
        for j in range(i):
            if nums[i] > nums[j]:
                hashmap[i] = max(hashmap[i], hashmap[j] + 1)
        res = max(res, hashmap[i])
    
    return res",94
22488431187,days_in_month,"def days_in_month(year, month):
    if month in [4, 6, 9, 11]:
        return 30
    elif month == 2:
        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
            return 29
        else:
            return 28
    else:
        return 31",94
27287431543,topKFrequent,"from collections import defaultdict
def topKFrequent(nums, k):
    numCount = defaultdict(int)
    for num in nums:
        numCount[num] += 1
    uniqueNums = set(nums)
    countNums = []
    for num in uniqueNums:
        countNums.append([numCount[num], num])
    countNums.sort(reverse = True)
    return [countNums[i][1] for i in range(k)]",94
16783111141,validate_credit_card,"def validate_credit_card(card_number):
  card_number = card_number[::-1]
  total = 0
  for i, digit in enumerate(card_number):
    if i % 2 == 1:
      doubled = int(digit) * 2
      if doubled > 9:
        doubled = doubled - 9
      total += doubled
    else:
      total += int(digit)
  
  return total % 10 == 0",94
16171826368,most_frequent_element,"def most_frequent_element(arr):
    frequency = {}
    for num in arr:
        if num in frequency:
            frequency[num] += 1
        else:
            frequency[num] = 1

    max_freq = 0
    result = None
    for num, freq in frequency.items():
        if freq > max_freq or (freq == max_freq and num < result):
            max_freq = freq
            result = num

    return result",94
72468797288,find_prime_numbers,"def find_prime_numbers(start, end):
  def is_prime(n):
    if n <= 1:
      return False
    for i in range(2, int(n**0.5) + 1):
      if n % i == 0:
        return False
    return True

  prime_numbers = []
  for num in range(start, end + 1):
    if is_prime(num):
      prime_numbers.append(num)
  return prime_numbers",94
1186130284,check_attendance,"def check_attendance(s: str) -> bool:
    aCount = 0
    freLate = 0
    for st in s:
        if st == ""A"":
            aCount += 1

        if st == ""L"":
            freLate += 1
            if freLate >= 3:
                return False
        else:
            freLate = 0

    return aCount < 2 and freLate < 3",94
74064464529,user_active_minutes,"from collections import defaultdict

def user_active_minutes(logs, max_uam):
    user_minutes = defaultdict(set)
    for log in logs:
        user_minutes[log[0]].add(log[1])
    
    uam_count = defaultdict(int)
    for minutes in user_minutes.values():
        uam_count[len(minutes)] += 1
    
    return {i: uam_count[i] for i in range(1, max_uam + 1)}",94
75280968366,is_valid_credit_card,"def is_valid_credit_card(card_number):
    card_number = card_number[::-1]
    total = 0
    for i in range(len(card_number)):
        if i % 2 == 0:
            total += int(card_number[i])
        else:
            doubled = int(card_number[i]) * 2
            total += doubled if doubled < 10 else (doubled - 9)
    return total % 10 == 0",94
20855505280,can_form_non_decreasing,"def can_form_non_decreasing(nums):
    modified = False
    for i in range(1, len(nums)):
        if nums[i] < nums[i - 1]:
            if modified:
                return False
            if i == 1 or nums[i] >= nums[i - 2]:
                nums[i - 1] = nums[i]
            else:
                nums[i] = nums[i - 1]
            modified = True
    return True",94
40525749513,longest_distinct_subarray,"def longest_distinct_subarray(nums):
    if not nums:
        return 0
    
    start = 0
    maxLen = 0
    seen = {}

    for i, num in enumerate(nums):
        if num in seen and start <= seen[num]:
            start = seen[num] + 1
        else:
            maxLen = max(maxLen, i - start + 1)

        seen[num] = i

    return maxLen",94
39005224248,can_partition,"def can_partition(nums):
    total = sum(nums)
    if total % 2 != 0:
        return False
    target = total // 2
    dp = [False] * (target + 1)
    dp[0] = True
    for num in nums:
        for i in range(target, num - 1, -1):
            dp[i] = dp[i] or dp[i - num]
    return dp[target]",94
22573071994,find_first_non_repeating,"def find_first_non_repeating(s):
    char_count = {}
    
    # Count the occurrence of each character in the string
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    
    # Find the first character with count 1
    for char in s:
        if char_count[char] == 1:
            return char
    return ''",94
30496603519,subarraySum,"def subarraySum(nums, k):
    count = 0
    sum = 0
    hash_map = {0 : 1}
    for i in range(len(nums)):
        sum += nums[i]
        if sum - k in hash_map:
            count += hash_map[sum - k]
        if sum not in hash_map:
            hash_map[sum] = 0
        hash_map[sum] += 1
    return count",94
39922249965,subarraySum,"def subarraySum(nums, k):
    count = 0
    sum = 0
    sum_dict = {0:1}
    for i in range(len(nums)):
        sum += nums[i]
        if sum - k in sum_dict:
            count += sum_dict[sum-k]
        if sum in sum_dict:
            sum_dict[sum] += 1
        else:
            sum_dict[sum] = 1
    return count",94
23795424250,max_length_subarray,"def max_length_subarray(arr):
  max_len = 0
  count = 0
  d = {0: -1}
  for i in range(len(arr)):
    if arr[i] == 0:
      count -= 1
    else:
      count += 1
    if count in d:
      max_len = max(max_len, i - d[count])
    else:
      d[count] = i
  return max_len",94
33760262158,count_BST,"def count_BST(n):
    if n == 0 or n == 1:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",94
40555978441,divisor,"def divisor(n):
    arr=[]
    k=1
    while(k<=n):
        if n % k == 0:
            arr.append(k)
        k+=1
    return sorted(arr)

def solution(n):
    k=2
    arr=[]
    while(k<=n):
        if n%k==0:
            arr.append(k)
            n=n//k
        else:
            k+=1
    return (list(set(arr)))",94
13322139348,rock_paper_scissors,"def rock_paper_scissors(player1, player2):
    if player1 == player2:
        return 'It is a tie!'
    elif (player1 == 'rock' and player2 == 'scissors') or (player1 == 'scissors' and player2 == 'paper') or (player1 == 'paper' and player2 == 'rock'):
        return 'Player 1 wins!'
    else:
        return 'Player 2 wins!'",94
13017569140,lis,"def lis(arr):
    n = len(arr)
    lis = [1]*n
    for i in range (1 , n):
        for j in range(0 , i):
            if arr[i] > arr[j] and lis[i]< lis[j] + 1 :
                lis[i] = lis[j]+1
    maximum = 0
    for i in range(n):
        maximum = max(maximum , lis[i])
    return maximum",94
14343294504,longest_substring_without_duplication,"def longest_substring_without_duplication(s):
    start = 0
    max_length = 0
    used_char = {}

    for i in range(len(s)):
        if s[i] in used_char and start <= used_char[s[i]]:
            start = used_char[s[i]] + 1
        else:
            max_length = max(max_length, i - start + 1)

        used_char[s[i]] = i

    return max_length",94
69800383110,longest_zero_sequence,"def longest_zero_sequence(n):
    binary = bin(n)[2:]
    max_gap = 0
    current_gap = 0
    found_one = False
    
    for bit in binary:
        if bit == '1':
            if found_one and current_gap > max_gap:
                max_gap = current_gap
            current_gap = 0
            found_one = True
        elif found_one:
            current_gap += 1
            
    return max_gap",94
5365915668,minimumJumps,"def minimumJumps(nums):
    n = len(nums)
    if n == 1:
        return 0
    dp = [float('inf')]*n
    dp[0] = 0
    for i in range(1, n):
        for j in range(i):
            if j + nums[j] >= i:
                dp[i] = min(dp[i], dp[j] + 1)
    return dp[n-1]",94
9040160166,minimumSwaps,"from typing import List

def minimumSwaps(nums: List[int]) -> int:
    swaps = 0
    i = 0
    while i < len(nums):
        correct_pos = nums[i] - 1
        if nums[i] != nums[correct_pos]:
            nums[i], nums[correct_pos] = nums[correct_pos], nums[i]
            swaps += 1
        else:
            i += 1
    return swaps",94
30124999516,staircase,"def staircase(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    else:
        dp = [0] * (n+1)
        dp[1] = 1
        dp[2] = 2
        for i in range(3, n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]",94
6268755952,max_sub_array_of_size_k,"def max_sub_array_of_size_k(arr, k):
    if k <= 0 or k > len(arr):
        return 0

    window_sum = 0
    for i in range(k):
        window_sum += arr[i]

    max_sum = window_sum

    for i in range(k, len(arr)):
        window_sum += arr[i] - arr[i - k]
        max_sum = max(max_sum, window_sum)

    return max_sum",94
9295048962,check_subarray_sum,"def check_subarray_sum(nums, k): 
    hash_map = {} 
    curr_sum = 0
    for i in range(0, len(nums)): 
        curr_sum = curr_sum + nums[i] 
        if (curr_sum % k == 0): 
            return True
        if (curr_sum % k in hash_map): 
            return True
        hash_map[(curr_sum % k)] = 1
    return False",94
73461824476,waysToSumAsPowersOf2,"def waysToSumAsPowersOf2(target):
    dp = [1] + [0] * target
    for i in range(1, target + 1):
        if i & (i - 1) == 0:  # Check if i is a power of 2
            for j in range(target, i - 1, -1):
                dp[j] += dp[j - i]
    return dp[target]",93
32225187547,length_of_lis,"def length_of_lis(nums):
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    if not nums:
        return 0

    dp = [1] * len(nums)

    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)",93
32420811271,count_a_surrounded_by_vowels,"def count_a_surrounded_by_vowels(s: str) -> int:
  vowels = 'aeiouAEIOU'
  count = 0
  for i in range(1, len(s) - 1):
    if s[i] == 'a' or s[i] == 'A':
      if s[i - 1] in vowels and s[i + 1] in vowels:
        count += 1
  return count",93
7704321925,is_perfect,"def is_perfect(n):
    if n < 1:
        return False
    sum_of_divisors = 1
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            if i * (n // i) == n:
                sum_of_divisors += i + n//i
            i += 1
    return sum_of_divisors == n",93
37648519964,find_kth_largest,"def find_kth_largest(nums, k):
    nums.sort()
    return nums[-k]


print(find_kth_largest([3,2,1,5,6,4], 2))
# 5
print(find_kth_largest([3,2,3,1,2,4,5,5,6], 4))
# 4
print(find_kth_largest([1], 1))
# 1",93
15304624305,is_permutation_palindrome,"def is_permutation_palindrome(s):
    s = s.replace("" "", """").lower()
    d = dict()
    for c in s:
        if c in d:
            d[c] += 1
        else:
            d[c] = 1
    odd_count = 0
    for key in d:
        if d[key] % 2 != 0:
            odd_count += 1
    return odd_count <= 1",93
4120848553,search_insert,"def search_insert(nums, target):
    """"""
    :type nums: List[int]
    :type target: int
    :rtype: int
    """"""
    if target <= nums[0]:
        return 0
    elif target > nums[-1]:
        return len(nums)
    else:
        for idx in range(len(nums) - 1):
            if nums[idx] < target <= nums[idx + 1]:
                return idx + 1",93
72852422848,is_strong_password,"import re

def is_strong_password(password):
    if len(password) < 8 or len(password) > 20:
        return False
    if 'password' in password.lower():
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    return True",93
13292994951,is_valid_cycle,"def is_valid_cycle(nums):
    if len(nums) <= 1:
        return False
    if nums[0] != nums[-1]:
        return False
    if len(set(nums)) != len(nums):
        return False
    current = nums[0]
    for _ in range(len(nums)):
        next_num = nums[current - 1]
        if next_num == current:
            return False
        current = next_num
    return True",93
3974941192,catalan,"def catalan(n):
    if n <= 1:
        return 1
    catalan = [0] * (n+1)
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n+1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]
    return catalan[n]",93
9770670095,find_longest_sequence,"def find_longest_sequence(nums):
    num_set = set(nums)
    longest_sequence = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_sequence = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_sequence += 1

            longest_sequence = max(longest_sequence, current_sequence)

    return longest_sequence",93
12160457357,longestConsecutive,"def longestConsecutive(nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        numsSet = set(nums)
        longest = 0
        for n in numsSet:
            added = False
            if n-1 not in numsSet:
                length = 0
                while (n+length) in numsSet:
                    length += 1
                longest = max(length, longest)
        return longest",93
40080664965,max_Subarray_Sum,"def max_Subarray_Sum(arr, k):
    max_sum = 0
    window_sum = 0
    window_start = 0

    for window_end in range(len(arr)):
        window_sum += arr[window_end]
        if window_end >= k-1:
            if window_sum > max_sum:
                max_sum = window_sum
            window_sum -= arr[window_start]
            window_start += 1
    return max_sum",93
40452875843,validate_password,"import re

def validate_password(password):
    if len(password) < 6 or len(password) > 16:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[$#@]"", password):
        return False
    return True",93
8687271860,numSubarraySum,"def numSubarraySum(nums, k):
    count, sum = 0, 0
    hash_map = {0:1}
    for i in range(len(nums)):
        sum += nums[i]
        if sum-k in hash_map:
            count += hash_map[sum-k]
        if sum in hash_map:
            hash_map[sum] += 1
        else:
            hash_map[sum] = 1
    return count",93
5684243076,subarraySum,"def subarraySum(nums, k):
    count = 0
    sums = 0
    hash_map = {0:1}
    for num in nums:
        sums += num
        if sums-k in hash_map:
            count += hash_map[sums-k]
        if sums in hash_map:
            hash_map[sums] += 1
        else:
            hash_map[sums] = 1
    return count",93
27424190756,binary_gap,"def binary_gap(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0
    found_one = False
    for bit in binary:
        if bit == '1':
            if found_one and current_gap > max_gap:
                max_gap = current_gap
            current_gap = 0
            found_one = True
        elif found_one:
            current_gap += 1
    return max_gap",93
21761023760,check_bracket_sequence,"def check_bracket_sequence(s):
    bracket_map = {')': '(', ']': '[', '}': '{'}
    open_t = set(['(', '[', '{'])
    stack = []
    for i in s:
        if i in open_t:
            stack.append(i)
        elif stack and (stack[-1] == bracket_map[i]):
            stack.pop()
        else:
            return False
    if stack:
        return False
    return True",93
2476840615,find_primes_in_range,"def find_primes_in_range(start, end):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    primes = []
    for num in range(start, end + 1):
        if is_prime(num):
            primes.append(num)
    return primes",93
34587160641,can_form_palindrome,"def can_form_palindrome(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
        if odd_count > 1:
            return False
    return True",93
32353311329,findUnsortedSubarray,"def findUnsortedSubarray(nums):
    sorted_nums = sorted(nums)
    start, end = -1, -1
    for i in range(len(nums)):
        if nums[i] != sorted_nums[i] and start == -1:
            start = i
        elif nums[i] != sorted_nums[i]:
            end = i

    if start == -1:
        return 0
    else:
        return end - start + 1",93
19776438989,find_combinations,"def find_combinations(nums, target):
    def dfs(nums, target, index, path, res):
        if target < 0:
            return 
        if target == 0:
            res.append(path)
            return 
        for i in range(index, len(nums)):
            dfs(nums, target-nums[i], i, path+[nums[i]], res)
    res = []
    dfs(nums, target, 0, [], res)
    return res",93
6521930894,climb_stairs,"def climb_stairs(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    elif n == 3:
        return 4
    first, second, third = 1, 2, 4
    for i in range(3, n):
        current = first + second + third
        first, second, third = second, third, current
    return third",93
8131717182,fib_number,"def fib_number(n: int) -> int:
    '''
    Time: O(n)
    Space: O(1)
    '''
    if n <= 0:
        return 0
    elif n == 1 or n == 2:
        return 1
    first, second = 1, 1
    for _ in range(3, n+1):
        first, second = second, first + second
    return second",93
6957546013,num_Divisors,"def num_Divisors(n):
    front = []
    back = []
    root = int(n**(1/2))
    for i in range(1, root+1):
        if (n%i == 0) and (i*i != n):
            front.append(i)
    if root*root == n:
        back.append(root)
    for f in list(reversed(front)):
        back.append(n/f)
    return len(front + back)",93
74608377965,subarraySum,"def subarraySum(nums, k):
    count = 0
    sum_ = 0
    hash_ = {0:1}
    for i in nums:
        sum_ += i
        if sum_ - k in hash_:
            count += hash_[sum_-k]
        if sum_ in hash_:
            hash_[sum_] += 1
        else:
            hash_[sum_] = 1
    return count",93
38556273790,str_to_num,"def str_to_num(str_num):
    dig = {""zero"": ""0"", ""one"": ""1"", ""two"": ""2"", ""three"": ""3"", ""four"": ""4"", ""five"": ""5"", ""six"": ""6"", ""seven"": ""7"", ""eight"": ""8"", ""nine"": ""9""}
    res = """"
    for i in str_num.split():
        res += dig[i]
    return int(res)",93
72461994548,is_valid_ipv4,"import re

def is_valid_ipv4(ip):
    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    return re.match(pattern, ip) is not None",93
28452822535,climbStairs,"def climbStairs(n): 
    if n == 1: 
        return 1
    elif n == 2: 
        return 2
    elif n == 3: 
        return 4
    a, b, c = 1, 2, 4
    for i in range(3, n): 
        a, b, c = b, c, a + b + c
    return c",93
20298288502,can_form_palindrome,"def can_form_palindrome(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
            if odd_count > 1:
                return False
    return True",93
16502419374,anagrams_in_string,"def anagrams_in_string(string1, string2):
    len1 = len(string1)
    len2 = len(string2)
    if len1 != len2:
        return []
    string1_sorted = sorted(string1)
    anagrams = []
    for i in range(len(string1)):
        substring = string1[i:i+len2]
        if sorted(substring) == string1_sorted:
            anagrams.append(substring)
    return anagrams",93
18326420108,longest_subarray,"def longest_subarray(arr, k):
    start = 0
    end = 0
    current_sum = 0
    max_len = 0
    while end < len(arr):
        current_sum += arr[end]
        while current_sum > k:
            current_sum -= arr[start]
            start += 1
        max_len = max(max_len, end - start + 1)
        end += 1
    return max_len",93
24508485465,play_rps,"def play_rps(player1, player2):
    if player1 == player2:
        return ""It's a tie!""
    elif (player1 == ""rock"" and player2 == ""scissors"") or (player1 == ""scissors"" and player2 == ""paper"") or (player1 == ""paper"" and player2 == ""rock""):
        return ""Player 1 wins!""
    else:
        return ""Player 2 wins!""",93
36876673608,subarrays_with_given_sum,"def subarrays_with_given_sum(arr, target_sum):
    res = 0
    hash_map = {0: 1}

    prefix_sum = 0
    for num in arr:
        prefix_sum += num
        if prefix_sum - target_sum in hash_map:
            res += hash_map[prefix_sum - target_sum]
        hash_map[prefix_sum] = hash_map.get(prefix_sum, 0) + 1

    return res",93
12307081935,longest_consecutive_sequence,"def longest_consecutive_sequence(nums):
    num_set = set(nums)
    longest_sequence = []
    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_sequence = []
            while current_num in num_set:
                current_sequence.append(current_num)
                current_num += 1
            if len(current_sequence) > len(longest_sequence):
                longest_sequence = current_sequence
    return longest_sequence",93
2974292889,can_form,"from collections import Counter

def can_form(str1, str2):
    """"""
    Checks if the given string str2 can be formed by rearranging the characters of str1.
    
    :param str1: First input string
    :param str2: Second input string
    :return: True if str2 can be formed by rearranging the characters of str1, False otherwise.
    """"""
    return Counter(str1) == Counter(str2)",93
14386039471,smallest_subarray_sum,"def smallest_subarray_sum(nums, target):
    left, current_sum, min_length = 0, 0, float(""inf"")
    for right in range(len(nums)):
        current_sum += nums[right]
        while current_sum >= target:
            min_length = min(min_length, right - left + 1)
            current_sum -= nums[left]
            left += 1
    return min_length if min_length != float(""inf"") else -1",93
30132883606,longest_string_length,"def longest_string_length(strings):
    if not strings:
        return 0
    return max(len(string) for string in strings)

# Test cases
print(longest_string_length([""cat"", ""dog"", ""elephant""]))  # 8
print(longest_string_length([""apple"", ""banana"", ""cherry""]))  # 6
print(longest_string_length([""hello"", ""world"", ""python"", ""programming""]))  # 11",93
74666386020,count_balanced_parentheses,"def count_balanced_parentheses(n):
    mod = 10**9 + 7
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        for j in range(i):
            dp[i] = (dp[i] + dp[j] * dp[i - j - 1]) % mod
    return dp[n]",93
9099030066,num_subarrays_with_sum,"from collections import defaultdict

def num_subarrays_with_sum(nums, goal):
    ans, prefixSum = 0, 0
    prefixSums = defaultdict(int)
    prefixSums[0] += 1
    for n in nums:
        prefixSum += n
        diff = prefixSum - goal
        ans += prefixSums.get(diff, 0)
        prefixSums[prefixSum] += 1
    return ans",93
11922734523,is_valid_ip,"def is_valid_ip(ip: str) -> bool:
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        if part[0] == '0' and len(part) > 1:
            return False
        if int(part) < 0 or int(part) > 255:
            return False
    return True",93
10514103681,lucky_numbers,"def lucky_numbers(matrix):
    result = []
    for c in range(len(matrix[0])):
        max_el = matrix[0][c]
        max_row = 0
        for r in range(1, len(matrix)):
            if matrix[r][c] > max_el:
                max_el = matrix[r][c]
                max_row = r
        if min(matrix[max_row]) == max_el:
            result.append(max_el)
    return result",93
74188154637,merge_intervals,"def merge_intervals(intervals):
	if not intervals:
		return [] 

	intervals.sort(key=lambda x: x[0])
	merged = [intervals[0]]

	for current in intervals:
		last_merged = merged[-1]

		if current[0] <= last_merged[1]:
			merged[-1] = (last_merged[0], max(last_merged[1], current[1]))
		else:
			merged.append(current)

	return merged",93
33783923723,count_valid_parentheses,"def count_valid_parentheses(n):
    if n % 2 != 0:
        return 0
    n //= 2
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - 1 - j]
    return dp[n]",93
25794919783,coin_change,"def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount+1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i-coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",93
11072858283,smallest_missing,"def smallest_missing(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i]-1] != nums[i]:
            nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1",93
17084624106,can_partition,"def can_partition(nums):
    total = sum(nums)
    if total % 2 != 0:
        return False
    target = total // 2
    dp = [False] * (target + 1)
    dp[0] = True

    for num in nums:
        for i in range(target, num-1, -1):
            dp[i] = dp[i] or dp[i - num]

    return dp[target]",93
14321168758,height_of_bst,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def height_of_bst(root):
    if root == None:
        return 0
    else:
        left_height = height_of_bst(root.left)
        right_height = height_of_bst(root.right)
        return 1 + max(left_height, right_height)",93
36086766148,find_most_frequent_char,"def find_most_frequent_char(s):
    char_count = {}
    max_count = 0
    most_frequent_char = ''
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
        if char_count[char] > max_count:
            max_count = char_count[char]
            most_frequent_char = char
    return most_frequent_char",93
36458546415,find_max_consecutive_ones,"def find_max_consecutive_ones(nums):
    temp_sum = 0
    max_sum = 0
    if not nums:
        return max_sum
    nums_temp = nums + [0]
    for i in range(len(nums_temp)):
        if nums_temp[i] == 1:
            temp_sum += 1
        else:
            max_sum = max(max_sum, temp_sum)
            temp_sum = 0
    return max_sum",93
25201567100,can_construct,"from collections import Counter

def can_construct(target, str_list):
    target_counter = Counter(target)
    for string in str_list:
        string_counter = Counter(string)
        for char in string_counter:
            if char not in target_counter or string_counter[char] > target_counter[char]:
                return False
        for char in string_counter:
            target_counter[char] -= string_counter[char]
    return all(value == 0 for value in target_counter.values())",93
73096285178,firstUniqueChar,"from collections import OrderedDict

def firstUniqueChar(s):
    char_order = OrderedDict()
    char_count = {}
    
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
            char_order[char] = True
            
    for char in char_order:
        if char_count[char] == 1:
            return s.index(char)
    return -1",92
5784173064,longest_subarray_sum,"def longest_subarray_sum(arr, k):
    n = len(arr)
    max_len = 0
    current_sum = 0
    left = 0

    for right in range(n):
        current_sum += arr[right]

        while current_sum > k and left <= right:
            current_sum -= arr[left]
            left += 1

        max_len = max(max_len, right - left + 1)

    return max_len",92
30178255515,find_missing_numbers,"def find_missing_numbers(nums):
    n = len(nums)
    for i in range(n):
        while nums[i] != i + 1 and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    return [i + 1 for i in range(n) if nums[i] != i + 1]",92
73571643035,can_segment_string,"def can_segment_string(s, wordDict):
    word_set = set(wordDict)
    n = len(s)
    dp = [False] * (n + 1)
    dp[0] = True
    for i in range(1, n+1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break
    return dp[n]",92
26753646026,max_depth,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def max_depth(root: TreeNode) -> int:
    if root is None:
        return 0
    else:
        left_height = max_depth(root.left)
        right_height = max_depth(root.right)
        return max(left_height, right_height) + 1",92
4098243950,most_frequent_char,"def most_frequent_char(s):
    char_count = {}
    for c in s:
        if c in char_count:
            char_count[c] += 1
        else:
            char_count[c] = 1
    max_count = 0
    max_char = ''
    for c in s:
        if char_count[c] > max_count:
            max_count = char_count[c]
            max_char = c
    return max_char",92
16865262638,product_except_self,"def product_except_self(nums):
    length = len(nums)
    answer = [1] * length

    answer[0] = 1
    for i in range(1, length):
        answer[i] = nums[i - 1] * answer[i - 1]

    R = 1
    for i in reversed(range(length)):
        answer[i] = answer[i] * R
        R *= nums[i]
    return answer",92
11578030005,longest_consecutive_substring,"def longest_consecutive_substring(s):
    if not s:
        return 0
    max_length = 1
    current_length = 1
    for i in range(1, len(s)):
        if ord(s[i]) - ord(s[i-1]) == 1:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1
    return max_length",92
40470618500,prime_numbers_in_range,"def prime_numbers_in_range(start, end):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    primes = []
    for num in range(start, end + 1):
        if is_prime(num):
            primes.append(num)
    return primes",92
33323557653,count_primes,"def count_primes(n):
    if n < 2:
        return 0
    primes = [1] * n
    primes[0] = primes[1] = 0
    for i in range(2, int(n ** 0.5) + 1):
        if primes[i]:
            primes[i*i:n:i] = [0] * len(primes[i*i:n:i])
    return sum(primes)",92
32820535110,tree_height,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def tree_height(root: TreeNode) -> int:
    if root is None:
        return 0
    else:
        left_height = tree_height(root.left)
        right_height = tree_height(root.right)
        return max(left_height, right_height) + 1",92
42496973235,word_segmentation,"def word_segmentation(s, wordDict):
    word_set = set(wordDict)
    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break

    return dp[len(s)]",92
3223253090,least_jumps,"def least_jumps(arr):
    if len(arr) <= 1:
        return 0
    jumps = 0
    curr_jump_end = 0
    farthest = 0
    for i in range(len(arr) - 1):
        farthest = max(farthest, i + arr[i])
        if i == curr_jump_end:
            jumps += 1
            curr_jump_end = farthest
    return jumps",92
74235990169,find_combinations,"def find_combinations(candidates, target):
    result = []
    candidates.sort()
    def dfs(start, path, target):
        if target == 0:
            result.append(path)
            return
        for i in range(start, len(candidates)):
            if target - candidates[i] < 0:
                break
            dfs(i, path + [candidates[i]], target - candidates[i])
    dfs(0, [], target)
    return result",92
25628558930,product_except_self,"def product_except_self(nums):
    length = len(nums)
    answer = [1] * length

    answer[0] = 1
    for i in range(1, length):
        answer[i] = nums[i - 1] * answer[i - 1]

    R = 1
    for i in reversed(range(length)):
        answer[i] = answer[i] * R
        R *= nums[i]

    return answer",92
11927560460,find_first_non_repeating_char,"from collections import OrderedDict

def find_first_non_repeating_char(s):
    char_order = OrderedDict()
    char_count = {}

    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
            char_order[char] = None

    for char in char_order.keys():
        if char_count[char] == 1:
            return char
    return None",92
73346032950,stair_climbing_ways,"def stair_climbing_ways(n):
    if n == 0 or n == 1:
        return 1
    elif n == 2:
        return 2
    a, b, c = 1, 1, 2
    for i in range(3, n + 1):
        d = a + b + c
        a, b, c = b, c, d
    return d",92
2976221333,can_partition,"def can_partition(nums: list) -> bool:
    total = sum(nums)
    if total%2 != 0: return False
    target = total/2

    s = set([0])
    for n in nums:
        new_s = set()
        for el in s:
            if el+n == target: return True
            new_s.add(el)
            new_s.add(el+n)
        s = new_s

    return False",92
3032031799,shell_sort,"def shell_sort(nums):
    n = len(nums)
    gap = n // 2
    while gap > 0:
        for i in range(gap, n):
            temp = nums[i]
            j = i
            while j >= gap and nums[j - gap] > temp:
                nums[j] = nums[j - gap]
                j -= gap
            nums[j] = temp
        gap //= 2
    return nums",92
34917819544,adjacent_product,"def adjacent_product(input_list):
    if len(input_list) < 2:
        raise ValueError(""Input list must have at least two elements"")
    max_product = input_list[0] * input_list[1]
    for i in range(1, len(input_list) - 1):
        product = input_list[i] * input_list[i + 1]
        if product > max_product:
            max_product = product
    return max_product",92
25538579124,valid_password,"import re

def valid_password(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%^&*()-_=+]"", password):
        return False
    return True",92
40469577470,find_primes_in_range,"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def find_primes_in_range(start, end):
    primes = []
    for num in range(start, end+1):
        if is_prime(num):
            primes.append(num)
    return primes",92
71921755087,jump,"def jump(nums):
    jumps = 0
    current_jump_end = 0
    farthest = 0
    for i in range(len(nums) - 1):

        farthest = max(farthest, i + nums[i])
        if i == current_jump_end:
            jumps += 1
            current_jump_end = farthest

            if current_jump_end >= len(nums) - 1:
                break

    return jumps",92
13978508090,password_checker,"import re

def password_checker(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%^&*()-_+=]"", password):
        return False
    return True",92
35097202438,is_valid_anagram_palindrome,"def is_valid_anagram_palindrome(s: str) -> bool:
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1",92
22578728363,longest_substring_without_repeating_chars,"def longest_substring_without_repeating_chars(s):
    char_index_map = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_index_map:
            left = max(left, char_index_map[s[right]] + 1)
        char_index_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",92
74298896959,sum_of_odds,"def sum_of_odds(n):
    # Initialize sum variable
    total = 0
    # Loop through the numbers from 1 to n
    for i in range(1, n + 1):
        # Check if the number is odd
        if i % 2 != 0:
            # Add the odd number to the total
            total += i
    # Return the total sum of all odd numbers
    return total",92
30920432172,is_permutation_of_palindrome,"def is_permutation_of_palindrome(s):
    s = s.replace("" "", """").lower()
    d = {}
    for char in s:
        if char in d:
            d[char] += 1
        else:
            d[char] = 1
    odd_count = 0
    for count in d.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1",92
10707220670,longest_substring_without_repeating,"def longest_substring_without_repeating(s: str) -> int:
    char_map = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",92
17205447075,find_catalan_number,"def find_catalan_number(n):
    if n <= 1:
        return 1
    catalan = [0] * (n+1)
    catalan[0] = catalan[1] = 1
    for i in range(2, n+1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]
    return catalan[n]",92
20138830441,look_and_say,"def look_and_say(n):
    result = ''
    i = 0
    while i < len(str(n)):
        count = 1
        while i + 1 < len(str(n)) and str(n)[i] == str(n)[i + 1]:
            i += 1
            count += 1
        result += str(count) + str(n)[i]
        i += 1
    return int(result)",92
30375513950,combination_sum,"def combination_sum(candidates, target):
    results = []
    def dfs(candidates, target, path, index):
        if target < 0:
            return
        if target == 0:
            results.append(path)
            return
        for i in range(index, len(candidates)):
            dfs(candidates, target - candidates[i], path + [candidates[i]], i)
    dfs(candidates, target, [], 0)
    return results",92
16454726207,lengthOfLastWord,"def lengthOfLastWord(s):
    ls = len(s)
    # slow and fast pointers
    slow = -1
    # iterate over trailing spaces
    while slow >= -ls and s[slow] == "" "":
        slow -= 1
    fast = slow
    # iterate over last word
    while fast >= -ls and s[fast] != "" "":
        fast -= 1
    return slow - fast",92
71916907133,rock_paper_scissors,"def rock_paper_scissors(player1, player2):
    if player1 == player2:
        return 'Tie'
    elif (player1 == 'rock' and player2 == 'scissors') or (player1 == 'paper' and player2 == 'rock') or (player1 == 'scissors' and player2 == 'paper'):
        return 'Player 1 wins'
    else:
        return 'Player 2 wins'",92
9671174497,min_Diff,"def min_Diff(A, B):
    A.sort()
    B.sort()
    i, j = 0, 0
    min_diff = float('inf')
    while i < len(A) and j < len(B):
        min_diff = min(min_diff, abs(A[i] - B[j]))
        if A[i] < B[j]:
            i += 1
        else:
            j += 1
    return min_diff",92
28319759071,count_odd_numbers,"def is_odd_digit(n):
    return n % 2 != 0

def first_last_odd(n):
    str_n = str(abs(n))
    first_digit = int(str_n[0])
    last_digit = int(str_n[-1])
    return is_odd_digit(first_digit) and is_odd_digit(last_digit)

def count_odd_numbers(lst):
    return sum(1 for n in lst if n > 10 and first_last_odd(n))",92
4217896607,product_except_self,"def product_except_self(nums):
    length = len(nums)
    answer = [1] * length

    answer[0] = 1
    for i in range(1, length):
        answer[i] = nums[i - 1] * answer[i - 1]

    R = 1;
    for i in reversed(range(length)):
        answer[i] = answer[i] * R
        R *= nums[i]
    return answer",92
16247597901,is_palindrome_rearrange,"def is_palindrome_rearrange(s: str) -> bool:
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1",92
40219735572,valid_ipv4,"import re

def valid_ipv4(ip):
    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    return re.match(pattern, ip) is not None",92
37262346088,max_non_adjacent_sum,"def max_non_adjacent_sum(nums):
    if not nums:
        return 0
    dp = [0] * (len(nums) + 2)
    dp[0], dp[1] = 0, 0
    for i in range(2, len(nums) + 2):
        dp[i] = max(dp[i-1], dp[i-2] + nums[i-2])
    return dp[-1]",92
70282581837,is_valid_bracket_sequence,"def is_valid_bracket_sequence(s: str) -> bool:
    stack = []
    bracket_map = {')': '(', ']': '[', '}': '{'}
    
    for char in s:
        if char in bracket_map.values():
            stack.append(char)
        elif char in bracket_map.keys():
            if stack == [] or bracket_map[char] != stack.pop():
                return False
        else:
            return False
    
    return stack == []",92
7503677231,max_depth,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def max_depth(root: TreeNode) -> int:
    if root is None:
        return 0
    else:
        left_depth = max_depth(root.left)
        right_depth = max_depth(root.right)
        return max(left_depth, right_depth) + 1",92
70611535571,find_missing_integer,"def find_missing_integer(arr):
    arr = list(set(arr)) # remove duplicates
    arr = [x for x in arr if x > 0] # remove negative numbers
    arr.sort() # sort the list
    smallest_missing_integer = 1
    for num in arr:
        if num == smallest_missing_integer:
            smallest_missing_integer += 1
        elif num > smallest_missing_integer:
            break
    return smallest_missing_integer",92
72925832316,jump_to_end,"def jump_to_end(nums):
    if len(nums) == 1:
        return 0
    jumps = 0
    current_jump_end = 0
    farthest = 0
    for i in range(len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        if i == current_jump_end:
            jumps += 1
            current_jump_end = farthest
    return jumps",92
4542273127,height_of_tree,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def height_of_tree(root: TreeNode) -> int:
    if root is None:
        return 0
    left_height = height_of_tree(root.left)
    right_height = height_of_tree(root.right)
    return max(left_height, right_height) + 1",92
9529113932,maxDepth,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxDepth(root: TreeNode) -> int:
    if root is None:
        return 0
    else:
        left_height = maxDepth(root.left)
        right_height = maxDepth(root.right)
        return max(left_height, right_height) + 1",92
28952822576,nth_Fibonacci,"def nth_Fibonacci(n):
    if n <= 0:
        return ""Invalid input""
    elif n == 1:
        return 1
    elif n == 2:
        return 1
    else:
        first = 1
        second = 1
        for i in range(3, n + 1):
            next = first + second
            first = second
            second = next
        return second",92
73598341784,is_anagram_of_palindrome,"def is_anagram_of_palindrome(s: str) -> bool:
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

    odd_counts = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_counts += 1
    return odd_counts <= 1",92
36005774233,canCompleteCircuit,"def canCompleteCircuit(gas, cost):
    start = 0
    total, curr = 0, 0

    for i in range(len(gas)):
        total += gas[i] - cost[i]
        curr += gas[i] - cost[i]
        if curr < 0:
            start = i + 1
            curr = 0

    if total < 0:
        return -1
    return start",92
71352049239,sorted,"from typing import List

def permutations(nums: List[int]) -> List[List[int]]:
    def backtrack(start=0):
        if start == len(nums):
            result.append(nums[:])
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]

    result = []
    backtrack()
    return result",92
18692875714,play_game,"def play_game(player1,player2):
    if player1 == player2:
        return 'It is a draw!'
    elif (player1 == 'rock' and player2 == 'scissors') or (player1 == 'scissors' and player2 == 'paper') or (player1 == 'paper' and player2 == 'rock'):
        return 'Player 1 wins!'
    else:
        return 'Player 2 wins!'",92
23726092029,num_distinct_subsequences,"def num_distinct_subsequences(s):
    if not s:
        return 0
    dp = [1]
    last_occurrence = {}
    for i in range(len(s)):
        dp.append(dp[-1] * 2)
        if s[i] in last_occurrence:
            dp[-1] -= dp[last_occurrence[s[i]]]
        last_occurrence[s[i]] = i
    return dp[-1] - 1",92
18012854888,max_points,"def max_points(nums):
    while len(nums) > 1:
        max_sum = 0
        for i in range(len(nums) - 1):
            temp_sum = nums[i] + nums[i + 1]
            if temp_sum > max_sum:
                max_sum = temp_sum
                max_index = i
        nums[max_index] = max_sum
        nums.pop(max_index + 1)
    return nums[0]",92
26536421349,longest_balanced_parentheses,"def longest_balanced_parentheses(s: str) -> int:
    max_len = 0
    stack = [-1]
    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if len(stack) == 0:
                stack.append(i)
            else:
                max_len = max(max_len, i - stack[len(stack)-1])
    return max_len",92
12298709232,find_longest_unique_substring,"def find_longest_unique_substring(s):
    char_index = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_index and char_index[s[right]] >= left:
            left = char_index[s[right]] + 1
        char_index[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",92
23777742577,find_largest_palindrome_product,"def find_largest_palindrome_product(max_limit, min_limit):
    largest_palindrome = 0
    for i in range(max_limit, min_limit - 1, -1):
        for j in range(i, min_limit - 1, -1):
            product = i * j
            if str(product) == str(product)[::-1] and product > largest_palindrome:
                largest_palindrome = product
    return largest_palindrome",92
31583889781,multiply_except_self,"def multiply_except_self(nums):
    length = len(nums)
    answer = [1] * length

    answer[0] = 1
    for i in range(1, length):
        answer[i] = nums[i - 1] * answer[i - 1]

    R = 1
    for i in reversed(range(length)):
        answer[i] = answer[i] * R
        R *= nums[i]

    return answer",92
70278530904,subarraySum,"def subarraySum(nums, k):
    count, sum = 0, 0
    hash_map = {0: 1}
    for num in nums:
        sum += num
        if sum - k in hash_map:
            count += hash_map[sum - k]
        if sum in hash_map:
            hash_map[sum] += 1
        else:
            hash_map[sum] = 1
    return count",92
44811207104,product_except_self,"def product_except_self(nums):
    length = len(nums)
    answer = [0] * length

    answer[0] = 1
    for i in range(1, length):
        answer[i] = nums[i - 1] * answer[i - 1]

    R = 1
    for i in reversed(range(length)):
        answer[i] = answer[i] * R
        R *= nums[i]

    return answer",92
7546287177,max_profit_with_fee,"def max_profit_with_fee(prices, fee):
    buy = [-prices[0] - fee]
    sell = [0]
    
    for i in range(1, len(prices)):
        buy.append(max(sell[i - 1] - prices[i] - fee, buy[i - 1]))
        sell.append(max(prices[i] + buy[i - 1], sell[i - 1]))
        
    return sell[-1]",92
18138832378,product_except_self,"def product_except_self(nums):
    length = len(nums)
    answer = [1] * length

    answer[0] = 1
    for i in range(1, length):
        answer[i] = nums[i - 1] * answer[i - 1]

    R = 1;
    for i in reversed(range(length)):
        answer[i] = answer[i] * R
        R *= nums[i]

    return answer",92
25426617222,max_sub_array_of_size_k,"def max_sub_array_of_size_k(k, arr):
    max_sum = float('-inf')
    window_sum = 0
    window_start = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end] 
        if window_end >= k-1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]
            window_start += 1
    return max_sum",92
32321434829,first_non_repeating,"from collections import OrderedDict

def first_non_repeating(input_string):
    char_order = OrderedDict()
    char_count = {}
    
    for char in input_string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
            char_order[char] = None
    
    for char in char_order:
        if char_count[char] == 1:
            return char
    return None",92
36455843169,subarraySum,"def subarraySum(nums, k):
    count, sum = 0, 0
    hash_map = {0 : 1}
    for num in nums:
        sum += num
        if sum - k in hash_map:
            count += hash_map[sum - k]
        if sum in hash_map:
            hash_map[sum] += 1
        else:
            hash_map[sum] = 1
    return count",92
70847664526,count_unique_BST,"def count_unique_BST(n):
    if n <= 1:
        return 1
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",92
36206584884,canFormPalindrome,"def canFormPalindrome(s: str) -> bool:
    odd_counts = 0
    char_counts = [0] * 26

    for char in s:
        char_counts[ord(char) - ord('a')] += 1

    for count in char_counts:
        if count % 2 != 0:
            odd_counts += 1
            if odd_counts > 1:
                return False

    return True",91
40499862444,count_subarrays,"def count_subarrays(nums, target):
    count = 0
    current_sum = 0
    prefix_sums = {0: 1}

    for num in nums:
        current_sum += num
        if current_sum - target in prefix_sums:
            count += prefix_sums[current_sum - target]
        prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1

    return count",91
73503970712,is_palindrome_number,"def is_palindrome_number(num):
    return str(num) == str(num)[::-1]

# Testing the function
assert is_palindrome_number(121) == True
assert is_palindrome_number(123) == False
assert is_palindrome_number(1221) == True
assert is_palindrome_number(1331) == True
assert is_palindrome_number(1234) == False",91
69829456586,max_rect_area,"def max_rect_area(heights):
    stack = []
    max_area = 0
    for i, h in enumerate(heights + [0]):
        while stack and heights[stack[-1]] > h:
            height = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, height * width)
        stack.append(i)
    return max_area",91
29354593735,longest_harmonic_subsequence,"from collections import defaultdict

def longest_harmonic_subsequence(nums):
    dp = defaultdict(int)
    max_len = 0
    for i in range(len(nums)):
        for j in range(i):
            diff = nums[i] - nums[j]
            dp[(i, diff)] = dp[(j, diff)] + 1
            max_len = max(max_len, dp[(i, diff)])
    return max_len + 1",91
26319178386,subarray_sum,"def subarray_sum(nums, k):
    count, sum_ = 0, 0
    hashmap = {0: 1}
    for n in nums:
        sum_ += n
        if sum_ - k in hashmap:
            count += hashmap[sum_ - k]
        if sum_ in hashmap:
            hashmap[sum_] += 1
        else:
            hashmap[sum_] = 1
    return count",91
1418866211,find_missing_element,"def find_missing_element(lst1, lst2):
    d = dict.fromkeys(lst1, 0)
    for i in lst1:
        d[i] = d.get(i, 0) + 1
    for i in lst2:
        if i in d:
            d[i] -= 1
        else:
            return i
    for i in d:
        if d[i] == -1:
            return i",91
72044367293,jump_game,"def jump_game(nums):
    if len(nums) == 1:
        return 0

    jumps = 0
    current_jump_end = 0
    farthest = 0

    for i in range(len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        if i == current_jump_end:
            jumps += 1
            current_jump_end = farthest

    return jumps",91
41489122958,validate_password,"import re
def validate_password(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%^&*()-+]"", password):
        return False
    return True",91
13954367386,is_happy_number,"def is_happy_number(n):
    def get_next_number(num):
        total_sum = 0
        while num > 0:
            num, digit = divmod(num, 10)
            total_sum += digit ** 2
        return total_sum

    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next_number(n)

    return n == 1",91
14218772268,sum_of_divisors,"def sum_of_divisors(n):
    divisors_sum = 1 # 1 is always a proper divisor
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            divisors_sum += i
            if i != n // i: # Avoid adding the square root twice for perfect squares
                divisors_sum += n // i
    return divisors_sum",91
1064632823,nextPowerOf2,"def nextPowerOf2(n):
    if n and not(n & (n - 1)):
        return n
    else:
        while n & (n - 1):
            n &= n - 1
        return n << 1


assert nextPowerOf2(6) == 8
assert nextPowerOf2(15) == 16
assert nextPowerOf2(17) == 32",91
36197780630,largestRectangleArea,"def largestRectangleArea(heights):
    stack = []
    max_area = 0
    for i, h in enumerate(heights + [0]):
        while stack and heights[stack[-1]] > h:
            height = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, height * width)
        stack.append(i)
    return max_area",91
32773893624,most_common_char,"def most_common_char(s):
    char_freq = {}
    for char in s:
        if char in char_freq:
            char_freq[char] += 1
        else:
            char_freq[char] = 1

    max_freq = 0
    common_char = None
    for char, freq in char_freq.items():
        if freq > max_freq:
            max_freq = freq
            common_char = char
            
    return common_char",91
13161963542,min_subarray_length,"def min_subarray_length(nums, target):
    left = 0
    total = 0
    min_length = float('inf')
    for right in range(len(nums)):
        total += nums[right]
        while total >= target:
            min_length = min(min_length, right - left + 1)
            total -= nums[left]
            left += 1
    return min_length if min_length != float('inf') else 0",91
19207828618,max_sub_array_of_size_k,"def max_sub_array_of_size_k(k, arr):
    max_sum = 0
    window_sum = 0
    window_start = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end] 
        if window_end >= k-1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]
            window_start += 1
    return max_sum",91
30085515317,word_break,"def word_break(s, wordDict):
    word_set = set(wordDict)
    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break

    return dp[len(s)]",91
73096077784,uniquePaths,"def uniquePaths(m, n):
    if m == 0 or n == 0:
        return 0

    dp = [[1 for _ in range(n)] for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",91
17934921467,max_length_unique_substring,"def max_length_unique_substring(s: str) -> int:
    char_map = {}
    left = 0
    max_length = 0

    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)

    return max_length",91
4128779796,third_largest,"def third_largest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 3:
        return None
    unique_numbers.sort()
    return unique_numbers[-3]


assert third_largest([1,2,3]) == 1
assert third_largest([1,2]) == None
assert third_largest([10,20,30,40,50]) == 30",91
74397748935,count_triangles,"def count_triangles(nums):
    nums.sort()
    count = 0
    for i in range(len(nums) - 2):
        for j in range(i + 1, len(nums) - 1):
            k = j + 1
            while k < len(nums) and nums[i] + nums[j] > nums[k]:
                k += 1
            count += k - j - 1
    return count",91
36283178328,find_Longest_Increasing_Subsequence,"def find_Longest_Increasing_Subsequence(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

# Time complexity: O(n^2)
# Space complexity: O(n)",91
71593338026,lengthOfLongestSubstring,"def lengthOfLongestSubstring(s): 
    maxLength = 0
    start = 0
    usedChar = {}

    for i in range(len(s)):
        if s[i] in usedChar and start <= usedChar[s[i]]:
            start = usedChar[s[i]] + 1
        else:
            maxLength = max(maxLength, i - start + 1)

        usedChar[s[i]] = i

    return maxLength",91
26283864388,canPermutePalindrome,"from collections import defaultdict

def canPermutePalindrome(s):
    s = s.replace("" "", """").lower()
    char_dict = defaultdict(int)

    for char in s:
        char_dict[char] += 1

    odd_count = 0
    for value in char_dict.values():
        if value % 2 == 1:
            odd_count += 1
        if odd_count > 1:
            return False
    return True",91
27216108128,no_consecutive_ones,"def no_consecutive_ones(n):
    def backtrack(s):
        if len(s) == n:
            result.append(s)
            return
        if s[-1] == '0':
            backtrack(s + '0')
            backtrack(s + '1')
        else:
            backtrack(s + '0')

    result = []
    if n == 0:
        return result
    backtrack('0')
    backtrack('1')
    return result",91
20137409232,is_valid_ipv4,"import re

def is_valid_ipv4(ip):
    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    return bool(re.match(pattern, ip))",91
29546217451,buddy_strings,"def buddy_strings(A: str, B: str) -> bool:
    n = len(A)
    if len(B) != n:
        return False
    if A == B:
        return len(set(A)) != n
    diff = [(a, b) for a, b in zip(A, B) if a != b]
    return len(diff) == 2 and diff[0] == diff[1][::-1]",91
71085492738,unique_bst,"def unique_bst(n):
    if n == 0 or n == 1:
        return 1
    dp = [0 for i in range(n+1)]
    dp[0], dp[1] = 1, 1
    for i in range(2, n+1):
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]
    return dp[n]",91
12020721919,is_permutation_palindrome,"def is_permutation_palindrome(s):
    s = s.replace("" "", """").lower()
    counts = {}
    for char in s:
        if char in counts:
            counts[char] += 1
        else:
            counts[char] = 1
    odd_counts = 0
    for count in counts.values():
        if count % 2 != 0:
            odd_counts += 1
    return odd_counts <= 1",91
43827903523,max_sub_array_of_size_k,"def max_sub_array_of_size_k(k, arr):
    max_sum = 0
    window_sum = 0
    window_start = 0

    for window_end in range(len(arr)):
        window_sum += arr[window_end] 

        if window_end >= k-1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]
            window_start += 1

    return max_sum",91
18674908371,max_histogram_area,"def max_histogram_area(heights):
    stack = []
    max_area = 0
    for i, h in enumerate(heights + [0]):
        while stack and heights[stack[-1]] > h:
            height = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, height * width)
        stack.append(i)
    return max_area",91
13322392208,pig_latin,"def pig_latin(word):
    vowels = ['a','e','i','o','u']
    if word[0] in vowels:
        return word+'ay'
    else:
        first_vowel_index = 0
        for i, char in enumerate(word):
            if char in vowels:
                first_vowel_index = i
                break
        return word[first_vowel_index:]+word[:first_vowel_index]+'ay'",91
15065045150,longest_Substring_Without_Repeating,"def longest_Substring_Without_Repeating(s: str) -> int:
    longest = 0
    start = 0
    char_index = {}

    for i, char in enumerate(s):
        if char in char_index and char_index[char] >= start:
            start = char_index[char] + 1
        char_index[char] = i
        longest = max(longest, i - start + 1)

    return longest",91
23677091929,caesar_cipher,"def caesar_cipher(text: str, shift: int) -> str:
    result = []
    for char in text:
        if char.isalpha():
            base = ord('A') if char.isupper() else ord('a')
            ciphered = chr(((ord(char) - base + shift) % 26) + base)
            result.append(ciphered)
        else:
            result.append(char)
    return ''.join(result)",91
47525328536,find_closest_palindrome,"def find_closest_palindrome(num):
    if str(num) == str(num)[::-1]:
        return num
    else:
        diff = float('inf')
        res = None
        for i in range(num-100,num+100):
            if str(i) == str(i)[::-1]:
                if abs(i-num) < diff:
                    diff = abs(i-num)
                    res = i
        return res",91
41263125287,peak_index_in_mountain_array,"def peak_index_in_mountain_array(A):
    """"""
    :type A: List[int]
    :rtype: int
    """"""
    left, right = 0, len(A) - 1
    while left < right:
        mid = (left + right) // 2
        if A[mid] < A[mid + 1]:
            left = mid + 1
        else:
            right = mid
    return left",91
26972565506,length_of_longest_subarray,"def length_of_longest_subarray(nums):
    if not nums:
        return 0

    res = 0
    start = 0
    lookup = {}
    for i in range(len(nums)):
        if nums[i] in lookup:
            start = max(start, lookup[nums[i]] + 1)
        lookup[nums[i]] = i
        res = max(res, i - start + 1)
    return res",91
42556969461,fibonacci_number,"def fibonacci_number(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1

    dp = [0] * (n+1)
    dp[0], dp[1] = 0, 1

    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]",91
37062420257,count_strings,"def count_strings(strings):
    counts = {}
    for string in strings:
        length = len(string)
        if length not in counts:
            counts[length] = []
        counts[length].append(string)
    result = {}
    for length in sorted(counts):
        for string in sorted(counts[length]):
            if string not in result:
                result[string] = 1
            else:
                result[string] += 1
    return result",91
31035894714,max_sum_subarray,"def max_sum_subarray(arr, k):
    max_sum = float('-inf')
    window_sum = 0
    window_start = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end] 
        if window_end >= k - 1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]
            window_start += 1
    return max_sum",91
9880974558,grade_calculator,"def grade_calculator(score):
    if score >= 90 and score <= 100:
        return 'A'
    elif score >= 80 and score <= 89:
        return 'B'
    elif score >= 70 and score <= 79:
        return 'C'
    elif score >= 60 and score <= 69:
        return 'D'
    else:
        return 'F'",91
37769462488,is_valid_ipv4,"import re

def is_valid_ipv4(ip):
    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    return bool(re.match(pattern, ip))",91
22904768853,string_compression,"def string_compression(s):
    if not s:
        return """"
    
    result = []
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            count += 1
        else:
            result.append(s[i-1] + str(count))
            count = 1
    result.append(s[-1] + str(count))
    return """".join(result)",91
18924643152,second_largest,"def second_largest(nums):
  if len(nums) < 2:
    return None
  first, second = (nums[0], nums[1]) if nums[0] > nums[1] else (nums[1], nums[0])
  for n in nums[2:]:
    if n > first:
      second = first
      first = n
    elif n > second:
      second = n
  return second",91
71358981330,max_sub_array_of_size_k,"def max_sub_array_of_size_k(k, arr):
    max_sum = float('-inf')
    window_sum = 0
    window_start = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end]
        if window_end >= k-1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]
            window_start += 1
    return max_sum",91
73083339036,find_largest_number,"def find_largest_number(nums):
    def compare(x, y):
        return int(str(x) + str(y)) > int(str(y) + str(x))
    
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if not compare(nums[i], nums[j]):
                nums[i], nums[j] = nums[j], nums[i]
                
    return int(''.join(map(str, nums)))",91
4876627121,sum_consecutive,"def sum_consecutive(n):
    count = 0
    i = 1
    while i * (i - 1) < 2 * n:
        a = (float(2 * n - i * (i - 1)) / (2 * i))
        if a - int(a) == 0.0 and a > 0:
            count += 1
        i += 1
    return count",91
39250146761,min_num_coins,"def min_num_coins(coins, amount):
    dp = [amount + 1] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != amount + 1 else -1",91
74612520571,find_primes,"def find_primes(start, end):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    
    primes = []
    for num in range(start, end + 1):
        if is_prime(num):
            primes.append(num)
    return primes",91
3642131806,find_missing_positive,"def find_missing_positive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i]-1] != nums[i]:
            nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
    for i in range(n):
        if nums[i] != i+1:
            return i+1
    return n+1",91
17041953597,is_valid_ipv4,"import re

def is_valid_ipv4(ip):
    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    return bool(re.match(pattern, ip))",91
38042252106,word_break,"def word_break(s, wordDict):
    wordSet = set(wordDict)
    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordSet:
                dp[i] = True
                break

    return dp[len(s)]",91
323528333,construct_string,"from collections import deque

def construct_string(s, wordDict):
    queue = deque([s])
    visited = set()
    while queue:
        current = queue.popleft()
        for word in wordDict:
            if current.startswith(word):
                next_string = current[len(word):]
                if next_string == """":
                    return True
                if next_string not in visited:
                    visited.add(next_string)
                    queue.append(next_string)
    return False",91
9113981015,next_power_of_2,"def next_power_of_2(n):
    """"""
    Calculate the next power of 2 for a given number.
    :param n: an integer
    :return: next power of 2 as an integer
    """"""
    if n == 0:
        return 1
    elif n & (n-1) == 0:
        return n
    else:
        return 1 << (n-1).bit_length()",91
8210139988,is_almost_palindrome,"def is_almost_palindrome(s):
    def helper(l, r, delete):
        while l < r:
            if s[l] != s[r]:
                if delete:
                    return helper(l, r-1, False) or helper(l+1, r, False)
                return False
            l += 1
            r -= 1
        return True

    return helper(0, len(s) - 1, True)",91
5842163467,lucas_sequence,"def lucas_sequence(n):
    if n <= 0:
        return []
    elif n == 1:
        return [2]
    elif n == 2:
        return [2, 1]
    else:
        lucas_list = [2, 1]
        for i in range(2, n):
            lucas_list.append(lucas_list[-1] + lucas_list[-2])
        return lucas_list",90
19778157272,common_substrings,"def common_substrings(s1, s2):
    m, n = len(s1), len(s2)
    count = 0
    for i in range(m):
        for j in range(n):
            length = 0
            while i + length < m and j + length < n and s1[i + length] == s2[j + length]:
                length += 1
            count += length
    return count",90
28464685671,solution,"def solution(x, y):
    oneLess = []
    main = []
    if len(x) > len(y):
        oneLess = y
        main = x
    else:
        oneLess = x
        main = y
    oneLess.sort()
    main.sort()
    for i in range(len(oneLess)):
        if main[i] != oneLess[i]:
            return main[i]
    return main[len(main)-1]",90
6106906132,product_except_self,"def product_except_self(nums):
    length = len(nums)
    answer = [1] * length

    answer[0] = 1
    for i in range(1, length):
        answer[i] = nums[i-1] * answer[i-1]

    R = 1
    for i in reversed(range(length)):
        answer[i] = answer[i] * R
        R *= nums[i]

    return answer",90
32275331071,combination_sum,"def combination_sum(k, n):
    res = []
    def dfs(path, target, start):
        if len(path) == k:
            if target == 0:
                res.append(path)
            return
        for i in range(start, 10):
            if i > target:
                break
            dfs(path + [i], target - i, i + 1)
    dfs([], n, 1)
    return res",90
33760477358,get_min_coins,"def get_min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",90
30412890895,subarray_sum,"def subarray_sum(nums, k):
    sum_occurrence = {0: 1}
    total, current_sum = 0, 0
    
    for num in nums:
        current_sum += num
        if current_sum - k in sum_occurrence:
            total += sum_occurrence[current_sum - k]
        sum_occurrence[current_sum] = sum_occurrence.get(current_sum, 0) + 1
    
    return total",90
38458737388,is_Perfect,"def is_Perfect(n):
    if n < 1:
        return False
    sum = 1
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            if i * (n // i) == n:
                sum = sum + i + n//i
            i += 1
    return sum == n and n!=1",90
31041185942,tribonacci,"def tribonacci(n):
    if n == 0:
        return 0
    elif n == 1 or n == 2:
        return 1
    else:
        a, b, c = 0, 1, 1
        for i in range(3, n+1):
            d = a + b + c
            a, b, c = b, c, d
        return c",90
13245372675,is_valid_ip,"def is_valid_ip(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        number = int(part)
        if number < 0 or number > 255:
            return False
        if part[0] == '0' and len(part) > 1:
            return False
    return True",90
32686835217,matrix_transpose,"def matrix_transpose(matrix):
    """"""
    Returns the transpose of the given matrix.
    """"""
    if not matrix:
        return []
    nrow = len(matrix)
    ncol = len(matrix[0])
    transpose = [[0] * nrow for _ in range(ncol)]
    for i in range(nrow):
        for j in range(ncol):
            transpose[j][i] = matrix[i][j]
    return transpose",90
70940432571,longestSubarrayLessThanOrEqualToK,"def longestSubarrayLessThanOrEqualToK(arr, k):
    n = len(arr)
    max_len = 0
    start = 0
    current_sum = 0
    for end in range(n):
        current_sum += arr[end]
        while current_sum > k:
            current_sum -= arr[start]
            start += 1
        max_len = max(max_len, end - start + 1)
    return max_len",90
75246816665,longest_repeated_substring,"def longest_repeated_substring(s):
    if len(s) == 0:
        return 0
    max_length = 1
    current_length = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1
    return max_length",90
43212952370,merge_intervals,"def merge_intervals(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]

    for interval in intervals[1:]:
        last_merged = merged[-1]

        if interval[0] <= last_merged[1]:
            last_merged[1] = max(last_merged[1], interval[1])
        else:
            merged.append(interval)

    return merged",90
21290653147,smallest_missing,"def smallest_missing(arr):
    arr = set(arr)
    n = 1
    while n in arr:
        n += 1
    return n

# Test cases
assert smallest_missing([1, 3, 6, 4, 1, 2]) == 5
assert smallest_missing([1, 2, 3]) == 4
assert smallest_missing([-1, -3]) == 1",90
11574341297,isPerfectSquare,"import math

def isPerfectSquare(n):
    if n < 0:
        return False
    root = math.sqrt(n)
    return int(root + 0.5) ** 2 == n

def test_isPerfectSquare():
    assert isPerfectSquare(16) == True
    assert isPerfectSquare(14) == False
    assert isPerfectSquare(25) == True

test_isPerfectSquare()",90
40713914324,longest_substring_without_repeating_characters,"def longest_substring_without_repeating_characters(s):
    char_map = {}
    left = 0
    result = """"
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        if right - left + 1 > len(result):
            result = s[left:right+1]
    return result",90
73299527086,most_frequent_char,"def most_frequent_char(string):
    freq = {}
    for char in string:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1

    max_freq = 0
    most_freq_char = None
    for char, count in freq.items():
        if count > max_freq:
            max_freq = count
            most_freq_char = char

    return most_freq_char",90
11561991472,number_to_excel_column,"def number_to_excel_column(n):
    """"""
    Convert a given number to its corresponding Excel column name.
    
    :param n: Integer representing the column number.
    :return: String representing the corresponding Excel column name.
    """"""
    result = ''
    while n > 0:
        n, remainder = divmod(n - 1, 26)
        result = chr(65 + remainder) + result
    return result",90
31474108645,find_unique_paths,"def find_unique_paths(m, n):
    dp = [[0]*n for _ in range(m)]
    for i in range(m):
        for j in range(n):
            if i == 0 or j == 0:
                dp[i][j] = 1
            else:
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",90
69963061880,num_tile_possibilities,"def num_tile_possibilities(n):
    obj = {}
    obj[0] = 1
    obj[1] = 1
    for i in range(2, n+1):
        obj[i] = obj[i-1] + obj[i-2]
    return obj[n]

print(num_tile_possibilities(3))
print(num_tile_possibilities(4))
print(num_tile_possibilities(5))",90
2279252060,find_pairs,"from collections import Counter

def find_pairs(nums, k):
    if k < 0:
        return 0
    freq = Counter(nums)
    result = 0
    if k == 0:
        for num in freq:
            if freq[num] > 1:
                result += 1
    else:
        for num in freq:
            if num + k in freq:
                result += 1
    return result",90
16171812918,top_k_frequent,"import heapq

def top_k_frequent(nums, k):
    count = {}
    for num in nums:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1

    heap = []
    for key, value in count.items():
        heapq.heappush(heap, (-value, key))

    return [heapq.heappop(heap)[1] for i in range(k)]",90
18403958199,filter_restaurants,"def filter_restaurants(restaurants, vegan_friendly, max_price, max_distance):
    filtered = [(id, rating) for id, rating, friendly, price, distance in restaurants 
                if (not vegan_friendly or friendly == 1) and price <= max_price and distance <= max_distance]
    filtered.sort(key=lambda x: (-x[1], -x[0]))
    return [id for id, _ in filtered]",90
40573903531,next_prime,"def next_prime(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    prime_candidate = n + 1
    while True:
        if is_prime(prime_candidate):
            return prime_candidate
        prime_candidate += 1",90
35127893173,longest_substring_length,"def longest_substring_length(s):
    n = len(s)
    char_map = {}
    left = 0
    max_length = 0
    for right in range(n):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",90
73838693943,find_repeated_words,"def find_repeated_words(text):
    words = text.lower().replace(""."", """").replace("","", """").split()
    word_count = {}
    for word in words:
        if word in word_count:
            word_count[word] += 1
        else:
            word_count[word] = 1
    repeated_words = [word for word, count in word_count.items() if count > 1]
    repeated_words.sort()
    return repeated_words",90
12235721680,can_construct_string,"def can_construct_string(s, words):
    word_set = set(words)
    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break

    return dp[len(s)]",90
4581896760,maxSubarrayLength,"def maxSubarrayLength(nums, target):
    max_length = 0
    left = 0
    current_sum = 0

    for right in range(len(nums)):
        current_sum += nums[right]
        while current_sum > target:
            current_sum -= nums[left]
            left += 1
        if current_sum == target:
            max_length = max(max_length, right - left + 1)

    return max_length",90
11908945226,unique_binary_search_trees,"def unique_binary_search_trees(n):
    if n == 0:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",90
28435044487,sort_array,"def sort_array(arr):
    i0 = 0
    i1 = 0
    for i in range(len(arr)):
        tmp = arr[i]
        arr[i] = 2
        if tmp <= 1:
            arr[i1] = 1
            i1 += 1
        if tmp == 0:
            arr[i0] = 0
            i0 += 1
    return arr",90
12186039917,find_max_binary_gap,"def find_max_binary_gap(n):
    binary_str = bin(n)[2:]  # Convert to binary and remove the '0b' prefix.
    max_gap = 0
    current_gap = 0
    for bit in binary_str:
        if bit == '1':
            max_gap = max(max_gap, current_gap)
            current_gap = 0
        else:
            current_gap += 1
    return max_gap",90
15103925820,fibonacci_sum,"def fibonacci_sum(n):
    if n <= 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    a, b = 0, 1
    fib_sum = 1
    for _ in range(2, n):
        a, b = b, a + b
        fib_sum += b
    return fib_sum",90
43551389044,buddy_strings,"def buddy_strings(s: str, goal: str) -> bool:
    if len(s) != len(goal):
        return False

    if s == goal and len(set(s)) < len(s):
        return True

    dif = [(a, b) for a, b in zip(s, goal) if a != b]

    return len(dif) == 2 and dif[0] == dif[1][::-1]",90
16864163432,next_prime,"def next_prime(n):
    def is_prime(num):
        if num <= 1:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    prime_candidate = n + 1
    while True:
        if is_prime(prime_candidate):
            return prime_candidate
        prime_candidate += 1",90
8993579465,longest_zero_sum_subarray,"def longest_zero_sum_subarray(arr):
    sum_to_index = {0: -1}
    max_length = 0
    current_sum = 0
    for i, num in enumerate(arr):
        current_sum += num
        if current_sum in sum_to_index:
            max_length = max(max_length, i - sum_to_index[current_sum])
        else:
            sum_to_index[current_sum] = i
    return max_length",90
74586952465,find_kth_largest,"import heapq

def find_kth_largest(nums, k):
    min_heap = []
    for num in nums:
        heapq.heappush(min_heap, num)

        # If heap size is greater than k then pop the smallest element from heap
        if len(min_heap) > k:
            heapq.heappop(min_heap)

    # The top of the heap will be the kth largest element
    return min_heap[0]",90
8223331286,can_construct,"def can_construct(ransomNote: str, magazine: str) -> bool:
    d = {}
    for i in magazine:
        if i in d:
            d[i] += 1
        else:
            d[i] = 1
    for i in ransomNote:
        if not i in d or d[i] == 0:
            return False
        else:
            d[i] -= 1
    return True",90
15574807708,binary_search,"def binary_search(arr, x):
    low = 0
    high = len(arr) - 1
    mid = 0
 
    while low <= high:
        mid = (high + low) // 2
 
        if arr[mid] < x:
            low = mid + 1
        elif arr[mid] > x:
            high = mid - 1
        else:
            return mid
    return -1",90
13086787555,is_happy_number,"def is_happy_number(n):
    def get_next(number):
        total_sum = 0
        while number > 0:
            number, digit = divmod(number, 10)
            total_sum += digit ** 2
        return total_sum

    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)
        
    return n == 1",90
31457180789,count_subarrays_with_sum,"from collections import defaultdict

def count_subarrays_with_sum(nums, k):
    count = 0
    current_sum = 0
    sum_dict = defaultdict(int)
    sum_dict[0] = 1

    for num in nums:
        current_sum += num
        if current_sum - k in sum_dict:
            count += sum_dict[current_sum - k]
        sum_dict[current_sum] += 1

    return count",90
3177144911,count_unique_bst,"def count_unique_bst(n):
    if n <= 1:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",90
39377284928,is_anagram_palindrome,"def is_anagram_palindrome(s):
    count = [0]*256
    for i in range(0, len(s)):
        count[ord(s[i])] += 1
    odd = 0
    for i in range(0, 256):
        if (count[i] & 1):
            odd += 1
        if (odd > 1):
            return False
    return True",90
71036682583,max_sum_subarray_k,"def max_sum_subarray_k(arr,k):
    max_sum = float('-inf')
    window_sum = 0
    window_start = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end] 
        if window_end >= k-1:
            max_sum = max(max_sum, window_sum)
            window_sum -= arr[window_start]
            window_start += 1
    return max_sum",90
72224481465,max_Product,"def max_Product(arr):
    arr.sort()
    return max(arr[0]*arr[1]*arr[-1], arr[-1]*arr[-2]*arr[-3])

assert max_Product([1, 2, 3]) == 6
assert max_Product([1, 2, 3, 4]) == 24
assert max_Product([-1, -2, -3, -4]) == -6",90
17916856527,next_greater_elements,"def next_greater_elements(nums):
    stack = []
    result = [-1] * len(nums)
    for i in range(2 * len(nums) - 1, -1, -1):
        while stack and stack[-1] <= nums[i % len(nums)]:
            stack.pop()
        if i < len(nums):
            if stack:
                result[i] = stack[-1]
            stack.append(nums[i])
    return result",90
74866335703,longest_Palindrome,"from collections import Counter

def longest_Palindrome(s: str) -> int:
    char_count = Counter(s)
    length = 0
    odd_found = False
    for count in char_count.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_found = True
    if odd_found:
        length += 1
    return length",90
36025328821,can_form,"def can_form(str1: str, str2: str) -> bool:
    table = {}
    for i in str1:
        if i in table:
            table[i] += 1
        else:
            table[i] = 1
    for i in str2:
        if i in table and table[i] > 0:
            table[i] -= 1
        else:
            return False
    return True",90
5230128375,count_unique_bst,"def count_unique_bst(n):
    if n == 0:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",90
1509575701,count_unique_bst,"def count_unique_bst(n):
    if n <= 1:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",90
31956653284,find_second_smallest,"def find_second_smallest(l):
    first_min = None
    second_min = None

    for num in l:
        if first_min is None:
            first_min = num
        else:
            if num < first_min:
                second_min = first_min
                first_min = num
            elif first_min < num:
                if second_min is None or num < second_min:
                    second_min = num

    return second_min",90
38900390641,max_unique_substring,"def max_unique_substring(s: str) -> int:
    char_map = {}
    left = 0
    max_length = 0

    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)

    return max_length",90
25621406551,most_frequent_char,"def most_frequent_char(s):
    freq = {}
    for char in s:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1
    max_freq = 0
    most_frequent = None
    for char, count in freq.items():
        if count > max_freq:
            max_freq = count
            most_frequent = char
    return most_frequent",90
4294199371,find_most_frequent,"def find_most_frequent(numbers):
    number_counts = {}
    max_count = 0
    most_frequent = None
    for number in numbers:
        if number in number_counts:
            number_counts[number] += 1
        else:
            number_counts[number] = 1
        if number_counts[number] > max_count:
            max_count = number_counts[number]
            most_frequent = number
    return most_frequent",90
21969432676,generate_permutations,"def generate_permutations(nums):
    if len(nums) == 1:
        return [nums]
    permutations = []
    for i in range(len(nums)):
        current_num = nums[i]
        remaining_nums = nums[:i] + nums[i+1:]
        sub_permutations = generate_permutations(remaining_nums)
        for sub_permutation in sub_permutations:
            permutations.append([current_num] + sub_permutation)
    return permutations",90
7343748487,longest_arithmetic_sequence,"from collections import defaultdict

def longest_arithmetic_sequence(nums):
    dp = defaultdict(int)
    max_length = 0
    for i in range(len(nums)):
        for j in range(i):
            diff = nums[i] - nums[j]
            dp[(i, diff)] = dp.get((j, diff), 1) + 1
            max_length = max(max_length, dp[(i, diff)])
    return max_length",90
18405278989,num_unique_bst,"def num_unique_bst(n):
    if n == 0:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",90
72217927767,longest_substring_without_repeating,"def longest_substring_without_repeating(s: str) -> int:
    char_set = set()
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
    
    return max_length",90
21546424380,max_unique_pokemon,"def max_unique_pokemon(nums):
    answer = 0
    length = len(nums) // 2
    visited = [False for i in range(len(nums))]
    num = []
    for i in range(len(nums)):
        if len(num) == length: break
        if not visited[i] and not(nums[i] in num):
            visited[i] = True
            num.append(nums[i])            
    return len(num)",90
16246866221,max_diff,"def max_diff(l1): 
	diff = l1[1] - l1[0] 
	minElement = l1[0] 
	for i in range(1, len(l1)): 
		if (l1[i] - minElement > diff): 
			diff = l1[i] - minElement 
		if (l1[i] < minElement): 
			minElement = l1[i] 
	return diff",90
8708602757,coin_sum,"def coin_sum(coins, target):
    dp = [float('inf') for _ in range(target+1)]
    dp[0] = 0
    for coin in coins:
        for i in range(coin, target+1):
            dp[i] = min(dp[i], dp[i-coin]+1)
    if dp[target] == float('inf'):
        return 'No'
    else:
        return 'Yes'",90
30343221587,is_happy_number,"def is_happy_number(n):
    def get_next(n):
        total_sum = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total_sum += digit ** 2
        return total_sum

    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)

    return n == 1",89
73493240793,min_coins,"def min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",89
21204498954,isValidIPv4,"def isValidIPv4(ip):
    nums = ip.split('.')
    if len(nums) != 4:
        return False
    for x in nums:
        if not x.isdigit():
            return False
        i = int(x)
        if i < 0 or i > 255:
            return False
        if len(x) > 1 and x[0] == '0':
            return False
    return True",89
34546011384,odd_sum_subarrays,"def odd_sum_subarrays(arr):
    odd = 0
    even = 0
    count = 0
    mod = 10**9 + 7
    for i in arr:
        if(i&1):
            temp = odd
            odd = even+1
            even = temp
            count+=odd
        else:
            even+=1
            count+=odd
    return count%mod",89
19512188131,minimum_jumps,"def minimum_jumps(nums):
    if len(nums) == 1:
        return 0
    jumps = 0
    current_end = 0
    farthest = 0
    for i in range(len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = farthest
    return jumps",89
22135048554,count_subarrays,"def count_subarrays(nums, k):
    count = {0: 1}
    total = 0
    result = 0
    for i in range(len(nums)):
        total += nums[i]
        if total - k in count:
            result += count[total-k]
        if total in count:
            count[total] += 1
        else:
            count[total] = 1
    return result",89
32504993104,min_coins,"def min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",89
13412388312,is_happy,"def is_happy(n):
    def get_next(n):
        total_sum = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total_sum += digit ** 2
        return total_sum

    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)
    
    return n == 1",89
25621449591,is_valid_ipv4,"def is_valid_ipv4(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        if part[0] == '0' and len(part) > 1:
            return False
        if int(part) < 0 or int(part) > 255:
            return False
    return True",89
2067375753,is_valid_ipv4,"def is_valid_ipv4(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        if part[0] == '0' and len(part) > 1:
            return False
        if int(part) < 0 or int(part) > 255:
            return False
    return True",89
26189249256,min_steps,"def min_steps(n):
    aux = [0] * (n + 1)
    aux[0], aux[1] = 0, 0
    for i in range(2, n + 1):
        aux[i] = 1 + min(aux[i - 1], aux[i - 2], aux[i - 3] if i > 2 else float('inf'))
    return aux[n]",89
10734805598,longest_Substring,"def longest_Substring(s: str) -> int:
    sub_set = {}
    left = 0
    max_len = 0
    for right in range(len(s)):
        if s[right] in sub_set:
            left = max(sub_set[s[right]] + 1, left)
        sub_set[s[right]] = right
        max_len = max(max_len, right - left + 1)
    return max_len",89
15021508601,find132pattern,"def find132pattern(nums):
    if len(nums) < 3:
        return False
    stack = []
    second = float('-inf')
    for i in range(len(nums) - 1, -1, -1):
        if nums[i] < second:
            return True
        while stack and stack[-1] < nums[i]:
            second = stack.pop()
        stack.append(nums[i])
    return False",89
11611607187,isStraightLine,"def isStraightLine(points):
    (x0, y0), (x1, y1) = points[0], points[1]
    for i in range(2, len(points)):
        (x, y) = points[i]
        if (x0 - x1) * (y1 - y) != (x1 - x) * (y0 - y1):
            return False
    return True",89
20527540400,min_elements_to_remove,"def min_elements_to_remove(arr):
    arr.sort()
    remove_count = 0
    i = 0
    while i < len(arr):
        if arr[i] > i + 1:
            remove_count += arr[i] - (i + 1)
            arr = arr[:i] + [i + 1] + arr[i+1:]
        else:
            i += 1
    return remove_count",89
16960582527,check_password,"import re

def check_password(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%^&*]"", password):
        return False
    return True",89
28127951464,check_happy_number,"def check_happy_number(n):
    def get_next(n):
        total_sum = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total_sum += digit ** 2
        return total_sum

    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)
    return n == 1",89
29071323491,min_coins,"def min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",89
18483239789,find_max_consecutive_ones,"def find_max_consecutive_ones(nums):
    count = 0
    max_count = 0
    zero_index = -1
    for i in range(len(nums)):
        if nums[i] == 0:
            count = i - zero_index - 1
            zero_index = i
        else:
            count += 1
        max_count = max(max_count, count)
    return max_count + 1",89
33048105539,remove_element,"class Solution:
    def remove_element(self, nums, val):
        i = 0
        j = 0
        n = len(nums)
        while j < n:
            if nums[j] != val:
                nums[i] = nums[j]
                i += 1
            j += 1
        return i

sol = Solution()
def remove_element(nums, val):
    return sol.remove_element(nums, val)",89
32225235967,count_change,"def count_change(amount, coins):
    """"""
    :type amount: int
    :type coins: List[int]
    :rtype: int
    """"""
    dp = [0] * (amount + 1)
    dp[0] = 1

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]

    return dp[amount]",89
12111239184,min_coins,"def min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",89
33846102167,frequent_char,"def frequent_char(string):
    char_count = {}
    for char in string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    max_count = 0
    frequent_char = ''
    for char, count in char_count.items():
        if count > max_count:
            max_count = count
            frequent_char = char
    return frequent_char",89
22697570463,countBST,"def countBST(n):
    if n == 0 or n == 1:
        return 1
    a = [0] * (n+1)
    a[0], a[1] = 1, 1
    for i in range(2, n+1):
        for j in range(i):
            a[i] += a[j] * a[i-j-1]
    return a[n]",89
8199644805,eval_postfix,"import operator

def eval_postfix(tokens):
    opt = {
        ""+"": operator.add,
        ""-"": operator.sub,
        ""*"": operator.mul,
        ""/"": operator.truediv
    }
    s = []
    for token in tokens:
        if token in opt:
            s.append(int(opt[token](s.pop(-2), s.pop(-1))))
        else:
            s.append(int(token))
    return s[0]",89
34402178229,primeSum,"def isPrime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def primeSum(n):
    sum = 0
    for num in range(2, n+1):
        if isPrime(num):
            sum += num
    return sum",89
7540590029,longest_substring,"def longest_substring(s: str) -> int:
    char_map = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",89
36296589529,max_subarrays_with_zero_sum,"def max_subarrays_with_zero_sum(arr):
    max_count = 0
    curr_sum = 0
    prefix_sum = {0: 1}
    for num in arr:
        curr_sum += num
        if curr_sum in prefix_sum:
            max_count += prefix_sum[curr_sum]
            prefix_sum[curr_sum] += 1
        else:
            prefix_sum[curr_sum] = 1
    return max_count",89
15456822212,min_coins,"def min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",89
6068993772,find_anagrams,"def find_anagrams(words):
    anagram_dict = {}
    for word in words:
        sorted_word = ''.join(sorted(word.lower()))
        if sorted_word in anagram_dict:
            anagram_dict[sorted_word].append(word)
        else:
            anagram_dict[sorted_word] = [word]

    return [anagram_list for anagram_list in anagram_dict.values() if len(anagram_list) > 1]",89
70452265812,largestRectangleArea,"def largestRectangleArea(heights):
    heights.append(0)
    stack = [-1]
    ans = 0
    for i in range(len(heights)):
        while heights[i] < heights[stack[-1]]:
            h = heights[stack.pop()]
            w = i - stack[-1] - 1
            ans = max(ans, h * w)
        stack.append(i)
    heights.pop()
    return ans",89
34625688304,sumOfConsecutive,"def sumOfConsecutive(n):
    count = 0
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            if i % 2 == 1:
                count += 1
            if (n // i) % 2 == 1 and (n // i) != i:
                count += 1
    return count",89
25487510878,moving_average,"def moving_average(nums, window_size):
    if window_size > len(nums) or window_size == 0:
        return []
    result = []
    window_sum = sum(nums[:window_size])
    result.append(window_sum / window_size)
    for i in range(window_size, len(nums)):
        window_sum = window_sum - nums[i - window_size] + nums[i]
        result.append(window_sum / window_size)
    return result",89
9656724221,buddyStrings,"def buddyStrings(A: str, B: str) -> bool:
    if len(A) != len(B):
        return False

    if A == B and len(set(A)) < len(A):
        return True

    diff = [(a, b) for a, b in zip(A, B) if a != b]

    return len(diff) == 2 and diff[0] == diff[1][::-1]",89
32648592985,max_non_adjacent_sum,"def max_non_adjacent_sum(arr):
    """"""
    Finds the maximum sum of a subarray with the constraint that no two elements are adjacent in the original array.
    """"""
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return excl if excl > incl else incl",89
33178919901,check_happy_number,"def check_happy_number(n):
    def get_next(n):
        total_sum = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total_sum += digit ** 2
        return total_sum
    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)
    return n == 1",89
32505342804,check_password,"import re

def check_password(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%^&*]"", password):
        return False
    return True",89
38615109209,minJumps,"def minJumps(nums):
    if len(nums) <= 1:
        return 0

    jumps = 0
    current_end = 0
    farthest = 0

    for i in range(len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = farthest

    return jumps",89
6497889838,find_longest_AP,"from collections import defaultdict

def find_longest_AP(nums):
    dp = defaultdict(int)
    max_len = 1
    for i in range(len(nums)):
        for j in range(i):
            diff = nums[i] - nums[j]
            dp[(i, diff)] = dp[(j, diff)] + 1
            max_len = max(max_len, dp[(i, diff)])
    return max_len + 1",89
42623288686,most_OccurringChar,"def most_OccurringChar(s):
  dict = {}
  for letter in s:
    if letter in dict:
      dict[letter] += 1
    else:
      dict[letter] = 1

  max_val = 0
  max_key = ''
  for key, val in dict.items():
    if val > max_val:
      max_val = val
      max_key = key
  return max_key",89
18695696594,list_permutations,"def list_permutations(lst):
    if len(lst) == 0:
        return []
    if len(lst) == 1:
        return [lst]
    l = []
    for i in range(len(lst)):
        m = lst[i]
        remLst = lst[:i] + lst[i+1:]
        for p in list_permutations(remLst):
            l.append([m] + p)
    return l",89
20734291217,find_substring,"def find_substring(haystack: str, needle: str) -> int:
    if not needle:
        return 0
    for i in range(len(haystack) - len(needle) + 1):
        for j in range(len(needle)):
            if haystack[i + j] != needle[j]:
                break
            elif j == len(needle) - 1:
                return i
    return -1",89
15030277152,valid_password,"import re

def valid_password(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%^&*]"", password):
        return False
    return True",89
11956473204,get_lucky,"def get_lucky(s: str, k: int) -> int:
    trans = """"
    for c in s:
        trans += str(ord(c) - ord('a') + 1)
    for _ in range(k):
        trans = sum_digits(trans)
    return int(trans)

def sum_digits(n):
    res = 0
    for i in str(n):
        res += int(i)
    return str(res)",89
17838265458,max_sliding_window,"from collections import deque
def max_sliding_window(nums, k):
    window = deque()
    res = []
    for i in range(len(nums)):
        while window and nums[i] >= nums[window[-1]]:
            window.pop()
        window.append(i)
        if window[0] <= i-k:
            window.popleft()
        if i >= k-1:
            res.append(nums[window[0]])
    return res",89
31097395884,generate_permutations,"def generate_permutations(nums):
    if len(nums) == 0:
        return []
    if len(nums) == 1:
        return [nums]

    permutations = []
    for i in range(len(nums)):
        current_num = nums[i]
        remaining_nums = nums[:i] + nums[i+1:]
        for perm in generate_permutations(remaining_nums):
            permutations.append([current_num] + perm)
    return permutations",89
22965090430,find_most_frequent_character,"def find_most_frequent_character(s):
    frequency = {}
    max_freq = 0
    for char in s:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
        max_freq = max(max_freq, frequency[char])
    result = []
    for char, freq in frequency.items():
        if freq == max_freq:
            result.append(char)
    return result",89
34628869301,min_cost_climbing_stairs,"def min_cost_climbing_stairs(cost):
    len1 = len(cost)
    ans = [0] * len1
    ans[0], ans[1] = cost[0], cost[1]
    for i in range(2, len1):
        ans[i] = min(ans[i - 2], ans[i - 1]) + cost[i]
    return min(ans[-1], ans[-2])",89
4196770137,buddy_strings,"def buddy_strings(s: str, goal: str) -> bool:
    if len(s) != len(goal):
        return False
    if s == goal and len(set(s)) < len(s):
        return True
    diff = [(a, b) for a, b in zip(s, goal) if a != b]
    return len(diff) == 2 and diff[0] == diff[1][::-1]",89
10325972006,is_perfect_number,"def is_perfect_number(n):
    if n < 1:
        return False
    sum_of_divisors = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            sum_of_divisors += i
            if i != n // i:
                sum_of_divisors += n // i
    return sum_of_divisors == n",89
74533794696,password_check,"import re

def password_check(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    if not re.search(""[!@#$%^&*]"", password):
        return False
    return True",89
2924068905,first_missing_positive,"def first_missing_positive(nums):
    nums.sort()
    one = 1
    if one not in nums:
        return 1
    a = nums.index(1)
    for i in range(a+1, len(nums)):
        if nums[i]-nums[i-1]>1:
            return nums[i-1]+1
        if i == len(nums)-1:
            return nums[i]+1
    return 2",89
36001586851,maxSlidingWindow,"from collections import deque

def maxSlidingWindow(nums, k):
    d = deque()
    out = []
    for i, n in enumerate(nums):
        while d and nums[d[-1]] < n:
            d.pop()
        d += i,
        if d[0] == i - k:
            d.popleft()
        if i >= k - 1:
            out += nums[d[0]],
    return out",89
9795808178,is_valid_ip,"def is_valid_ip(ip: str) -> bool:
    octets = ip.split('.')
    if len(octets) != 4:
        return False
    for octet in octets:
        if not octet.isdigit() or not (0 <= int(octet) <= 255) or (octet.startswith('0') and len(octet) > 1):
            return False
    return True",89
23546701850,is_anagram_of_palindrome,"def is_anagram_of_palindrome(str1):
  char_count = {}
  for char in str1:
    if char in char_count:
      char_count[char] += 1
    else:
      char_count[char] = 1

  odd_count = 0
  for count in char_count.values():
    if count % 2 != 0:
      odd_count += 1

  return odd_count <= 1",89
3553550693,maxDiff,"def maxDiff(arr): 
    max_diff = arr[1] - arr[0] 
    min_element = arr[0] 
    for i in range(1, len(arr)): 
        if (arr[i] - min_element) > max_diff: 
            max_diff = arr[i] - min_element 
  
        if arr[i] < min_element: 
            min_element = arr[i] 
    return max_diff",89
37282873958,minimum_coins,"def minimum_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1",89
38616795800,count_ways,"def count_ways(n):
    if n == 1:
        return 1
    if n == 2:
        return 2
    one_step_before = 2
    two_steps_before = 1
    for _ in range(2, n):
        current_step = one_step_before + two_steps_before
        two_steps_before = one_step_before
        one_step_before = current_step
    return current_step",89
40404449863,is_anagram_of_palindrome,"def is_anagram_of_palindrome(test_str):
    char_count = {}
    for char in test_str:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1",89
14694895155,is_valid_ipv4,"def is_valid_ipv4(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        if part[0] == '0' and len(part) > 1:
            return False
        if int(part) < 0 or int(part) > 255:
            return False
    return True",89
10896192256,find_common_divisors,"def find_common_divisors(n, m):
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    common_divisors = 0
    for i in range(1, gcd(n, m) + 1):
        if n % i == 0 and m % i == 0:
            common_divisors += 1
    return common_divisors",89
2270232353,shell_sort,"def shell_sort(nums):
    gap = len(nums) // 2
    while gap > 0:
        for i in range(gap, len(nums)):
            tmp = nums[i]
            j = i
            while j >= gap and nums[j - gap] > tmp:
                nums[j] = nums[j - gap]
                j -= gap
            nums[j] = tmp
        gap //= 2
    return nums",89
31042487180,merge_intervals,"def merge_intervals(intervals):
    if not intervals:
        return []
    
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    
    for interval in intervals[1:]:
        if interval[0] <= merged[-1][1]:
            merged[-1][1] = max(merged[-1][1], interval[1])
        else:
            merged.append(interval)
    
    return merged",89
14198389233,largest_number_in_binary_tree,"def largest_number_in_binary_tree(tree):
    if not tree:
        return None
    max_val = float('-inf')
    def dfs(node):
        nonlocal max_val
        if node < len(tree) and tree[node] is not None:
            max_val = max(max_val, tree[node])
            dfs(2*node+1)
            dfs(2*node+2)
    dfs(0)
    return max_val",89
42236890242,minimum_coins,"def minimum_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",89
72617758145,mostCommonWord,"from collections import Counter
import re

def mostCommonWord(paragraph: str, banned: list[str]) -> str:
    counts = Counter()
    banned_words = set(banned)

    words = re.findall(r'\w+', paragraph.lower())
    for word in words:
        if word not in banned_words:
            counts[word] += 1
    return max(counts.items(), key=lambda p: p[1])[0]",89
10990623815,min_coins,"def min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",89
32424095761,combination_sum,"def combination_sum(k, n):
  res = []
  def dfs(path, target, start):
    if len(path) == k:
      if target == 0:
        res.append(path)
      return
    for i in range(start, 10):
      if i > target: break
      dfs(path + [i], target - i, i + 1)
  dfs([], n, 1)
  return res",89
19765835321,find_largest_palindrome,"def find_largest_palindrome(min_limit, max_limit):
    largest_palindrome = 0
    for x in range(max_limit, min_limit-1, -1):
        for y in range(x, min_limit-1, -1):
            product = x * y
            if str(product) == str(product)[::-1] and product > largest_palindrome:
                largest_palindrome = product
    return largest_palindrome",89
42203691757,largestRectangleArea,"def largestRectangleArea(heights):
    stack = [-1]
    heights = [0] + heights + [0]
    res = 0
    for i in range(len(heights)):
        while stack and heights[stack[-1]] > heights[i]:
            tmp = stack.pop()
            res = max(res, (i - stack[-1] - 1) * heights[tmp])
        stack.append(i)
    return res",89
20064647052,reverseWords,"def reverseWords(s):
    # Remove leading and trailing spaces
    s = s.strip()
    # Split the string into words
    words = s.split(' ')
    # Remove empty strings caused by multiple spaces
    words = [word for word in words if word]
    # Reverse the list of words
    words.reverse()
    # Join the words back into a string with a single space
    return ' '.join(words)",89
70446157236,gcd_lcm,"def gcd_lcm(n, m):
    # Greatest Common Divisor (GCD)
    gcd = 1
    for i in range(1, min(n, m) + 1):
        if n % i == 0 and m % i == 0:
            gcd = i

    # Least Common Multiple (LCM)
    lcm = (n * m) // gcd

    return (gcd, lcm)",89
9855382016,num_trees,"def num_trees(n):
    if n <= 1:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",88
24463710676,min_squares,"def min_squares(n):
    dp = [float('inf')] * (n + 1)
    dp[0] = 0

    for i in range(1, n + 1):
        j = 1
        while j * j <= i:
            dp[i] = min(dp[i], dp[i - j * j] + 1)
            j += 1

    return dp[n]",88
34420560347,make_change,"def make_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",88
35623408959,longest_zero_sum_subarray,"def longest_zero_sum_subarray(nums):
    sumTable = {}
    sumTable[0] = -1
    curSum = 0
    maxLength = 0
    for i in range(len(nums)):
        curSum += nums[i]
        if curSum in sumTable:
            maxLength = max(maxLength, i - sumTable[curSum])
        else:
            sumTable[curSum] = i
    return maxLength",88
1186396594,remove_occurrences,"from typing import List

def remove_occurrences(nums: List[int], val: int) -> List[int]:
    count = 0
    i = 0
    while i < len(nums):
        if nums[i] == val:
            if count < 2:
                count += 1
                i += 1
            else:
                nums.pop(i)
        else:
            i += 1
    return nums",88
29741316694,is_valid_parentheses,"def is_valid_parentheses(s: str) -> bool:
    stack = []
    map = {"")"": ""("", ""]"": ""["", ""}"": ""{""}
    
    for char in s:
        if char in map.values():
            stack.append(char)
        elif char in map.keys():
            if stack == [] or map[char] != stack.pop():
                return False
        else:
            return False
    return stack == []",88
534180693,min_parentheses_removal,"def min_parentheses_removal(parentheses: str) -> int:
    open_count = 0
    invalid_close_count = 0
    for char in parentheses:
        if char == '(':
            open_count += 1
        elif char == ')' and open_count > 0:
            open_count -= 1
        else:
            invalid_close_count += 1
    return open_count + invalid_close_count",88
13573097148,coinChange,"def coinChange(coins, amount):
    dp = [0] + [float('inf')] * amount
    for i in range(1, amount + 1):
        dp[i] = min([dp[i - c] if i - c >= 0 else float('inf') for c in coins]) + 1
    return dp[amount] if dp[amount] != float('inf') else -1",88
37071892187,uncommon_words,"def uncommon_words(A, B):
    """"""
    :type A: str
    :type B: str
    :rtype: List[str]
    """"""
    word_dict = {}
    for word in (A + ' ' + B).split():
        word_dict[word] = word_dict.get(word, 0) + 1
    return [key for key, value in word_dict.items() if value == 1]",88
3612220531,nth_prime,"def nth_prime(n):
    count = 0
    number = 1
    while count < n:
        number += 1
        is_prime = True
        for k in range(2, int(number**0.5) + 1):
            if number % k == 0:
                is_prime = False
                break
        if is_prime == True:
            count += 1
    return number",88
72711320338,is_happy,"def is_happy(n):
    def get_next(n):
        total_sum = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total_sum += digit ** 2
        return total_sum

    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)
    return n == 1",88
17876096470,count_equal_pairs,"def count_equal_pairs(numbers):
    pair_count = 0
    number_count = {}
    for number in numbers:
        if number in number_count:
            number_count[number] += 1
        else:
            number_count[number] = 1

    for count in number_count.values():
        if count > 1:
            pair_count += (count * (count - 1)) // 2

    return pair_count",88
74904011957,min_diff,"def min_diff(list_nums):
  if len(list_nums) < 2:
    return None
  list_nums.sort()
  min_difference = abs(list_nums[0] - list_nums[1])
  for i in range(1, len(list_nums)-1):
    difference = abs(list_nums[i] - list_nums[i + 1])
    if difference < min_difference:
      min_difference = difference
  return min_difference",88
6165632387,length_of_longest_unique_substring,"def length_of_longest_unique_substring(s):
    char_map = {}
    left = 0
    max_length = 0

    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)

    return max_length",88
5283467057,nth_tribonacci,"def nth_tribonacci(n):
    if n == 0:
        return 0
    elif n == 1 or n == 2:
        return 1
    else:
        a, b, c = 0, 1, 1
        for i in range(3, n + 1):
            a, b, c = b, c, a + b + c
        return c",88
4083033566,find_tribonacci,"def find_tribonacci(n):
    if n == 0:
        return 0
    elif n == 1 or n == 2:
        return 1
    else:
        a, b, c = 0, 1, 1
        for i in range(3, n + 1):
            a, b, c = b, c, a + b + c
        return c",88
6763685215,move_zeros,"def move_zeros(arr):
    length = len(arr)
    counter = 0
    newArr = []
    while(counter != length):
        if(counter > length):
            break
        if(arr[counter] != 0):
            newArr.append(arr[counter])
            counter += 1
        else:
            counter += 1
    for i in range(len(arr) - len(newArr)):
        newArr.append(0)
    return newArr",88
39658491450,largest_product,"def largest_product(n: int, k: int) -> int:
    s = str(n)
    if k > len(s):
        return 0
    max_product = 0
    for i in range(len(s) - k + 1):
        product = 1
        for j in range(k):
            product *= int(s[i+j])
        max_product = max(max_product, product)
    return max_product",88
28447325880,coinChange,"def coinChange(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",88
26932902831,coin_change,"def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",88
9364402629,count_subarrays_with_sum,"def count_subarrays_with_sum(nums, target):
    count = 0
    sum_dict = {0: 1}
    current_sum = 0
    for num in nums:
        current_sum += num
        if current_sum - target in sum_dict:
            count += sum_dict[current_sum - target]
        sum_dict[current_sum] = sum_dict.get(current_sum, 0) + 1
    return count",88
31042557120,list_permutation,"def list_permutation(nums):
    """"""
    :type nums: List[int]
    :rtype: List[List[int]]
    """"""
    result = []

    def dfs(result, ans, nums):
        if not nums:
            result.append(ans)
        for i in range(len(nums)):
            dfs(result, ans + [nums[i]], nums[:i] + nums[i+1:])
    
    dfs(result, [], nums)
    return result",88
38421355368,subarray_count,"from collections import Counter

def subarray_count(nums, target):
    counter = Counter()
    counter[0] = 1
    sum_acc, ans = 0, 0
    
    for i, item in enumerate(nums):
        sum_acc += nums[i]
        if sum_acc - target in counter:
            ans += counter[sum_acc - target]
        
        counter[sum_acc] += 1
        
    return ans",88
34556242802,do_rectangles_intersect,"def do_rectangles_intersect(rect1, rect2):
    x1, y1, w1, h1 = rect1
    x2, y2, w2, h2 = rect2
    if x1 + w1 < x2 or x2 + w2 < x1 or y1 + h1 < y2 or y2 + h2 < y1:
        return False
    return True",88
9902978131,is_self_dividing,"def is_self_dividing(n):
    """"""
    :type n: int
    :rtype: bool
    """"""
    original = n
    while n > 0:
        digit = n % 10
        # a self-dividing number cannot contain a zero digit
        if digit == 0 or original % digit != 0:
            return False
        n = n // 10
    return True",88
15024833673,make_change,"def make_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1",88
38474997902,generate_brackets,"def generate_brackets(n):
    def backtrack(s, left, right):
        if len(s) == 2 * n:
            res.append(s)
            return
        if left < n:
            backtrack(s + '(', left + 1, right)
        if right < left:
            backtrack(s + ')', left, right + 1)

    res = []
    backtrack('', 0, 0)
    return res",88
22072822295,find_missing_numbers,"def find_missing_numbers(nums):
    for i in range(len(nums)):
        while nums[i] != i + 1 and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    return [i + 1 for i in range(len(nums)) if nums[i] != i + 1]",88
18405679799,isValidIP,"def isValidIP(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        i = int(part)
        if i < 0 or i > 255:
            return False
        if len(part) > 1 and part[0] == '0':
            return False
    return True",88
1371984315,length_of_longest_substring,"def length_of_longest_substring(s):
    char_map = {}
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    
    return max_length",88
5578238999,smallest_distance,"from math import sqrt

def smallest_distance(points):
    min_distance = float('inf')
    for i in range(len(points)):
        for j in range(i + 1, len(points)):
            distance = sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)
            if distance < min_distance:
                min_distance = distance
    return min_distance",88
71942462828,longest_subarray_sum,"def longest_subarray_sum(nums, k):
    s, res = 0, 0
    d = {}
    for index in range(len(nums)):
        s += nums[index]
        if s == k:
            res = index + 1
        if s-k in d:
            res = max(res, index - d[s-k])
        if s not in d:
            d[s] = index
    return res",88
766901412,numGoodPairs,"from typing import List


def numGoodPairs(nums: List[int]) -> int:
    count = {}
    good_pairs = 0
    
    for num in nums:
        if not num in count:
            count[num] = 0
        count[num] += 1
    
    for num in count:
        good_pairs += (count[num] * (count[num] - 1)) // 2
    
    return good_pairs",88
33760358998,max_difference,"def max_difference(arr):
    if len(arr) < 2:
        return 0
    min_val = arr[0]
    max_diff = 0
    for i in range(1, len(arr)):
        if arr[i] - min_val > max_diff:
            max_diff = arr[i] - min_val
        if arr[i] < min_val:
            min_val = arr[i]
    return max_diff",88
71321197437,erase_overlap_intervals,"def erase_overlap_intervals(intervals):
    if not intervals:
        return 0

    intervals.sort(key=lambda x: x[1])
    count = 0
    prev_end = intervals[0][1]

    for i in range(1, len(intervals)):
        if intervals[i][0] < prev_end:
            count += 1
        else:
            prev_end = intervals[i][1]

    return count",88
8853702402,angleClock,"def angleClock(hour: int, minutes: int) -> float:
    hour = hour % 12
    hour_angle = (hour * 30) + (minutes / 60) * 30
    minute_angle = minutes * 6
    angle = abs(hour_angle - minute_angle)
    if angle > 180:
        angle = 360 - angle
    return angle",88
42446871174,num_trees,"def num_trees(n):
    if n == 0:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",88
11690950069,check_brackets,"def check_brackets(s: str) -> bool:
    pair = {"")"": ""("", ""]"": ""["", ""}"": ""{""}
    stack = list()
    for parenthesis in s:
        if parenthesis in pair.values():
            stack.append(parenthesis)
        elif parenthesis in pair.keys():
            if len(stack) == 0 or stack.pop() != pair[parenthesis]:
                return False
    return len(stack) == 0",88
5860106744,length_of_longest_substring,"def length_of_longest_substring(s: str) -> int:
    char_map = {}
    left = 0
    result = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        result = max(result, right - left + 1)
    return result",88
31157912779,longest_subarray_with_sum,"def longest_subarray_with_sum(nums, target):
    max_len = 0
    sum_so_far = 0
    start = 0

    for end in range(len(nums)):
        sum_so_far += nums[end]

        while sum_so_far > target:
            sum_so_far -= nums[start]
            start += 1

        max_len = max(max_len, end - start + 1)

    return max_len",88
37073480709,checkStraightLine,"def checkStraightLine(coordinates):
    (x0, y0), (x1, y1) = coordinates[0], coordinates[1]
    
    for i in range(2, len(coordinates)):
        x, y = coordinates[i]
        if (x0 - x1) * (y1 - y) != (x1 - x) * (y0 - y1):
            return False
    return True",88
38047850415,is_happy_string,"def is_happy_string(s: str) -> bool:
    for i in range(len(s)):
        if i > 0 and s[i] == s[i-1]:
            return False
        if i > 1 and s[i-2:i+1] in [""aaa"", ""bbb"", ""ccc""]:
            return False
    return all(c in ['a', 'b', 'c'] for c in s)",88
7001907340,find_combinations,"def find_combinations(nums, target):
    def backtrack(start, path, target):
        if target == 0:
            result.append(path)
            return
        for i in range(start, len(nums)):
            if nums[i] > target:
                continue
            backtrack(i, path + [nums[i]], target - nums[i])
    
    nums.sort()
    result = []
    backtrack(0, [], target)
    return result",88
38869790663,find_second_max,"def find_second_max(arr):
    if len(arr) < 2:
        return None
    first_max = second_max = float('-inf')
    for num in arr:
        if num > first_max:
            second_max = first_max
            first_max = num
        elif num > second_max and num != first_max:
            second_max = num
    return second_max if second_max != float('-inf') else None",88
27667166314,ways_to_write_n_as_sum,"def ways_to_write_n_as_sum(n):
    dp = [0] * (n+1)
    dp[0] = 1 # Base case
    for i in range(1, n+1):
        for j in range(i, n+1):
            dp[j] += dp[j - i]
    return dp[n] - 1 # Subtracting 1 for the case where n is written as itself",88
41129566243,num_trees,"def num_trees(n):
    if n == 0:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",88
26172988621,find_Duplicate,"def find_Duplicate(nums):
    tortoise = nums[0]
    hare = nums[0]
    while True:
        tortoise = nums[tortoise]
        hare = nums[nums[hare]]
        if tortoise == hare:
            break

    tortoise = nums[0]
    while tortoise != hare:
        tortoise = nums[tortoise]
        hare = nums[hare]

    return tortoise",88
70928308666,subarrayCount,"from collections import defaultdict

def subarrayCount(nums, k):
    count = 0
    sum = 0
    sum_dict = defaultdict(int)
    sum_dict[0] = 1
    for i in range(len(nums)):
        sum += nums[i]
        if sum - k in sum_dict:
            count += sum_dict[sum - k]
        sum_dict[sum] += 1
    return count",88
36354600166,non_overlapping_intervals,"from typing import List


def non_overlapping_intervals(intervals: List[List[int]]) -> int:
    if not intervals:
        return 0

    intervals.sort(key=lambda x: x[1])
    count = 1
    end = intervals[0][1]

    for start, end_next in intervals[1:]:
        if start >= end:
            count += 1
            end = end_next

    return count",88
16865276088,decimal_to_base,"def decimal_to_base(decimal_number, base):
    if base < 2 or base > 36:
        return ""Invalid base""
    
    digits = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    result = """"
    
    while decimal_number > 0:
        remainder = decimal_number % base
        result = digits[remainder] + result
        decimal_number = decimal_number // base
    
    return result",88
74064383569,merge_intervals,"def merge_intervals(intervals):
    if len(intervals) == 0:
        return []

    intervals.sort()
    result = [intervals[0]]
    for interval in intervals[1:]:
        last_interval = result[-1]
        if last_interval[1] >= interval[0]:
            last_interval[1] = max(last_interval[1], interval[1])
        else:
            result.append(interval)
    return result",88
73656265617,max_consecutive,"def max_consecutive(s):
    max_len = 1
    current_len = 1
    if len(s) == 1:
        return max_len
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_len += 1
            max_len = max(max_len, current_len)
        else:
            current_len = 1
    return max_len",88
14338679713,maxZeroSumSubarrays,"def maxZeroSumSubarrays(arr):
    max_count = 0
    sum_count = {0: 1}
    current_sum = 0
    for num in arr:
        current_sum += num
        if current_sum in sum_count:
            max_count += sum_count[current_sum]
            sum_count[current_sum] += 1
        else:
            sum_count[current_sum] = 1
    return max_count",88
70726629881,find_n_digit,"def find_n_digit(n):
    digit = 1
    while n > 9 * digit * 10 ** (digit - 1):
        n -= 9 * digit * 10 ** (digit - 1)
        digit += 1
    quotient, remainder = divmod(n - 1, digit)
    return int(str(10 ** (digit - 1) + quotient)[remainder])",88
72418396286,pascal_triangle_row,"def pascal_triangle_row(n):
    if n == 0:
        return [1]
    elif n == 1:
        return [1, 1]
    else:
        row = [1]
        for j in range(1, n):
            row.append(pascal_triangle_row(n-1)[j-1] + pascal_triangle_row(n-1)[j])
        row.append(1)
        return row",88
22539266781,find_most_frequent_char,"def find_most_frequent_char(s):
    char_freq = {}
    for char in s:
        if char in char_freq:
            char_freq[char] += 1
        else:
            char_freq[char] = 1
    max_freq = max(char_freq.values())
    most_frequent_chars = [char for char, freq in char_freq.items() if freq == max_freq]
    return min(most_frequent_chars)",88
1405145047,find_two_sum,"def find_two_sum(nums, target):
    """"""
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    """"""
    num_to_index = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_to_index:
            return [num_to_index[complement], i]
        num_to_index[num] = i
    return []",88
71012429577,num_trees,"def num_trees(n):
    if n == 0:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",88
31504966424,longest_unique_subarray,"def longest_unique_subarray(arr):
    n = len(arr)
    start = 0
    max_len = 0
    seen = {}
    
    for end in range(n):
        if arr[end] in seen:
            start = max(start, seen[arr[end]] + 1)
        seen[arr[end]] = end
        max_len = max(max_len, end - start + 1)
    
    return max_len",88
28076233272,make_change,"def make_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",88
3238097226,nth_permutation,"from functools import reduce
def nth_permutation(lst, n):
    numbers = lst.copy()
    NN = reduce(lambda x, y: x*y, numbers)
    n = (n-1) % NN
    result = []
    while len(numbers) > 0:
        NN = NN // len(numbers)
        i, n = n // NN, n % NN
        result.append(numbers.pop(i))
    return result",88
33624610879,shortest_word_distance,"def shortest_word_distance(wordsDict, word1, word2):
    res = len(wordsDict)
    prev = -1
    for i, w in enumerate(wordsDict):
        if w == word1 or w == word2:
            if prev != -1 and (word1 == word2 or wordsDict[prev] != w):
                res = min(res, i - prev)
            prev = i
    return res",88
13042414963,longest_no_repeat_substring,"def longest_no_repeat_substring(s):
    char_map = {}
    left = 0
    result = """"
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        if right - left + 1 > len(result):
            result = s[left:right+1]
    return result",88
2175400675,max_difference,"def max_difference(lst):
    if len(lst) < 2:
        return 0
    min_val = lst[0]
    max_diff = 0
    for i in range(1, len(lst)):
        if lst[i] - min_val > max_diff:
            max_diff = lst[i] - min_val
        if lst[i] < min_val:
            min_val = lst[i]
    return max_diff",88
15210927089,numTrees,"def numTrees(n):
    if n == 0:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",88
11218358396,isHappy,"def isHappy(n):
    def get_next(n):
        total_sum = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total_sum += digit ** 2
        return total_sum

    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)
        
    return n == 1",88
16865106618,max_unique_substring_length,"def max_unique_substring_length(s: str) -> int:
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length",88
16080788623,coinChange,"def coinChange(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",88
27207782913,is_unique,"def is_unique(s):
    bit_flag = 0
    for ch in s:
        x = ord(ch) - ord('a')
        if x < 0 or x > 25:
            raise ValueError(""Input string must contain only lowercase letters."")
        if (bit_flag >> x) & 1 == 0:
            bit_flag |= 1 << x
        else:
            return False
    return True",88
43972449580,top_k_frequent,"from typing import List
from collections import Counter
import heapq

def top_k_frequent(nums: List[int], k: int) -> List[int]:
    counter = Counter(nums)
    heap = []
    for num, freq in counter.items():
        heapq.heappush(heap, (-freq, num))
    result = []
    for _ in range(k):
        result.append(heapq.heappop(heap)[1])
    return result",88
74608437485,string_permutation,"def string_permutation(s):
    if len(s) == 1:
        return {s}
    first = s[0]
    remainder = s[1:]
    remainder_permutations = string_permutation(remainder)
    result = set()
    for perm in remainder_permutations:
        for i in range(len(perm) + 1):
            result.add(perm[:i] + first + perm[i:])
    return result",88
5981892239,coin_change,"def coin_change(coins, amount):
    dp = [float(""inf"")] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float(""inf"") else -1",88
11595375676,max_diff,"def max_diff(arr):
    if len(arr) < 2:
        return 0
    max_diff = 0
    min_element = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",88
15670321986,find_longest_substring,"def find_longest_substring(s):
    char_map = {}
    left = 0
    result = """"
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        if right - left + 1 > len(result):
            result = s[left:right+1]
    return result",88
71242598263,check_password,"import re

def check_password(password):
    if len(password) < 8:
        return False
    elif not re.search(""[a-z]"", password):
        return False
    elif not re.search(""[A-Z]"", password):
        return False
    elif not re.search(""[0-9]"", password):
        return False
    elif not re.search(""[_@$]"", password):
        return False
    else:
        return True",88
27046075887,is_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    max_divisor = int(n**0.5) + 1
    for d in range(3, max_divisor, 2):
        if n % d == 0:
            return False
    return True",88
22256168474,coinChange,"def coinChange(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1",88
37608611180,count_permutations,"from math import factorial

def count_permutations(s: str) -> int:
    char_counts = [0] * 26
    for char in s:
        char_counts[ord(char) - ord('A')] += 1
    
    total_permutations = factorial(len(s))
    for count in char_counts:
        if count > 1:
            total_permutations //= factorial(count)
    
    return total_permutations",87
4729725207,max_unique_substring,"def max_unique_substring(s: str) -> int:
    char_set = set()
    left = 0
    max_length = 0
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
    return max_length",87
32864120734,subarrays_with_sum,"def subarrays_with_sum(arr, k):
    d = {0: 1}
    ans = 0
    s = 0
    for item in arr:
        s += item
        if (s - k) in d:
            ans += d[s - k]
        if s in d:
            d[s] += 1
        else:
            d[s] = 1
    return ans",87
36427355989,most_frequent,"def most_frequent(arr):
    counter = {}
    for num in arr:
        if num in counter:
            counter[num] += 1
        else:
            counter[num] = 1
    max_freq = 0
    max_num = 0
    for key in counter:
        if counter[key] > max_freq:
            max_freq = counter[key]
            max_num = key
    return max_num",87
28603151920,stairClimbWays,"def stairClimbWays(n):
    if n == 0 or n == 1:
        return 1
    elif n == 2:
        return 2
    a, b, c = 1, 1, 2
    for _ in range(3, n + 1):
        a, b, c = b, c, a + b + c
    return c",87
6600958007,is_perfect_number,"def is_perfect_number(n):
    if n < 1:
        return False
    sum = 1
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            if i * (n // i) == n:
                sum = sum + i + n//i
            i += 1
    return sum == n",87
8282598555,jump,"def jump(nums):
    if len(nums) == 1:
        return 0
    jumps = 0
    current_end = 0
    farthest = 0
    for i in range(len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = farthest
    return jumps",87
35851848538,pascal_row,"def pascal_row(n):
    row = [1] * (n + 1)
    for i in range(n + 1):
        row[i] = comb(n, i)
    return row

def comb(n, k):
    result = 1
    for i in range(1, k + 1):
        result = result * (n - i + 1) // i
    return result",87
6061130355,find_duplicate,"def find_duplicate(nums):
    tortoise = nums[0]
    hare = nums[0]
    while True:
        tortoise = nums[tortoise]
        hare = nums[nums[hare]]
        if tortoise == hare:
            break

    tortoise = nums[0]
    while tortoise != hare:
        tortoise = nums[tortoise]
        hare = nums[hare]

    return tortoise",87
73965313720,findMaxAverage,"from collections import deque

def findMaxAverage(nums, k):
    queue = deque()
    max_avg = float('-inf')
    window_sum = 0
    for i, num in enumerate(nums):
        queue.append(num)
        window_sum += num
        if i >= k - 1:
            max_avg = max(max_avg, window_sum / k)
            window_sum -= queue.popleft()
    return max_avg",87
9967087289,longest_ordered_substring,"def longest_ordered_substring(s: str) -> str:
    if not s:
        return """"
    
    longest = current = s[0]
    
    for i in range(1, len(s)):
        if s[i] >= s[i-1]:
            current += s[i]
            if len(current) > len(longest):
                longest = current
        else:
            current = s[i]
    
    return longest",87
71704789267,sum_of_two_largest,"def sum_of_two_largest(nums):
    if len(nums) < 2:
        raise ValueError(""List should contain at least 2 elements"")
    max1 = max2 = float('-inf')
    for num in nums:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2:
            max2 = num
    return max1 + max2",87
489822653,subarrays_with_product_less_than_k,"def subarrays_with_product_less_than_k(arr, k):
    if k <= 1:
        return 0

    prod = 1
    result = 0
    left = 0
    for right in range(len(arr)):
        prod *= arr[right]
        while prod >= k:
            prod /= arr[left]
            left += 1
        result += right - left + 1
    return result",87
5984823790,median_of_two_sorted_arrays,"def median_of_two_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]

# optimization to meet O(log (m+n)) is left to the reader",87
19735958024,min_perimeter,"def min_perimeter(N):
    factor = []
    i = 1
    while i * i < N:
        n,res = divmod(N,i)
        if res == 0:
            factor.append((i,n))
        i += 1
        
    if i * i == N:
        factor.append((i,i))

        
    A,B = factor[-1]
    return 2 * (A + B)",87
43494984836,longest_substring,"def longest_substring(s):
    char_map = {}
    left = 0
    result = """"
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        if len(result) < right - left + 1:
            result = s[left:right+1]
        char_map[s[right]] = right
    return result",87
31454640087,longest_zero_sum_subarray,"def longest_zero_sum_subarray(arr):
    sum_to_index = {0: -1}
    sum = 0
    max_len = 0
    for i in range(len(arr)):
        sum += arr[i]
        if sum in sum_to_index:
            max_len = max(max_len, i - sum_to_index[sum])
        else:
            sum_to_index[sum] = i
    return max_len",87
34765569665,is_anagram_of_palindrome,"def is_anagram_of_palindrome(str):
    char_count = {}
    for char in str:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1",87
2846346021,max_unique_substring_length,"def max_unique_substring_length(s):
    char_map = {}
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    
    return max_length",87
36206482664,max_unique_substring,"def max_unique_substring(s: str) -> int:
    char_set = set()
    left = 0
    max_length = 0
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
    return max_length",87
4196420437,numSubarrayProductLessThanK,"def numSubarrayProductLessThanK(nums, k):
    if k < 2:
        return 0
    ans = 0
    i = 0
    curr = 1
    for j, num in enumerate(nums):
        curr *= num
        while curr >= k:
            curr //= nums[i]
            i += 1
        ans += j - i + 1
    return ans",87
16142792070,longest_substring_length,"def longest_substring_length(s: str) -> int:
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length",87
12371869412,is_valid_bracket_sequence,"def is_valid_bracket_sequence(s):
    stack = []
    bracket_map = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in bracket_map.values():
            stack.append(char)
        elif char in bracket_map.keys():
            if stack == [] or stack.pop() != bracket_map[char]:
                return False
        else:
            return False
    return stack == []",87
17704662780,find_duplicate,"def find_duplicate(nums):
    tortoise = nums[0]
    hare = nums[0]
    while True:
        tortoise = nums[tortoise]
        hare = nums[nums[hare]]
        if tortoise == hare:
            break

    tortoise = nums[0]
    while tortoise != hare:
        tortoise = nums[tortoise]
        hare = nums[hare]

    return tortoise",87
25758382119,findDuplicate,"def findDuplicate(nums):
    tortoise = nums[0]
    hare = nums[0]
    while True:
        tortoise = nums[tortoise]
        hare = nums[nums[hare]]
        if tortoise == hare:
            break
    tortoise = nums[0]
    while tortoise != hare:
        tortoise = nums[tortoise]
        hare = nums[hare]
    return tortoise",87
19606154825,is_almost_palindrome,"def is_almost_palindrome(s):
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            m, n = s[left:right], s[left + 1: right + 1]
            return m == m[::-1] or n == n[::-1]
        left += 1
        right -= 1
    return True",87
72628735709,longestSubstring,"def longestSubstring(s):
    left = 0
    maxLength = 0
    usedChar = {}

    for right in range(len(s)):
        if s[right] in usedChar and left <= usedChar[s[right]]:
            left = usedChar[s[right]] + 1
        else:
            maxLength = max(maxLength, right - left + 1)

        usedChar[s[right]] = right

    return maxLength",87
36170824532,most_frequent_char,"def most_frequent_char(str1):
    count = {}
    max_char = ''
    max_count = 0
    for char in str1:
        if char in count:
            count[char] += 1
        else:
            count[char] = 1
        if count[char] > max_count:
            max_count = count[char]
            max_char = char
    return (max_char, max_count)",87
38099301802,largest_product,"def largest_product(lst):
    if len(lst) < 2:
        return None
    lst.sort()
    return max(lst[0]*lst[1], lst[-1]*lst[-2])

print(largest_product([1,3,5,7,9]))
print(largest_product([2,4,6,8,10]))
print(largest_product([-1,0,1,2,3]))",87
34951608543,max_sub_array_of_size_k,"def max_sub_array_of_size_k(arr, k):
    max_sum = 0
    window_sum = 0
    for i in range(k):
        window_sum += arr[i]
    max_sum = window_sum
    for i in range(k, len(arr)):
        window_sum -= arr[i - k]
        window_sum += arr[i]
        max_sum = max(max_sum, window_sum)
    return max_sum",87
1825390018,min_product,"def min_product(nums):
    nums.sort()
    return nums[0] * nums[1]

# Test cases
assert min_product([4, 2, 5, 1, 3]) == 2
assert min_product([9, 8, 7, 6]) == 42
assert min_product([1, 2, 3, 4, 5]) == 2",87
11696017674,findDuplicate,"def findDuplicate(nums):
    tortoise = nums[0]
    hare = nums[0]
    while True:
        tortoise = nums[tortoise]
        hare = nums[nums[hare]]
        if tortoise == hare:
            break

    tortoise = nums[0]
    while tortoise != hare:
        tortoise = nums[tortoise]
        hare = nums[hare]

    return tortoise",87
13919415456,find_consecutive_sums,"from typing import List

def find_consecutive_sums(target: int) -> List[List[int]]:
    result = []
    for i in range(1, target):
        sum = 0
        for j in range(i, target):
            sum += j
            if sum == target:
                result.append(list(range(i, j + 1)))
                break
            elif sum > target:
                break
    return result",87
10713442849,single_row_keyboard,"def single_row_keyboard(word):
    row_1 = set('qwertyuiop')
    row_2 = set('asdfghjkl')
    row_3 = set('zxcvbnm')
    
    word_set = set(word.lower())
    
    return word_set.issubset(row_1) or word_set.issubset(row_2) or word_set.issubset(row_3)",87
34705418039,smallest_range,"def smallest_range(nums, K):
    nums.sort()
    res = nums[-1] - nums[0]
    for i in range(1, len(nums)):
        big = max(nums[i-1] + abs(K), nums[-1] - abs(K))
        small = min(nums[i] - abs(K), nums[0] + abs(K))
        res = min(res, big - small)
    return res",87
11293916473,is_strong_number,"def factorial(num):
    if num == 0:
        return 1
    else:
        return num * factorial(num-1)

def is_strong_number(num):
    temp = num
    sum_factorial = 0
    while temp > 0:
        digit = temp % 10
        sum_factorial += factorial(digit)
        temp //= 10
    return sum_factorial == num",87
4100299110,unique_common_elements,"def unique_common_elements(list1, list2):
  count = {}
  for x in list1:
    if x not in count:
      count[x] = 0
    count[x] += 1
  result = 0
  for x in list2:
    if x in count and count[x] > 0:
      result += 1
      count[x] = 0
  return result",87
28587594672,unique_grid_paths,"def unique_grid_paths(grid_size):
    rows, cols = grid_size
    dp = [[1] * cols for _ in range(rows)]
    for row in range(1, rows):
        for col in range(1, cols):
            dp[row][col] = dp[row - 1][col] + dp[row][col - 1]
    return dp[rows - 1][cols - 1]",87
9274167824,findDuplicate,"def findDuplicate(nums):
    tortoise = nums[0]
    hare = nums[0]
    while True:
        tortoise = nums[tortoise]
        hare = nums[nums[hare]]
        if tortoise == hare:
            break

    tortoise = nums[0]
    while tortoise != hare:
        tortoise = nums[tortoise]
        hare = nums[hare]

    return tortoise",87
205217660,is_perfect_number,"def is_perfect_number(n):
    if n < 1:
        return False
    sum = 1
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            if i * (n // i) == n:
                sum = sum + i + n//i
            i += 1
    return sum == n",87
22315521344,second_highest,"def second_highest(numbers):
    unique_numbers = set(numbers)
    if len(unique_numbers) < 2:
        return None
    first_max = second_max = float('-inf')
    for num in unique_numbers:
        if num > first_max:
            second_max = first_max
            first_max = num
        elif num > second_max and num != first_max:
            second_max = num
    return second_max",87
32085421788,quicksort_desc,"def quicksort_desc(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x > pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x < pivot]
    return quicksort_desc(left) + middle + quicksort_desc(right)",87
10741297249,product_except_self,"def product_except_self(nums):
    n = len(nums)
    output = [1] * n
    left_product = 1
    right_product = 1
    
    for i in range(n):
        output[i] *= left_product
        left_product *= nums[i]
        
        output[n - 1 - i] *= right_product
        right_product *= nums[n - 1 - i]
    
    return output",87
21979669951,max_depth,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def max_depth(root):
    if root is None:
        return 0
    else:
        left_depth = max_depth(root.left)
        right_depth = max_depth(root.right)
        return max(left_depth, right_depth) + 1",87
18114582493,can_rearrange_palindrome,"def can_rearrange_palindrome(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1",87
29250315045,meetings,"def meetings(meetings):
    meetings.sort(key=lambda x: x[1])
    i = 0
    count = 0
    while i < len(meetings):
        count += 1
        end_time = meetings[i][1]
        i += 1
        while i < len(meetings) and meetings[i][0] < end_time:
            i += 1
    return count",87
44784389631,find_lucky,"def find_lucky(arr):
    db = {}
    for val in arr:
        if (val not in db):
            db[val] = 0
        db[val] += 1
    a = []
    for (k, v) in db.items():
        if (k == v):
            a.append(v)
    if (len(a) == 0):
        return (-1)
    return max(a)",87
15550722203,staircase,"def staircase(n):
    if n == 0 or n == 1:
        return 1
    elif n == 2:
        return 2
    a, b, c = 1, 1, 2
    for i in range(3, n + 1):
        d = a + b + c
        a, b, c = b, c, d
    return d",87
13811136943,check_parentheses,"def check_parentheses(s):
    bracket_map = {""("": "")"", ""["": ""]"", ""{"": ""}""}
    open_brackets = set([""("", ""["", ""{""])
    stack = []

    for i in s:
        if i in open_brackets:
            stack.append(i)
        elif stack and i == bracket_map[stack[-1]]:
            stack.pop()
        else:
            return False
    return not stack",87
74387251229,is_anagram_of_palindrome,"def is_anagram_of_palindrome(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_counts = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_counts += 1
    return odd_counts <= 1",87
40509355240,zigzag_conversion,"def zigzag_conversion(s, n):
    if n == 1 or n >= len(s):
        return s

    L = [''] * n
    index, step = 0, -1

    for x in s:
        L[index] += x
        if index == 0 or index == n - 1:
            step = -step
        index += step

    return ''.join(L)",87
33926752563,find_depth,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def find_depth(root):
    if root is None:
        return 0
    else:
        left_depth = find_depth(root.left)
        right_depth = find_depth(root.right)
        return max(left_depth, right_depth) + 1",87
74180660580,is_pal_perm,"def is_pal_perm(str1):
  d = dict()
  odd = 0
  for i in str1:
    if i in d:
      d[i] += 1
    else:
      d[i] = 1
  for v in d.values():
    if v % 2 != 0:
      odd += 1
  if odd > 1:
    return False
  return True",87
39171608694,most_frequent_char,"def most_frequent_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    max_count = max(char_count.values())
    most_frequent_chars = [char for char, count in char_count.items() if count == max_count]
    return sorted(most_frequent_chars)",87
9436599451,longest_subarray_with_sum_zero,"def longest_subarray_with_sum_zero(arr):
    sum_dict = {0: -1}
    max_length = 0
    current_sum = 0
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum in sum_dict:
            max_length = max(max_length, i - sum_dict[current_sum])
        else:
            sum_dict[current_sum] = i
    return max_length",87
12186082957,min_subarray_len,"def min_subarray_len(target, nums):
    res = float(""inf"")
    Sum = 0
    slow = 0
    for fast in range(len(nums)):
        Sum += nums[fast]
        while Sum >= target:
            res = min(res, fast-slow+1)
            Sum -= nums[slow]
            slow += 1
    return 0 if res == float(""inf"") else res",87
9625165077,find_two_largest,"def find_two_largest(numbers):
    if len(numbers)<2:
        return None
    first_largest = second_largest = float('-inf')
    for number in numbers:
        if number > first_largest:
            second_largest = first_largest
            first_largest = number
        elif number > second_largest:
            second_largest = number
    return (first_largest, second_largest)",87
9096195948,find_duplicate,"def find_duplicate(nums):
    tortoise = nums[0]
    hare = nums[0]
    while True:
        tortoise = nums[tortoise]
        hare = nums[nums[hare]]
        if tortoise == hare:
            break

    tortoise = nums[0]
    while tortoise != hare:
        tortoise = nums[tortoise]
        hare = nums[hare]

    return tortoise",87
34444852890,longest_substring_length,"def longest_substring_length(s: str) -> int:
    char_set = set()
    left = 0
    max_length = 0
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
    return max_length",87
31531009232,is_Anagram_Palindrome,"def is_Anagram_Palindrome(str):
    char_dict = {}
    for char in str:
        if char in char_dict:
            char_dict[char] += 1
        else:
            char_dict[char] = 1
    odd_count = 0
    for count in char_dict.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1",87
38901845931,longest_unique_substring,"def longest_unique_substring(s):
    char_map = {}
    left = 0
    result = """"
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        if right - left + 1 > len(result):
            result = s[left:right+1]
    return result",87
27337323950,largestNumber,"from functools import cmp_to_key

def largestNumber(numbers):
    answer = ''
    numbers = [str(n) for n in numbers]

    numbers.sort(key=cmp_to_key(lambda a, b: -1 if a+b > b+a else 1 if a+b < b+a else 0))

    answer = ''.join(numbers)
    if answer[0] == '0':
        return '0'
    return answer",87
29904267032,is_strong_number,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def is_strong_number(num):
    temp = num
    sum_factorial = 0
    while temp > 0:
        digit = temp % 10
        sum_factorial += factorial(digit)
        temp //= 10
    return sum_factorial == num",87
71208298239,maxDepth,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxDepth(root):
    if root is None:
        return 0
    else:
        left_height = maxDepth(root.left)
        right_height = maxDepth(root.right)
        return max(left_height, right_height) + 1",87
26366657239,length_longest_subarray,"def length_longest_subarray(arr):
    sum_dict = {0: -1}
    max_length = 0
    current_sum = 0
    for i, num in enumerate(arr):
        current_sum += num
        if current_sum not in sum_dict:
            sum_dict[current_sum] = i
        else:
            max_length = max(max_length, i - sum_dict[current_sum])
    return max_length",87
23774679211,longest_increasing_subarray,"def longest_increasing_subarray(nums):
    if not nums:
        return 0
    max_len = 1
    current_len = 1
    for i in range(1, len(nums)):
        if nums[i] > nums[i - 1]:
            current_len += 1
            max_len = max(max_len, current_len)
        else:
            current_len = 1
    return max_len",87
36018342263,combination_sublists,"def combination_sublists(nums, target):
    nums = sorted(nums)
    result = []
    def dfs(index, path, total):
        if total > target:
            return
        if total == target:
            result.append(path)
            return
        for i in range(index, len(nums)):
            dfs(i, path + [nums[i]], total + nums[i])
    dfs(0, [], 0)
    return result",87
9794209153,largest_product,"def largest_product(arr):
    arr.sort()
    return max(arr[0]*arr[1], arr[-1]*arr[-2])

assert largest_product([1,2,3,4,5]) == 20
assert largest_product([-1,-2,-3,-4,-5]) == 20
assert largest_product([10,3,5,6,20]) == 200",87
41259479226,generate_permutations,"def generate_permutations(arr):
    if len(arr) == 0:
        return []
    if len(arr) == 1:
        return [arr]
    permutations = []
    for i in range(len(arr)):
        m = arr[i]
        remaining_elements = arr[:i] + arr[i+1:]
        for p in generate_permutations(remaining_elements):
            permutations.append([m] + p)
    return permutations",87
71012420617,staircase_climb,"def staircase_climb(n):
    if n == 0 or n == 1:
        return 1
    elif n == 2:
        return 2
    else:
        a, b, c = 1, 1, 2
        for i in range(3, n + 1):
            a, b, c = b, c, a + b + c
        return c",87
29320473878,findDuplicate,"def findDuplicate(nums):
    tortoise = nums[0]
    hare = nums[0]
    while True:
        tortoise = nums[tortoise]
        hare = nums[nums[hare]]
        if tortoise == hare:
            break

    tortoise = nums[0]
    while tortoise != hare:
        tortoise = nums[tortoise]
        hare = nums[hare]

    return tortoise",87
19765988651,min_jumps,"def min_jumps(nums):
    if len(nums) <= 1:
        return 0
    jumps = 0
    current_end = 0
    farthest = 0
    for i in range(len(nums)-1):
        farthest = max(farthest, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = farthest
    return jumps",87
39730424061,max_unique,"from itertools import combinations

def max_unique(arr):
    def is_unique(s):
        return len(s) == len(set(s))
    
    max_len = 0
    for r in range(1, len(arr) + 1):
        for combo in combinations(arr, r):
            s = ''.join(combo)
            if is_unique(s):
                max_len = max(max_len, len(s))
    return max_len",87
35097285828,unique_permutations,"from math import factorial

def unique_permutations(s: str) -> int:
    char_counts = {}
    for char in s:
        if char in char_counts:
            char_counts[char] += 1
        else:
            char_counts[char] = 1
    
    total_permutations = factorial(len(s))
    for count in char_counts.values():
        total_permutations //= factorial(count)
        
    return total_permutations",86
26319210666,longest_zero_sum_subarray,"def longest_zero_sum_subarray(nums):
    sum_index = {0: -1}
    current_sum = 0
    max_length = 0
    for i, num in enumerate(nums):
        current_sum += num
        if current_sum in sum_index:
            max_length = max(max_length, i - sum_index[current_sum])
        else:
            sum_index[current_sum] = i
    return max_length",86
22557745593,can_form_string,"def can_form_string(str1, str2):
    t_dict = {}
    for i in str2:
        t_dict[i] = t_dict.get(i, 0) + 1
  
    for i in str1:
        if i in t_dict and t_dict[i] > 0:
            t_dict[i] = t_dict[i] - 1
        else:
            return False
    return True",86
42497054392,reorderedPowerOf2,"from collections import Counter
def reorderedPowerOf2(n):
        c = Counter([int(i) for i in str(n)])
        N, i = 0,0
        while N <= 10**9:
            N = 2 ** i
            d = Counter([int(i) for i in str(N)])
            if c == d: return True
            i += 1
        return False",86
23502055297,next_prime,"def next_prime(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    next_num = n + 1
    while not is_prime(next_num):
        next_num += 1
    return next_num",86
70495248115,num_unique_bst,"def num_unique_bst(n):
    catalan = [0 for _ in range(n + 1)]
    catalan[0] = 1
    catalan[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]
    return catalan[n]",86
16556275912,numTrees,"def numTrees(n: int) -> int:
    G = [0] * (n+1)
    G[0] = 1
    G[1] = 1

    for nodes in range(2, n+1):
        for root in range(1, nodes+1):
            G[nodes] += G[root-1] * G[nodes-root]

    return G[n]",86
12174117621,find_most_common,"def find_most_common(nums):
    freq_map = {}
    for num in nums:
        if num in freq_map:
            freq_map[num] += 1
        else:
            freq_map[num] = 1
    max_freq = max(freq_map.values())
    most_common = [k for k, v in freq_map.items() if v == max_freq]
    return (most_common[0], max_freq)",86
70262677258,longest_consecutive_subsequence,"def longest_consecutive_subsequence(s):
    if not s:
        return 0
    max_len = 1
    current_len = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_len += 1
            max_len = max(max_len, current_len)
        else:
            current_len = 1
    return max_len",86
16341324814,count_pattern_occurrences,"def count_pattern_occurrences(text, pattern):
    if not pattern:
        return 0
    count = 0
    i = 0
    while i < len(text):
        if text[i:i+len(pattern)] == pattern:
            count += 1
            i += 1  # Move one step instead of len(pattern) to allow overlapping
        else:
            i += 1
    return count",86
35090788269,reverse_odd,"def reverse_odd(lst):
    odd_list = [i for i in lst if i%2 != 0]
    odd_list.reverse()
    new_list = []
    odd_counter = 0
    for i in lst:
        if i%2 != 0:
            new_list.append(odd_list[odd_counter])
            odd_counter += 1
        else:
            new_list.append(i)
    return new_list",86
5086017808,find_summands,"def find_summands(n):
    summands = []
    current_summand = 1

    while n > 0:
        if n - current_summand > current_summand or n == current_summand:
            summands.append(current_summand)
            n -= current_summand
            current_summand += 1
        else:
            current_summand += 1

    return summands",86
13086994685,min_moves_to_palindrome,"def min_moves_to_palindrome(arr):
    n = len(arr)
    moves = 0
    i = 0
    j = n - 1
    while i < j:
        moves += abs(arr[i] - arr[j])
        arr[i] = min(arr[i], arr[j])
        arr[j] = arr[i]
        i += 1
        j -= 1
    return moves",86
40582080426,subarraySum,"def subarraySum(nums, k):
    count = 0
    sum = 0 
    hash = {0:1}
    for i in nums:
        sum += i
        if sum - k in hash:
            count += hash[sum - k]
        if sum in hash:
            hash[sum] += 1
        else:
            hash[sum] = 1
    return count",86
8320972519,max_length_subarray,"def max_length_subarray(arr):
    max_length = 0
    sum_dict = {0: -1}
    current_sum = 0
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum not in sum_dict:
            sum_dict[current_sum] = i
        else:
            max_length = max(max_length, i - sum_dict[current_sum])
    return max_length",86
6948019964,longest_same_char_substring,"def longest_same_char_substring(s):
    if not s:
        return 0
    max_length = 1
    current_length = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1
    return max_length",86
3765710328,max_unique_substring,"def max_unique_substring(s):
    n = len(s)
    seen = {}
    start = 0
    max_length = 0
    for i in range(n):
        if s[i] in seen:
            start = max(start, seen[s[i]] + 1)
        seen[s[i]] = i
        max_length = max(max_length, i - start + 1)
    return max_length",86
2175887565,longest_palindrome,"from collections import Counter

def longest_palindrome(s: str) -> int:
    char_count = Counter(s)
    length = 0
    odd_found = False
    for count in char_count.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            odd_found = True
    return length + 1 if odd_found else length",86
73982073900,numUniqueBSTs,"def numUniqueBSTs(n):
    if n == 0:
        return 1
    dp = [0] * (n+1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n+1):
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]
    return dp[n]",86
43385151459,find_max_len_subarray,"def find_max_len_subarray(arr):
    max_len = 0
    sum_map = {0: -1}
    curr_sum = 0

    for i in range(len(arr)):
        curr_sum += arr[i]
        if curr_sum in sum_map:
            max_len = max(max_len, i - sum_map[curr_sum])
        else:
            sum_map[curr_sum] = i

    return max_len",86
6867637418,mode,"from collections import Counter

def mode(numbers):
    if len(numbers) == 0:
        return -1

    number_counts = Counter(numbers)
    max_count = max(number_counts.values())
    mode_numbers = [num for num, count in number_counts.items() if count == max_count]

    if len(mode_numbers) == len(set(numbers)):
        return -1
    else:
        return mode_numbers[0]",86
19791128642,tribonacci,"def tribonacci(n):
    if n == 0 or n == 1:
        return 0
    elif n == 2:
        return 1
    else:
        a, b, c = 0, 0, 1
        for i in range(3, n + 1):
            a, b, c = b, c, a + b + c
        return c",86
12094449300,generate_primes,"def generate_primes(n):
    primes = []
    for possiblePrime in range(2, n + 1):
        isPrime = True
        for num in range(2, int(possiblePrime ** 0.5) + 1):
            if possiblePrime % num == 0:
                isPrime = False
                break
        if isPrime:
            primes.append(possiblePrime)
    return primes",86
510145971,is_valid_parentheses,"def is_valid_parentheses(s: str) -> bool:
    closedToOpen = { "")"" : ""(""}
    stack = []

    for bracket in s:
        if bracket in closedToOpen:
            if stack and stack[-1] == closedToOpen.get(bracket):
                stack.pop()
            else:
                return False
        else:
            stack.append(bracket)
    
    return len(stack) == 0",86
18735756439,repeated_sum,"def repeated_sum(nums):
    if not nums:
        return 0
        
    total_sum = 0
    count = 1
    
    for i in range(1,len(nums)):
        if nums[i] == nums[i-1]:
            count += 1
            if count == 2:
                total_sum += nums[i] * 2
        else:
            count = 1
            
    return total_sum",86
23706184274,len_longest_substring,"def len_longest_substring(s):
    char_map = {}
    left = 0
    max_len = 0

    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_len = max(max_len, right - left + 1)

    return max_len",86
22637752934,is_valid_bracket_sequence,"def is_valid_bracket_sequence(s):
    stack = []
    bracket_map = {')': '(', ']': '[', '}': '{'}

    for char in s:
        if char in bracket_map.values():
            stack.append(char)
        elif char in bracket_map.keys():
            if stack == [] or bracket_map[char] != stack.pop():
                return False
        else:
            return False

    return stack == []",86
32442793261,length_of_lis,"def length_of_lis(nums):
    dp = [1] * len(nums)
    
    j =0
    i =1
    while i <len(nums):
        j = 0
        while j < i:
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j]+1)
            j += 1
        i+=1
            
    return max(dp)",86
9528855692,is_anagram_palindrome,"def is_anagram_palindrome(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1",86
26879928104,find_FirstNonRepeatingCharacter,"def find_FirstNonRepeatingCharacter(s: str) -> str:
    char_count = {}
    queue = []

    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
            queue.append(char)

    for char in queue:
        if char_count[char] == 1:
            return char
    return -1",86
33182430351,count_primes,"def count_primes(nums):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    count = 0
    for num in nums:
        if is_prime(num):
            count += 1
    return count",86
18189218766,num_ways_consecutive_sum,"def num_ways_consecutive_sum(n) : 
    total_ways = 0
    for i in range(1, n + 1):
        sum = 0
        for j in range(i, n + 1):
            sum += j
            if sum == n:
                total_ways += 1
                break
            elif sum > n:
                break
    return total_ways",86
7834636740,check_attendance,"def check_attendance(s):
    seenA = False
    L_count = 0
    for char in s:
        if char == 'A':
            if seenA:
                return False
            seenA = True
        elif char == 'L':
            if L_count >= 2:
                return False
            L_count += 1
        else:
            L_count = 0
    return True",86
33029447520,next_perfect_square,"import math

def next_perfect_square(n):
    # Check if n is a perfect square
    root = math.isqrt(n)
    if root * root == n:
        # Find the next perfect square
        return (root + 1) * (root + 1)
    else:
        # Find the nearest greater perfect square
        return (root + 1) * (root + 1)",86
36876404608,max_unique_substring,"def max_unique_substring(s):
    char_map = {}
    left = 0
    max_length = 0

    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)

    return max_length",86
24777982227,tribonacci,"def tribonacci(n):
    if n == 0:
        return 0
    elif n == 1 or n == 2:
        return 1
    else:
        a, b, c = 0, 1, 1
        for i in range(3, n + 1):
            a, b, c = b, c, a + b + c
        return c",86
2299389001,balanced_parentheses,"def balanced_parentheses(n):
    if n == 1:
        return 1
    dp = [0] * (n+1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n+1):
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]
    return dp[n]",86
3852950310,find_permutation,"def find_permutation(s):
    if len(s) == 1:
        return set(s)
    first_char = s[0]
    remainder = s[1:]
    permutations = find_permutation(remainder)
    result = set()
    for permutation in permutations:
        for position in range(len(permutation) + 1):
            result.add(permutation[:position] + first_char + permutation[position:])
    return result",86
35186095171,paint_fence,"def paint_fence(n, k):
    if n == 0:
        return 0
    if n == 1:
        return k
    same = k
    diff = k * (k - 1)
    for i in range(2, n):
        temp = diff
        diff = (same + diff) * (k - 1)
        same = temp
    return same + diff",86
4979938113,isPerfectNumber,"def isPerfectNumber(n):
    if n < 1:
        return False
    sum = 1
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            if i * (n // i) == n:
                sum = sum + i + n//i
            i += 1
    return sum == n",86
34764614715,min_operations_anagrams,"from collections import Counter

def min_operations_anagrams(str1, str2):
    count1 = Counter(str1)
    count2 = Counter(str2)
    result = 0

    for ch in count1:
        result += abs(count1[ch] - count2[ch])
    for ch in count2:
        if ch not in count1:
            result += count2[ch]

    return result // 2",86
20497905820,balanced_brackets,"def balanced_brackets(s):
    brackets_map = {')': '(', ']': '[', '}': '{'}
    open_brackets = set(['(', '[', '{'])
    stack = []
    for char in s:
        if char in open_brackets:
            stack.append(char)
        elif char in brackets_map:
            if not stack or stack.pop() != brackets_map[char]:
                return False
    return not stack",86
22698676053,longest_substring_length,"def longest_substring_length(s):
    char_index = {}
    start = 0
    max_length = 0
    for i, char in enumerate(s):
        if char in char_index and char_index[char] >= start:
            start = char_index[char] + 1
        char_index[char] = i
        max_length = max(max_length, i - start + 1)
    return max_length",86
26627868869,is_valid_bracket_sequence,"def is_valid_bracket_sequence(s):
    stack = []
    bracket_map = {')': '(', '}': '{', ']': '['}

    for char in s:
        if char in bracket_map.values():
            stack.append(char)
        elif char in bracket_map.keys():
            if stack == [] or bracket_map[char] != stack.pop():
                return False
        else:
            return False

    return stack == []",86
36642513855,tribonacci,"def tribonacci(n):
    if n == 0:
        return 0
    elif n == 1 or n == 2:
        return 1
    else:
        a, b, c = 0, 1, 1
        for _ in range(3, n + 1):
            a, b, c = b, c, a + b + c
        return c",86
1039554698,smallest_evenly_divisible,"def smallest_evenly_divisible(n):
    def gcd(x, y):
        while(y):
            x, y = y, x % y
        return x
    def lcm(x, y):
        lcm = (x*y)//gcd(x,y)
        return lcm
    num = 1
    for i in range(1, n + 1):
        num = lcm(num, i)
    return num",86
35306583965,is_anagram_palindrome,"def is_anagram_palindrome(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1",86
32819335370,nth_fibonacci,"def nth_fibonacci(n):
    if n <= 0:
        raise ValueError(""Input should be a positive integer"")
    elif n == 1:
        return 0
    elif n == 2:
        return 1
    else:
        a, b = 0, 1
        for _ in range(n-2):
            a, b = b, a + b
        return b",86
71446574113,nth_prime,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def nth_prime(numbers, n):
    primes = [x for x in numbers if is_prime(x)]
    primes.sort(reverse=True)
    return primes[n-1]",86
6193909357,greatest_product,"def greatest_product(numbers):
    if len(numbers) < 2:
        return None
    numbers.sort()
    if numbers[0] < 0 and numbers[1] < 0:
        product1 = numbers[0] * numbers[1]
    else:
        product1 = float('-inf')
    product2 = numbers[-1] * numbers[-2]
    return max(product1, product2)",86
15618040646,tribonacci,"def tribonacci(n):
    if n == 0:
        return 0
    elif n == 1 or n == 2:
        return 1
    else:
        a, b, c = 0, 1, 1
        for i in range(3, n + 1):
            a, b, c = b, c, a + b + c
        return c",86
21557691272,consecutive_sum_ways,"def consecutive_sum_ways(n):
    count = 0
    i = 1
    while i * (i - 1) / 2 < n:
        x = (float(2 * n - i * (i - 1)) / (2 * i))
        if x.is_integer() and x >= 0:
            count += 1
        i += 1
    return count",86
1771002358,primes_up_to,"def primes_up_to(n):
    primes = []
    for possiblePrime in range(2, n + 1):
        isPrime = True
        for num in range(2, int(possiblePrime ** 0.5) + 1):
            if possiblePrime % num == 0:
                isPrime = False
                break
        if isPrime:
            primes.append(possiblePrime)
    return primes",86
33038180942,single_number,"class Solution:
    def singleNumber(self, nums):
        val0 = 0
        val1 = 0
        for num in nums:
            val0 = (val0 ^ num) & ~val1
            val1 = (val1 ^ num) & ~val0
        return val0 | val1

def single_number(nums):
    solution = Solution()
    return solution.singleNumber(nums)",86
5367537738,custom_sort_string,"from collections import Counter

def custom_sort_string(order: str, p: str) -> str:
    digCounter = Counter(p)
    output = []
    for val in order:
        if val in digCounter:
            output.extend(val * digCounter[val])
            del digCounter[val]
                
    for key in sorted(digCounter.keys()):
        output.extend(key * digCounter[key])
            
    return """".join(output)",86
41914098049,valid_valley_array,"def valid_valley_array(A):
    if len(A) < 3:
        return False
    peak = False
    for i in range(1, len(A)):
        if A[i] > A[i-1]:
            if peak:
                return False
        elif A[i] < A[i-1]:
            if not peak:
                peak = True
        else:
            return False
    return peak",86
72757116915,minSubArrayLen,"def minSubArrayLen(target, nums):
    left = right = s = 0
    ans = float('inf')
    for right in range(len(nums)):
        s += nums[right]
        while(s >= target):
            ans = min(ans, right - left + 1)
            s = s - nums[left]
            left += 1
    return ans if ans != float('inf') else 0",86
26569064794,find_max_sum,"def find_max_sum(arr,k):
    max_sum = 0
    window_sum = 0
    window_start = 0
    for window_end in range(len(arr)):
        window_sum += arr[window_end]
        if window_end >= k-1:
            max_sum = max(max_sum,window_sum)
            window_sum -= arr[window_start]
            window_start += 1
    return max_sum",86
30554743281,isPerfectNumber,"def isPerfectNumber(num):
    if num < 1:
        return False
    sum = 1
    i = 2
    while i * i <= num:
        if num % i:
            i += 1
        else:
            if i * (num // i) == num:
                sum = sum + i + num//i
            i += 1
    return sum == num",86
16427771669,numTrees,"def numTrees(n):
    if n == 0:
        return 0
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]
    return dp[n]",86
69856362361,length_longest_substring,"def length_longest_substring(s):
    char_map = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",86
17739221206,num_ways_to_climb,"def num_ways_to_climb(n):
    if n <= 1:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]",86
16208909563,find_longest_valid_parentheses,"def find_longest_valid_parentheses(s: str) -> int:
    max_len = 0
    stack = [-1]

    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_len = max(max_len, i - stack[-1])

    return max_len",86
70676499337,first_non_repeating,"def first_non_repeating(s: str) -> str:
    if not s:
        return """"
    tableSize = 256
    hashTable = [0]*tableSize
    for i in range(len(s)):
        hashTable[ord(s[i])]+=1
    for i in range(len(s)):
        if hashTable[ord(s[i])]==1:
            return s[i]
    return """"",86
70328986230,reverse_integer,"def reverse_integer(x):
    result = 0
    s = (x > 0) - (x < 0)
    x = x * s
    while x:
        result = (result * 10) + (x % 10)
        x //= 10
            
    return 0 if result > ((2**31) - 1) else (result * s)",86
16303231246,is_permutation,"def is_permutation(A):
    vmax = max(A)
    counter = {} 
    for a in A:
        if a in counter:
            counter[a] += 1
        else:
            counter[a] = 1
    for i in range(1, vmax+1):
        if (i not in counter) or (counter[i] > 1):
            return 0
    return 1",86
17898195758,is_rotated_string,"def is_rotated_string(A, B):
    if A == B:
        return 0
    pushed = []
    word = A
    for _ in range(len(word)-1):
        word_list = list(word)
        word_list.insert(0, word_list.pop())
        word = ''.join(word_list)
        pushed.append(word)
    if B in pushed : return 1
    else: return -1",86
36878026678,find_combinations,"def find_combinations(nums, target):
    result = []
    def dfs(path, index, target):
        if target == 0:
            result.append(path)
            return
        for i in range(index, len(nums)):
            if target - nums[i] < 0:
                break
            dfs(path + [nums[i]], i, target - nums[i])
    dfs([], 0, target)
    return result",86
33830813508,doRectanglesOverlap,"def doRectanglesOverlap(x1, y1, x2, y2, x3, y3, x4, y4):
    # Rectangles overlap if one rectangle's x-range overlaps with the other's and the y-range overlaps as well.
    if x1 < x4 and x3 < x2 and y1 < y4 and y3 < y2:
        return True
    return False",86
21602795746,is_anagram_palindrome,"def is_anagram_palindrome(s):
  char_count = {}
  for char in s:
    if char in char_count:
      char_count[char] += 1
    else:
      char_count[char] = 1
  odd_count = 0
  for count in char_count.values():
    if count % 2 != 0:
      odd_count += 1
  return odd_count <= 1",86
72155402625,longest_valid_parentheses,"def longest_valid_parentheses(s: str) -> int:
    max_length = 0
    stack = [-1]

    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_length = max(max_length, i - stack[-1])

    return max_length",85
37236121440,car_fleets,"def car_fleets(target, position, speed):
        stack = []
        cars = []
        for i in range(len(position)):
            cars.append([position[i], speed[i]])
        for j, k in reversed(sorted(cars)):
            stack.append((target - j)/k)
            if len(stack) > 1 and stack[-1] <= stack[-2]:
                stack.pop()
        return len(stack)",85
7583865730,numTrees,"def numTrees(n):
    if n == 0:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n+1):
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]
    return dp[n]",85
15664199545,max_length_substring,"def max_length_substring(s):
    char_map = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",85
17633790100,min_abs_diff,"def min_abs_diff(nums):
    nums.sort()
    if(len(nums)==2):
        return abs(nums[0]-nums[1])
    else:
        mn=abs(nums[0]-nums[1])
        for i in range(1,len(nums)-1):
            if (abs(nums[i]-nums[i+1]) < mn):
                mn = abs(nums[i]-nums[i+1])
        return mn",85
23997265250,height,"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
def height(root):
    if root is None:
        return 0
    else:
        left_height = height(root.left)
        right_height = height(root.right)
        return max(left_height, right_height) + 1",85
36874190112,find_max_subarray_sum,"def find_max_subarray_sum(arr, k):
    max_sum = 0
    current_sum = 0
    for i in range(k):
        current_sum += arr[i]
    max_sum = current_sum
    for i in range(k, len(arr)):
        current_sum = current_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, current_sum)
    return max_sum",85
2576533008,countWays,"def countWays(n): 
    if n <= 1: 
        return n 
    res = [0] * (n+1) 
    res[0] = 1
    res[1] = 1
    for i in range(2, n+1): 
        res[i] = res[i-1] + res[i-2] 
    return res[n]",85
27856208214,binary_search,"def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1",85
29193114071,longest_unique_substring,"def longest_unique_substring(s):
    char_map = {}
    left = 0
    max_length = 0

    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)

    return max_length",85
3299427810,is_balanced,"def is_balanced(s):
    bracket_map = {""("": "")"", ""["": ""]"", ""{"": ""}""}
    open_par = set([""("", ""["", ""{""])
    stack = []
    
    for i in s:
        if i in open_par:
            stack.append(i)
        elif stack and i == bracket_map[stack[-1]]:
            stack.pop()
        else:
            return False
    return not stack",85
26530575882,is_balanced,"def is_balanced(brackets: str) -> bool:
    stack = []
    bracket_map = {')': '(', '}': '{', ']': '['}
    for bracket in brackets:
        if bracket in bracket_map.values():
            stack.append(bracket)
        elif bracket in bracket_map:
            if stack == [] or stack.pop() != bracket_map[bracket]:
                return False
    return stack == []",85
13129083584,max_depth,"class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def max_depth(root):
    if root is None:
        return 0
    else:
        left_height = max_depth(root.left)
        right_height = max_depth(root.right)
        return max(left_height, right_height) + 1",85
26436463330,is_valid_ip,"def is_valid_ip(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        if not 0 <= int(part) <= 255:
            return False
        if part[0] == '0' and len(part) > 1:
            return False
    return True",85
39850520143,diagonal_sum,"def diagonal_sum(mat):
    n = len(mat)
    
    principal = 0
    secondary = 0
    
    for i in range(0, n):
        principal += mat[i][i]
        secondary += mat[i][n - i - 1]
        
    if n % 2 == 1: secondary -= mat[n // 2][n // 2]
        
    return principal + secondary",85
41456423605,max_unique_substring,"def max_unique_substring(s):
    char_map = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",85
30885375770,find_largest_prime,"def find_largest_prime(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

    primes = [num for num in numbers if is_prime(num)]
    return max(primes) if primes else None",85
72219889460,max_unique_substring,"def max_unique_substring(s):
    start = 0
    max_length = 0
    char_index = {}

    for end in range(len(s)):
        if s[end] in char_index:
            start = max(start, char_index[s[end]] + 1)
        char_index[s[end]] = end
        max_length = max(max_length, end - start + 1)

    return max_length",85
71764519225,longest_valid_parentheses,"def longest_valid_parentheses(s: str) -> int:
    stack = [-1]
    max_len = 0
    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_len = max(max_len, i - stack[-1])
    return max_len",85
29523691405,find_Largest_Product,"def find_Largest_Product(arr):
    arr.sort()
    return max(arr[0]*arr[1], arr[-1]*arr[-2])

print(find_Largest_Product([1,2,3,4])) #12
print(find_Largest_Product([10,2,5,20])) #200
print(find_Largest_Product([0,-1,-2,-3])) #6",85
35111804656,reverse_words,"def reverse_words(sentence):
    sentence = sentence.strip()
    words = sentence.split()
    words = list(filter(lambda word: word != """", words))
    start = 0
    end = len(words) - 1
    while start < end:
        words[start], words[end] = words[end], words[start]
        start += 1
        end -= 1
    return "" "".join(words)",85
56129523,is_digit_sum_palindrome,"def is_digit_sum_palindrome(num):
    sum = 0
    while(num > 0):
        p = num % 10
        sum = sum + p
        num = num // 10
    dupli = str(sum)
    dupli2 = dupli[::-1]
    if(dupli == dupli2):
        return 1
    else:
        return 0",85
74117378101,max_valid_parentheses,"def max_valid_parentheses(s: str) -> int:
    max_length = 0
    stack = [-1]
    for i in range(len(s)):
        if s[i] == ""("":
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_length = max(max_length, i - stack[-1])
    return max_length",85
7279573140,is_abundant,"def is_abundant(n):
    if n <= 1:
        return False
    divisors_sum = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            divisors_sum += i
            if i != n // i:
                divisors_sum += n // i
    return divisors_sum > n",85
3458391451,intersect,"def intersect(nums1, nums2):
    from collections import Counter
    count1 = Counter(nums1)
    count2 = Counter(nums2)
    res = []
    for num in nums1:
        if count1[num] > 0 and count2[num] > 0:
            res.append(num)
            count1[num] -= 1
            count2[num] -= 1
    return res",85
16821151501,binary_search,"def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1",85
25268639588,combinations,"def combinations(arr, k):
    if k == 0:
        return [[]]
    if len(arr) == k:
        return [arr]
    if len(arr) < k:
        return []
    result = []
    for i in range(len(arr)):
        rest = arr[i+1:]
        for item in combinations(rest, k-1):
            result.append([arr[i]] + item)
    return result",85
36604436600,max_adjacent_product,"def max_adjacent_product(input_list):
    if len(input_list) < 2:
        return None
    max_product = input_list[0] * input_list[1]
    for i in range(1, len(input_list) - 1):
        product = input_list[i] * input_list[i + 1]
        if product > max_product:
            max_product = product
    return max_product",85
9447153811,count_subarrays,"from collections import defaultdict

def count_subarrays(nums, target):
    count = 0
    current_sum = 0
    hashmap = defaultdict(int)
    hashmap[0] = 1

    for num in nums:
        current_sum += num
        if (current_sum - target) in hashmap:
            count += hashmap[current_sum - target]

        hashmap[current_sum] += 1

    return count",85
2279736766,reverse_prime,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def reverse_prime(n):
    reversed_num = int(str(n)[::-1])
    if is_prime(reversed_num):
        return reversed_num
    return -1",85
10938784414,findSmallestSetOfVertices,"from collections import defaultdict

def findSmallestSetOfVertices(n, edges):
    graph = defaultdict(list)
    for start, dest in edges:
        graph[start].append(dest)

    ans = []
    values = []
    for val in graph.values():
        values += val
    values = set(values)

    for i in range(n):
        if i not in values:
            ans.append(i)

    return ans",85
73696193899,tribonacci,"def tribonacci(n):
    if n == 0 or n == 1:
        return n
    elif n == 2:
        return 1
    else:
        a, b, c = 0, 1, 1
        for i in range(3, n + 1):
            a, b, c = b, c, a + b + c
        return c",85
72944703449,first_unique_char,"def first_unique_char(s):
    char_count = {}
    for c in s:
        if c in char_count:
            char_count[c] += 1
        else:
            char_count[c] = 1
    for i in range(len(s)):
        if char_count[s[i]] == 1:
            return i
    return -1

s = ""loveleetcode""
print(first_unique_char(s))",85
6522855684,prime_numbers,"def prime_numbers(n):
    primes = []
    for possiblePrime in range(2, n + 1):
        isPrime = True
        for num in range(2, int(possiblePrime ** 0.5) + 1):
            if possiblePrime % num == 0:
                isPrime = False
                break
        if isPrime:
            primes.append(possiblePrime)
    return primes",85
39788161383,longest_valid_parentheses,"def longest_valid_parentheses(s: str) -> int:
    stack = [-1]
    max_len = 0
    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_len = max(max_len, i - stack[-1])
    return max_len",85
43371193417,find_duplicates,"def find_duplicates(nums):
    nums.sort()
    duplicates = []
    i = 0
    while i < len(nums):
        if i+1 < len(nums) and nums[i] == nums[i+1]:
            duplicates.append(nums[i])
            while i+1 < len(nums) and nums[i] == nums[i+1]:
                i += 1
        i += 1
    return duplicates",85
17740620006,longest_substring_length,"def longest_substring_length(s):
    char_map = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",85
36533878054,permute,"def permute(arr):
    if len(arr) == 0:
        return []
    if len(arr) == 1:
        return [arr]
    l = []
    for i in range(len(arr)):
        m = arr[i]
        rem_list = arr[:i] + arr[i+1:]
        for p in permute(rem_list):
            l.append([m] + p)
    return l",85
72686006397,findPair,"def findPair(arr, target):
    arr.sort()
    l = 0
    r = len(arr) - 1
    while l < r:
        curr_sum = arr[l] + arr[r]
        if curr_sum == target:
            return (arr[l], arr[r])
        elif curr_sum < target:
            l += 1
        else:
            r -= 1
    return None",85
75181583503,height,"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def height(root):
    if root is None:
        return 0
    else:
        left_height = height(root.left)
        right_height = height(root.right)
        return max(left_height, right_height) + 1",85
3415718024,prime_product,"from math import sqrt

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def prime_product(lst):
    product = 1
    for num in lst:
        if is_prime(num):
            product *= num
    return product",85
17015385405,prime_numbers,"def prime_numbers(n):
    primes = []
    for possiblePrime in range(2, n + 1):
        isPrime = True
        for num in range(2, int(possiblePrime ** 0.5) + 1):
            if possiblePrime % num == 0:
                isPrime = False
                break
        if isPrime:
            primes.append(possiblePrime)
    return primes",85
70676456457,find_smallest_distance,"def find_smallest_distance(words, word1, word2):
    idx1, idx2 = float(""-inf""), float(""inf"")
    res = len(words)
    for idx, word in enumerate(words):
        if word == word1:
            idx1 = idx
        elif word == word2:
            idx2 = idx
        res = min(res, abs(idx1-idx2))
    return res",85
33037507461,prime_numbers,"def prime_numbers(n):
    primes = []
    for possiblePrime in range(2, n + 1):
        isPrime = True
        for num in range(2, int(possiblePrime ** 0.5) + 1):
            if possiblePrime % num == 0:
                isPrime = False
                break
        if isPrime:
            primes.append(possiblePrime)
    return primes",85
20170245071,longest_unique_subarray,"def longest_unique_subarray(arr):
    start = 0
    max_len = 0
    seen = {}
    
    for end, num in enumerate(arr):
        if num in seen and start <= seen[num]:
            start = seen[num] + 1
        else:
            max_len = max(max_len, end - start + 1)
        
        seen[num] = end
    
    return max_len",85
8718899236,sum_odd_length_subarrays,"def sum_odd_length_subarrays(arr):
    total_sum = 0
    n = len(arr)
    for i in range(0, n):
        subarray_sum = 0
        for j in range(i, n):
            subarray_sum += arr[j]
            if (j - i + 1) % 2 != 0:
                total_sum += subarray_sum
    return total_sum",85
73968160502,prime_numbers,"def prime_numbers(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    count = 0
    for num in numbers:
        if is_prime(num):
            count += 1
    return count",85
14301371505,length_of_substring,"def length_of_substring(s):
    char_map = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",85
10946143258,count_triangles,"def count_triangles(edges):
    edges.sort()
    count = 0
    n = len(edges)
    for i in range(n-2):
        k = i + 2
        for j in range(i+1,n):
            while k < n and edges[i] + edges[j] > edges[k]:
                k += 1
            count += k - j - 1
    return count",85
2633400619,find_Max_Sum,"def find_Max_Sum(nums, k):
    if not nums or k <= 0:
        return 0
    if k > len(nums):
        return sum(nums)
    max_sum = current_sum = sum(nums[:k])
    for i in range(k, len(nums)):
        current_sum += nums[i] - nums[i-k]
        max_sum = max(max_sum, current_sum)
    return max_sum",85
41734839533,max_length_valid_parentheses,"def max_length_valid_parentheses(s: str) -> int:
    stack = [-1]
    max_length = 0
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_length = max(max_length, i - stack[-1])
    return max_length",85
25821746835,can_form_palindrome,"def can_form_palindrome(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_counts = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_counts += 1
    return odd_counts <= 1",85
27358394727,count_unique_bst,"def count_unique_bst(n):
    catalan = [0 for _ in range(n+1)]
    catalan[0] = 1
    catalan[1] = 1
    
    for i in range(2, n+1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]
    
    return catalan[n]",85
21254133471,find_Max_Diff,"def find_Max_Diff(arr, n):
    max_diff = arr[1] - arr[0]
    min_element = arr[0]
    for i in range(1, n):
        if (arr[i] - min_element > max_diff):
            max_diff = arr[i] - min_element
        if (arr[i] < min_element):
            min_element = arr[i]
    return max_diff",85
11494893413,longest_valid_parentheses,"def longest_valid_parentheses(s: str) -> int:
    stack = [-1]
    max_length = 0
    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_length = max(max_length, i - stack[-1])
    return max_length",85
41489125648,nth_fibonacci,"def nth_fibonacci(n):
    if n <= 0:
        return ""Input should be positive integer""
    elif n == 1:
        return 1
    elif n == 2:
        return 1
    else:
        a, b = 1, 1
        for i in range(n - 2):
            a, b = b, a + b
        return b",85
15128086812,can_form_palindrome,"def can_form_palindrome(chars):
    char_count = {}
    for char in chars:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
    
    return odd_count <= 1",85
20088991548,number_of_pairs,"from collections import Counter

def number_of_pairs(nums):
    counts = Counter(nums)
    unpaired = []
    pairs = 0
    for num, count in counts.items():
        if count % 2 == 0:
            pairs += count // 2
        else:
            pairs += (count - 1) // 2
            unpaired.append(num)
    return [pairs, unpaired]",85
31633425492,can_form_palindrome,"def can_form_palindrome(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1",85
14627541180,longest_substring_without_repeating_characters,"def longest_substring_without_repeating_characters(s):
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length",85
20179314625,removeKdigits,"def removeKdigits(num: str, k: int) -> str:
    stack = []
    for digit in num:
        while k and stack and stack[-1] > digit:
            stack.pop()
            k -= 1
        stack.append(digit)
    final_num = ''.join(stack[:-k] if k else stack).lstrip('0')
    return final_num if final_num else '0'",85
11964932997,maxDepth,"class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxDepth(root):
    if root is None:
        return 0
    else:
        leftDepth = maxDepth(root.left)
        rightDepth = maxDepth(root.right)
        return max(leftDepth, rightDepth) + 1",85
12120495253,longest_substring,"def longest_substring(s):
    char_map = {}
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    
    return max_length",85
36940444299,maxSubArray,"def maxSubArray(nums):
    if len(nums)==0:
        return 0
    b = [0]*len(nums)
    b[0] = nums[0]
    mam = b[0]
    for i in range(1,len(nums)):
        b[i] = max(nums[i],b[i-1]+nums[i])
        if mam<b[i]:
            mam=b[i]
    return mam",85
33182069891,max_length_subarray,"def max_length_subarray(arr):
    max_length = 0
    sum_map = {0: -1}
    current_sum = 0
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum in sum_map:
            max_length = max(max_length, i - sum_map[current_sum])
        else:
            sum_map[current_sum] = i
    return max_length",85
36886571106,reverse_letters_only,"def reverse_letters_only(input_string):
    letters = [char for char in input_string if char.isalpha()]
    reversed_letters = letters[::-1]
    result = []
    letter_index = 0
    for char in input_string:
        if char.isalpha():
            result.append(reversed_letters[letter_index])
            letter_index += 1
        else:
            result.append(char)
    return ''.join(result)",85
4857740570,is_single_row_word,"def is_single_row_word(word):
    row1 = set(""qwertyuiop"")
    row2 = set(""asdfghjkl"")
    row3 = set(""zxcvbnm"")

    w = word.lower()
    if set(w).issubset(row1) or set(w).issubset(row2) or set(w).issubset(row3):
        return True
    return False",85
74117488821,longest_valid_parentheses,"def longest_valid_parentheses(s: str) -> int:
    stack = [-1]
    max_len = 0
    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_len = max(max_len, i - stack[-1])
    return max_len",85
72683200467,is_valid_ip,"def is_valid_ip(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        if part.startswith('0') and len(part) > 1:
            return False
        if int(part) < 0 or int(part) > 255:
            return False
    return True",85
21382445325,get_combinations,"def get_combinations(arr, r):
    def backtrack(temp, index, start):
        if len(temp) == r:
            result.append(temp[:])
            return
        for i in range(start, len(arr)):
            temp.append(arr[i])
            backtrack(temp, index + 1, i + 1)
            temp.pop()
    
    result = []
    backtrack([], 0, 0)
    return result",85
8341046009,binary_search,"def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1",85
31357187854,count_primes,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def count_primes(nums):
    count = 0
    for num in nums:
        if is_prime(num):
            count += 1
    return count",85
10497680943,max_depth,"class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def max_depth(root):
    if root is None:
        return 0
    else:
        left_depth = max_depth(root.left)
        right_depth = max_depth(root.right)
        return max(left_depth, right_depth) + 1",85
21558366462,longest_valid_parentheses,"def longest_valid_parentheses(s: str) -> int:
    max_len = 0
    stack = [-1]
    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_len = max(max_len, i - stack[-1])
    return max_len",85
14426031242,convert_to_int_array,"def convert_to_int_array(arr):
    word_to_num = {""zero"": 0, ""one"": 1, ""two"": 2, ""three"": 3, ""four"": 4, ""five"": 5, ""six"": 6, ""seven"": 7, ""eight"": 8, ""nine"": 9}
    return [word_to_num[word] for word in arr]",85
6784482489,convertToBase5,"def convertToBase5(num):
    if num == 0:
        return ""0""
    num_list = []
    n = abs(num)
    while n > 0:
        remainder = n % 5
        num_list.append(str(remainder))
        n = n // 5
    return ''.join(num_list[::-1]) if num > 0 else '-'+''.join(num_list[::-1])",85
72488057727,prime_counter,"def prime_counter(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    count = 0
    for number in numbers:
        if is_prime(number):
            count += 1
    return count",85
20269213479,maxDifference,"def maxDifference(arr):
    n = len(arr)
    max_diff = arr[1] - arr[0]
    min_element = arr[0]
    for i in range(1, n):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",85
34419164919,max_subarray,"def max_subarray(nums):
    if len(nums) == 1: return nums[0]
        
    mintili = 0
    cursum = 0
    ans = float('-inf')
        
    for i in range(len(nums)):
        cursum += nums[i]
        ans = max(ans, cursum - mintili)
        mintili = min(cursum, mintili)
            
    return ans",85
11648653804,is_balanced_parentheses,"def is_balanced_parentheses(s):
    stack = []
    opening = set(['(', '{', '['])
    matching = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in opening:
            stack.append(char)
        elif stack and matching[char] == stack[-1]:
            stack.pop()
        else:
            return False
    
    return stack == []",85
15575267698,product_except_self,"def product_except_self(nums):
    length = len(nums)
    answer = [1] * length
    left = 1
    for i in range(length):
        answer[i] = left
        left *= nums[i]
    right = 1
    for i in range(length-1, -1, -1):
        answer[i] *= right
        right *= nums[i]
    return answer",84
15519747939,validate,"def validate(s):
    if not s:
        return True

    s = s.lower()
    data = [c for c in s if c.isalnum()]

    low, high = 0, len(data) - 1

    while low < high:
        if data[low] != data[high]:
            return False
        low += 1
        high -= 1

    return True",84
69878197227,search_insert,"def search_insert(nums, target):
  i = 0
  if target < nums[0]:
    return 0
  while i < len(nums):
    if nums[i] == target:
      return i
    elif i < len(nums) - 1 and nums[i] < target < nums[i + 1]:
      return i + 1
    i += 1
  return i",84
42235583779,can_form_word,"def can_form_word(word_list, word):
    dp = [False] * (len(word) + 1)
    dp[0] = True

    for i in range(1, len(word) + 1):
        for j in range(i):
            if dp[j] and word[j:i] in word_list:
                dp[i] = True
                break

    return dp[len(word)]",84
32615222647,find_longest_harmonious_subsequence,"from collections import Counter

def find_longest_harmonious_subsequence(nums):
    c = Counter(nums)
    keys = sorted(c.keys())
    res = 0
    for i in range(1, len(keys)):
        if keys[i] - keys[i - 1] == 1:
            res = max(res, c[keys[i]] + c[keys[i - 1]])
    return res",84
35820286288,quick_sort,"def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)",84
6508465614,find_element,"def find_element(arr, x):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] < x:
            low = mid + 1
        elif arr[mid] > x:
            high = mid - 1
        else:
            return mid
    return -1",84
73903706548,next_greater_elements,"def next_greater_elements(arr):
    n = len(arr)
    result = [-1]*n
    stack = []
    for i in range(2*n-1, -1, -1):
        while stack and stack[-1] <= arr[i%n]:
            stack.pop()
        result[i%n] = stack[-1] if stack else -1
        stack.append(arr[i%n])
    return result",84
21943705451,lengthOfLongestSubstring,"def lengthOfLongestSubstring(s: str) -> int:
    charSet = set()
    l = 0
    res = 0
    
    for r in range(len(s)):
        while s[r] in charSet:
            charSet.remove(s[l])
            l += 1
        charSet.add(s[r])
        res = max(res, r - l + 1)
    return res",84
12215338041,count_unique_bst,"def count_unique_bst(n):
    catalan = [0 for k in range(n+1)]
    catalan[0] = 1
    catalan[1] = 1
    
    for i in range(2, n+1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i-j-1]
    return catalan[n]",84
8229504186,find_longest_alphabetical_substring,"def find_longest_alphabetical_substring(s: str) -> int:
    max_length = 1
    current_length = 1

    for i in range(1, len(s)):
        if s[i] >= s[i-1]:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1

    return max_length",84
26436024860,longest_valid_parentheses,"def longest_valid_parentheses(s: str) -> int:
    stack = [-1]
    max_len = 0
    for i, ch in enumerate(s):
        if ch == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_len = max(max_len, i - stack[-1])
    return max_len",84
22357302546,quicksort,"def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + middle + quicksort(right)",84
18779514445,anagrams,"def anagrams(strs):
    anag = {}
    result = []
    for str in strs:
        s = ''.join(sorted(str))
        if (s in anag):
            anag[s].append(str)
        else:
            anag[s] = [str]
    for str in anag:
        if(len(anag[str])>1):
            result.extend(anag[str])
    return result",84
24823225919,find_max_depth,"class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def find_max_depth(root: Node) -> int:
    if root is None:
        return 0
    if root.children == []:
        return 1
    return 1 + max(find_max_depth(child) for child in root.children)",84
3458994011,get_fibonacci,"def get_fibonacci(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    else:
        fib = [0, 1]
        for i in range(2, n):
            fib.append(fib[i-1] + fib[i-2])
        return fib",84
10785701115,length_of_longest_substring,"def length_of_longest_substring(s):
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length",84
26686212330,binary_search_position,"def binary_search_position(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1",84
71831652818,max_valid_parentheses,"def max_valid_parentheses(s: str) -> int:
    stack = [-1]
    max_length = 0
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_length = max(max_length, i - stack[-1])
    return max_length",84
35849545489,longest_Subarray_Sum,"def longest_Subarray_Sum(arr, k):
    maxLen = 0
    start = 0
    currentSum = 0
    for end in range(len(arr)):
        currentSum += arr[end]
        while currentSum > k:
            currentSum -= arr[start]
            start += 1
        maxLen = max(maxLen, end - start + 1)
    return maxLen",84
2175809555,length_of_longest_substring,"def length_of_longest_substring(s):
    char_set = set()
    left = 0
    max_length = 0
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
    return max_length",84
2778170897,nth_Fibonacci,"def nth_Fibonacci(n):
    if n <= 0:
        return ""Invalid input""
    elif n == 1 or n == 2:
        return 1
    else:
        fib = [0, 1, 1]
        for i in range(3, n+1):
            fib.append(fib[i-1] + fib[i-2])
        return fib[n]",84
5360212521,find_prime_numbers,"def find_prime_numbers(n):
    primes = []
    if n >= 2:
        primes.append(2)
    for num in range(3, n + 1, 2):
        for j in range(3, int(num**0.5) + 1, 2):
            if num % j == 0:
                break
        else:
            primes.append(num)
    return primes",84
5205418530,max_subarrays_with_zero_sum,"from collections import defaultdict

def max_subarrays_with_zero_sum(arr):
    max_count = 0
    count = defaultdict(int)
    count[0] = 1
    sum_ = 0

    for num in arr:
        sum_ += num
        if sum_ in count:
            max_count += count[sum_]
        count[sum_] += 1

    return max_count",84
26735569968,diff_list,"from collections import Counter

def diff_list(lst):
    if len(lst) <= 1:
        return 0
    freq = Counter(lst)
    max_val, min_val = max(lst), min(lst)
    if freq[max_val] == 1:
        lst.remove(max_val)
    if freq[min_val] == 1:
        lst.remove(min_val)
    return max(lst) - min(lst)",84
14689812339,minimum_sum,"def minimum_sum(num):
    # Convert the integer to a sorted list of its digits
    digits = sorted(str(num))
    
    # Form two new integers by using the digits
    new1 = int(digits[0] + digits[2])
    new2 = int(digits[1] + digits[3])
    
    # Return the sum of the two new integers
    return new1 + new2",84
17216214778,quicksort,"def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + middle + quicksort(right)",84
1652760245,generate_pascal_triangle,"def generate_pascal_triangle(n):
    if n == 0:
        return []
    triangle = [[1]]
    for i in range(1, n):
        row = [1]
        for j in range(1, i):
            row.append(triangle[i-1][j-1] + triangle[i-1][j])
        row.append(1)
        triangle.append(row)
    return triangle",84
22129868488,find_smallest_common,"def find_smallest_common(arr1, arr2):
    i, j = 0, 0
    while i < len(arr1) and j < len(arr2):
        if arr1[i] == arr2[j]:
            return arr1[i]
        elif arr1[i] < arr2[j]:
            i += 1
        else:
            j += 1
    return -1",84
42824028989,backspaceCompare,"def backspaceCompare(s: str, t: str) -> bool:
    def processString(string):
        stack = []
        for char in string:
            if char == ""#"" and len(stack):
                stack.pop()
            elif char != ""#"":
                stack.append(char)
        return """".join(stack)
    s1 = processString(s)
    s2 = processString(t)
    return s1 == s2",84
21118538379,next_prime,"def next_prime(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True

    prime = n + 1
    while not is_prime(prime):
        prime += 1
    return prime",84
38556443260,count_triangles,"from itertools import combinations

def count_triangles(edges):
    count = 0
    for edge in list(combinations(edges, 3)):
        if edge[0] + edge[1] > edge[2] and edge[0] + edge[2] > edge[1] and edge[1] + edge[2] > edge[0]:
            count += 1
    return count",84
33183051741,longest_valid_parentheses,"def longest_valid_parentheses(s: str) -> int:
    stack = [-1]
    max_len = 0
    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_len = max(max_len, i-stack[-1])
    return max_len",84
34679701654,product_after_decrement,"def product_after_decrement(nums):
    nums.sort()
    return max((x-1)*(y-1) for x, y in zip(nums[:-1], nums[1:]))

assert product_after_decrement([3,4,5,2])==12
assert product_after_decrement([1,5,4,5])==16
assert product_after_decrement([3,7])==12",84
17479635501,binary_search,"def binary_search(nums, target):
    left = 0
    right = len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1",84
74397735815,combinations,"def combinations(n, r):
    nums = [i for i in range(n)]
    res = []
    
    def backtrack(start, path):
        if len(path) == r:
            res.append(''.join(str(i) for i in path))
            return
        for i in range(start, n):
            backtrack(i+1, path+[nums[i]])
    
    backtrack(0, [])
    return res",84
7106886533,count_unique_bst,"def count_unique_bst(n):
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        for j in range(1, i + 1):
            dp[i] += dp[j - 1] * dp[i - j]
    return dp[n]",84
39679841669,validate_credit_card,"def validate_credit_card(num):
    num = list(map(int, str(num)))
    for i in range(len(num) - 2, -1, -2):
        num[i] *= 2
        if num[i] > 9:
            num[i] = num[i] // 10 + num[i] % 10
    return sum(num) % 10 == 0",84
40673620285,fib_series,"def fib_series(n):
    fib_list = [0, 1]
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return fib_list
    else:
        for i in range(2, n):
            fib_list.append(fib_list[i-1] + fib_list[i-2])
        return fib_list",84
23588789152,count_pairs,"def count_pairs(arr, target):
    count, sum_map = 0, {}
    for i in range(len(arr)):
        complement = target - arr[i]
        if complement in sum_map:
            count += sum_map[complement]
        if arr[i] in sum_map:
            sum_map[arr[i]] += 1
        else:
            sum_map[arr[i]] = 1
    return count",84
5345891872,reverse_words_in_sentence,"def reverse_words_in_sentence(sentence):
    return ' '.join(word[::-1] for word in sentence.split())

# Test the function
assert reverse_words_in_sentence(""Hello World"") == ""olleH dlroW""
assert reverse_words_in_sentence(""Python Programming"") == ""nohtyP gnimmargorP""
assert reverse_words_in_sentence(""I love coding"") == ""I evol gnidoc""",84
30409308479,fibonacci_sum,"def fibonacci_sum(n):
    if n <= 0:
        return 0
    fibo = [0, 1]
    sum = 1
    for i in range(2, n + 1):
        next_fibo = fibo[i - 1] + fibo[i - 2]
        fibo.append(next_fibo)
        sum += next_fibo
    return sum",84
4530480226,find_max_consecutive_ones,"def find_max_consecutive_ones(n):
    binary = bin(n)[2:]
    max_ones = 0
    current_ones = 0
    for bit in binary:
        if bit == '1':
            current_ones += 1
            max_ones = max(max_ones, current_ones)
        else:
            current_ones = 0
    return max_ones",84
19643870318,comb,"def comb(n, r):
    if r > n:
        return 0
    if r == 0 or r == n:
        return 1
    if r > n - r:
        r = n - r
    result = 1
    for i in range(1, r + 1):
        result *= n - r + i
        result //= i
    return result",84
33971431175,word_segment,"def word_segment(s, wordDict):
    length = len(s)
    dp = [False] * (length + 1)
    dp[0] = True

    for i in range(1, length + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break

    return dp[length]",84
27301726928,perfect_squares,"def perfect_squares(n):
    dp = [1e9]*(n+1)
    dp[0] = 0
    for i in range(1, n+1):
        for j in range(1, i+1):
            if(j*j > i):
                break
            dp[i] = min(dp[i], dp[i-j*j] + 1)
    return dp[n]",84
71333339798,find_element_index,"def find_element_index(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1",84
799090459,most_frequent_element,"def most_frequent_element(nums):
    count = {}
    for i in nums:
        if i in count:
            count[i] += 1
        else:
            count[i] = 1
    max_count = 0
    result = None
    for i in nums:
        if count[i] > max_count:
            max_count = count[i]
            result = i
    return result",84
6798768329,longest_substring,"def longest_substring(s):
    char_map = {}
    left = 0
    max_length = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length",84
41404106001,is_valid_bracket_sequence,"def is_valid_bracket_sequence(s: str) -> bool:
    stack = []
    bracket_map = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}

    for char in s:
        if char in bracket_map.values():
            stack.append(char)
        elif char in bracket_map.keys():
            if stack == [] or bracket_map[char] != stack.pop():
                return False

    return stack == []",84
9656716151,unique_grid_paths,"def unique_grid_paths(m: int, n: int) -> int:
    row = [1] * n
    for i in range(m-1):
        newRow = [1] * n
        for j in range(n - 2, -1, -1):
            newRow[j] = newRow[j + 1] + row[j]
        row = newRow
    return row[0]",84
21533512938,prime_product,"def prime_product(nums):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    product = 1
    for num in nums:
        if is_prime(num):
            product *= num
    return product",84
37567915673,ways_to_climb,"def ways_to_climb(n: int) -> int:
    if n <= 2:
        return max(n, 1)
    dp = [1 for _ in range(n)]
    for i in range(1, n):
        dp[i] = (dp[i-1] + dp[i-2]) % 1000000007
    return dp[-1]",84
4268577041,max_unique_chars,"def max_unique_chars(s):
    char_map = {}
    left = 0
    max_len = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_len = max(max_len, right - left + 1)
    return max_len",84
7928309574,contains_all_vowels,"def contains_all_vowels(s):
    vowels = set('aeiou')
    return vowels.issubset(set(s.lower()))

print(contains_all_vowels('aeiou'))
print(contains_all_vowels('A quick brown fox'))
print(contains_all_vowels('The quick brown fox jumps over the lazy dog'))
print(contains_all_vowels('The quick brown fox jum'))",84
10951095332,findPairs,"from collections import Counter

def findPairs(nums, k):
    if k < 0:
        return 0
    counter = Counter(nums)
    result = 0
    for num in counter:
        if k > 0 and num + k in counter:
            result += 1
        elif k == 0 and counter[num] > 1:
            result += 1
    return result",84
71883348824,height,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def height(root):
    if root is None:
        return 0
    else:
        left_height = height(root.left)
        right_height = height(root.right)
        return max(left_height, right_height) + 1",84
22637747554,can_segment_string,"def can_segment_string(s, wordDict):
    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break

    return dp[len(s)]",84
2288874689,find_longest_substring,"def find_longest_substring(s):
    char_set = set()
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
    
    return max_length",84
33323805133,length_Of_Longest_Substring,"def length_Of_Longest_Substring(s):
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length",84
20978386282,list_to_dict,"def list_to_dict(keys, values, fillvalue=None):
    result = {}
    keys_len = len(keys)
    values_len = len(values)
    if keys_len < values_len:
        keys.extend([fillvalue] * (values_len - keys_len))
    elif keys_len > values_len:
        values.extend([fillvalue] * (keys_len - values_len))
    return dict(zip(keys, values))",84
71960354707,next_prime,"def next_prime(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2,num):
            if num % i == 0:
                return False
        return True

    prime = n
    found = False
    while not found:
        prime += 1
        if is_prime(prime):
            found = True
    return prime",84
23303050766,canSegmentString,"def canSegmentString(s, wordDict):
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break
    return dp[len(s)]",84
4121066443,checkPerfectNumber,"from math import sqrt

def checkPerfectNumber(num):
    if num == 1:
        return False
    
    sum_factor = 0
    for factor in range(1, int(sqrt(num)) + 1):
        if num % factor == 0:
            sum_factor += factor
            if factor != num // factor:
                sum_factor += num // factor
    return num == sum_factor - num",84
39190777182,find_pair,"def find_pair(arr, target):
    arr.sort()
    left = 0
    right = len(arr) - 1
    while left < right:
        if arr[left] + arr[right] == target:
            return (arr[left], arr[right])
        elif arr[left] + arr[right] < target:
            left += 1
        else:
            right -= 1
    return None",84
15601552318,nth_smallest_prime,"def nth_smallest_prime(lst, n):
    primes = []
    for num in lst:
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    if len(primes) < n:
        return None
    else:
        return sorted(primes)[n-1]",84
73469877642,combination,"def combination(nums, k):
    def backtrack(start=0, current_combination=[]):
        if len(current_combination) == k:
            result.append(current_combination[:])
            return
        for i in range(start, len(nums)):
            current_combination.append(nums[i])
            backtrack(i + 1, current_combination)
            current_combination.pop()
    result = []
    backtrack()
    return result",84
74061132546,frequent_char,"def frequent_char(s):
    max_count = 0
    max_char = ''
    char_count = {}
    for c in s:
        if c in char_count:
            char_count[c] += 1
        else:
            char_count[c] = 1
        if char_count[c] > max_count:
            max_count = char_count[c]
            max_char = c
    return max_count",84
489798443,quick_sort,"def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)",84
18897493280,generate_permutations,"def generate_permutations(s):
    s = s.replace('\n', '')
    length = len(s)

    if length == 1:
        return [s]

    results = []
    for i in range(length):
        result = s[:i]+s[i+1:]

        temp = generate_permutations(result)

        for j in temp:
            results.append(s[i:i+1]+j)

    return results",84
8993522975,valid_parentheses,"def valid_parentheses(n):
	def backtrack(s, left, right):
		if len(s) == 2 * n:
			res.append(s)
			return
		if left < n:
			backtrack(s+'(', left+1, right)
		if right < left:
			backtrack(s+')', left, right+1)
	res = []
	backtrack('', 0, 0)
	return res",84
1724721457,smallest_prime,"def smallest_prime(list1):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    primes = [x for x in list1 if is_prime(x)]
    return min(primes) if primes else None",84
74085551100,max_valid_parentheses,"def max_valid_parentheses(s: str) -> int:
    max_len = 0
    stack = [-1]

    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_len = max(max_len, i - stack[-1])

    return max_len",84
17564247924,count_trailing_zeros,"def count_trailing_zeros(n: int) -> int:
    """"""
    Counts the number of trailing zeros in the factorial of a given integer.

    Args:
    n: An integer.

    Returns:
    The number of trailing zeros in the factorial of n.
    """"""
    count = 0
    while n > 0:
        n = n // 5
        count += n
    return count",84
13129207324,longest_unique_subarray,"def longest_unique_subarray(arr):
    max_len = 0
    start = 0
    seen = {}
    for end, value in enumerate(arr):
        if value in seen and start <= seen[value]:
            start = seen[value] + 1
        else:
            max_len = max(max_len, end - start + 1)
        
        seen[value] = end
    return max_len",84
18598262978,has_cycle,"# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    slow = head
    fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False",84
33072396824,quick_sort,"def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)",84
27270599365,subarrays_divisible_by_k,"def subarrays_divisible_by_k(A, K):
    re = [0 for _ in range(K)]
    re[0] = 1
    s, res = 0, 0
    for i in range(len(A)):
        s += A[i]
        modulus = s % K
        res += re[modulus]
        re[modulus] += 1
    return res",84
1186313204,quick_sort,"def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)",84
30784623570,quick_sort,"def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)",84
16979051259,is_perfect,"def is_perfect(n):
    if n < 1:
        return False
    sum_divisors = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            sum_divisors += i
            if i != n // i:
                sum_divisors += n // i
    return sum_divisors == n",84
36993346689,divisible_number,"def divisible_number(n):
    def gcd(x, y):
        while(y):
            x, y = y, x % y
        return x

    def lcm(x, y):
        lcm = (x*y)//gcd(x,y)
        return lcm

    num = 1
    for i in range(1, n + 1):
        num = lcm(num, i)
    return num",83
42797641287,first_recurring_char,"def first_recurring_char(arr):
    seen = set() # Initialize an empty set to keep track of seen characters
    for char in arr: # Iterate through the array
        if char in seen: # If the character is already in the set, it's recurring
            return char
        seen.add(char) # Add the character to the set
    return None # If no recurring characters are found",83
74666412900,is_perfect_cube,"import math
def is_perfect_cube(n):
    temp = round(n ** (1. / 3))
    return n == temp ** 3

def main():
    assert is_perfect_cube(1) == True
    assert is_perfect_cube(27) == True
    assert is_perfect_cube(2) == False

if __name__=='__main__':
    main()",83
30980295199,product_except_self,"def product_except_self(nums):
    result = [1] * len(nums)
    left = 1
    for i in range(len(nums)):
        result[i] *= left
        left *= nums[i]
    right = 1
    for i in range(len(nums) - 1, -1, -1):
        result[i] *= right
        right *= nums[i]
    return result",83
37554363121,largest_prime,"def largest_prime(n):
    def is_prime(x):
        if x < 2:
            return False
        for i in range(2, int(x**0.5) + 1):
            if x % i == 0:
                return False
        return True

    for i in range(n - 1, 1, -1):
        if is_prime(i):
            return i",83
4286552500,firstNonRepeatingCharacter,"def firstNonRepeatingCharacter(s):
  count = {}
  for i in range(len(s)):
    if s[i] not in count:
      count[s[i]] = [i, 1]
    else:
      count[s[i]][1] += 1
  for c in count:
    if count[c][1] == 1:
      return count[c][0]
  return -1",83
15853860998,can_segment,"def can_segment(s, wordDict):
    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break

    return dp[len(s)]",83
1789607875,check_subarray_sum,"def check_subarray_sum(nums, k):
    dic = {0: -1}
    curSum = 0
    for i, n in enumerate(nums):
        curSum += n
        curSum %= k
        if curSum in dic:
            if i - dic[curSum] > 1:
                return True
        else:
            dic[curSum] = i
    return False",83
70452300692,productArray,"def productArray(nums):
    length = len(nums)
    answer = [1] * length
    left = 1
    for i in range(length):
        answer[i] *= left
        left *= nums[i]
    right = 1
    for i in range(length-1, -1, -1):
        answer[i] *= right
        right *= nums[i]
    return answer",83
32421801191,longest_unique_subarray,"def longest_unique_subarray(arr):
    start = 0
    max_len = 0
    seen = {}
    for i, num in enumerate(arr):
        if num in seen and start <= seen[num]:
            start = seen[num] + 1
        else:
            max_len = max(max_len, i - start + 1)
        seen[num] = i
    return max_len",83
14865290415,find_max_difference,"def find_max_difference(l):
    max_diff = l[1] - l[0]
    min_element = l[0]
    for i in range(1, len(l)):
        if (l[i] - min_element) > max_diff:
            max_diff = l[i] - min_element
        if l[i] < min_element:
            min_element = l[i]
    return max_diff",83
4618184649,find_lcm,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def find_lcm(n):
    lcm_val = 1
    for i in range(1, n + 1):
        lcm_val = lcm(lcm_val, i)
    return lcm_val",83
1212736942,capitalize_words,"def capitalize_words(s):
    answer = ''
    s = s.lower()
    s = list(s)
    for i,s_char in enumerate(s):
        if i == 0:
            s[i] = s[i].upper()
        elif s_char == ' ':
            s[i+1] = s[i+1].upper()
    return answer.join(s).replace(""  "", "" "").strip()",83
15951190651,make_change,"def make_change(coins, amount):
    if coins is None or 0 == len(coins):
        return 0

    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]
    return dp[amount]",83
4997236270,longest_substring_length,"def longest_substring_length(s: str) -> int:
    charSet = set()
    l = 0
    res = 0

    for r in range(len(s)):
        while s[r] in charSet:
            charSet.remove(s[l])
            l += 1
        charSet.add(s[r])
        res = max(res, r - l + 1)
    return res",83
34444680730,generate_parentheses,"def generate_parentheses(n):
    def backtrack(s='', left=0, right=0):
        if len(s) == 2 * n:
            result.append(s)
            return
        if left < n:
            backtrack(s+'(', left+1, right)
        if right < left:
            backtrack(s+')', left, right+1)
    result = []
    backtrack()
    return result",83
15733648962,rotate_matrix,"def rotate_matrix(matrix):
    n = len(matrix)
    # Transpose the matrix
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # Reverse each row
    for i in range(n):
        matrix[i] = matrix[i][::-1]
    return matrix",83
17545280107,valid_ip,"def valid_ip(ip):
    parts = ip.split(""."")
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit() or part[0] == ""0"" and len(part) > 1:
            return False
        if int(part) < 0 or int(part) > 255:
            return False
    return True",83
37880467859,count_subsequence,"def count_subsequence(s: str, sub: str) -> int:
    if not sub:
        return 1
    if not s:
        return 0
    if s[0] == sub[0]:
        return count_subsequence(s[1:], sub[1:]) + count_subsequence(s[1:], sub)
    else:
        return count_subsequence(s[1:], sub)",83
14379431247,maxConsecutiveOnes,"def maxConsecutiveOnes(n):
    binary = bin(n)[2:]
    max_ones = 0
    current_ones = 0
    for bit in binary:
        if bit == '1':
            current_ones += 1
            max_ones = max(max_ones, current_ones)
        else:
            current_ones = 0
    return max_ones",83
38987064146,longest_possible_palindrome,"from collections import Counter


def longest_possible_palindrome(s):
    c = Counter(s)
    length = 0
    odd_found = False
    for val in c.values():
        if val % 2 == 0:
            length += val
        else:
            length += val - 1
            odd_found = True
    if odd_found:
        length += 1
    return length",83
28898404967,binary_search,"def binary_search(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1",83
30108972988,valid_password,"import re
def valid_password(password):
    if re.search(r""[A-Z]"", password) and re.search(r""[a-z]"", password) and re.search(r""[0-9]"", password) and re.search(r""[!@#$%^&*()\-_=+{}|\\?/.>,<]"", password) and len(password) >= 8:
        return True
    else:
        return False",83
21954006145,max_length_subarray,"def max_length_subarray(arr):
    max_length = 0
    sum_dict = {0: -1}
    sum = 0
    for i, num in enumerate(arr):
        sum += num
        if sum not in sum_dict:
            sum_dict[sum] = i
        else:
            max_length = max(max_length, i - sum_dict[sum])
    return max_length",83
12559298935,length_of_longest_substring,"def length_of_longest_substring(s):
    char_map = {}
    left = 0
    result = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        result = max(result, right - left + 1)
    return result",83
2599281070,max_overlapping_intervals,"def max_overlapping_intervals(intervals):
    points = []
    for start, end in intervals:
        points.append((start, 1))
        points.append((end, -1))
    points.sort()
    max_overlap, current_overlap = 0, 0
    for _, delta in points:
        current_overlap += delta
        max_overlap = max(max_overlap, current_overlap)
    return max_overlap",83
38901294481,is_valid_ipv4,"def is_valid_ipv4(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        num = int(part)
        if num < 0 or num > 255 or (part.startswith('0') and len(part) > 1):
            return False
    return True",83
5300797534,count_Ways,"def count_Ways(n):
    if n <= 1:
        return n
    dp = [0 for _ in range(n + 1)]
    dp[0], dp[1] = 1, 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]",83
32383427446,find_smallest_prime,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def find_smallest_prime(lst):
    primes = [num for num in lst if is_prime(num)]
    return min(primes) if primes else None",83
20063458072,fibonacci_sequence,"def fibonacci_sequence(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]

    sequence = [0, 1]
    for i in range(2, n):
        next_number = sequence[-1] + sequence[-2]
        sequence.append(next_number)
    return sequence",83
23882259750,can_jump,"def can_jump(nums):
    if not nums:
        return False

    i = 0
    max_index = nums[i]
    while i < len(nums) and i <= max_index:
        new_index = nums[i]+i
        max_index = max(max_index, new_index)
        i += 1
    if i == len(nums):
        return True
    else:
        return False",83
3535968026,ang_diff,"def ang_diff(a, b):
    ans = []
    for l in range(len(a)):
        i = a[l]
        j = b[l]
        if len(i) != len(j):
            ans.append(-1)
            continue
        for i_c in i:
            if i_c in j:
                j = j.replace(i_c,'',1)
        ans.append(len(j))
    return ans",83
17740211126,maxConsecutiveOnes,"def maxConsecutiveOnes(n):
    binary = bin(n)[2:]
    max_ones = 0
    current_ones = 0
    for bit in binary:
        if bit == '1':
            current_ones += 1
            max_ones = max(max_ones, current_ones)
        else:
            current_ones = 0
    return max_ones",83
39327408194,convert_base_to_decimal,"def convert_base_to_decimal(s, base):
    digits = ""0123456789ABCDEF""
    num = 0
    negative = False

    if s[0] == '-':
        negative = True
        s = s[1:]

    for char in s:
        num = num * base + digits.index(char)

    return -num if negative else num",83
26992143020,sum_proper_divisors,"def sum_proper_divisors(n):
    if n <= 1:
        return 0
    divisors = [1]
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    return sum(divisors)",83
31290784842,count_unique_bsts,"def count_unique_bsts(n):
    if n<=1:
        return 1
    dp = [0]*(n+1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n+1):
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]
    return dp[n]",83
14096349067,subarray_product_less_than,"def subarray_product_less_than(nums, k):
    if k <= 1:
        return 0
    left, count, product = 0, 0, 1
    for right in range(len(nums)):
        product *= nums[right]
        while product >= k:
            product /= nums[left]
            left += 1
        count += right - left + 1
    return count",83
36993650659,max_difference_between_two_elements,"def max_difference_between_two_elements(arr):
    max_diff = arr[1] - arr[0]
    min_element = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",83
978105677,two_sum,"def two_sum(nums, target):
    """"""
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    """"""
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []",83
19011444432,word_break,"def word_break(s, wordDict):
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break
    return dp[len(s)]",83
38814694630,reverse_digits,"def reverse_digits(s):
    digits = []
    for char in s:
        if char.isdigit():
            digits.append(char)
    digits = digits[::-1]
    result = []
    digit_index = 0
    for char in s:
        if char.isdigit():
            result.append(digits[digit_index])
            digit_index += 1
        else:
            result.append(char)
    return ''.join(result)",83
7658677612,prime_product,"def prime_product(n):
    primes = []
    for num in range(2, n):
        is_prime = True
        for i in range(2, num):
            if num % i == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(num)
    product = 1
    for prime in primes:
        product *= prime
    return product",83
37648579144,is_perfect_square_fibonacci,"def is_perfect_square(x):
    s = int(x**0.5)
    return s*s == x

def is_fibonacci(n):
    return is_perfect_square(5*n*n + 4) or is_perfect_square(5*n*n - 4)

def is_perfect_square_fibonacci(n):
    return is_perfect_square(n) and is_fibonacci(n)",83
19170955479,primes_in_range,"def primes_in_range(n):
    sieve = [True] * (n+1)
    for x in range(2, int(n**0.5) + 1):
        if sieve[x]: 
            for u in range(x*2, n+1, x): 
                sieve[u] = False
    return [x for x in range(2, n) if sieve[x]]",83
73699366167,duplicate_count,"def duplicate_count(text):
    text = text.lower()
    char_count = {}
    for char in text:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    duplicate_count = 0
    for count in char_count.values():
        if count > 1:
            duplicate_count += 1
    return duplicate_count",83
3519353876,can_construct,"import collections

def can_construct(ransomNote: str, magazine: str) -> bool:
    if set(ransomNote) - set(magazine):
        return False
    magazine_count = collections.Counter(magazine)
    ransomNote_count = collections.Counter(ransomNote)
    for i, j in ransomNote_count.items():
        if j > magazine_count[i]:
            return False
    return True",83
31189305017,generate_parentheses,"def generate_parentheses(n):
    def backtrack(s='', left=0, right=0):
        if len(s) == 2 * n:
            res.append(s)
            return
        if left < n:
            backtrack(s+'(', left+1, right)
        if right < left:
            backtrack(s+')', left, right+1)
    res = []
    backtrack()
    return res",83
11847067804,find_largest_prime,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def find_largest_prime(n):
    for i in range(n-1, 1, -1):
        if is_prime(i):
            return i",83
1600615447,max_consecutive_ones,"def max_consecutive_ones(n):
    binary = bin(n)[2:]
    max_ones = 0
    current_ones = 0
    for bit in binary:
        if bit == '1':
            current_ones += 1
            max_ones = max(max_ones, current_ones)
        else:
            current_ones = 0
    return max_ones",83
12234169550,most_frequent_char,"def most_frequent_char(s):
    count = dict()
    for item in s:
        if item in count:
            count[item] += 1
        else:
            count[item] = 1
    max_freq = max(count.values())
    result = [k for k, v in count.items() if v == max_freq]
    return sorted(result, key=lambda x: s.index(x))",83
180052961,word_break,"def word_break(s, wordDict):
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break
    return dp[-1]",83
8404256956,duplicate_count,"def duplicate_count(text):
    text = text.lower()
    char_count = {}
    for char in text:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    duplicate_count = 0
    for count in char_count.values():
        if count > 1:
            duplicate_count += 1
    return duplicate_count",83
70938703739,max_overlapping_intervals,"def max_overlapping_intervals(intervals):
    events = []
    for start, end in intervals:
        events.append((start, 1))
        events.append((end, -1))
    events.sort()
    max_overlap, current_overlap = 0, 0
    for _, delta in events:
        current_overlap += delta
        max_overlap = max(max_overlap, current_overlap)
    return max_overlap",83
5176331804,find_n_largest_elements,"def find_n_largest_elements(arr, n):
    # Use the heap queue algorithm (also known as the priority queue algorithm)
    # to find the 'n' largest elements in the array 'arr'
    import heapq
    largest_elements = heapq.nlargest(n, arr)
    # Sort these 'n' largest elements in ascending order before returning them
    largest_elements.sort()
    return largest_elements",83
2129183684,is_valley_array,"def is_valley_array(A):
    l, r = 0, len(A) - 1
    while l < r and A[l] > A[l + 1]: l += 1
    while r > l and A[r] > A[r - 1]: r -= 1
    return l == r and l != 0 and r != len(A) - 1",83
37334868445,find_two_largest,"def find_two_largest(arr):
    max1 = max(arr[0], arr[1])
    max2 = min(arr[0], arr[1])
    for num in arr[2:]:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2:
            max2 = num
    return [max2, max1]",83
4458926810,find_max_consecutive_substring,"def find_max_consecutive_substring(s):
    max_length = 1
    current_length = 1
    for i in range(1, len(s)):
        if ord(s[i]) == ord(s[i-1]) + 1:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1
    return max_length",83
28247218127,int_sqrt,"def int_sqrt(x):
    lo, hi = 0, x
    while lo < hi:
        mid = lo + (hi - lo) // 2
        if (mid + 1) * (mid + 1) > x:
            hi = mid
        else:
            lo = mid + 1
    return lo if lo * lo <= x else lo - 1",83
10108364529,count_subsequence,"def count_subsequence(s: str, sub: str) -> int:
    if not sub:
        return 1
    if not s:
        return 0
    if s[0] == sub[0]:
        return count_subsequence(s[1:], sub[1:]) + count_subsequence(s[1:], sub)
    else:
        return count_subsequence(s[1:], sub)",83
31743737890,is_ugly,"def is_ugly(n):
    if n == 1:
        return True
    if n <= 0:
        return False
    while n%2 == 0:
        n = n //2
    while n%3 == 0:
        n = n //3
    while n%5 == 0:
        n = n //5
    return n == 1",83
44947073066,smallestMultiple,"import math

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def smallestMultiple(n):
    result = 1
    for i in range(1, n + 1):
        result = lcm(result, i)
    return result",83
15953471218,compress_string,"def compress_string(s):
    result = []
    i = 0
    while i < len(s):
        count = 1
        while i + 1 < len(s) and s[i] == s[i + 1]:
            i += 1
            count += 1
        result.append(s[i] + str(count))
        i += 1
    return ''.join(result)",83
8545933881,can_segment,"def can_segment(s, wordDict):
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break
    return dp[len(s)]",83
33427248194,fibonacci,"def fibonacci(n):
    if n <= 1:
        return n
    temp = [0 for i in range(n + 1)]
    temp[0] = 0
    temp[1] = 1
    for i in range(2, n + 1):
        temp[i] = temp[i - 1] + temp[i - 2]
    return temp[n]",83
37650244868,count_distinct_words,"import re

def count_distinct_words(sentence):
    # Remove punctuation and convert to lowercase
    clean_sentence = re.sub(r'[^\w\s]', '', sentence).lower()
    # Split the sentence into words
    words = clean_sentence.split()
    # Use a set to get unique words
    unique_words = set(words)
    # Return the number of unique words
    return len(unique_words)",83
33784679613,max_consecutive_sum,"def max_consecutive_sum(arr, k):
    if not arr or k <= 0 or k > len(arr):
        return 0

    current_sum = sum(arr[:k])
    max_sum = current_sum

    for i in range(k, len(arr)):
        current_sum += arr[i] - arr[i - k]
        max_sum = max(max_sum, current_sum)

    return max_sum",83
29750757046,generate_parentheses,"def generate_parentheses(n):
    def backtrack(s='', left=0, right=0):
        if len(s) == 2 * n:
            res.append(s)
            return
        if left < n:
            backtrack(s+'(', left+1, right)
        if right < left:
            backtrack(s+')', left, right+1)

    res = []
    backtrack()
    return res",83
34116018772,addHexadecimal,"def addHexadecimal(a: str, b: str) -> str:
    # Convert hexadecimal strings to integers
    num1 = int(a, 16)
    num2 = int(b, 16)
    
    # Add the numbers
    result = num1 + num2
    
    # Convert the result back to a hexadecimal string and return
    return hex(result)[2:].upper()",83
34425179048,max_Consecutive_Ones,"def max_Consecutive_Ones(n):
    binary = bin(n)[2:]
    max_ones = 0
    current_ones = 0
    for bit in binary:
        if bit == '1':
            current_ones += 1
            max_ones = max(max_ones, current_ones)
        else:
            current_ones = 0
    return max_ones",83
70597334836,longest_unique_subarray,"def longest_unique_subarray(arr):
    start = 0
    max_len = 0
    seen = {}
    
    for end in range(len(arr)):
        if arr[end] in seen:
            start = max(start, seen[arr[end]] + 1)
        seen[arr[end]] = end
        max_len = max(max_len, end - start + 1)
    
    return max_len",83
348016015,most_frequent,"def most_frequent(lst):
    max_count = 0
    max_item = lst[0]
    dict = {}
    for item in lst:
        if (item in dict):
            dict[item] += 1
        else:
            dict[item] = 1
        if dict[item] > max_count:
            max_count = dict[item]
            max_item = item
    return max_item",83
33181583001,num_unique_bst,"def num_unique_bst(n):
    if n == 0:
        return 1
    dp = [1 for _ in range(n + 1)]
    for i in range(2, n + 1):
        dp[i] = 0
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",83
25426224482,find_Max,"def find_Max(arr, low, high): 
    if (low == high): 
        return arr[low] 
    if ((high - low) == 1): 
        return max(arr[low], arr[high]) 
    mid = (low + high) // 2 
    return max(find_Max(arr, low, mid), find_Max(arr, mid + 1, high))",83
41957305571,longest_zero_sum_subarray,"def longest_zero_sum_subarray(arr):
    sum_dict = {0: -1}
    sum = 0
    max_length = 0
    for i in range(len(arr)):
        sum += arr[i]
        if sum in sum_dict:
            max_length = max(max_length, i - sum_dict[sum])
        else:
            sum_dict[sum] = i
    return max_length",83
2220810567,largest_binary_gap,"def largest_binary_gap(N):
    binary_str = bin(N)[2:]  # Convert integer to binary string
    max_gap = 0
    current_gap = 0

    for bit in binary_str:
        if bit == '0':
            current_gap += 1
        else:
            max_gap = max(max_gap, current_gap)
            current_gap = 0

    return max_gap",83
33841386599,findInsertPosition,"def findInsertPosition(nums, target):
    l, r = 0, len(nums) - 1
        
    while l <= r:
        m = (l + r) // 2

        if nums[m] == target:
            return m
        elif nums[m] > target:
            r = m - 1
        else:
            l = m + 1

    return l",83
37938988468,nth_lucas,"def nth_lucas(n: int) -> int:
  if n == 0: return 2
  if n == 1: return 1
  last = 1
  bflast = 2
  for i in range(2, n+1):
    current = bflast + last
    bflast = last
    last = current
  return current",83
44335238545,is_valid_parentheses,"def is_valid_parentheses(s: str) -> bool:
    stack = []
    mapping = {"")"": ""("", ""]"": ""["", ""}"": ""{""}

    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack",82
73348327063,min_jumps,"def min_jumps(nums):
    if len(nums) == 1: return 0
    curReach, maxReach, step = 0, 0, 0
    for i, n in enumerate(nums[:-1]):
        maxReach = max(maxReach, i+n)
        if i == curReach:
            step += 1
            curReach = maxReach
    return step",82
20088792488,maxDiff,"def maxDiff(arr):
    max_diff = arr[1] - arr[0]
    min_element = arr[0]
    for i in range(1, len(arr)):
        if (arr[i] - min_element) > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",82
41099431391,isValidIPv4,"def isValidIPv4(ip):
    nums = ip.split('.')
    if len(nums) != 4:
        return False
    for x in nums:
        if not x.isdigit() or int(x) < 0 or int(x) > 255:
            return False
        if len(x) > 1 and x[0] == '0':
            return False
    return True",82
868708488,subarray_sum,"def subarray_sum(nums, k):
    count = 0
    pre = 0
    map = {0: 1}
    for i in range(len(nums)):
        pre += nums[i]
        if (pre - k) in map:
            count += map[pre - k]
        map[pre] = map.get(pre, 0) + 1
    return count",82
34447610157,max_lexico_substring,"def max_lexico_substring(s: str) -> int:
    max_length = 1
    current_length = 1
    for i in range(1, len(s)):
        if s[i] >= s[i - 1]:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1
    return max_length",82
12638401079,max_product,"def max_product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])

assert max_product([1,2,3,4]) == 24
assert max_product([-1,-2,-3,1]) == 6
assert max_product([1,2,3]) == 6",82
33785015863,can_segment_string,"def can_segment_string(s, dictionary):
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in dictionary:
                dp[i] = True
                break
    return dp[len(s)]",82
3970951818,is_bipartite,"def is_bipartite(graph):
    color = {}
    def dfs(v, c = 0):
        if v in color:
            return color[v] == c
        color[v] = c
        return all(dfs(nei, c ^ 1) for nei in graph[v])
    return all(dfs(v) for v in range(len(graph)) if v not in color)",82
31779038498,tree_height,"class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def tree_height(root):
    if root is None:
        return -1
    left_height = tree_height(root.left)
    right_height = tree_height(root.right)
    return max(left_height, right_height) + 1",82
19750341454,max_area,"def max_area(height):
    max_area = 0
    left, right = 0, len(height) - 1
    while left < right:
        max_area = max(max_area, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area",82
42060840072,lucas_numbers,"def lucas_numbers(n):
    if n == 0:
        return []
    elif n == 1:
        return [2]
    elif n == 2:
        return [2, 1]

    lucas = [2, 1]
    for i in range(2, n):
        lucas.append(lucas[-1] + lucas[-2])
    return lucas",82
40710785854,max_difference,"def max_difference(arr):
    max_diff = 0
    min_element = arr[0]

    for i in range(1, len(arr)):
        diff = arr[i] - min_element
        if diff > max_diff:
            max_diff = diff
        if arr[i] < min_element:
            min_element = arr[i]

    return max_diff if max_diff > 0 else None",82
1520508113,has_increasing_triplet,"def has_increasing_triplet(nums):
    if len(nums) < 3:
        return False

    min_num = float('inf')
    second_min_num = float('inf')

    for num in nums:
        if num <= min_num:
            min_num = num
        elif num <= second_min_num:
            second_min_num = num
        else:
            return True

    return False",82
22816581246,top_k_frequent,"from collections import Counter
from heapq import heapify, heappop

def top_k_frequent(words, k):
    dic = Counter(words)
    heap = []
    for key, value in dic.items():
        heap.append((-value, key))
    heapify(heap)
    
    ans = []
    for i in range(k):
        ans.append(heappop(heap)[1])
    return ans",82
72126697631,smallest_positive_integer,"def smallest_positive_integer(n):
    if n == 0:
        return -1
    elif n < 10:
        return n
    else:
        digit = n % 9
        if digit == 0:
            return int(""9"" * (n // 9))
        else:
            return int(str(digit) + ""9"" * (n // 9))",82
35888058909,max_substring_length,"def max_substring_length(s):
  char_set = set()
  left = 0
  max_length = 0

  for right in range(len(s)):
    while s[right] in char_set:
      char_set.remove(s[left])
      left += 1
    char_set.add(s[right])
    max_length = max(max_length, right - left + 1)

  return max_length",82
72612057304,max_meetings,"def max_meetings(meetings):
    n = len(meetings)
    meetings.sort(key = lambda x: (x[1], x[0]))
    
    ans = 0
    t = 0
    for i in range(n):
        if t > meetings[i][0]: continue
        ans += 1
        t = meetings[i][1]
    return ans",82
22938093504,can_segment_string,"def can_segment_string(s, dictionary):
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in dictionary:
                dp[i] = True
                break
    return dp[len(s)]",82
27879013256,length_of_LIS,"def length_of_LIS(nums):
    if not nums:
        return 0
    dp = [1]*len(nums)
    for i in range (1 , len(nums)):
        for j in range(0 , i):
            if nums[i] > nums[j] and dp[i]< dp[j] + 1 :
                dp[i] = dp[j]+1
    return max(dp)",82
26282049547,height,"class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def height(root):
    if root is None:
        return 0
    else:
        left_height = height(root.left)
        right_height = height(root.right)
        return max(left_height, right_height) + 1",82
36777586771,rock_paper_scissors,"def rock_paper_scissors(player1, player2):
    if player1 == player2:
        return 'Tie'
    if (player1 == 'Rock' and player2 == 'Scissors') or (player1 == 'Scissors' and player2 == 'Paper') or (player1 == 'Paper' and player2 == 'Rock'):
        return player1
    return player2",82
40290735491,is_anagram_of_palindrome,"def is_anagram_of_palindrome(s):
    d = {}
    for char in s:
        if char in d:
            d[char] += 1
        else:
            d[char] = 1
    odd_count = 0
    for count in d.values():
        if count % 2 != 0:
            odd_count += 1
    return odd_count <= 1",82
33785317143,longest_sub_string_of_duplicate_characters,"def longest_sub_string_of_duplicate_characters(s):
    max_length = 0
    current_length = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1
    return max(max_length, current_length)",82
43709929601,isAnagram,"def isAnagram(str1, str2):
    str1 = str1.lower()
    str2 = str2.lower()
    str1 = ''.join(e for e in str1 if e.isalnum())
    str2 = ''.join(e for e in str2 if e.isalnum())
    
    if sorted(str1) == sorted(str2):
        return True
    else:
        return False",82
27173897777,length_longest_substring,"def length_longest_substring(s):
    char_dict = {}
    left = 0
    result = 0
    for right in range(len(s)):
        if s[right] in char_dict:
            left = max(char_dict[s[right]] + 1, left)
        char_dict[s[right]] = right
        result = max(result, right - left + 1)
    return result",82
42874908011,staircase,"def staircase(n):
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]",82
8730146512,balanced_trees,"def balanced_trees(n):
    if n <= 1:
        return 1
    
    dp = [0] * (n+1)
    dp[0] = dp[1] = 1

    for i in range(2, n+1):
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]

    return dp[n]",82
42927717684,binary_search_sqrt,"def binary_search_sqrt(n):
    start = 0
    end = n
    while start <= end:
        mid = (start + end) // 2
        if mid * mid == n:
            return mid
        elif mid * mid < n:
            start = mid + 1
            result = mid
        else:
            end = mid - 1
    return result",82
32902767343,move_zeros,"def move_zeros(nums):
    p, q = 0, 0
    while q < len(nums):
        if nums[q] != 0:
            nums[p], nums[q] = nums[q], nums[p]
            p += 1
        q += 1
    while p < len(nums):
        nums[p] = 0
        p += 1
    return nums",82
14233408269,fib_dyn,"def fib_dyn(n):
    if n == 0:
        return 0
    dp = [0] * (n + 1)
    dp[0], dp[1] = 0, 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]",82
8311894482,num_ways_to_climb,"def num_ways_to_climb(n):
  if n <= 1:
    return 1
  if n == 2:
    return 2
  a, b, c = 1, 1, 2
  for _ in range(3, n + 1):
    a, b, c = b, c, a + b + c
  return c",82
29781483153,is_valid_parentheses,"def is_valid_parentheses(s: str) -> bool:
    stack = []
    mapping = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}

    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)

    return not stack",82
5259169496,find_duplicate,"def find_duplicate(nums):
    tortoise = hare = nums[0]
    while True:
        tortoise = nums[tortoise]
        hare = nums[nums[hare]]
        if tortoise == hare:
            break

    tortoise = nums[0]
    while tortoise != hare:
        tortoise = nums[tortoise]
        hare = nums[hare]

    return tortoise",82
72907457358,get_fibonacci,"def get_fibonacci(n):
    if n <= 0:
        return 0
    dp = [0] * (n+1)
    dp[0] = 0
    dp[1] = 1
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]",82
21148541404,max_length_substring,"def max_length_substring(s):
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length",82
314880062,most_frequent_words,"def most_frequent_words(words):
    word_count = {}
    for word in words:
        if word in word_count:
            word_count[word] += 1
        else:
            word_count[word] = 1

    max_count = max(word_count.values())
    most_frequent = [word for word, count in word_count.items() if count == max_count]

    return most_frequent",82
40080697245,max_water,"def max_water(height):
    left, right = 0, len(height) - 1
    max_area = 0
    while left < right:
        max_area = max(max_area, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area",82
32051761092,groupAnagrams,"def groupAnagrams(strs):
    dict = {}

    for i in range(len(strs)):
        str = """".join(sorted(strs[i]))

        if str in dict:
            dict[str] = dict[str] + [strs[i]]
        else:
            dict[str] = [strs[i]]

    final = []
    for key in dict:
        final.append(dict[key])

    return final",82
42843004236,is_valid_parentheses,"def is_valid_parentheses(s: str) -> bool:
    mapping = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}
    stack = []
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack",82
30980297889,lengthOfLongestSubstring,"def lengthOfLongestSubstring(s):
    charMap = {}
    left = 0
    res = 0
    for right in range(len(s)):
        if s[right] in charMap:
            left = max(left, charMap[s[right]] + 1)
        charMap[s[right]] = right
        res = max(res, right - left + 1)
    return res",82
10591210708,combination,"def combination(n, k):
    if k > n:
        return 0
    if k == 0 or k == n:
        return 1
    k = min(k, n - k) # take advantage of symmetry
    c = 1
    for i in range(k):
        c = c * (n - i) // (i + 1)
    return c",82
73330357877,findFirstDuplicate,"def findFirstDuplicate(nums):
    i = 0
    while i < len(nums):
        j = nums[i] - 1
        if i != j and nums[i] == nums[j]: return nums[i]
        if nums[j] != nums[i]:
            nums[i], nums[j] = nums[j], nums[i]
        else:
            i += 1
                
    return -1",82
35832197861,smallest_divisible,"def gcd(x, y):
    while(y):
        x, y = y, x % y
    return x

def lcm(x, y):
    lcm = (x*y)//gcd(x,y)
    return lcm

def smallest_divisible(n):
    num = 1
    for i in range(1, n + 1):
        num = lcm(num, i)
    return num",82
20816261883,count_duplicates,"def count_duplicates(text):
    text = text.lower()
    char_count = {}
    for char in text:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    duplicates = 0
    for char, count in char_count.items():
        if count > 1:
            duplicates += 1
    return duplicates",82
27963522759,lucas,"def lucas(n): 
    if n == 0: 
        return 2
    if n == 1: 
        return 1
    else: 
        a = 2
        b = 1
        for _ in range(2, n + 1): 
            c = a + b 
            a = b 
            b = c 
        return c",82
20855629020,is_valid_sequence,"def is_valid_sequence(operations):
    stack = []
    for op in operations:
        if op == ""push"":
            stack.append(None)  # We don't care about the value, just the operation
        elif op == ""pop"":
            if not stack:
                return False
            stack.pop()
        elif op == ""peek"":
            if not stack:
                return False
    return True",82
15907216588,count_ways_to_climb,"def count_ways_to_climb(n: int, max_steps: int) -> int:
    if n == 0:
        return 1
    if n < 0:
        return 0

    ways = 0
    for i in range(1, max_steps + 1):
        ways += count_ways_to_climb(n - i, max_steps)

    return ways",82
479789224,find_anagrams,"from collections import Counter

def find_anagrams(lst):
    anagrams = {}
    for word in lst:
        sorted_word = """".join(sorted(word))
        if sorted_word in anagrams:
            anagrams[sorted_word].append(word)
        else:
            anagrams[sorted_word] = [word]
    return [group for group in anagrams.values() if len(group) > 1]",82
2331284142,permutations,"def backtrack(curr, remaining):
    if len(remaining) == 0:
        return [curr]
    result = []
    for i in range(len(remaining)):
        new_curr = curr + [remaining[i]]
        new_remaining = remaining[:i] + remaining[i+1:]
        result += backtrack(new_curr, new_remaining)
    return result

def permutations(elements):
    return backtrack([], elements)",82
19224495629,is_rotated_string,"def is_rotated_string(s1: str, s2: str) -> bool:
    if len(s1) != len(s2):
        return False
    s2 = s2[-2:] + s2[:-2]
    if s1 == s2:
        return True
    s2 = s2[-2:] + s2[:-2]
    return s1 == s2",82
28617977423,isSubsequence,"def isSubsequence(s: str, t: str) -> bool:
    l,r = 0,0
    bound_1,bound_2 = len(s),len(t)
    
    while l < bound_1 and r < bound_2:
        if s[l] == t[r]:
            l += 1
        r += 1
            
    return l == bound_1",82
6538466624,find_two_largest_unique,"def find_two_largest_unique(l):
    unique_numbers = set(l)
    if len(unique_numbers) == 0:
        return (None, None)
    elif len(unique_numbers) == 1:
        return (list(unique_numbers)[0], None)
    else:
        unique_numbers = list(unique_numbers)
        unique_numbers.sort()
        return (unique_numbers[-1], unique_numbers[-2])",82
31942144290,find_duplicate,"def find_duplicate(nums):
    tortoise = hare = nums[0]
    while True:
        tortoise = nums[tortoise]
        hare = nums[nums[hare]]
        if tortoise == hare:
            break

    tortoise = nums[0]
    while tortoise != hare:
        tortoise = nums[tortoise]
        hare = nums[hare]

    return tortoise",82
18179727841,next_greater_element,"import heapq

def next_greater_element(arr):
    answer = [-1] * len(arr)
    heap = []

    for i in range(len(arr)):
        val = arr[i]

        while heap and heap[0][0] < val:
            _, idx = heapq.heappop(heap)
            answer[idx] = val

        heapq.heappush(heap, [val, i])

    return answer",82
24844835820,is_valid_bracket_sequence,"def is_valid_bracket_sequence(s: str) -> bool:
    bracket_map = {')': '(', ']': '[', '}': '{'}
    stack = []
    for char in s:
        if char in bracket_map.values():
            stack.append(char)
        elif char in bracket_map.keys():
            if not stack or stack.pop() != bracket_map[char]:
                return False
    return not stack",82
1764787312,largest_num,"from functools import cmp_to_key

def largest_num(nums):
    def compare(a, b):
        return int(b + a) - int(a + b)
    
    str_nums = [str(num) for num in nums]
    str_nums.sort(key=cmp_to_key(compare))
    result = ''.join(str_nums)
    return int(result) if result[0] != '0' else 0",82
8941736827,max_substring_length,"def max_substring_length(s):
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length",82
75181561743,find_LongestSubstring,"def find_LongestSubstring(s):
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length",82
22117869569,intersection_nested_lists,"def intersection_nested_lists(l1, l2):
    # Calculate the intersection of the first list and each nested list in the second list
    result = []
    for lst in l2:
        # Filter nested list to only include elements that are in l1
        nested_list_intersection = [n for n in lst if n in l1]
        result.append(nested_list_intersection)
    return result",82
17381797641,sumOddLengthSubarrays,"def sumOddLengthSubarrays(arr):
    total_sum = 0
    n = len(arr)
    for i in range(n):
        subarray_sum = 0
        for j in range(i, n):
            subarray_sum += arr[j]
            if (j - i + 1) % 2 != 0:
                total_sum += subarray_sum
    return total_sum",82
15951551111,count_ways_to_climb,"def count_ways_to_climb(n):
    if n <= 1:
        return 1
    if n == 2:
        return 2
    a, b, c = 1, 1, 2
    for _ in range(3, n + 1):
        a, b, c = b, c, a + b + c
    return c",82
14337767803,smallestMultiple,"def smallestMultiple(n):
    def gcd(a, b):
        while b != 0:
            a, b = b, a % b
        return a

    def lcm(a, b):
        return a * b // gcd(a, b)

    result = 1
    for i in range(2, n + 1):
        result = lcm(result, i)
    return result",82
7313490296,compress_list,"def compress_list(nums):
    result = []
    count = 1
    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1]:
            count += 1
        else:
            result.append(nums[i - 1])
            result.append(count)
            count = 1
    result.append(nums[-1])
    result.append(count)
    return result",82
40335087361,max_length_substring,"def max_length_substring(s):
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length",82
74362594558,isIPv6,"import re

def isIPv6(IP):
    if IP.count("":"") == 7:
        IPArray = IP.split("":"")
        for part in IPArray:
            if 0<=int(part, 16)<=65535:
                if part == hex(int(part))[2:] or part == ""0"":
                    continue
                return False
        return True
    return False",82
22047802061,isPerfectNumber,"def isPerfectNumber(n):
    if n < 1:
        return False
    divisors = [1]
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    return sum(divisors) == n",82
35956165575,longest_unique_subarray,"def longest_unique_subarray(arr):
    start, max_len, seen = 0, 0, {}
    for end, val in enumerate(arr):
        if val in seen and start <= seen[val]:
            start = seen[val] + 1
        else:
            max_len = max(max_len, end - start + 1)
        seen[val] = end
    return max_len",81
41261852917,is_sad,"def is_sad(n):
    """"""
    :type n: int
    :rtype: bool
    """"""
    occurred = set()
    while n != 1:
        total = 0
        for s in str(n):
            total += pow(int(s), 2)
        if total in occurred:
            return True
        occurred.add(total)
        n = total
    return False",81
40982383937,flatten_dict,"def flatten_dict(d, parent_key='', sep='.'):
    items = []
    for k, v in d.items():
        new_key = parent_key + sep + k if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep=sep).items())
        else:
            items.append((new_key, v))
    return dict(items)",81
14938605887,find_unsorted_subarray,"def find_unsorted_subarray(nums):
    sorted_nums = sorted(nums)
    start, end = -1, -1
    for i in range(len(nums)):
        if nums[i] != sorted_nums[i]:
            if start == -1:
                start = i
            end = i
    if start == -1:
        return 0
    return end - start + 1",81
37912782816,max_unique_characters,"def max_unique_characters(s):
    char_set = set()
    left = 0
    max_length = 0
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
    return max_length",81
19605546885,findDuplicate,"def findDuplicate(nums):
    tortoise = hare = nums[0]
    while True:
        tortoise = nums[tortoise]
        hare = nums[nums[hare]]
        if tortoise == hare:
            break

    tortoise = nums[0]
    while tortoise != hare:
        tortoise = nums[tortoise]
        hare = nums[hare]

    return hare",81
35672364218,connected_components,"def dfs(graph, node, visited):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

def connected_components(graph):
    visited = set()
    count = 0
    for node in graph:
        if node not in visited:
            dfs(graph, node, visited)
            count += 1
    return count",81
69941233193,string_reverse,"def string_reverse(s):
    s.reverse()
    return ''.join(s)

# check function to verify the correctness of the solution
def check_solution():
    assert string_reverse(list(""hello""))==""olleh""
    assert string_reverse(list(""python""))==""nohtyp""
    assert string_reverse(list(""algorithm""))==""mhtirogla""
    print(""All test cases passed"")

check_solution()",81
32087467380,longest_unique_subarray,"def longest_unique_subarray(arr):
    start = 0
    max_length = 0
    seen = {}
    for end in range(len(arr)):
        if arr[end] in seen:
            start = max(start, seen[arr[end]] + 1)
        seen[arr[end]] = end
        max_length = max(max_length, end - start + 1)
    return max_length",81
23483573327,dec_to_base,"def dec_to_base(num, base):
    if base < 2 or base > 16:
        return ""ERROR""
    result = """"
    digits = ""0123456789ABCDEF""
    while num > 0:
        remainder = num % base
        num = num // base
        result = digits[remainder] + result
    return result",81
5406358125,check_word_combination,"def check_word_combination(s: str, wordDict):
    dp = [False] * (len(s)+1)
    dp[0] = True

    for start in range(len(s)):
        for end in range(start,len(s)):
            if dp[start] and s[start:end+1] in wordDict:
                dp[end+1] = True

    return dp[-1]",81
41956963941,longest_repeated_char_substring,"def longest_repeated_char_substring(str1):
    max_len = 1
    current_len = 1
    for i in range(1, len(str1)):
        if str1[i] == str1[i-1]:
            current_len += 1
            max_len = max(max_len, current_len)
        else:
            current_len = 1
    return max_len",81
40023995067,can_make_sum,"def can_make_sum(nums, target):
    dp = [False] * (target + 1)
    dp[0] = True
    for i in range(1, target + 1):
        for num in nums:
            if i >= num:
                dp[i] = dp[i] or dp[i - num]
            if dp[i]:
                break
    return dp[target]",81
8108693051,max_possible_number,"def max_possible_number(numbers):
    numbers = list(map(str, numbers))
    numbers.sort(key=lambda x: x*3, reverse=True)
    return str(int(''.join(numbers)))

print(max_possible_number([3, 30, 34, 5, 9]))
print(max_possible_number([10,2]))
print(max_possible_number([121,12]))",81
74928798857,tree_height,"from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def tree_height(root: Optional[TreeNode]) -> int:
    if not root:
        return 0
    return 1 + max(tree_height(root.left), tree_height(root.right))",81
15951965371,max_Diff,"def max_Diff(arr):
    max_diff = arr[1] - arr[0]
    min_val = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_val > max_diff:
            max_diff = arr[i] - min_val
        if arr[i] < min_val:
            min_val = arr[i]
    return max_diff",81
31942539720,reverse_odd,"def reverse_odd(lst):
    odd = [i for i in lst if i % 2 != 0]
    odd.reverse()
    result = []
    odd_index = 0
    for i in lst:
        if i % 2 != 0:
            result.append(odd[odd_index])
            odd_index += 1
        else:
            result.append(i)
    return result",81
14541583022,is_pangram,"import string

def is_pangram(s: str) -> bool:
    alphabet = set(string.ascii_lowercase)
    s = s.lower()
    return bool(set(s) & alphabet == alphabet)

print(is_pangram(""The quick brown fox jumps over the lazy dog""))
print(is_pangram(""Hello world""))
print(is_pangram(""Pack my box with five dozen liquor jugs""))",81
23729198318,wordPatternMatch,"def wordPatternMatch(pattern, words):
    word_dict = {}
    if len(pattern) != len(words):
        return False
    for p, w in zip(pattern, words):
        if p not in word_dict:
            if w in word_dict.values():
                return False
            word_dict[p] = w
        elif word_dict[p] != w:
            return False
    return True",81
33841750289,spread_info,"from collections import defaultdict

def spread_info(n, headID, manager, informTime):
    graph = defaultdict(list)
    for i, m in enumerate(manager):
        graph[m].append(i)

    def dfs(node):
        if not graph[node]:
            return 0
        return informTime[node] + max(dfs(subordinate) for subordinate in graph[node])

    return dfs(headID)",81
71036661143,find_max_value,"def find_max_value(tuples_list):
  # Use the max function with a key parameter that specifies the second element of each tuple
  # as the value to compare. The max function will return the tuple with the maximum value for
  # the second element, and we return its second element as the result.
  return max(tuples_list, key=lambda x: x[1])[1]",81
14597544738,is_perfect,"def is_perfect(num):
    if num < 2:
        return False

    sum_div = 1
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            sum_div += i
            if i != num // i:
                sum_div += num // i

    return sum_div == num",81
25943459631,reverse_words,"def reverse_words(sentence):
    return ' '.join(word[::-1] for word in sentence.split())

# Testing the function
print(reverse_words(""I love programming"")) # Should print ""I evol gnimmargorp""
print(reverse_words(""Hello world"")) # Should print ""olleH dlrow""
print(reverse_words(""Python is fun"")) # Should print ""nohtyP si nuf""",81
42713806806,find_smallest_pattern,"def find_smallest_pattern(s):
    pattern_length = 1
    while pattern_length <= len(s) // 2:
        if len(s) % pattern_length == 0:
            pattern = s[:pattern_length]
            if pattern * (len(s) // pattern_length) == s:
                return len(s) // pattern_length
        pattern_length += 1
    return 1",81
19434228727,is_binary_search_tree,"def is_binary_search_tree(root, min_val=float('-inf'), max_val=float('inf')):
    if root is None:
        return True

    if not (root.val > min_val and root.val < max_val):
        return False

    return (is_binary_search_tree(root.left, min_val, root.val) and
            is_binary_search_tree(root.right, root.val, max_val))",81
35850172259,unique_bst,"def unique_bst(n):
    if n == 0:
        return 1
    dp = [1] * (n + 1)
    for i in range(2, n + 1):
        dp[i] = 0
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",81
17533192922,max_sum_subarray_of_size_k,"def max_sum_subarray_of_size_k(arr, k):
    if not arr or k <= 0 or k > len(arr):
        return 0

    max_sum = current_sum = sum(arr[:k])
    for i in range(k, len(arr)):
        current_sum += arr[i] - arr[i-k]
        max_sum = max(max_sum, current_sum)
    return max_sum",81
21158904046,count_pairs_with_sum,"def count_pairs_with_sum(arr, target):
    count = 0
    seen = {}
    for i in range(len(arr)):
        complement = target - arr[i]
        if complement in seen:
            count += seen[complement]
        if arr[i] in seen:
            seen[arr[i]] += 1
        else:
            seen[arr[i]] = 1
    return count",81
39533198318,is_valid,"def is_valid(s: str) -> bool:
    stack = []
    mapping = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}
    
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    
    return not stack",81
26627836589,find_max_difference,"def find_max_difference(arr):
    max_diff = arr[1] - arr[0]
    min_element = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",81
70751786320,kth_smallest_number,"import heapq

def kth_smallest_number(nums, k):
    # Create a min heap from the array
    heapq.heapify(nums)
    # Pop the smallest element from the heap k-1 times
    for _ in range(k-1):
        heapq.heappop(nums)
    # The kth smallest element is now at the root of the heap
    return nums[0]",81
13735721712,sum_of_primes,"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def sum_of_primes(start, end):
    return sum([num for num in range(start, end+1) if is_prime(num)])",81
25308938222,find_substring,"def find_substring(s):
    char_set = set()
    left = 0
    max_length = 0
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
    return max_length",81
44157825766,string_compression,"def string_compression(s):
    result = """"
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            count += 1
        else:
            result += s[i - 1] + str(count)
            count = 1
    result += s[-1] + str(count)
    return result",81
6321741444,uniqueBSTs,"def uniqueBSTs(n):
    if n == 0:
        return 0
    dp = [1] * (n + 1)
    for i in range(2, n + 1):
        dp[i] = 0
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",81
6142090623,min_time_visit,"def min_time_visit(points):
    total_time = 0
    for i in range(1, len(points)):
        x_diff = abs(points[i][0] - points[i-1][0])
        y_diff = abs(points[i][1] - points[i-1][1])
        total_time += x_diff + y_diff - min(x_diff, y_diff)
    return total_time",81
7365276739,most_frequent_element,"def most_frequent_element(lst):
    count = {}
    max_element = None
    max_count = 0
    for element in lst:
        if element in count:
            count[element] += 1
        else:
            count[element] = 1
        if count[element] > max_count:
            max_element = element
            max_count = count[element]
    return max_element",81
11190023870,reverse_num,"def reverse_num(num):
    if num == 0:
        return 0
    negative = False
    if num < 0:
        negative = True
        num = -num
    rev = 0
    while num > 0:
        rev = rev*10 + num%10
        num //= 10
    return -rev if negative else rev",81
32976969445,count_pairs_with_sum,"def count_pairs_with_sum(arr, target):
    count = 0
    freq = {}
    for i in range(len(arr)):
        complement = target - arr[i]
        if complement in freq:
            count += freq[complement]
        if arr[i] in freq:
            freq[arr[i]] += 1
        else:
            freq[arr[i]] = 1
    return count",81
7469674383,list_intersection,"def list_intersection(list1, list2):
    set1 = set(list1)
    set2 = set(list2)
    return [item for item in list1 if item in set2]

# Alternative solution using set intersection
def list_intersection(list1, list2):
    set1 = set(list1)
    set2 = set(list2)
    return list(set1.intersection(set2))",81
4997373460,max_increasing_subarray,"def max_increasing_subarray(arr):
    n = len(arr)
    max_len = 1
    curr_len = 1
    for i in range(1, n):
        if arr[i] > arr[i-1]:
            curr_len += 1
            max_len = max(max_len, curr_len)
        else:
            curr_len = 1
    return max_len",81
71527785349,is_perfect_cube,"def is_perfect_cube(num):
    """"""
    Check if a number is a perfect cube.
    
    :param num: integer, the number to check
    :return: boolean, True if num is a perfect cube, False otherwise
    """"""
    if num < 0:
        num = -num
    return round(num ** (1. / 3)) ** 3 == num",81
73054585807,generate_permutations,"def generate_permutations(nums):
    result = []
    prev_element = []
    
    def dfs(element):
        if len(element) == 0:
            result.append(prev_element[:])
        
        for e in element:
            next_element = element[:]
            next_element.remove(e)
            
            prev_element.append(e)
            dfs(next_element)
            prev_element.pop()
    
    dfs(nums)
    return result",81
34818290955,longest_Substring,"def longest_Substring(s):
    charMap = {}
    left = 0
    maxLength = 0
    for right in range(len(s)):
        if s[right] in charMap:
            left = max(left, charMap[s[right]] + 1)
        charMap[s[right]] = right
        maxLength = max(maxLength, right - left + 1)
    return maxLength",81
7596632790,find_unique_pairs,"def find_unique_pairs(arr, k):
    seen = {}
    count = 0
    for i in range(len(arr)):
        complement = k - arr[i]
        if complement in seen:
            count += len(seen[complement])
        if arr[i] in seen:
            seen[arr[i]].append(i)
        else:
            seen[arr[i]] = [i]
    return count",81
34696566950,find_smallest_divisible,"def find_smallest_divisible(n):
    def gcd(x, y):
        while(y):
            x, y = y, x % y
        return x
    def lcm(x, y):
        return (x*y)//gcd(x,y)
    num = 1
    for i in range(1, n + 1):
        num = lcm(num, i)
    return num",81
29112648031,top_k_frequent,"def top_k_frequent(nums, k):
    count = {}
    for n in nums:
        count[n] = count.get(n, 0) + 1

    count_list = list(count.items())
    k_elems = sorted(count_list, key=lambda key: key[1], reverse=True)[:k]
    res = [res[0] for res in k_elems]
    return res",81
8734800419,count_single_letter_substrings,"def count_single_letter_substrings(s):
    count = 0
    left = 0
    n = len(s)
    
    for right in range(n + 1):
        if right == n or s[left] != s[right]:
            length = right - left
            count += (length * (length + 1)) // 2
            left = right
            
    return count",81
29539407723,Fibonacci,"def Fibonacci(n):
    if n<0:
        print(""Incorrect input"")
    elif n==1:
        return 0
    elif n==2:
        return 1
    else:
        fib = [0, 1]
        for i in range(2, n):
            fib.append(fib[i-1] + fib[i-2])
        return fib[-1]",81
75069658869,largest_divisible,"def largest_divisible(nums, divisor):
    # Filter the list to only include numbers divisible by the divisor
    divisible_nums = [num for num in nums if num % divisor == 0]
    
    # If the filtered list is empty, return None
    if not divisible_nums:
        return None
    
    # Return the maximum number in the filtered list
    return max(divisible_nums)",81
41384197238,shortestSubarray,"def shortestSubarray(nums):
    sortedNums = sorted(nums)
    start, end = -1, -1
    for i in range(len(nums)):
        if nums[i] != sortedNums[i]:
            if start == -1:
                start = i
            end = i
    if start == -1:
        return 0
    return end - start + 1",81
9243793325,flatten_dict,"def flatten_dict(d, parent_key='', sep='.'):
    items = []
    for k, v in d.items():
        new_key = parent_key + sep + k if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep=sep).items())
        else:
            items.append((new_key, v))
    return dict(items)",81
43025067704,doIntersect,"def doIntersect(rect1, rect2):
    (x1, y1), (x2, y2) = rect1
    (x3, y3), (x4, y4) = rect2

    if x2 < x3 or x4 < x1 or y2 < y3 or y4 < y1:
        return False
    return True",81
3169134070,spiral_matrix,"def spiral_matrix(matrix):
    result = []
    while matrix:
        result += matrix.pop(0)
        if matrix and matrix[0]:
            for row in matrix:
                result.append(row.pop())
        if matrix:
            result += matrix.pop()[::-1]
        if matrix and matrix[0]:
            for row in matrix[::-1]:
                result.append(row.pop(0))
    return result",81
42216597235,smallest_divisible,"def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def smallest_divisible(n):
    result = 1
    for i in range(1, n + 1):
        result = lcm(result, i)
    return result",81
32397267717,is_valid_IPV4,"def is_valid_IPV4(s: str) -> bool:
    parts = s.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit() or not 0 <= int(part) <= 255 or (part[0] == '0' and len(part) > 1):
            return False
    return True",81
35150306340,longest_balanced_parentheses,"def longest_balanced_parentheses(s):
    max_len = 0
    stack = [-1]
    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_len = max(max_len, i - stack[-1])
    return max_len",81
27856719314,caesar_cipher,"def caesar_cipher(text, shift):
    result = """"
    for char in text:
        if char.isalpha():
            ascii_offset = 65 if char.isupper() else 97
            cipher_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
            result += cipher_char
        else:
            result += char
    return result",81
12235248240,uniquePaths,"def uniquePaths(m: int, n: int) -> int:
    dp = [[1 for _ in range(n)] for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",81
16458934931,smallest_prime,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def smallest_prime(numbers):
    primes = [num for num in numbers if is_prime(num)]
    return min(primes) if primes else None",81
20586120219,maxSumSubarray,"def maxSumSubarray(arr, k):
    if (not arr) or (len(arr) < k):
        return None
    
    max_sum = window_sum = sum(arr[:k])
    for i in range(len(arr) - k):
        window_sum = window_sum - arr[i] + arr[i+k]
        max_sum = max(max_sum, window_sum)
        
    return max_sum",81
33322363293,max_k_consecutive_sum,"def max_k_consecutive_sum(array, k):
    if k == 1:
        return max(array)
    window_sum = sum(array[:k])
    max_sum = window_sum
    for i in range(len(array) - k):
        window_sum = window_sum - array[i] + array[i + k]
        max_sum = max(max_sum, window_sum)
    return max_sum",80
25042223966,num_subarrays_with_given_sum,"def num_subarrays_with_given_sum(arr, k):
    hashmap = {0: 1}
    total = 0
    res = 0
    for num in arr:
        total += num
        differ = total - k
        res += hashmap.get(differ, 0)
        hashmap[total] = 1 + hashmap.get(total, 0)
    return res",80
18957523027,remove_duplicates_and_sort,"def remove_duplicates_and_sort(nums):
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    nums.sort()
    i = 0
    while i < len(nums) - 1:
        if nums[i] == nums[i + 1]:
            nums.pop(i + 1)
        else:
            i += 1
    return len(nums)",80
33184988541,min_operations_to_one,"def min_operations_to_one(n):
    operations = 0
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            if n == 3 or n % 4 == 1:
                n -= 1
            else:
                n += 1
        operations += 1
    return operations",80
12888554128,string_compression,"def string_compression(s):
    compressed = """"
    count = 1
    for i in range(len(s)):
        if i+1 < len(s) and s[i] == s[i+1]:
            count += 1
        else:
            compressed += s[i]
            if count > 1:
                compressed += str(count)
            count = 1
    return compressed",80
40653529831,can_construct,"from collections import defaultdict

def can_construct(str1: str, str2: str) -> bool:
    str1_dict = defaultdict(int)
    str2_dict = defaultdict(int)

    for char in str1:
        str1_dict[char] += 1

    for char in str2:
        str2_dict[char] += 1

    return str1_dict == str2_dict",80
5671137255,encode_message,"def encode_message(text, n):
    encoded_message = """"
    for char in text:
        if char.isalpha():
            shift = n % 26
            new_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))
            encoded_message += new_char
        else:
            encoded_message += char
    return encoded_message",80
21585056639,calculate_triangle_area,"def calculate_triangle_area(a, b, c):
    '''
    Calculate the area of a triangle given the lengths of its three sides using Heron's formula.
    '''
    s = (a + b + c) / 2
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    return area",80
70082261705,weird_or_not_weird,"def weird_or_not_weird(n):
    if n % 2 != 0:
        return 'Weird'
    elif n % 2 == 0 and 6 <= n <= 20:
        return 'Weird'
    elif n % 2 == 0 and n > 20:
        return 'Not Weird'
    else:
        return 'Not Weird'",80
42131898441,find132pattern,"def find132pattern(nums):
    stack = []
    curMin = nums[0]
    for curr in nums:
        while stack and curr >= stack[-1][0]:
            stack.pop()
        if stack and curr > stack[-1][1]:
            return True
        stack.append([curr, curMin])
        curMin = min(curr, curMin)
    return False",80
25407546468,sum_of_even_numbers,"def sum_of_even_numbers(num_list):
    # Initialize the sum to 0
    total_sum = 0

    # Iterate through the list
    for num in num_list:
        # If the number is even, add it to the total sum
        if num % 2 == 0:
            total_sum += num

    # Return the total sum
    return total_sum",80
10137995632,least_common_multiple,"def least_common_multiple(n):
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    def lcm(a, b):
        return a * b // gcd(a, b)

    result = 1
    for i in range(1, n + 1):
        result = lcm(result, i)
    return result",80
17740369836,find_max_sum_subarray,"def find_max_sum_subarray(arr, k):
    if not arr or k <= 0 or k > len(arr):
        return 0

    max_sum = current_sum = sum(arr[:k])
    for i in range(k, len(arr)):
        current_sum += arr[i] - arr[i - k]
        max_sum = max(max_sum, current_sum)

    return max_sum",80
32418684048,group_elements,"from typing import List

def group_elements(lst: List[int], group_size: int) -> List[List[int]]:
    ans = []
    temp = []
    for i, num in enumerate(lst):
        temp.append(num)
        if (i+1) % group_size == 0:
            ans.append(temp)
            temp = []
    if temp:
        ans.append(temp)
    return ans",80
10457313633,maxDifference,"def maxDifference(arr):
    max_diff = arr[1] - arr[0]
    min_element = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",80
72253709878,max_sum_of_subarray,"def max_sum_of_subarray(arr, k):
    if len(arr) < k:
        return None
    
    max_sum = sum(arr[:k])
    temp_sum = max_sum
    
    for i in range(k, len(arr)):
        temp_sum = temp_sum - arr[i - k] + arr[i]
        max_sum = max(max_sum, temp_sum)
    
    return max_sum",80
21944771512,lucas_number,"def lucas_number(n):
    if n == 0:
        return 2
    if n == 1:
        return 1

    first = 2
    second = 1

    i = 2
    while i <= n:
        current = first + second
        first = second
        second = current
        i += 1

    return second",80
23756468856,max_Product_Subarray,"def max_Product_Subarray(nums):
    res = max(nums)
    currMin, currMax = 1, 1

    for n in nums:
        tmp = currMax*n
        currMax = max(n, currMin*n, currMax*n)
        currMin = min(n, currMin*n, tmp)
        res = max(res, currMax)
    
    return res",80
14921506252,length_Of_Longest_Substring,"def length_Of_Longest_Substring(s):
    charSet = set()
    l = 0
    res = 0

    for r in range(len(s)):
        while s[r] in charSet:
            charSet.remove(s[l])
            l += 1
        charSet.add(s[r])
        res = max(res, r - l + 1)
    return res",80
22535732102,uniquePaths,"def uniquePaths(m: int, n: int) -> int:
    dp = [[1] * n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    return dp[-1][-1]",80
37496205791,count_connected_components,"def count_connected_components(G):
    def dfs(node):
        visited[node] = True
        for neighbor in G[node]:
            if not visited[neighbor]:
                dfs(neighbor)
    visited = [False] * len(G)
    count = 0
    for i in range(len(G)):
        if not visited[i]:
            dfs(i)
            count += 1
    return count",80
72331209368,find_max_difference,"def find_max_difference(arr):
    max_diff = arr[1] - arr[0]
    min_element = arr[0]
    for i in range(1,len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",80
14557062102,long_substring,"def long_substring(s):
    char_map = {}
    left = 0
    result = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        result = max(result, right - left + 1)
    return result",80
1852894277,smallest_multiple,"def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def smallest_multiple(n):
    result = 1
    for i in range(1, n + 1):
        result = lcm(result, i)
    return result",80
35047171579,longest_substring,"def longest_substring(s):
    char_map = {}
    left = 0
    result = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        result = max(result, right - left + 1)
    return result",80
6268742502,top_frequent,"def top_frequent(words, k):
    d={}
    for word in words:
        if word in d:
            d[word]+=1
        else:
            d[word]=1
    ls=sorted(d.items(),key=lambda x:(-x[1],x[0]))[:k]
    result=[]
    for i in ls:
        result.append(i[0])
    return result",80
40251946665,longest_valid_parentheses,"def longest_valid_parentheses(s):
    max_len = 0
    stack = [-1]
    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_len = max(max_len, i - stack[-1])
    return max_len",80
14951228024,longest_arithmetic_subsequence,"from collections import defaultdict

def longest_arithmetic_subsequence(arr, d):
    dp = defaultdict(int)
    max_length = 0
    for i in range(len(arr)):
        prev = arr[i] - d
        dp[arr[i]] = max(dp[arr[i]], dp[prev] + 1)
        max_length = max(max_length, dp[arr[i]])
    return max_length",80
18760837166,find_min_product,"import heapq as hq

def find_min_product(A, B):
    hq.heapify(A)

    B = list(map(lambda x: -x, B))
    hq.heapify(B)
    answer = 0
    for i in range(len(A)):
        answer += hq.heappop(A) * (hq.heappop(B)) * -1

    return answer",80
70474712029,unique_permutations,"from math import factorial

def unique_permutations(s):
    char_counts = {}
    for char in s:
        if char in char_counts:
            char_counts[char] += 1
        else:
            char_counts[char] = 1
    total_permutations = factorial(len(s))
    for count in char_counts.values():
        total_permutations //= factorial(count)
    return total_permutations",80
22671568546,find_single_number,"def find_single_number(nums):
    """"""
    Finds the single number in an array where every other number appears twice.

    :param nums: List[int] -- List of integers where every element appears twice except for one.
    :return: int -- The single number that appears only once.
    """"""
    result = 0
    for num in nums:
        result ^= num
    return result",80
71314668689,find_missing_integer,"def find_missing_integer(A):
    N = len(A)
    B = N * [0]
    extras = 0
    for elem in A:
        if elem <= N and elem > 0:
            B[elem-1] = elem
    for i in range(N):
        if B[i] == 0:
            return i+1
    return N+1",80
18275559786,check_one_row_word,"def check_one_row_word(word):
    row1 = set('qwertyuiop')
    row2 = set('asdfghjkl')
    row3 = set('zxcvbnm')
    word = word.lower()
    if set(word) <= row1 or set(word) <= row2 or set(word) <= row3:
        return True
    else:
        return False",80
71942461228,find_permutations,"def find_permutations(input_string):
    if len(input_string) == 1:
        return [input_string]
    permutations = []
    for i in range(len(input_string)):
        char = input_string[i]
        remaining_chars = input_string[:i] + input_string[i+1:]
        for perm in find_permutations(remaining_chars):
            permutations.append(char + perm)
    return permutations",80
3256105681,compute_Longest_Substring,"def compute_Longest_Substring(s): 
    charSet = set()
    l = 0
    res = 0

    for r in range(len(s)):
        while s[r] in charSet:
            charSet.remove(s[l])
            l += 1
        charSet.add(s[r])
        res = max(res, r - l + 1)
    return res",80
24831044429,count_repeated_words,"def count_repeated_words(s):
    word_list = s.split()
    word_count = {}
    for word in word_list:
        if word in word_count:
            word_count[word] += 1
        else:
            word_count[word] = 1
    repeated_words_count = sum(1 for count in word_count.values() if count > 1)
    return repeated_words_count",80
6744778319,max_sum_subarray_k,"def max_sum_subarray_k(arr, k):
    if len(arr) < k:
        return None
    max_sum = sum(arr[:k])
    current_sum = max_sum
    for i in range(len(arr) - k):
        current_sum = current_sum - arr[i] + arr[i + k]
        max_sum = max(max_sum, current_sum)
    return max_sum",80
4101063070,is_beautiful_array,"def is_beautiful_array(arr):
    """"""
    Check if the given array is a beautiful array.
    """"""
    n = len(arr)
    for i in range(n):
        for j in range(i+1, n):
            for k in range(i+1, j):
                if arr[k] * 2 == arr[i] + arr[j]:
                    return False
    return True",80
22526138827,longest_substring,"def longest_substring(s):
    char_map = {}
    left = 0
    result = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        result = max(result, right - left + 1)
    return result",80
7504237441,find_max_difference,"def find_max_difference(arr):
    if not arr:
        return 0
    
    min_val = arr[0]
    max_diff = 0

    for i in range(1, len(arr)):
        if arr[i] < min_val:
            min_val = arr[i]
        else:
            max_diff = max(max_diff, arr[i] - min_val)

    return max_diff",80
7411751996,count_subarray,"from typing import List


def count_subarray(arr: List[int], sub: List[int]) -> int:
    if len(sub) > len(arr):
        return 0
    
    count = 0
    for i in range(len(arr) - len(sub) + 1):
        if arr[i: i + len(sub)] == sub:
            count += 1
    return count",80
8343904006,sum_two_largest_evens,"def sum_two_largest_evens(A):
    list1 = []
    for i in A:
        if i % 2 == 0:
            list1.append(i)
    list1.sort()
    if len(list1) >= 2:
        return list1[-1] + list1[-2]
    else:
        return ""There are not enough even numbers in the list""",80
25813633800,isValidParentheses,"def isValidParentheses(s: str) -> bool:
    stack = []
    mapping = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}

    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)

    return not stack",80
29744401990,max_sub_array_of_size_k,"def max_sub_array_of_size_k(arr, k):
    if not arr or k <= 0 or k > len(arr):
        return 0
    max_sum = current_sum = sum(arr[:k])
    for i in range(k, len(arr)):
        current_sum += arr[i] - arr[i-k]
        max_sum = max(max_sum, current_sum)
    return max_sum",80
8019974914,longest_equal_subsequence,"def longest_equal_subsequence(arr): 
    max_len = 1
    current_len = 1
    for i in range(1, len(arr)): 
        if arr[i] == arr[i-1]: 
            current_len += 1
            max_len = max(max_len, current_len) 
        else: 
            current_len = 1
    return max_len",80
25756181231,longest_substring_without_repeating,"def longest_substring_without_repeating(s):
    charSet = set()
    l = 0
    res = 0
    
    for r in range(len(s)):
        while s[r] in charSet:
            charSet.remove(s[l])
            l += 1
        charSet.add(s[r])
        res = max(res, r - l + 1)
    return res",80
19065076875,num_trees,"def num_trees(n):
    if n == 0:
        return 1
    dp = [1] * (n + 1)
    for i in range(2, n + 1):
        dp[i] = 0
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",80
17808152645,max_pairwise_product,"def max_pairwise_product(numbers):
    n = len(numbers)
    max1 = -1
    max2 = -1

    for i in range(n):
        if numbers[i] > max1:
            max2 = max1
            max1 = numbers[i]
        elif numbers[i] > max2:
            max2 = numbers[i]

    return max1 * max2",80
8054321952,is_valid_ip,"def is_valid_ip(s: str) -> bool:
    parts = s.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit() or not 0 <= int(part) <= 255 or (part[0] == '0' and len(part) > 1):
            return False
    return True",80
6587446123,maxDifference,"def maxDifference(arr):
    max_diff = arr[1] - arr[0]
    min_element = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",80
32504890884,max_diff,"def max_diff(arr):
    max_diff = arr[1] - arr[0]
    min_element = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",80
71924689526,prime_count,"def prime_count(n):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2,num):
            if (num % i) == 0:
                return False
        return True
    count = 0
    for i in range(2,n):
        if is_prime(i):
            count += 1
    return count",80
73087778305,lengthOfLongestSubstring,"from collections import deque

def lengthOfLongestSubstring(s: str) -> int:
    answer = 0
    ch_set = set()
    queue = deque()
    for ch in s:
        while ch in ch_set:
            ch_set.remove(queue.popleft())

        queue.append(ch)
        ch_set.add(ch)

        answer = max(len(ch_set), answer)
    return answer",80
10242675227,longest_Substring,"def longest_Substring(s):
    char_map = {}
    left = 0
    result = 0
    for right in range(len(s)):
        if s[right] in char_map:
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        result = max(result, right - left + 1)
    return result",80
44205463910,is_Perfect_Number,"def is_Perfect_Number(n):
    sum = 1
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            if i * (n // i) == n:
                sum = sum + i + n//i
            i += 1
    return sum == n and n!=1",80
20538764696,is_properly_nested,"def is_properly_nested(brackets):
    stack = []
    pairs = {')': '(', '}': '{', ']': '['}
    
    for bracket in brackets:
        if bracket in pairs.values():
            stack.append(bracket)
        elif bracket in pairs.keys():
            if stack == [] or stack.pop() != pairs[bracket]:
                return False
    return stack == []",80
14116086746,is_Perfect_Number,"def is_Perfect_Number(n):
    sum = 1
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            if i * (n // i) == n:
                sum = sum + i + n//i
            i += 1
    return sum == n and n!=1",80
35069379908,valid_mountain_array,"def valid_mountain_array(arr):
    l=len(arr)
    i=0
    while i+1<l and arr[i]<arr[i+1]:
        i+=1 
    if i==0 or i==l-1:
        return False
    while i+1<l and arr[i]>arr[i+1]:
        i+=1
    return i==l-1",80
35123874877,next_power_of_2,"def next_power_of_2(n):
    power = 1
    while power < n:
        power *= 2
    return power

# Check function with provided data points
assert next_power_of_2(5) == 8
assert next_power_of_2(10) == 16
assert next_power_of_2(31) == 32",80
42209888402,is_leap_year,"def is_leap_year(year):
    """"""
    Check if a given year is a leap year.
    """"""
    if year % 4 == 0:
        if year % 100 == 0:
            if year % 400 == 0:
                return True
            else:
                return False
        else:
            return True
    else:
        return False",80
41999960052,max_subarray_sum_k,"def max_subarray_sum_k(arr, k):
    if not arr or k <= 0 or k > len(arr):
        return 0

    max_sum = current_sum = sum(arr[:k])
    for i in range(k, len(arr)):
        current_sum += arr[i] - arr[i - k]
        max_sum = max(max_sum, current_sum)
    return max_sum",80
13693838278,peculiar_sort,"def peculiar_sort(nums):
    sorted_nums = []
    while nums:
        # Append the minimum value
        min_val = min(nums)
        nums.remove(min_val)
        sorted_nums.append(min_val)
        if not nums:
            break
        # Append the maximum value
        max_val = max(nums)
        nums.remove(max_val)
        sorted_nums.append(max_val)
    return sorted_nums",80
30548979683,subarray_sum,"from collections import defaultdict

def subarray_sum(arr, k):
    output = 0
    currsum = 0
    d = defaultdict(int)
    d[0] = 1

    for n in arr:
        currsum += n
        dif  = currsum - k
        output += d[dif]
        d[currsum] +=1
    return output",80
38617046009,shortest_repeating_pattern,"def shortest_repeating_pattern(s: str) -> str or None:
    if len(set(s)) == len(s):
        return None

    for i in range(1, len(s)//2 + 1):
        if len(s) % i == 0:
            if s[:i] * (len(s)//i) == s:
                return s[:i]
    return None",80
74612468091,remove_value,"def remove_value(nums, val):
    """"""
    :type nums: List[int]
    :type val: int
    :rtype: int
    """"""
    i = 0  # Pointer for elements not equal to val
    for j in range(len(nums)):
        if nums[j] != val:
            nums[i] = nums[j]
            i += 1
    return i",80
12815773154,max_overlapping_intervals,"def max_overlapping_intervals(intervals):
    events = []
    for start, end in intervals:
        events.append((start, 1))
        events.append((end, -1))
    events.sort()
    active, max_overlap = 0, 0
    for _, event in events:
        active += event
        max_overlap = max(max_overlap, active)
    return max_overlap",80
12314678591,generateBalancedBrackets,"def generateBalancedBrackets(n):
    def backtrack(s,left,right):
        if len(s) == 2 * n:
            res.append(s)
            return
        if left < n:
            backtrack(s+'(',left+1,right)
        if right < left:
            backtrack(s+')',left,right+1)
    res = []
    backtrack('',0,0)
    return res",80
32422516731,is_subsequence,"def is_subsequence(subseq, seq):
    subseq_index = 0
    seq_index = 0
    while subseq_index < len(subseq) and seq_index < len(seq):
        if subseq[subseq_index] == seq[seq_index]:
            subseq_index += 1
        seq_index += 1
    return subseq_index == len(subseq)",80
74733429839,find_middle_element,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def find_middle_element(head: ListNode) -> int:
    slow = head
    fast = head
    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next
    return slow.val",80
75246833625,is_Perfect_Square,"def is_Perfect_Square(n):
    if n < 0:
        return False
    if n == 0:
        return True
    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x*x == n",79
22722213092,pair_up,"def pair_up(nums):
    return [[nums[i], nums[i + 1]] for i in range(0, len(nums) - 1, 2)]

print(pair_up([1,2,3,4]))
print(pair_up([1,2,3,4,5]))
print(pair_up([7,8,9,10,11,12]))",79
20196491392,longest_string,"def longest_string(strings):
    if not strings:
        return """"
    return max(strings, key=len)

# Test cases
assert longest_string([""apple"", ""banana"", ""cherry""]) == ""banana""
assert longest_string([""dog"", ""elephant"", ""cat""]) == ""elephant""
assert longest_string([""hello"", ""world"", ""python"", ""programming""]) == ""programming""",79
72277534718,h_index,"def h_index(citations):
    citations.sort(reverse=True)
    cSize = len(citations)  
    for idx in range(cSize, -1, -1):
        count = 0
        for c in citations:
            if c >= idx:
                count += 1
            else:
                break

        if count >= idx:
            return idx
    return 0",79
32768105956,find_missing_numbers,"def find_missing_numbers(nums):
    allNums = [0] * (len(nums) + 1)
    missing = []
    
    for i in nums:
        allNums[i] += 1
    
    for i in range(len(allNums)):
        if allNums[i] == 0 and i != 0:
            missing.append(i)
                
    return missing",79
36439964102,find_first_non_repeating_character,"def find_first_non_repeating_character(s: str) -> str:
    char_count = {}
    
    for c in s:
        if c in char_count:
            char_count[c] += 1
        else:
            char_count[c] = 1

    for c in s:
        if char_count[c] == 1:
            return c
    return ""-1""",79
3480000572,perfect_squares,"def perfect_squares(n):
    dp = [0] + [float('inf')] * n
    for i in range(1, n + 1):
        j = 1
        while j * j <= i:
            dp[i] = min(dp[i], dp[i - j * j] + 1)
            j += 1
    return dp[n]",79
21338810042,find_max_product_adjacent,"def find_max_product_adjacent(numbers):
    if len(numbers) < 2:
        return None
    
    max_product = numbers[0] * numbers[1]
    for i in range(1, len(numbers) - 1):
        product = numbers[i] * numbers[i + 1]
        if product > max_product:
            max_product = product
    return max_product",79
37979227070,find_pairs,"def find_pairs(arr, target):
    count = 0
    seen = {}
    for i in range(len(arr)):
        complement = target - arr[i]
        if complement in seen:
            count += seen[complement]
        if arr[i] in seen:
            seen[arr[i]] += 1
        else:
            seen[arr[i]] = 1
    return count",79
26412988014,maxConsecutiveOnes,"def maxConsecutiveOnes(n):
    binary = bin(n).replace(""0b"", """")
    max_len = 0
    current_len = 0
    for bit in binary:
        if bit == '1':
            current_len += 1
            max_len = max(max_len, current_len)
        else:
            current_len = 0
    return max_len",79
74630899591,max_word_length,"def max_word_length(words):
  # Initialize the maximum length to 0
  max_length = 0

  # Iterate through each word in the list
  for word in words:
    # Update the maximum length if the current word is longer
    if len(word) > max_length:
      max_length = len(word)

  # Return the maximum length
  return max_length",79
36259635695,LengthOfLongestSubstring,"def LengthOfLongestSubstring(s):
    charSet = set()
    l = 0
    res = 0
    
    for r in range(len(s)):
        while s[r] in charSet:
            charSet.remove(s[l])
            l += 1
        charSet.add(s[r])
        res = max(res, r - l + 1)
    return res",79
72878974568,lucky_triples,"def lucky_triples(lst):
    count = 0
    for i in range(len(lst)):
        for j in range(i+1, len(lst)):
            if lst[j] % lst[i] == 0:
                for k in range(j+1, len(lst)):
                    if lst[k] % lst[j] == 0:
                        count += 1
    return count",79
70897068663,find_substring,"def find_substring(text, substring):
    count = 0
    text = text.lower()
    substring = substring.lower()
    start = 0
    
    while start < len(text):
        index = text.find(substring, start)
        if index == -1:
            break
        else:
            count += 1
            start = index + 1
            
    return count",79
4197028377,count_unique_pairs,"from collections import defaultdict

def count_unique_pairs(arr, target):
    freq = defaultdict(int)
    count = 0
    for num in arr:
        complement = target - num
        if freq[complement] > 0:
            count += 1
            freq[complement] -= 1
        else:
            freq[num] += 1
    return count",79
41672499284,max_sum_subarray,"def max_sum_subarray(arr,k):
    if len(arr) < k:
        return ""Invalid operation""
    maxSum = sum(arr[:k])
    windowSum = maxSum
    for i in range(len(arr) - k):
        windowSum = windowSum - arr[i] + arr[i+k]
        maxSum = max(maxSum, windowSum)
    return maxSum",79
72524041809,get_peak_element,"def get_peak_element(nums):
    if not nums:
        return None
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[mid + 1]:
            right = mid
        else:
            left = mid + 1
    return left",79
72765629833,consecutive_sum_ways,"def consecutive_sum_ways(n):
    answer = 0
    
    total = 0
    p2 = 1
    for p1 in range(1, n+1):
        total += p1
            
        while total > n:
            total -= p2
            p2 += 1
        
        if total == n:
            answer += 1
    
    return answer",79
40499421284,distinct_subsequences,"def distinct_subsequences(s):
    dp = [1]
    last_occurrence = {}
    for i in range(len(s)):
        dp.append(2 * dp[-1])
        if s[i] in last_occurrence:
            dp[-1] -= dp[last_occurrence[s[i]]]
        last_occurrence[s[i]] = i
    return dp[-1] - 1",79
28766908956,compress_string,"def compress_string(s):
    compressed = """"
    count = 1
    for i in range(len(s)):
        if i != len(s) - 1 and s[i] == s[i+1]:
            count += 1
        else:
            compressed += s[i] + (str(count) if count > 1 else """")
            count = 1
    return compressed",79
22049601671,find_pairs,"def find_pairs(arr, target):
    freq = {}
    count = 0
    for i in range(len(arr)):
        complement = target - arr[i]
        if complement in freq:
            count += freq[complement]
        if arr[i] in freq:
            freq[arr[i]] += 1
        else:
            freq[arr[i]] = 1
    return count",79
70268217348,max_sum_subarray_k,"def max_sum_subarray_k(arr, k):
    if not arr or k <= 0 or k > len(arr):
        return 0
    max_sum = current_sum = sum(arr[:k])
    for i in range(k, len(arr)):
        current_sum += arr[i] - arr[i-k]
        max_sum = max(max_sum, current_sum)
    return max_sum",79
74241352500,is_Perfect_Square,"def is_Perfect_Square(n):
    if n < 0:
        return False
    if n == 0:
        return True
    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x*x == n",79
30841909926,max_consecutive_ones,"def max_consecutive_ones(n):
    binary = bin(n)[2:]
    max_count = 0
    current_count = 0
    for i in range(len(binary)):
        if binary[i] == '1':
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count",79
17232464106,max_difference,"def max_difference(arr):
    if not arr:
        return 0
    min_val = arr[0]
    max_diff = 0
    for i in range(1, len(arr)):
        if arr[i] > min_val:
            max_diff = max(max_diff, arr[i] - min_val)
        else:
            min_val = arr[i]
    return max_diff",79
17593082189,is_perfect,"def is_perfect(n):
    sum = 1
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            if i * (n // i) == n:
                sum = sum + i + n//i
            i += 1
    return sum == n and n!=1",79
40677047976,max_substring_length,"def max_substring_length(s):
    used = {}
    max_length = start = 0
    for i, char in enumerate(s):
        if char in used and start <= used[char]:
            start = used[char] + 1
        else:
            max_length = max(max_length, i - start + 1)

        used[char] = i

    return max_length",79
23114430009,lengthOfLongestSubstring,"def lengthOfLongestSubstring(s):
    charSet = set()
    l = 0
    res = 0
    
    for r in range(len(s)):
        while s[r] in charSet:
            charSet.remove(s[l])
            l += 1
        charSet.add(s[r])
        res = max(res, r - l + 1)
    return res",79
2572302289,quadratic_roots,"import math

def quadratic_roots(a, b, c):
    D = b**2 - 4*a*c
    if D < 0:
        return ""Complex""
    x1 = (-b + math.sqrt(D)) / (2*a)
    x2 = (-b - math.sqrt(D)) / (2*a)
    return sorted([x1, x2])",79
28732568682,maxConsecutiveOnes,"def maxConsecutiveOnes(n):
    maxCount = 0
    currentCount = 0
    while n > 0:
        if n % 2 == 1:
            currentCount += 1
            maxCount = max(maxCount, currentCount)
        else:
            currentCount = 0
        n = n // 2
    return maxCount",79
17339095658,climb_staircase,"def climb_staircase(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    else:
        first = 1
        second = 2
        for _ in range(3, n + 1):
            third = first + second
            first = second
            second = third
        return second",79
70270867227,reduce_to_one,"def reduce_to_one(n):
  steps = 0
  while n != 1:
    if n % 2 == 0:
      n = n // 2
    else:
      if n == 3 or n % 4 == 1:
        n -= 1
      else:
        n += 1
    steps += 1
  return steps",79
24989323963,is_valid_bracket_sequence,"def is_valid_bracket_sequence(s):
    stack = []
    mapping = {"")"": ""("", ""]"": ""["", ""}"": ""{""}
    
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
            
    return not stack",79
43826736063,find_consecutive_ones,"def find_consecutive_ones(n):
    binary = bin(n).replace(""0b"","""")
    max_count = 0
    current_count = 0
    for bit in binary:
        if bit == '1':
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count",79
20064628222,union_intervals,"def union_intervals(A, B):
    intervals = sorted(A + B, key=lambda x: x[0])
    result = []
    for interval in intervals:
        if not result or result[-1][1] < interval[0]:
            result.append(interval)
        else:
            result[-1][1] = max(result[-1][1], interval[1])
    return result",79
71691548981,unique_pair_sum,"def unique_pair_sum(arr, target):
    seen = set()
    pairs = set()
    count = 0
    for num in arr:
        complement = target - num
        if complement in seen:
            pair = tuple(sorted((num, complement)))
            if pair not in pairs:
                pairs.add(pair)
                count += 1
        seen.add(num)
    return count",79
40587756236,next_greater_element,"def next_greater_element(arr):
    result = [-1] * len(arr)
    stack = []
    for i in range(len(arr) - 1, -1, -1):
        while stack and arr[stack[-1]] <= arr[i]:
            stack.pop()
        if stack:
            result[i] = arr[stack[-1]]
        stack.append(i)
    return result",79
8421425047,fib_number,"def fib_number(n):
    if n <= 1:
        return n
    array = [None] * (n+1)
    array[0] = 0
    array[1] = 1
    for i in range(2, n+1):
        array[i] = array[i-1] + array[i-2]
    return array[n]",79
27087499911,find_two_sum,"def find_two_sum(nums, target):
    if not nums: return []
    rslt, n = [], len(nums)
    num_dict = {}
    for i in range(n):
        complement = target - nums[i]
        if complement in num_dict:
            rslt.append((num_dict[complement], i))
        num_dict[nums[i]] = i
    return rslt",79
28138385299,min_steps_to_reach,"def min_steps_to_reach(start, end):
    startX, startY = start
    endX, endY = end
    # Calculate the differences in x and y coordinates
    deltaX = abs(startX - endX)
    deltaY = abs(startY - endY)
    # The minimum steps required is the maximum of deltaX and deltaY
    return max(deltaX, deltaY)",79
14579717683,find_First_Non_Repeating_Char,"from collections import OrderedDict

def find_First_Non_Repeating_Char(str):
    char_dict = OrderedDict()
    for char in str:
        if char in char_dict:
            char_dict[char] += 1
        else:
            char_dict[char] = 1
    for key, value in char_dict.items():
        if value == 1:
            return key
    return ""-""",79
24190934336,find_sum,"def find_sum(str1):
    s = '0'
    total = 0
    for i in str1:
        if i.isdigit():
            s += i
        else:
            total += int(s) if s != '0' else 0
            s = '0'
    total += int(s) if s != '0' else 0
    return total",79
28653626566,substring_count,"def substring_count(string, substring):
    count = 0
    len_string = len(string)
    len_substring = len(substring)
    if len_substring > len_string:
        return 0
    for i in range(len_string - len_substring + 1):
        if string[i:i+len_substring] == substring:
            count += 1
    return count",79
41820314566,distinctSubsequences,"def distinctSubsequences(s):
    dp = [1]
    last_occurrence = {}
    for i in range(len(s)):
        dp.append(2 * dp[-1])
        if s[i] in last_occurrence:
            dp[-1] -= dp[last_occurrence[s[i]]]
        last_occurrence[s[i]] = i
    return dp[-1] - 1",79
8168266069,lengthOfLongestSubstring,"def lengthOfLongestSubstring(s):
    charSet = set()
    l = 0
    result = 0

    for r in range(len(s)):
        while s[r] in charSet:
            charSet.remove(s[l])
            l += 1
        charSet.add(s[r])
        result = max(result, r - l + 1)
    return result",79
3914676891,to_uppercase,"def to_uppercase(s):
    uppercase_string = """"
    for character in s:
        # If the character is a lowercase letter
        if 'a' <= character <= 'z':
            # Convert the character to uppercase
            uppercase_character = chr(ord(character) - 32)
            uppercase_string += uppercase_character
        else:
            uppercase_string += character
    return uppercase_string",79
17994107080,lengthOfLongestSubstring,"def lengthOfLongestSubstring(s):
    charSet = set()
    l = 0
    res = 0
    
    for r in range(len(s)):
        while s[r] in charSet:
            charSet.remove(s[l])
            l += 1
        charSet.add(s[r])
        res = max(res, r - l + 1)
    return res",79
43312483492,find_largest_num,"def largest_num(arr):
    def compare(x, y):
        return int(str(x) + str(y)) - int(str(y) + str(x))
    
    arr = sorted(arr, key=cmp_to_key(compare), reverse=True)
    return int(''.join(map(str, arr)))

from functools import cmp_to_key

def find_largest_num(nums):
    return largest_num(nums)",79
21215072,count_pairs,"def count_pairs(arr, target):
    count = 0
    frequency = {}
    for i in range(len(arr)):
        complement = target - arr[i]
        if complement in frequency:
            count += frequency[complement]
        if arr[i] in frequency:
            frequency[arr[i]] += 1
        else:
            frequency[arr[i]] = 1
    return count",79
22742745930,is_prime_list,"def is_prime_list(numbers):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                return False
        return True

    prime_numbers = [num for num in numbers if is_prime(num)]
    return prime_numbers",79
24008728020,largest_prime,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def largest_prime(n):
    for i in range(n, 1, -1):
        if is_prime(i):
            return i",79
9820021529,longest_distinct_subarray,"def longest_distinct_subarray(arr):
    start = 0
    max_length = 0
    seen = {}
    for end, value in enumerate(arr):
        if value in seen:
            start = max(start, seen[value] + 1)
        seen[value] = end
        max_length = max(max_length, end - start + 1)
    return max_length",79
25103384041,is_permutation,"from collections import Counter

def is_permutation(s1, s2):
    """"""
    :type s1: str
    :type s2: str
    :rtype: bool
    """"""
    if len(s1) != len(s2):
        return False
    d1 = Counter(s1)
    d2 = Counter(s2)
    return d1 == d2",79
34854470855,lengthOfLongestSubstring,"def lengthOfLongestSubstring(s):
    charSet = set()
    l = 0
    res = 0
    
    for r in range(len(s)):
        while s[r] in charSet:
            charSet.remove(s[l])
            l += 1
        charSet.add(s[r])
        res = max(res, r - l + 1)
    return res",79
75246722585,find_peak_element,"def find_peak_element(nums):
    if not nums:
        return None
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[mid + 1]:
            right = mid
        else:
            left = mid + 1
    return left",79
70208642237,countAnagrams,"from collections import Counter

def countAnagrams(s):
    counter = Counter()
    result = 0
    for i in range(len(s)):
        c = Counter()
        for j in range(i, len(s)):
            c[s[j]] += 1
            t = tuple(sorted(c.items()))
            result += counter[t]
            counter[t] += 1
    return result",79
6507452126,find_repeating_pattern,"def find_repeating_pattern(s: str) -> (str, int):
    for i in range(1, len(s) // 2 + 1):
        if len(s) % i == 0:
            if s[:i] * (len(s) // i) == s:
                return s[:i], len(s) // i
    return s, 1",79
21353122918,max_length_consecutive_sequence,"def max_length_consecutive_sequence(nums):
    if not nums: return 0
    nums = set(nums)
    longest = 0
    for n in nums:
        if n - 1 not in nums:
            y = n + 1
            while y in nums:
                y += 1
            longest = max(longest, y - n)
    return longest",79
31586823210,find_duplicates,"def find_duplicates(s):
    words = s.split()
    word_count = {}
    duplicates = []
    for word in words:
        if word in word_count:
            word_count[word] += 1
        else:
            word_count[word] = 1
    for word, count in word_count.items():
        if count > 1:
            duplicates.append(word)
    return duplicates",79
7658947313,reduce_to_one,"def reduce_to_one(n):
    operations = 0
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            if n == 3 or n % 4 == 1:
                n -= 1
            else:
                n += 1
        operations += 1
    return operations",79
12405196912,fibonacci_dp,"def fibonacci_dp(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        fib_nums = [0, 1]
        for i in range(2, n + 1):
            fib_nums.append(fib_nums[i-1] + fib_nums[i-2])
        return fib_nums[n]",79
44154194266,list_product_common_elements,"from collections import Counter

def list_product_common_elements(l1, l2):
    c1 = Counter(l1)
    c2 = Counter(l2)

    result = 1
    for k in c1.keys():
        if k in c2.keys():
            min_count = min(c1[k], c2[k])
            result *= (k ** min_count)

    return result",79
7867971084,char_consecutive,"def char_consecutive(string, char):
    max_consecutive = 0
    current_consecutive = 0
    for i in string:
        if i == char:
            current_consecutive += 1
            if current_consecutive > max_consecutive:
                max_consecutive = current_consecutive
        else:
            current_consecutive = 0
    return max_consecutive",79
69915897980,maxUniqueSubstr,"def maxUniqueSubstr(s):
    used = {}
    start = max_length = 0
    for i, char in enumerate(s):
        if char in used and start <= used[char]:
            start = used[char] + 1
        else:
            max_length = max(max_length, i - start + 1)
        used[char] = i
    return max_length",79
14865628397,jump,"def jump(nums):
    if len(nums) <= 1:
        return 0
    jumps, far, max_far = 0, 0, 0
    for i in range(len(nums)-1):
        max_far = max(max_far, i + nums[i])
        if i == far:
            jumps += 1
            far = max_far
    return jumps",79
39989246647,pascal_row,"def pascal_row(n):
    bigArray = [[1]]
    for i in range(n):
        tmp = [0] + bigArray[-1] + [0]
        tmp2 = []
        for j in range(len(bigArray[-1])+1):
            tmp2.append(tmp[j]+tmp[j+1])
        bigArray.append(tmp2)
    return bigArray[n]",79
39788126413,sum_unique_elements,"def sum_unique_elements(nums):
    unique_elements = {}
    for num in nums:
        if num in unique_elements:
            unique_elements[num] += 1
        else:
            unique_elements[num] = 1
    sum_unique = 0
    for key, value in unique_elements.items():
        if value == 1:
            sum_unique += key
    return sum_unique",79
27196274911,is_rotation_palindrome,"def is_rotation_palindrome(s):
    def check_palindrome(s):
        for i in range(len(s) // 2):
            if s[i] != s[~i]:
                return False
        return True

    for i in range(len(s)):
        rotated = s[i:] + s[:i]
        if check_palindrome(rotated):
            return True

    return False",79
28031296928,max_Product,"def max_Product(nums):
    nums.sort()
    # The maximum product can be either (the product of the three largest numbers)
    # or (the product of the two smallest numbers (which could be negative) and the largest number)
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",79
18139066408,remove_k_digits,"def remove_k_digits(num, k):
    stack = []
    for digit in num:
        while k and stack and stack[-1] > digit:
            stack.pop()
            k -= 1
        stack.append(digit)
    while k and stack:
        stack.pop()
        k -= 1
    return ''.join(stack).lstrip('0') or '0'",78
71575854265,convert_base,"def convert_base(num, base):
    if num == 0:
        return '0'
    result = []
    while num > 0:
        num, remainder = divmod(num, base)
        if remainder < 10:
            result.append(str(remainder))
        else:
            result.append(chr(remainder + 55))
    return ''.join(reversed(result))",78
44073917045,find_largest_triplet_product,"def find_largest_triplet_product(arr):
    if len(arr) < 3:
        return None
    arr.sort()
    # The largest product can be either (3 largest numbers) or (2 smallest + largest number)
    return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])",78
30529410877,count_connected_components,"def count_connected_components(graph):
    def dfs(node, visited):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor, visited)

    visited = set()
    components = 0
    for node in graph:
        if node not in visited:
            dfs(node, visited)
            components += 1
    return components",78
7332237978,intersection_lists,"def intersection_lists(list1, list2):
    # Convert lists to sets to eliminate duplicates and find common elements
    set1 = set(list1)
    set2 = set(list2)
    # Find the intersection of the two sets
    intersection = set1.intersection(set2)
    # Convert the intersection set back to a list and return it
    return list(intersection)",78
11961646178,product_of_primes,"def product_of_primes(n):
    primes = []
    i = 2
    while len(primes) < n:
        for p in primes:
            if i % p == 0:
                break
        else:
            primes.append(i)
        i += 1
    product = 1
    for prime in primes:
        product *= prime
    return product",78
30138164570,remove_duplicate_numbers,"def remove_duplicate_numbers(nums):
    ptr1 = 0
    if len(nums) == 0:
        return 0
    for ptr2 in range(1, len(nums)):
        if nums[ptr2] != nums[ptr1]:
            ptr1 += 1
            nums[ptr1] = nums[ptr2]
    return ptr1 + 1",78
34311349124,max_pairwise_product,"def max_pairwise_product(numbers):
    n = len(numbers)
    if n < 2:
        raise ValueError(""The list must contain at least two numbers."")
    max_product = 0
    for i in range(n):
        for j in range(i + 1, n):
            max_product = max(max_product, numbers[i] * numbers[j])
    return max_product",78
39067866671,find_longest_conseq_subseq,"def find_longest_conseq_subseq(arr, n):
    arr_set = set(arr)
    longest = 0
    for i in arr:
        if i - 1 not in arr_set:
            j = i
            while j in arr_set:
                j += 1
            if longest < j - i:
                longest = j - i
    return longest",78
74666557703,findPairs,"def findPairs(arr, k):
    if len(arr) < 2:
        return 0
    seen = set()
    output = set()
    for num in arr:
        target = k - num
        if target not in seen:
            seen.add(num)
        else:
            output.add( (min(num,target), max(num,target)) )
    return len(output)",78
39770204741,minimum_operations,"def minimum_operations(n):
    operations = 0
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            if n == 3 or n % 4 == 1:
                n -= 1
            else:
                n += 1
        operations += 1
    return operations",78
29920710651,angle_between_hands,"def angle_between_hands(hour: int, minutes: int) -> float:
    if hour >= 12:
        hour %= 12
    m = 6 * minutes
    h = 30 * hour + minutes / 2
    ans = abs(m - h)
    return ans if ans <= 180 else 360 - ans",78
40810728127,min_operations,"def min_operations(n):
    operations = 0
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            if n == 3 or n % 4 == 1:
                n -= 1
            else:
                n += 1
        operations += 1
    return operations",78
72679327606,is_toeplitz,"from typing import List

def is_toeplitz(matrix: List[List[int]]) -> bool:
    for row_index, row in enumerate(matrix):
        for digit_index, digit in enumerate(row):
            if not row_index or not digit_index:
                continue
            if matrix[row_index - 1][digit_index - 1] != digit:
                return False
    return True",78
38307136448,smallest_divisible,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def smallest_divisible(n):
    result = 1
    for i in range(1, n + 1):
        result = lcm(result, i)
    return result",78
18138851208,min_max_difference,"def min_max_difference(arr, k):
    if k == 1:
        return 0
    arr.sort()
    min_diff = float('inf')
    for i in range(len(arr) - k + 1):
        diff = arr[i + k - 1] - arr[i]
        if diff < min_diff:
            min_diff = diff
    return min_diff",78
40447786639,count_unique_words,"def count_unique_words(words):
    word_count = {}
    for word in words:
        if word in word_count:
            word_count[word] += 1
        else:
            word_count[word] = 1
    unique_words = 0
    for count in word_count.values():
        if count == 1:
            unique_words += 1
    return unique_words",78
40123594440,prime_factors,"def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            if i not in factors:
                factors.append(i)
    if n > 1 and n not in factors:
        factors.append(n)
    return len(factors)",78
42426215846,str_permutations,"def str_permutations(str1):
    if len(str1) == 1:
        return [str1]
    permutations = []
    for i in range(len(str1)):
        char = str1[i]
        remaining = str1[:i] + str1[i+1:]
        for perm in str_permutations(remaining):
            permutations.append(char + perm)
    return permutations",78
7210900977,find_longest_increasing_subsequence,"def find_longest_increasing_subsequence(nums):
    if not nums:
        return 0

    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)",78
42368676144,max_unique_chars,"def max_unique_chars(s):
    used = {}
    max_len = start = 0
    for index, char in enumerate(s):
        if char in used and start <= used[char]:
            start = used[char] + 1
        else:
            max_len = max(max_len, index - start + 1)
        used[char] = index
    return max_len",78
9542282917,max_sub_array,"def max_sub_array(arr, k):
    if len(arr) < k:
        return None
    max_sum = sum(arr[:k])
    window_sum = max_sum
    for i in range(len(arr) - k):
        window_sum = window_sum - arr[i] + arr[i + k]
        max_sum = max(max_sum, window_sum)
    return max_sum",78
5113556571,num_trees,"def num_trees(n):
    G = [0] * (n + 1)
    G[0], G[1] = 1, 1
    for i in range(2, n+1):
        for j in range(1, i+1):
            G[i] += G[j-1] * G[i-j]
    return G[n]",78
36794453445,quick_sort,"def quick_sort(list):
    if len(list) <= 1:
        return list
    else:
        pivot = list.pop()
        greater = []
        lesser = []
        for item in list:
            if item > pivot:
                greater.append(item)
            else:
                lesser.append(item)
        return quick_sort(lesser) + [pivot] + quick_sort(greater)",78
8680105614,find_max_min,"import heapq

def find_max_min(nums):
    heap = []
    
    for num in nums:
        heapq.heappush(heap, num)
        
    if len(heap)<1: return (0,0)
    
    min_ = heapq.heappop(heap)
    max_ = max(heap)
    heapq.heappush(heap, min_)
    
    return (max_, min_)",78
36395443739,most_frequent,"from collections import Counter

def most_frequent(lst):
    if not lst:
        return None
    data = Counter(lst)
    get_mode = dict(data)
    mode = [k for k, v in get_mode.items() if v == max(list(data.values()))]
    if len(mode) == len(lst):
        return None
    else:
        return mode[0]",78
33426541161,find_most_occurring_char,"def find_most_occurring_char(input_string):
    char_count = {}
    for char in input_string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    max_count = max(char_count.values())
    for char in input_string:
        if char_count[char] == max_count:
            return char",78
38587870144,check_perfect_number,"def check_perfect_number(num):
    if num < 1:
        return False
    sum = 1
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            sum += i
            if i != num // i:
                sum += num // i
    return sum == num",78
28116325492,boat_carrying,"def boat_carrying(people, limit):
    answer = 0
    people.sort(reverse = True)
    left, right = 0, len(people) - 1
    while left <= right:
        if people[left] + people[right] <= limit:
            right -= 1
        left += 1
        answer += 1
    return answer",78
3432492703,longest_subsequence,"def longest_subsequence(str1):
  max_len = 1
  current_len = 1
  for i in range(1, len(str1)):
    if str1[i] == str1[i-1]:
      current_len += 1
      max_len = max(max_len, current_len)
    else:
      current_len = 1
  return max_len",78
1581016511,max_score,"import heapq, math

def max_score(nums, k):
    nums = [-v for v in nums]
    heapq.heapify(nums)

    score = 0
    for _ in range(k):
        updated_v = -heapq.heappop(nums)

        score += updated_v
        heapq.heappush(nums, -math.ceil(updated_v/3))
    
    return score",78
24276957925,caesar_cipher,"def caesar_cipher(text, shift):
    cipher_text = """"
    for char in text:
        if char.isalpha():
            shift_val = 65 if char.isupper() else 97
            cipher_text += chr((ord(char) + shift - shift_val) % 26 + shift_val)
        else:
            cipher_text += char
    return cipher_text",78
40908891358,max_subarray_sum,"def max_subarray_sum(arr, k):
    if len(arr) < k:
        return ""Invalid""
    max_sum = sum(arr[:k])
    window_sum = max_sum
    for i in range(len(arr)-k):
        window_sum = window_sum - arr[i] + arr[i+k]
        max_sum = max(max_sum, window_sum)
    return max_sum",78
1876617052,lucas,"def lucas(n): 
    a = 2
    b = 1
    if n == 0: 
        return a 
    elif n == 1: 
        return b 
    else: 
        for i in range(2,n+1): 
            c = a + b 
            a = b 
            b = c 
        return b",78
19104588126,to_uppercase,"def to_uppercase(s):
    result = """"
    for c in s:
        # Check if character is lowercase
        if 'a' <= c <= 'z':
            # Convert to uppercase by subtracting the difference in ASCII values
            result += chr(ord(c) - (ord('a') - ord('A')))
        else:
            result += c
    return result",78
34299859964,min_start_value,"def min_start_value(nums):
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    mm = nums[0]
    cursum = nums[0]
    for i in range(1, len(nums)):
        cursum += nums[i]
        mm = min(mm, cursum)
    return abs(min(0, mm)) + 1",78
32296310756,frequent_element,"def frequent_element(nums):
    count = {}
    res = nums[0]
    max_count = 1
    for n in nums:
        if n in count:
            count[n] += 1
        else:
            count[n] = 1
        if count[n] > max_count:
            max_count = count[n]
            res = n
    return res",78
881487826,is_balanced,"def is_balanced(parentheses: str) -> bool:
    stack = []
    mapping = {"")"": ""("", ""]"": ""["", ""}"": ""{""}
    
    for char in parentheses:
        if char in mapping.values():
            stack.append(char)
        elif char in mapping.keys():
            if not stack or mapping[char] != stack.pop():
                return False
    return not stack",78
19331003878,search_insert,"def search_insert(nums, target):
    left, right = 0, len(nums)-1
    while left <= right:
        mid = (left + right)//2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left",78
7961388621,sort_strings_by_length,"def sort_strings_by_length(strings):
    return sorted(strings, key=lambda x: (-len(x), strings.index(x)))

print(sort_strings_by_length([""apple"", ""banana"", ""kiwi"", ""orange""]))
print(sort_strings_by_length([""cat"", ""dog"", ""elephant"", ""tiger""]))
print(sort_strings_by_length([""red"", ""blue"", ""green"", ""yellow""]))",78
7258792906,max_diff,"def max_diff(arr):
    max_diff_val = 0
    min_val = arr[0]

    for i in range(1, len(arr)):
        if arr[i] - min_val > max_diff_val:
            max_diff_val = arr[i] - min_val
        if arr[i] < min_val:
            min_val = arr[i]
    return max_diff_val",78
48948775277,compress_string,"def compress_string(s):
    result = """"
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            count += 1
        else:
            result += s[i-1] + str(count)
            count = 1
    result += s[-1] + str(count)
    return result",78
70045710264,longest_repeated_char_substring,"def longest_repeated_char_substring(s):
    max_length = 1
    current_length = 1
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1
    return max_length",78
31902170118,check_perfect_number,"def check_perfect_number(num):
    # space_complexity: O(1)
    # time_complexity: O(n)
    if num < 1:
        return False
    sum_divisors = 0
    for i in range(1, num):
        if num % i == 0:
            sum_divisors += i
    return sum_divisors == num",78
20789542261,find_pair_product,"def find_pair_product(n, arr, m):
    l, r = 0, n - 1
    while l < r:
        if arr[l] * arr[r] > m:
            r -= 1
        elif arr[l] * arr[r] < m:
            l += 1
        else:
            return 'yes'
    return 'no'",78
30948437462,largestNumber,"def largestNumber(nums):
    from functools import cmp_to_key
    def compare(x, y):
        return 1 if x + y < y + x else -1 if x + y > y + x else 0
    nums = [str(num) for num in nums]
    nums.sort(key=cmp_to_key(compare))
    return str(int(''.join(nums)))",78
19002107438,most_frequent_element,"def most_frequent_element(lst):
    if not lst:
        return None
    frequency = {}
    for element in lst:
        if element in frequency:
            frequency[element] += 1
        else:
            frequency[element] = 1
    max_freq = max(frequency.values())
    for element in lst:
        if frequency[element] == max_freq:
            return element",78
5360605261,generate_primes,"def generate_primes(n):
    primes = []
    for num in range(2, n+1):
        is_prime = True
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(num)
    return primes",78
31505227354,are_numbers_strictly_increasing,"def are_numbers_strictly_increasing(s: str) -> bool:
    lst = s.split()
    num_lst = []
    for w in lst:
        if w.isdigit():
            num_lst.append(int(w))
    for i in range(len(num_lst) - 1):
        if num_lst[i] >= num_lst[i + 1]:
            return False
    return True",78
40731425569,find_prime,"def find_prime(list):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    
    for num in list:
        if is_prime(num):
            return num
    return -1",78
37286726953,compress_string,"def compress_string(s):
    result = """"
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            count += 1
        else:
            result += s[i-1] + str(count)
            count = 1
    result += s[-1] + str(count)
    return result",78
38220657766,max_Sum_SubarrayOfSizeK,"def max_Sum_SubarrayOfSizeK(arr,k): 
    if (not arr) or (len(arr) < k):
        return None
    current_sum = max_sum = sum(arr[:k])
    for i in range(k,len(arr)):
        current_sum += arr[i] - arr[i-k]
        max_sum = max(max_sum, current_sum)
    return max_sum",78
71403138267,can_construct,"def can_construct(ransomNote: str, magazine: str) -> bool:
    ransomNote = list(ransomNote)
    magazine = list(magazine)
    for m in magazine:
        if m in ransomNote:
            idx = ransomNote.index(m)
            ransomNote.pop(idx)
        if len(ransomNote) == 0:
            return True
    return False",78
29546265871,find_primes,"def find_primes(n):
    primes = []
    for num in range(2, n+1):
        is_prime = True
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(num)
    return primes",78
43143447008,max_profit,"def max_profit(stock_prices):
    if len(stock_prices) < 2:
        return 0
    min_price = stock_prices[0]
    max_profit = 0
    for price in stock_prices:
        min_price = min(min_price, price)
        current_profit = price - min_price
        max_profit = max(max_profit, current_profit)
    return max_profit",78
27220294195,num_trees,"def num_trees(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",78
12234597260,can_group_subsequences,"from collections import Counter

def can_group_subsequences(hand):
    cardcount = Counter(hand)
    for card in sorted(hand):
        if cardcount[card] > 0:
            for i in range(card, card + 3):
                if cardcount[i] > 0:
                    cardcount[i] -= 1
                else:
                    return False
    return True",78
38922231168,count_distinct_subsequences,"def count_distinct_subsequences(s):
    dp = [1]
    last_occurrence = {}
    for i, char in enumerate(s):
        dp.append(dp[-1] * 2)
        if char in last_occurrence:
            dp[-1] -= dp[last_occurrence[char]]
        last_occurrence[char] = i
    return dp[-1] - 1",78
1448452267,first_non_repeating,"def first_non_repeating(str1):
    char_order = []
    ctr = {}
    for c in str1:
        if c in ctr:
            ctr[c] += 1
        else:
            ctr[c] = 1
            char_order.append(c)
    for c in char_order:
        if ctr[c] == 1:
            return c
    return """"",78
25204736089,find_majority_element,"def find_majority_element(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    if candidate is None:
        return -1

    return candidate if nums.count(candidate) > len(nums) // 2 else -1",78
25872544841,max_Subarray_Sum,"def max_Subarray_Sum(arr,k):
    if not arr or k <= 0 or k > len(arr):
        return 0

    max_sum = current_sum = sum(arr[:k])
    for i in range(k, len(arr)):
        current_sum += arr[i] - arr[i-k]
        max_sum = max(max_sum, current_sum)

    return max_sum",78
40958194098,unique_char_count,"def unique_char_count(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    unique_count = 0
    for count in char_count.values():
        if count == 1:
            unique_count += 1
    return unique_count",78
33772064277,to_upper,"def to_upper(s):
    upper_str = """"
    for char in s:
        if 97 <= ord(char) <= 122: # Checks if the character is lowercase
            upper_str += chr(ord(char)-32) # Converts lowercase to uppercase by subtracting 32 from ASCII value
        else:
            upper_str += char
    return upper_str",78
33266459134,longest_valid_parentheses,"def longest_valid_parentheses(s):
    longest = 0
    stack = [-1]

    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                longest = max(longest, i - stack[-1])
                
    return longest",78
74202648265,first_unique_char,"def first_unique_char(s: str) -> int:
    char_count = {}
    
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
            
    for i, char in enumerate(s):
        if char_count[char] == 1:
            return i
            
    return -1",78
4997981400,find_max_gap,"def find_max_gap(number):
    binary = bin(number)[2:]
    max_gap = 0
    current_gap = 0

    for bit in binary:
        if bit == '1':
            if current_gap > max_gap:
                max_gap = current_gap
            current_gap = 0
        else:
            current_gap += 1

    return max_gap",77
33642176185,is_subsequence,"def is_subsequence(s: str, t: str) -> bool:
    s_index = 0
    t_index = 0
    
    while s_index < len(s) and t_index < len(t):
        if s[s_index] == t[t_index]:
            s_index += 1
        t_index += 1
    
    return s_index == len(s)",77
11759243777,decimal_to_hex,"def decimal_to_hex(decimal_num):
    hexadecimal = """"
    while decimal_num != 0:
        remainder = decimal_num % 16
        if remainder < 10:
            hexadecimal = str(remainder) + hexadecimal
        else:
            hexadecimal = chr(remainder+55) + hexadecimal
        decimal_num = decimal_num // 16
    return hexadecimal",77
73327340798,Max_Consecutive_Ones,"def Max_Consecutive_Ones(n):
    bin_str = bin(n)[2:]
    max_count = 0
    current_count = 0
    for bit in bin_str:
        if bit == '1':
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count",77
24460749203,max_sum_subarray,"def max_sum_subarray(arr, k):
    if len(arr) < k:
        return None
    max_sum = sum(arr[:k])
    temp_sum = max_sum
    for i in range(k, len(arr)):
        temp_sum = temp_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, temp_sum)
    return max_sum",77
4985320888,findCommonElements,"from collections import Counter

def findCommonElements(list1, list2):
    counter1 = Counter(list1)
    counter2 = Counter(list2)
    commonElements = []
    for element in set(list1) & set(list2):
        minFrequency = min(counter1[element], counter2[element])
        commonElements.extend([element] * minFrequency)
    return commonElements",77
70082443785,longest_word_length,"def longest_word_length(words):
    return len(max(words, key=len))

assert longest_word_length([""cat"", ""window"", ""defenestrate""]) == 12
assert longest_word_length([""short"", ""longer"", ""longest""]) == 7
assert longest_word_length([""one"", ""two"", ""three"", ""four"", ""five""]) == 5",77
2732338077,find_max_subarray_sum,"def find_max_subarray_sum(arr, k):
    if len(arr) < k:
        return None
    
    max_sum = window_sum = sum(arr[:k])
    for i in range(len(arr) - k):
        window_sum = window_sum - arr[i] + arr[i + k]
        max_sum = max(max_sum, window_sum)
    
    return max_sum",77
12234532700,generate_parentheses,"def generate_parentheses(n):
    def generate(p, left, right, parens=[]):
        if left:         generate(p + '(', left-1, right)
        if right > left: generate(p + ')', left, right-1)
        if not right:    parens.append(p)
        return parens
    return generate('', n, n)",77
38425531761,transpose_matrix,"def transpose_matrix(mat):
    num_rows = len(mat)
    num_cols = len(mat[0])
    transposed_matrix = [[0 for _ in range(num_rows)] for _ in range(num_cols)]
    for i in range(num_rows):
        for j in range(num_cols):
            transposed_matrix[j][i] = mat[i][j]
    return transposed_matrix",77
70928301946,is_subsequence,"def is_subsequence(s: str, t: str) -> bool:
    s_index = 0
    t_index = 0
    while s_index < len(s) and t_index < len(t):
        if s[s_index] == t[t_index]:
            s_index += 1
        t_index += 1
    return s_index == len(s)",77
70897124023,length_of_LIS,"def length_of_LIS(nums: list) -> int:
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",77
27384182284,min_moves_to_equal,"def min_moves_to_equal(arr):
    arr.sort()
    mid = arr[len(arr)//2]
    return sum([abs(i-mid) for i in arr])

print(min_moves_to_equal([1,2,3]))
print(min_moves_to_equal([1,10,2,9]))
print(min_moves_to_equal([1,0,0,8,6]))",77
9426393307,sieve_primes,"def sieve_primes(n):
    sieve = [True] * n
    for x in range(2, int(n**0.5) + 1):
        if sieve[x]: sieve[2*x::x] = [False] * len(sieve[2*x::x])
    return [x for x in range(2, n) if sieve[x]]",77
38665746564,is_krishnamurthy,"def is_krishnamurthy(num):
    temp = num
    sum = 0
    while temp > 0:
        digit = temp % 10
        fact = 1
        for i in range(1, digit + 1):
            fact *= i
        sum += fact
        temp //= 10
    return sum == num",77
4068906002,parse_expression,"def parse_expression(expression):
    expression = expression.replace("" "", """")
    while ""("" in expression:
        start = expression.rfind(""("")
        end = expression.find("")"", start)
        sub_expr = expression[start+1:end]
        sub_result = eval(sub_expr)
        expression = expression[:start] + str(sub_result) + expression[end+1:]
    return eval(expression)",77
2865160106,smallest_prime,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def smallest_prime(numbers):
    primes = [num for num in numbers if is_prime(num)]
    return min(primes)",77
38726736521,connectSticks,"from heapq import heapify, heappop, heappush, heapreplace

def connectSticks(sticks):
    heapify(sticks)
    cost = 0
    while len(sticks)>1:
        temp = heappop(sticks) + heappop(sticks)
        cost += temp
        heappush(sticks, temp)
    return cost",77
71230437366,count_larger_followers,"def count_larger_followers(arr):
    count = 0
    for i in range(len(arr)): # 2重 for文を使用して、各要素が後続の要素より大きい回数を数えます
        for j in range(i+1, len(arr)):
            if arr[i] < arr[j]:
                count += 1
    return count",77
6070612883,first_unique_char,"def first_unique_char(s: str) -> int:
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for i in range(len(s)):
        if char_count[s[i]] == 1:
            return i
    return -1",77
40628149516,next_greater,"def next_greater(arr):
    next = -1
    result = [-1]*len(arr)
    s = []
    for i in range(len(arr)):
        while(len(s) != 0 and arr[s[-1]] < arr[i]):
            next = arr[i]
            result[s[-1]] = next
            s.pop()
        s.append(i)
    return result",77
41963123652,common_elements,"from collections import Counter

def common_elements(nums1, nums2):
    c1 = Counter(nums1)
    c2 = Counter(nums2)
    l = list(set(nums1).intersection(set(nums2)))
    lst = []
    for n in l:
        ln = [n] * min(c1[n], c2[n])
        lst.extend(ln)
    return lst",77
40853106531,factorial_digit_sum,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def factorial_digit_sum(n):
    fact = factorial(n)
    digit_sum = 0
    while fact > 0:
        digit_sum += fact % 10
        fact = fact // 10
    return digit_sum",77
24569868090,combinations,"def combinations(arr, k):
    answer = []
    def combine(index, temp_list):
        if len(temp_list) == k:
            answer.append(temp_list[:])
            return
        for i in range(index, len(arr)):
            temp_list.append(arr[i])
            combine(i+1, temp_list)
            temp_list.pop()
    combine(0, [])
    return answer",77
3892462367,permutations,"def permutations(nums):
    result = []

    def backtrace(path, options):
        if not options:
            result.append(list(path))
            return
        
        for i in range(len(options)):
            num = options[i]
            path.append(num)
            backtrace(path, options[:i] + options[i+1:])
            path.pop()

    backtrace([], nums)
    return result",77
20770555773,smallest_multiple,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def smallest_multiple(n):
    result = 1
    for i in range(1, n + 1):
        result = lcm(result, i)
    return result",77
17063751889,length_of_increasing_subsequence,"def length_of_increasing_subsequence(nums):
    if not nums:
        return 0

    dp = [1] * len(nums)

    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)",77
38947772994,balanced_parentheses,"def balanced_parentheses(n):
    def generate(p, left, right, parens=[]):
        if left:         generate(p + '(', left-1, right)
        if right > left: generate(p + ')', left, right-1)
        if not right:    parens.append(p)
        return parens
    return generate('', n, n)",77
18815368048,word_segmentation,"from functools import lru_cache

def word_segmentation(s, wordDict):
    @lru_cache(None)
    def recursion(i):
        if i == len(s): return True
        result = False
        for word in wordDict:
            if s[i:].startswith(word):
                result |= recursion(i + len(word))
        return result

    return recursion(0)",77
21052878150,countSubarrays,"from collections import defaultdict

def countSubarrays(nums, k):
    count = defaultdict(int)
    count[0] = 1
    result, sum_ = 0, 0
    for num in nums:
        sum_ += num % 2
        result += count[sum_ - k]
        count[sum_] += 1
    return result",77
1022106618,bounding_box,"def bounding_box(points):
    min_x = min(point[0] for point in points)
    min_y = min(point[1] for point in points)
    max_x = max(point[0] for point in points)
    max_y = max(point[1] for point in points)
    return ((min_x, min_y), (max_x, max_y))",77
7054796756,smallest_divisor_greater_than,"def smallest_divisor_greater_than(number, value):
    """"""
    Finds the smallest divisor of 'number' that is greater than 'value'.
    Time complexity: O(sqrt(number))
    Space complexity: O(1)
    """"""
    for i in range(value + 1, number + 1):
        if number % i == 0:
            return i
    return number",77
1375117488,is_prime,"def is_prime(n):
    if n <= 1:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    i = 3
    while i * i <= n:
        if n % i == 0:
            return False
        i += 2
    return True",77
23273272526,MaxConsecutiveOnes,"def MaxConsecutiveOnes(n): 
    count = 0 
    result = 0
    while (n != 0): 
        if (n % 2 == 1): 
            count+=1
            result = max(result, count) 
        else: 
            count = 0
        n = n // 2
    return result",77
74117050101,find_parentheses,"def find_parentheses(n):
    def generate(p, left, right, parens=[]):
        if left:         generate(p + '(', left-1, right)
        if right > left: generate(p + ')', left, right-1)
        if not right:    parens.append(p)
        return parens
    return generate('', n, n)",77
14123690626,decode_cipher,"def decode_cipher(cipher_text, key):
    decoded_text = """"
    for char in cipher_text:
        if char.isalpha():
            shift = 65 if char.isupper() else 97
            decoded_text += chr((ord(char) - shift - key) % 26 + shift)
        else:
            decoded_text += char
    return decoded_text",77
44157930676,unique_elements,"def unique_elements(nums):
    d = dict()
    for i in range(len(nums)):
        if nums[i] not in d:
            d[nums[i]] = 1
        else:
            d[nums[i]]+=1
    result = []
    for k in d.keys():
        if d[k] == 1:
            result.append(k)
    return result",77
12283321658,unique_bst,"def unique_bst(n):
    if n == 0:
        return 1
    dp = [1] * (n+1)
    for i in range(2, n+1):
        dp[i] = 0
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]
    return dp[n]",77
28933958725,max_consecutive_sublist_length,"def max_consecutive_sublist_length(s):
    max_length = 1
    current_length = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1
    return max_length",77
32122681744,count_Parentheses,"def count_Parentheses(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        dp[i] = 0
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]
    return dp[n]",77
30431753838,uniquePaths,"def uniquePaths(m, n):
    dp = [[1 for _ in range(n)] for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[m-1][n-1]",77
36552424668,multiply_except_self,"def multiply_except_self(nums):
    output = [1] * len(nums)
    left_product = 1
    right_product = 1
    for i in range(len(nums)):
        output[i] *= left_product
        left_product *= nums[i]

        output[-1 - i] *= right_product
        right_product *= nums[-1 - i]

    return output",77
17677998315,find_prime_numbers,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def find_prime_numbers(numbers):
    prime_numbers = [n for n in numbers if is_prime(n)]
    return prime_numbers",77
22637755624,difference_sum_squares,"def difference_sum_squares(n):
    sum_of_squares = 0
    square_of_sum = 0
    for i in range(1, n + 1):
        sum_of_squares += i ** 2
        square_of_sum += i
    square_of_sum = square_of_sum ** 2
    return square_of_sum - sum_of_squares",77
11089472202,find_missing_numbers,"def find_missing_numbers(nums):
    if nums is None or len(nums) ==0:
        return []
    nums.sort()
    res = []
    for i in range(len(nums)-1):
        if nums[i+1] - nums[i] > 1:
            for j in range(nums[i]+1, nums[i+1]):
                res.append(j)
    return res",77
42061515262,max_freq_element,"def max_freq_element(arr):
    freq = {}
    for i in arr:
        if i in freq:
            freq[i] += 1
        else:
            freq[i] = 1
    max_freq = max(freq.values())
    max_freq_elements = [k for k, v in freq.items() if v == max_freq]
    return min(max_freq_elements)",77
27106017886,intersection_of_arrays,"from typing import List

def intersection_of_arrays(arr1: List[int], arr2: List[int]) -> List[int]:
    # Convert both arrays to sets to eliminate duplicates
    set1 = set(arr1)
    set2 = set(arr2)
    
    # Find the intersection of the two sets
    intersection = list(set1 & set2)
    
    return intersection",77
39031350529,longest_repeated_char_substring,"def longest_repeated_char_substring(s):
    max_length = 1
    current_length = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1
    return max_length",77
40712001734,all_possible_permutations,"def all_possible_permutations(lst):
    if len(lst) <= 1:
        return [lst]
    result = []
    for i in range(len(lst)):
        m = lst[i]
        remaining_list = lst[:i] + lst[i+1:]
        for p in all_possible_permutations(remaining_list):
            result.append([m] + p)
    return result",77
25593618067,staircase,"def staircase(n):
    if n <= 1:
        return 1
    elif n == 2:
        return 2
    a, b, c = 1, 1, 2
    for _ in range(3, n + 1):
        a, b, c = b, c, a + b + c
    return c",77
7993918891,convert_to_upper,"def convert_to_upper(input_string):
    upper_string = """"
    for char in input_string:
        if 'a' <= char <= 'z':
            # Convert lowercase character to uppercase by subtracting the difference in ASCII values.
            upper_string += chr(ord(char) - ord('a') + ord('A'))
        else:
            upper_string += char
    return upper_string",77
71739921077,first_unique_char,"def first_unique_char(s: str) -> int:
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for i in range(len(s)):
        if char_count[s[i]] == 1:
            return i
    return -1",77
19151827728,num_trees,"def num_trees(n):
    if n <= 1:
        return 1
    dp = [1, 1]
    for i in range(2, n + 1):
        dp.append(0)
        for j in range(0, i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",77
16063810474,max_k_consecutive_sum,"def max_k_consecutive_sum(arr, k):
    if k > len(arr):
        return None

    max_sum = sum(arr[:k])
    temp_sum = max_sum

    for i in range(k, len(arr)):
        temp_sum = temp_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, temp_sum)

    return max_sum",77
8992950005,max_sum_subarray,"def max_sum_subarray(arr, k):
    if len(arr) < k:
        return None
    max_sum = sum(arr[:k])
    current_sum = max_sum
    for i in range(k, len(arr)):
        current_sum = current_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, current_sum)
    return max_sum",77
33391203095,is_subsequence,"def is_subsequence(s: str, t: str) -> bool:
    s_index = 0
    t_index = 0

    while s_index < len(s) and t_index < len(t):
        if s[s_index] == t[t_index]:
            s_index += 1
        t_index += 1

    return s_index == len(s)",77
73096469498,maximum_score,"def maximum_score(a, b, c):
    a, b, c = sorted([a, b, c])
    res = a + min(b, c - a)
    for i in range(1, a + 1):
        res = max(res, a - i + min(c - (a - i), b - i) + i)
    return res",77
35756094698,find_non_repeating_char,"def find_non_repeating_char(s):
    char_order = []
    counts = {}
    for char in s:
        if char in counts:
            counts[char] += 1
        else:
            counts[char] = 1
            char_order.append(char)
    for char in char_order:
        if counts[char] == 1:
            return char
    return None",77
70093726189,fibonacci,"def fibonacci(n):
    fib_series = [0]
    a, b = 0, 1
    if n == 0:
        return []
    elif n == 1:
        return fib_series
    else:
        for _ in range(n-1):
            fib_series.append(b)
            a, b = b, a + b
        return fib_series",77
2804410141,to_lowercase,"def to_lowercase(s):
    lower_str = """"
    for char in s:
        ascii_val = ord(char)
        if 65 <= ascii_val <= 90: # ASCII values for uppercase A-Z
            ascii_val += 32 # Convert to lowercase by adding 32 to ASCII value
        lower_str += chr(ascii_val)
    return lower_str",77
1850090790,is_valid_identifier,"import keyword

def is_valid_identifier(s: str) -> bool:
    if keyword.iskeyword(s):
        return False
    if not s or not s[0].isalpha() and s[0] != '_':
        return False
    for char in s[1:]:
        if not char.isalnum() and char != '_':
            return False
    return True",77
7466381715,num_trees,"def num_trees(n):
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    
    for i in range(2, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    
    return dp[n]",77
4368170927,first_unique_char,"def first_unique_char(s: str) -> int:
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for i in range(len(s)):
        if char_count[s[i]] == 1:
            return i
    return -1",77
35357875471,remove_outer_parentheses,"def remove_outer_parentheses(s: str) -> str:
    result, opened = [], 0
        
    for c in s:
        if c == ""("" and opened > 0: result.append(c)
        if c == "")"" and opened > 1:result.append(c)
            
        opened += 1 if c == ""("" else -1 
            
    return """".join(result)",77
18988740703,is_perfect_number,"def is_perfect_number(n):
    if n < 1:
        return False
    sum = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            sum += i
            if i != n // i:
                sum += n // i
    return sum == n",77
35011340599,count_target_pairs,"def count_target_pairs(nums, target):
    pair_count = 0
    nums_dict = {}

    for num in nums:
        if target - num in nums_dict:
            pair_count += nums_dict[target - num]
        if num in nums_dict:
            nums_dict[num] += 1
        else:
            nums_dict[num] = 1

    return pair_count",77
73459983544,climbStairs,"def climbStairs(n, maxStep):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        for j in range(1, min(i, maxStep) + 1):
            dp[i] += dp[i - j]
    return dp[n]",77
42561398905,find_largest_binary_gap,"def find_largest_binary_gap(N):
    binary_representation = bin(N)[2:]
    max_gap = 0
    current_gap = 0

    for bit in binary_representation:
        if bit == '0':
            current_gap += 1
        else:
            max_gap = max(max_gap, current_gap)
            current_gap = 0

    return max_gap",77
1694091416,max_binary_gap,"def max_binary_gap(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0

    for bit in binary:
        if bit == '1':
            if current_gap > max_gap:
                max_gap = current_gap
            current_gap = 0
        else:
            current_gap += 1

    return max_gap",77
25282496068,canFormString,"def canFormString(str1, str2):
    d1 = {}
    d2 = {}
    for c in str1:
        d1[c] = d1.get(c, 0) + 1
    for c in str2:
        d2[c] = d2.get(c, 0) + 1
    return d1 == d2",77
4065874812,generate_parentheses,"def generate_parentheses(n):
    def generate(p, left, right, parens=[]):
        if left:         generate(p + '(', left-1, right)
        if right > left: generate(p + ')', left, right-1)
        if not right:    parens.append(p)
        return parens
    return generate('', n, n)",77
42648155062,length_of_longest_increasing_subsequence,"def length_of_longest_increasing_subsequence(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",76
37695394466,searchInsert,"def searchInsert(nums, target):
    f=0
    e=len(nums)-1
    while f<=e:
        mid=(f+e)//2
        if nums[mid]==target:
            return mid
        elif nums[mid]<=target:
            f=mid+1
        elif nums[mid]>=target:
            e=mid-1
    return f",76
36777659783,jump,"def jump(nums):
    jumps = 0
    current_jump_end = 0
    farthest = 0
    for i in range(len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        if i == current_jump_end:
            jumps += 1
            current_jump_end = farthest
    return jumps",76
10735047698,word_break,"def word_break(s, wordDict):
    n=len(s)
    dp=[0]*n
    for i in range(n):
        for w in wordDict:
            if s[i-len(w)+1:i+1]==w and (dp[i-len(w)] or i-len(w)+1==0):
                dp[i]=1
    return bool(dp[-1])",76
33427081414,longest_increasing_subsequence,"def longest_increasing_subsequence(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",76
40562834847,kadanesAlgorithm,"def kadanesAlgorithm(array):
    maxEndingHere = array[0]
    maxSoFar = array[0]
    
    for i in range(1, len(array)):
        num = array[i]
        maxEndingHere = max(num, maxEndingHere + num)
        maxSoFar = max(maxSoFar, maxEndingHere)
    
    return maxSoFar",76
17296986208,substring_length,"def substring_length(s):
  char_set = set()
  l = 0
  res = 0
  for r in range(len(s)):
    while s[r] in char_set:
      char_set.remove(s[l])
      l += 1
    char_set.add(s[r])
    res = max(res, r - l + 1)
  return res",76
71012407817,find_max_consecutive_ones,"def find_max_consecutive_ones(nums):
    max_ones = 0
    current_ones = 0
    for num in nums:
        if num == 1:
            current_ones += 1
            max_ones = max(max_ones, current_ones)
        else:
            current_ones = 0
    return max_ones",76
18698332472,prime_sieve,"def prime_sieve(n):
    sieve = [True] * n
    for x in range(2, int(n**0.5) + 1):
        if sieve[x]: 
            for i in range(x*x, n, x):
                sieve[i] = False
    return [x for x in range(2, n) if sieve[x]]",76
44070028911,decimal_to_binary,"def decimal_to_binary(num):
    if num == 0:
        return '0'
    
    if num < 0:
        num = 2 ** 32 + num
        
    result = ''
    while num != 0:
        remainder = num % 2
        result = str(remainder) + result
        num //= 2
    return result",76
12321358205,is_balanced,"def is_balanced(parentheses):
    stack = []
    mapping = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}
    for char in parentheses:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack",76
33708396970,longest_sequence,"def longest_sequence(nums):
    numsSet = set(nums)
    res = 0
    for i in nums:
        if (i-1) not in numsSet:
            l = 0
            while (i+l) in numsSet:
                numsSet.remove(i+l)
                l += 1
            res = max(res, l)
    return res",76
4255654204,primes_less_than,"def primes_less_than(n):
    sieve = [True] * n
    for x in range(2, int(n**0.5) + 1):
        if sieve[x]: 
            for i in range(x*x, n, x):
                sieve[i] = False
    return [x for x in range(2, n) if sieve[x]]",76
75019965718,jump,"def jump(nums):
    jumps = 0
    current_jump_end = 0
    farthest = 0
    for i in range(len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        if i == current_jump_end:
            jumps += 1
            current_jump_end = farthest
    return jumps",76
74837159106,largest_continuous_sum,"def largest_continuous_sum(arr):
    if len(arr) == 0:
        return 0
    max_sum = arr[0]
    current_sum = arr[0]
    for i in range(1, len(arr)):
        current_sum = max(arr[i], current_sum + arr[i])
        max_sum = max(max_sum, current_sum)
    return max_sum",76
702117876,longest_increasing_subsequence,"def longest_increasing_subsequence(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",76
6165772267,count_substrings,"from collections import Counter

def count_substrings(s):
    def nC2(n):
        return (n * (n - 1)) // 2

    freqs = Counter(s)
    soln = 0
    for k, f in freqs.items():
        soln += f
        soln += nC2(f)
    return soln",76
40419143908,check_valid_ip,"def check_valid_ip(s: str) -> bool:
    parts = s.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit() or int(part) > 255 or (part[0] == '0' and len(part) > 1):
            return False
    return True",76
32383900886,max_abs_difference,"def max_abs_difference(arr):
    if len(arr) < 2:
        return 0
    min_val = arr[0]
    max_diff = 0
    for i in range(1, len(arr)):
        max_diff = max(max_diff, arr[i] - min_val)
        min_val = min(min_val, arr[i])
    return max_diff",76
21290486367,maxSubArraySum,"def maxSubArraySum(arr, k):
    max_sum = 0
    window_sum = sum(arr[:k])
    max_sum = max(max_sum, window_sum)
    for i in range(len(arr)-k):
        window_sum = window_sum - arr[i] + arr[i+k]
        max_sum = max(max_sum, window_sum)
    return max_sum",76
16021322639,frequent_chars,"def frequent_chars(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    max_count = max(char_count.values())
    result = [char for char, count in char_count.items() if count == max_count]
    return result",76
37648966504,find_second_largest,"def find_second_largest(arr):
    first_largest = second_largest = float('-inf')
    for num in arr:
        if num > first_largest:
            second_largest = first_largest
            first_largest = num
        elif num > second_largest and num != first_largest:
            second_largest = num
    return second_largest",76
74397767815,climb_staircase,"def climb_staircase(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    else:
        first, second = 1, 2
        for i in range(3, n+1):
            third = first + second
            first, second = second, third
        return second",76
25389167111,verifyPreorder,"def verifyPreorder(preorder):
    low = float('-inf')
    l = -1
    for val in preorder:
        if val < low: return False
            
        while l >= 0 and preorder[l] < val:
            low = preorder[l]
            l -= 1
        l += 1
        preorder[l] = val
            
    return True",76
5841444045,prime_numbers,"def prime_numbers(n):
    sieve = [True] * n
    for x in range(2, int(n**0.5) + 1):
        if sieve[x]: sieve[2*x::x] = [False] * len(sieve[2*x::x])
    return [x for x in range(2, n) if sieve[x]]",76
21712048612,next_prime,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def next_prime(n):
    while True:
        n += 1
        if is_prime(n):
            return n",76
31615910150,longest_increasing_subsequence,"def longest_increasing_subsequence(nums):
    if not nums:
        return 0

    dp = [1] * len(nums)

    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)",76
7787485058,smallest_repeating_unit,"def smallest_repeating_unit(s):
    for i in range(1, len(s) // 2 + 1):
        if len(s) % i == 0:
            unit = s[:i]
            if unit * (len(s) // i) == s:
                return (unit, len(s) // i)
    return (s, 1)",76
74418663794,change_making,"def change_making(target_amount, coin_denominations):
    ways = [0] * (target_amount + 1)
    ways[0] = 1

    for coin in coin_denominations:
        for amount in range(coin, target_amount + 1):
            ways[amount] += ways[amount - coin]

    return ways[target_amount]",76
18671351762,reverseInParentheses,"def reverseInParentheses(inputString):
    stack = []
    for char in inputString:
        if char == ')':
            temp = """"
            while stack and stack[-1] != ""("":
                temp += stack.pop()
            stack.pop() 
            for i in temp:
                stack.append(i)
        else:
            stack.append(char)
    return """".join(stack)",76
9360824400,valid_ipv4,"def valid_ipv4(ip):
    octets = ip.split('.')
    if len(octets) != 4:
        return False
    for octet in octets:
        if not octet.isdigit():
            return False
        i = int(octet)
        if i < 0 or i > 255:
            return False
    return True",76
74825846921,max_sum_subarray_k,"def max_sum_subarray_k(arr,k):
    if not arr or k <= 0:
        return 0
    max_sum = current_sum = sum(arr[:k])
    for i in range(k, len(arr)):
        current_sum = current_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, current_sum)
    return max_sum",76
2079521050,matrix_sum,"def matrix_sum(matrix1, matrix2):
    result = [[0 for _ in range(len(matrix1[0]))] for _ in range(len(matrix1))]
    for i in range(len(matrix1)):
        for j in range(len(matrix1[0])):
            result[i][j] = matrix1[i][j] + matrix2[i][j]
    return result",76
20908334207,isSubsequence,"def isSubsequence(s: str, t: str) -> bool:
    s_index, t_index = 0, 0
    while s_index < len(s) and t_index < len(t):
        if s[s_index] == t[t_index]:
            s_index += 1
        t_index += 1
    return s_index == len(s)",76
27866086666,find_max_consecutive_ones,"def find_max_consecutive_ones(n):
    binary = bin(n)[2:]
    max_count = 0
    current_count = 0
    for bit in binary:
        if bit == '1':
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count",76
26267734710,solution,"def solution(n):
    answer = 1
    total = 0
    for i in range(1,(n//2)+1):
        for j in range(i, n+1):
            total += j
            if total == n:
                answer += 1
            elif total > n:
                break
        total = 0
    return answer",76
44155687216,duplicate_count,"def duplicate_count(text):
    text = text.lower()
    count = {}
    for char in text:
        if char in count:
            count[char] += 1
        else:
            count[char] = 1
    duplicates = 0
    for char in count:
        if count[char] > 1:
            duplicates += 1
    return duplicates",76
16171815608,max_consecutive_vowels,"def max_consecutive_vowels(s):
    vowels = ""aeiouAEIOU""
    max_count, current_count = 0, 0
    for char in s:
        if char in vowels:
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count",76
32240255007,unique_permutations,"from math import factorial

def unique_permutations(s):
    count = [0] * 256 # Assuming ASCII character set
    for i in s:
        count[ord(i)] += 1
    n = len(s)
    result = factorial(n)
    for i in range(256):
        result //= factorial(count[i])
    return result",76
22087792674,max_non_overlapping_intervals,"def max_non_overlapping_intervals(intervals):
    if not intervals:
        return 0

    intervals.sort(key=lambda x: x[1])
    count = 1
    end = intervals[0][1]

    for start, end_ in intervals[1:]:
        if start >= end:
            count += 1
            end = end_

    return count",76
16959140873,count_balanced_parentheses,"def count_balanced_parentheses(s: str) -> int:
    stack = []
    count = 0
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')' and len(stack) > 0:
            stack.pop()
            if len(stack) == 0:
                count += 1
    return count",76
15175689477,is_valid_url,"import re

def is_valid_url(url):
    pattern = r'^(http|https)://[a-zA-Z0-9]+([\-\.]{1}[a-zA-Z0-9]+)*\.[a-zA-Z]{2,5}(:[0-9]{1,5})?(/.*)?$'
    return bool(re.match(pattern, url))",76
26436694074,is_valid_ip,"def is_valid_ip(ip):
    parts = ip.split(""."")
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit() or not 0 <= int(part) <= 255 or (part[0] == '0' and len(part) > 1):
            return False
    return True",76
34734543746,longest_binary_gap,"def longest_binary_gap(N):
    binary_representation = bin(N)[2:]
    longest_gap = 0
    current_gap = 0

    for digit in binary_representation:
        if digit == '0':
            current_gap += 1
        else:
            longest_gap = max(longest_gap, current_gap)
            current_gap = 0

    return longest_gap",76
72565044674,count_pairs_with_difference,"def count_pairs_with_difference(arr, k):
    count = 0
    freq = {}
    for num in arr:
        if num + k in freq:
            count += freq[num + k]
        if num - k in freq:
            count += freq[num - k]
        freq[num] = freq.get(num, 0) + 1
    return count",76
4128994996,count_pairs_with_diff,"def count_pairs_with_diff(nums, k):
    count = 0
    freq = {}
    for num in nums:
        if num + k in freq:
            count += freq[num + k]
        if num - k in freq:
            count += freq[num - k]
        freq[num] = freq.get(num, 0) + 1
    return count",76
24333647156,count_binary_strings,"from math import factorial

def count_binary_strings(s):
    ones = s.count(""1"")
    zeros = len(s) - ones
    return factorial(ones + zeros) // (factorial(ones) * factorial(zeros))

print(count_binary_strings(""1010""))
print(count_binary_strings(""1100""))
print(count_binary_strings(""10""))",76
40792144997,max_difference,"def max_difference(arr):
    max_diff = 0
    min_element = arr[0]
    for i in range(1, len(arr)):
        if (arr[i] - min_element) > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",76
10100846762,zigzag_length,"def zigzag_length(arr):
    up = 1
    down = 1
    for i in range(1, len(arr)):
        if arr[i] > arr[i - 1]:
            up = down + 1
        elif arr[i] < arr[i - 1]:
            down = up + 1
    return max(up, down)",76
23870640136,all_permutations,"def all_permutations(lst):
    if len(lst) == 0:
        return [[]]
    result = []
    for i in range(len(lst)):
        current_num = lst[i]
        remaining_nums = lst[:i] + lst[i+1:]
        for p in all_permutations(remaining_nums):
            result.append([current_num] + p)
    return result",76
30991005859,is_perfect,"def is_perfect(n):
    sum = 1
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        elif i * (n // i) == n:
            sum = sum + i + n//i
            i += 1
    return sum == n and n!=1",76
43147321830,max_sum_of_subarray,"def max_sum_of_subarray(arr, k):
    if len(arr) < k:
        return ""Invalid""
    max_sum = current_sum = sum(arr[:k])
    for i in range(len(arr) - k):
        current_sum = current_sum - arr[i] + arr[i+k]
        max_sum = max(max_sum, current_sum)
    return max_sum",76
28462582694,find_duplicate,"def find_duplicate(nums):
    slow = nums[0]
    fast = nums[nums[0]]
    while slow != fast:
        slow = nums[slow]
        fast = nums[nums[fast]]
    slow2 = 0
    while slow != slow2:
        slow = nums[slow]
        slow2 = nums[slow2]
    return slow",76
14793293852,smallest_range,"def smallest_range(nums, K):
    if len(nums) == 1:
        return 0
    min_num = min(nums)
    max_num = max(nums)
    min_num = min_num + K
    max_num = max_num - K
    if max_num > min_num:
        return max_num - min_num
    else:
        return 0",76
6275609487,validate_mac_address,"import string

def validate_mac_address(mac_address):
    s = mac_address.split(""-"")
    
    if len(s) != 6:
        return False
        
    for e in s:
        if len(e) != 2:
            return False
    
    return all(e[0] in string.hexdigits and e[1] in string.hexdigits for e in s)",76
10512407840,group_anagrams,"from typing import List
from collections import defaultdict

def group_anagrams(strs: List[str]) -> List[List[str]]:
    anagrams = defaultdict(list)
    for word in strs:
        # Sort the word and use it as the key in the dictionary
        key = """".join(sorted(word))
        anagrams[key].append(word)
    return list(anagrams.values())",76
397718146,word_segment,"def word_segment(s, words):
    dp = [False] * (len(s)+1)
    dp[0] = True
    for i in range(len(s)):
        for j in range(i, len(s)):
            if dp[i] and s[i:j+1] in words:
                dp[j+1] = True
    return dp[-1]",76
70726592441,find_Max_Diff,"def find_Max_Diff(arr):
    max_diff = 0
    min_element = arr[0]

    for i in range(1, len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element

        if arr[i] < min_element:
            min_element = arr[i]

    return max_diff",76
17571723801,longest_consecutive_subsequence,"def longest_consecutive_subsequence(s):
    max_length = 1
    current_length = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1
    return max_length",76
25191340330,jump,"def jump(nums):
    jumps = 0
    current_jump_end = 0
    farthest = 0
    for i in range(len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        if i == current_jump_end:
            jumps += 1
            current_jump_end = farthest
    return jumps",76
5361582458,count_valid_parentheses,"def count_valid_parentheses(n: int) -> int:
    if n == 0:
        return 1
    if n == 1:
        return 1
    result = 0
    for i in range(n):
        result += count_valid_parentheses(i) * count_valid_parentheses(n - 1 - i)
    return result",76
70474721949,valid_parentheses,"def valid_parentheses(s):
    stack = []
    mapping = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack",76
12186104477,longest_increasing_subsequence,"def longest_increasing_subsequence(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",76
26972433696,parentheses_combinations,"def parentheses_combinations(n):
    def generate(p, left, right, parens=[]):
        if left:         generate(p + '(', left-1, right)
        if right > left: generate(p + ')', left, right-1)
        if not right:    parens.append(p)
        return parens
    return generate('', n, n)",76
42592791123,max_lexico_substring,"def max_lexico_substring(s):
    max_length = 1
    current_length = 1
    for i in range(1, len(s)):
        if s[i] >= s[i-1]:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1
    return max_length",76
35571865889,nextGreaterElement,"def nextGreaterElement(arr):
    result = [-1] * len(arr)
    stack = []
    for i in range(len(arr) - 1, -1, -1):
        while stack and stack[-1] <= arr[i]:
            stack.pop()
        if stack:
            result[i] = stack[-1]
        stack.append(arr[i])
    return result",76
28993355463,find_max_binary_gap,"def find_max_binary_gap(N):
    binary_representation = bin(N)[2:]
    max_gap = 0
    current_gap = 0
    for bit in binary_representation:
        if bit == '0':
            current_gap += 1
        else:
            max_gap = max(max_gap, current_gap)
            current_gap = 0
    return max_gap",76
27131223967,lucas_series,"def lucas_series(n):
    if n == 0:
        return 2
    if n == 1:
        return 1
    l0, l1 = 2, 1
    for _ in range(2, n + 1):
        l0, l1 = l1, l0 + l1
    return l1",76
6774096105,is_Perfect,"def is_Perfect(num):
    if num < 1:
        return False
    sum = 1
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            sum += i
            if i != num // i:
                sum += num // i
    return sum == num",76
5113634581,check_subarray_sum,"def check_subarray_sum(nums):
    s = 0
    targs = {0: -1}
    for i, n in enumerate(nums):
        s += n
        if s in targs and i-targs[s] >= 2:
            return True
        if s not in targs:
            targs[s] = i
    return False",76
2246548631,diagonal_sum,"def diagonal_sum(mat):
    s=set()
    for i in range(0,len(mat)):
        s.add((i,i))
        s.add((i,len(mat)-(i+1)))
    tot=0
    for coords in s:
        x=coords[0]
        y=coords[1]
        tot=tot+mat[x][y]
    return tot",76
6207372647,is_subsequence,"def is_subsequence(s: str, t: str) -> bool:
    s_index, t_index = 0, 0
    while s_index < len(s) and t_index < len(t):
        if s[s_index] == t[t_index]:
            s_index += 1
        t_index += 1
    return s_index == len(s)",76
6391125156,convert_to_one,"def convert_to_one(n):
    moves = 0
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        elif n == 3 or n % 4 == 1:
            n -= 1
        else:
            n += 1
        moves += 1
    return moves",76
13487673706,find_length_of_lis,"def find_length_of_lis(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",76
33000356013,longest_increasing_subarray,"def longest_increasing_subarray(arr):
    max_len = 1
    current_len = 1
    for i in range(1, len(arr)):
        if arr[i] > arr[i-1]:
            current_len += 1
            max_len = max(max_len, current_len)
        else:
            current_len = 1
    return max_len",76
73432365869,to_uppercase,"def to_uppercase(s):
    uppercase_str = """"
    for char in s:
        if 'a' <= char <= 'z':
            # Convert lowercase to uppercase by subtracting the difference in ASCII values
            uppercase_str += chr(ord(char) - (ord('a') - ord('A')))
        else:
            uppercase_str += char
    return uppercase_str",75
33323503853,count_pairs_with_diff,"from collections import defaultdict

def count_pairs_with_diff(nums, k):
    count = defaultdict(int)
    ans = 0
    for num in nums:
        if num - k in count:
            ans += count[num - k]
        if num + k in count:
            ans += count[num + k]
        count[num] += 1
    return ans",75
42722141512,find_square_root,"def find_square_root(n, precision=1e-7):
    if n < 0:
        raise ValueError(""Square root is not defined for negative numbers"")
    x = n
    while True:
        root = 0.5 * (x + n / x)
        if abs(root - x) < precision:
            return root
        x = root",75
21455581246,lis_length,"def lis_length(arr):
    if len(arr) <= 1:
        return len(arr)
    dp = [1] * (len(arr))
    for i in range(len(arr)):
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",75
24936158248,max_product_three_numbers,"def max_product_three_numbers(nums):
    nums.sort()
    # The maximum product can be formed by three largest numbers or two smallest and one largest number.
    # The following line calculates both possibilities and returns the maximum.
    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])",75
12637962611,rearrange_log_files,"from typing import List

def rearrange_log_files(logs: List[str]) -> List[str]:
    def get_key(log):
        _id, rest = log.split("" "", 1)
        return (0, rest, _id) if rest[0].isalpha() else (1, None, None)

    return sorted(logs, key=get_key)",75
40300415171,bitwise_complement,"def bitwise_complement(n: int) -> int:
    if n == 0:
        return 1

    numOfBits = 0
    current = n
    while current > 0:
        current = current >> 1
        numOfBits += 1
    mask = (2 ** numOfBits) - 1

    return mask ^ n",75
12711335977,fibonacci_num,"def fibonacci_num(n): 
    dp = [0] * (n + 1) 
    dp[0] = 0
    dp[1] = 1
    for i in range(2, n+1): 
        dp[i] = dp[i - 1] + dp[i - 2] 
    return dp[n]",75
34988824759,generate_combinations,"def generate_combinations(elements, k):
    def backtrack(start, k, path):
        if k == 0:
            result.append(path)
            return
        for i in range(start, len(elements)):
            backtrack(i + 1, k - 1, path + [elements[i]])
    result = []
    backtrack(0, k, [])
    return result",75
14842482251,longest_consecutive_ones,"def longest_consecutive_ones(arr):
    max_count = 0
    count = 0
    for i in arr:
        if i == 1:
            count += 1
        else:
            if count > max_count:
                max_count = count
                count = 0
    return max(max_count, count) if arr else 0",75
37303392964,find_max_difference,"def find_max_difference(arr):
    max_diff = -1
    min_element = arr[0]

    for i in range(1, len(arr)):
        diff = arr[i] - min_element
        if diff > max_diff:
            max_diff = diff
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",75
73459925304,find_majority_element,"def find_majority_element(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    if candidate is not None and nums.count(candidate) > len(nums) // 2:
        return candidate
    return None",75
44204716090,find_repeated_numbers,"def find_repeated_numbers(nums):
    num_dict = {}
    repeated = []
    for num in nums:
        if num in num_dict:
            num_dict[num] += 1
        else:
            num_dict[num] = 1
    for key, value in num_dict.items():
        if value > 1:
            repeated.append(key)
    return repeated",75
43793299222,largest_binary_gap,"def largest_binary_gap(N):
    binary_str = bin(N)[2:]
    max_gap = 0
    current_gap = 0
    
    for bit in binary_str:
        if bit == '1':
            max_gap = max(max_gap, current_gap)
            current_gap = 0
        else:
            current_gap += 1
    
    return max_gap",75
38727441301,anagramMappings,"from collections import defaultdict

def anagramMappings(nums1, nums2):
    value_ind = defaultdict()
    for i in range(len(nums2)):
        value_ind[nums2[i]] = i
    
    mappings = [0]*len(nums1)
    for i in range(len(nums1)):
        mappings[i] = value_ind[nums1[i]]
    return mappings",75
14341972406,find_max_consecutive_ones,"def find_max_consecutive_ones(n):
    max_count = 0
    current_count = 0
    while n > 0:
        if n & 1:
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
        n >>= 1
    return max_count",75
24491517384,length_of_longest_increasing_subsequence,"def length_of_longest_increasing_subsequence(nums):
    if not nums:
        return 0
    dp = [1]*len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",75
21151414324,find_smallest_missing_positive,"def find_smallest_missing_positive(nums):
    nums = [n for n in nums if n > 0]
    nums = list(set(nums))
    nums.sort()
    smallest_missing = 1

    for num in nums:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break

    return smallest_missing",75
2804948141,all_permutations,"def all_permutations(lst):
    if len(lst) <= 1:
        return [lst]

    result = []
    for i in range(len(lst)):
        m = lst[i]
        rem_lst = lst[:i] + lst[i+1:]

        for p in all_permutations(rem_lst):
            result.append([m] + p)
    return result",75
35388031270,subsetSums,"def subsetSums(nums):
    ret = [0]

    def dfs(nums, index, path, ret):
        for i in range(index, len(nums)):
            ret.append(sum(path+[nums[i]]))
            dfs(nums, i+1, path+[nums[i]], ret)

    dfs(nums, 0, [], ret)
    return sorted(list(set(ret)))",75
26977148113,max_attendable_events,"def max_attendable_events(events):
    events.sort(key=lambda x: x[1])
    count = 1
    end_time = events[0][1]
    for i in range(1, len(events)):
        if events[i][0] >= end_time:
            count += 1
            end_time = events[i][1]
    return count",75
74647741647,first_non_repeating_character,"def first_non_repeating_character(s: str) -> str:
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return ""-""",75
43666025377,min_delete_intervals,"def min_delete_intervals(intervals):
    if not intervals:
        return 0

    intervals.sort(key=lambda n: n[1])
    res, prv = 0, intervals[0][1]

    for s, e in intervals[1:]:
        if s < prv:
            res += 1
        else:
            prv = e

    return res",75
21060537195,find_duplicate,"def find_duplicate(nums):
    slow, fast = nums[0], nums[nums[0]]
    while slow != fast:
        slow = nums[slow]
        fast = nums[nums[fast]]
    slow2 = 0
    while slow != slow2:
        slow = nums[slow]
        slow2 = nums[slow2]
    return slow",75
37286735023,max_nested_envelopes,"import bisect

def max_nested_envelopes(envelopes):
    lst = []
    for _, i in sorted(envelopes, key=lambda e: (e[0], -e[1])):
        try:
            lst[bisect.bisect_left(lst, i)] = i
        except IndexError:
            lst.append(i)
    return len(lst)",75
26175249602,max_sum_subarray_of_size_k,"def max_sum_subarray_of_size_k(arr, k):
    max_sum = 0
    window_sum = sum(arr[:k])
    for i in range(len(arr) - k):
        window_sum = window_sum - arr[i] + arr[i + k]
        max_sum = max(max_sum, window_sum)
    return max(max_sum, window_sum)",75
14132579136,find_max_recursive,"def find_max_recursive(lst, index=0, max_val=None):
    if max_val is None:
        max_val = lst[index]
    if index == len(lst) - 1:
        return max_val
    if lst[index] > max_val:
        max_val = lst[index]
    return find_max_recursive(lst, index + 1, max_val)",75
74319555465,lucas_number,"def lucas_number(n):
    if n == 0:
        return 2
    if n == 1:
        return 1
    prev = 2
    curr = 1
    for _ in range(2, n + 1):
        temp = curr
        curr = prev + curr
        prev = temp
    return curr",75
72384618450,first_non_repeating_character,"def first_non_repeating_character(input_string):
    char_count = {}
    for char in input_string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in input_string:
        if char_count[char] == 1:
            return char
    return ""None""",75
39657813570,largest_binary_gap,"def largest_binary_gap(N):
    binary_str = bin(N)[2:]
    max_gap = 0
    current_gap = 0

    for bit in binary_str:
        if bit == '0':
            current_gap += 1
        else:
            max_gap = max(max_gap, current_gap)
            current_gap = 0

    return max_gap",75
1275262610,smallest_number,"def smallest_number(numbers):
    # Assuming the first number is the smallest initially
    smallest = numbers[0]
    # Loop through all the numbers
    for number in numbers:
        # If the current number is smaller than the current smallest, update smallest
        if number < smallest:
            smallest = number
    # Return the smallest number found
    return smallest",75
5860026044,find_Longest_Increasing_Subsequence,"def find_Longest_Increasing_Subsequence(arr):
    if not arr:
        return 0
    dp = [1] * len(arr)
    for i in range(len(arr)):
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",75
43374466848,maxDifference,"def maxDifference(arr):
    max_diff = 0
    min_element = arr[0]
    for i in range(1,len(arr)):
        if (arr[i] - min_element) > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",75
42111066278,encrypt,"def encrypt(text, shift):
    result = """"
    for char in text:
        if char.isalpha():
            start = ord('a') if char.islower() else ord('A')
            offset = (ord(char) - start + shift) % 26
            result += chr(start + offset)
        else:
            result += char
    return result",75
41849427591,max_diff,"def max_diff(arr):
    max_diff = 0
    min_element = arr[0]
    for i in range(1,len(arr)):
        if (arr[i] - min_element) > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",75
17002990497,findMaxDifference,"def findMaxDifference(arr):
    max_diff = 0
    min_element = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",75
70592624955,largest_product,"def largest_product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])

print(largest_product([1,2,3,4,5]))
print(largest_product([-1,-2,-3,1]))
print(largest_product([-1,0,1]))",75
41073434208,find_anagrams,"from collections import defaultdict

def find_anagrams(words):
    sorted_word_dict = defaultdict(list)
    for word in words:
        sorted_word_dict[''.join(sorted(word))].append(word)
    anagrams = []
    for word_list in sorted_word_dict.values():
        if len(word_list) > 1:
            anagrams.extend(word_list)
    return anagrams",75
69904304822,largest_Binary_Gap,"def largest_Binary_Gap(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0
    
    for bit in binary:
        if bit == '1':
            max_gap = max(max_gap, current_gap)
            current_gap = 0
        else:
            current_gap += 1
    
    return max_gap",75
18021378989,first_non_repeated_char,"def first_non_repeated_char(s: str) -> str:
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",75
31122803285,find_longest_increasing_subsequence,"def find_longest_increasing_subsequence(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",75
70988403411,Max_Number,"def Max_Number(num):
    # Convert the number to a list of digits
    digits = [int(d) for d in str(num)]
    # Sort the digits in descending order
    digits.sort(reverse=True)
    # Join the digits back into a number
    max_num = int(''.join([str(d) for d in digits]))
    return max_num",75
11604130310,is_balanced,"from collections import deque

def is_balanced(s):
    q = deque()
    
    for i in range(len(s)):
        if s[i] == ""("":
            q.append(s[i])
        else:
            if len(q) == 0:
                return False
            q.pop()
    if len(q) != 0:
        return False
    return True",75
74067723867,find_longest_increasing_subsequence,"def find_longest_increasing_subsequence(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",75
25776178393,longestEqualSubsequence,"def longestEqualSubsequence(arr):
    max_length = 1
    current_length = 1
    for i in range(1, len(arr)):
        if arr[i] == arr[i-1]:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1
    return max_length",75
24212991343,length_of_lis,"from bisect import bisect_left

def length_of_lis(nums):
    if not nums:
        return 0

    tails = []
    for num in nums:
        i = bisect_left(tails, num)
        if i == len(tails):
            tails.append(num)
        else:
            tails[i] = num

    return len(tails)",75
2228843692,find_unique_paths,"def find_unique_paths(m, n):
    dp = [[1 for _ in range(n)] for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",75
71856241689,to_uppercase,"def to_uppercase(s):
    uppercase_str = """"
    for char in s:
        if 'a' <= char <= 'z':
            # Calculate the difference from 'a' and add it to 'A'
            uppercase_str += chr(ord('A') + ord(char) - ord('a'))
        else:
            uppercase_str += char
    return uppercase_str",75
74067233526,longest_equal_subsequence,"def longest_equal_subsequence(arr):
    max_length = 1
    current_length = 1

    for i in range(1, len(arr)):
        if arr[i] == arr[i-1]:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1

    return max_length",75
33761176329,is_balanced,"def is_balanced(s):
    stack = []
    mapping = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack",75
39266565429,check_balanced_brackets,"def check_balanced_brackets(s):
    stack = []
    mapping = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}

    for char in s:
        if char in mapping:
            if stack and stack[-1] == mapping[char]:
                stack.pop()
            else:
                return False
        else:
            stack.append(char)

    return not stack",75
41218089189,number_of_passing_cars,"def number_of_passing_cars(A):
	counter = 0
	_sum = 0
	for i in A:
		if i == 0:
			counter += 1
		else:
			_sum += counter
		if _sum > 1_000_000_000:
			return -1
	return _sum",75
6793326587,count_unique_bst,"def count_unique_bst(n):
    dp = [0] * (n + 1)
    dp[0], dp[1] = 1, 1
    
    for i in range(2, n+1):
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]
    return dp[n]",75
15229696815,max_consecutive_ones,"def max_consecutive_ones(n):
    binary = bin(n)[2:]
    max_count = 0
    current_count = 0
    for bit in binary:
        if bit == '1':
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count",75
72213485100,frog_jump,"def frog_jump(n):
    if n <= 1:
        return n
    one_step_back = 1
    two_steps_back = 1
    for i in range(2, n):
        current_step = one_step_back + two_steps_back
        two_steps_back = one_step_back
        one_step_back = current_step
    return current_step",75
43021730614,find_longest_increasing_subsequence,"def find_longest_increasing_subsequence(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",75
24272430287,count_partitions,"def count_partitions(n: int) -> int:
    if n == 0:
        return 1
    partitions = [1] + [0] * n
    for i in range(1, n + 1):
        for j in range(i, n + 1):
            partitions[j] += partitions[j - i]
    return partitions[n]",75
41937560226,find_max_difference,"def find_max_difference(arr):
    max_diff = -1
    min_element = arr[0]
    for i in range(1, len(arr)):
        diff = arr[i] - min_element
        if diff > max_diff:
            max_diff = diff
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",75
26366320989,count_distinct_substrings,"def count_distinct_substrings(s):
    def is_distinct(sub):
        return len(sub) == len(set(sub))
    
    count = 0
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            if is_distinct(s[i:j]):
                count += 1
    return count",75
14235356782,max_subarray_sum,"def max_subarray_sum(arr,k):
    if len(arr) < k:
        return None
    max_sum = sum(arr[:k])
    temp_sum = max_sum
    for i in range(k,len(arr)):
        temp_sum = temp_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum,temp_sum)
    return max_sum",74
3005100583,duplicate_strings,"from collections import OrderedDict

def duplicate_strings(strings):
    string_counts = {}
    for string in strings:
        if string in string_counts:
            string_counts[string] += 1
        else:
            string_counts[string] = 1
    
    duplicates = [string for string, count in OrderedDict(string_counts).items() if count > 1]
    return duplicates",74
43383138512,prime_sum,"def prime_sum(num_list):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return sum([num for num in num_list if is_prime(num)])",74
25071756158,first_non_repeating_character,"def first_non_repeating_character(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for i in range(len(s)):
        if char_count[s[i]] == 1:
            return i
    return -1",74
74491430438,coin_combinations,"def coin_combinations(nums, target):
        dp = [0 for _ in range(target + 1)]
        dp[0] = 1
        for i in range(1, target + 1):
            for index,coin in enumerate(nums):
                if(i >= coin):
                    dp[i] += dp[i - coin]
        return dp[target]",74
18534420827,find_kth_largest,"from heapq import heappush, heappushpop

def find_kth_largest(nums, k):
    maxHeap = []
    for i, num in enumerate(nums):
        if len(maxHeap) < k:
            heappush(maxHeap, num)
        else:
            heappushpop(maxHeap, num)
    return maxHeap[0]",74
22505884454,findClosestElements,"def findClosestElements(arr, k, x):
    l, r = 0, len(arr)-k
    while(l<r):
        m = l+(r-l)//2
        if x-arr[m]>arr[m+k]-x:
            l = m+1
        else:
            r = m
    return arr[l:l+k]",74
2752862977,max_difference,"def max_difference(arr):
    max_diff = 0
    min_element = arr[0]

    for i in range(1, len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]

    return max_diff",74
17650787800,binary_gap,"def binary_gap(N):
    binary_str = bin(N)[2:]
    max_gap = 0
    current_gap = 0
    for bit in binary_str:
        if bit == '0':
            current_gap += 1
        else:
            max_gap = max(max_gap, current_gap)
            current_gap = 0
    return max_gap",74
15664196855,count_consecutive_sums,"def count_consecutive_sums(n):
    count = 0
    i = 1
    while i * (i - 1) // 2 < n:
        if (n - i * (i - 1) // 2) % i == 0:
            count += 1
        i += 1
    return count",74
30968261800,max_sum_subarray,"def max_sum_subarray(arr, k):
    if len(arr) < k:
        return None
    max_sum = window_sum = sum(arr[:k])
    for i in range(len(arr) - k):
        window_sum = window_sum - arr[i] + arr[i+k]
        max_sum = max(max_sum, window_sum)
    return max_sum",74
28127395670,firstNonRepeatingChar,"def firstNonRepeatingChar(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for index, char in enumerate(s):
        if char_count[char] == 1:
            return index
    return -1",74
19207486988,max_diff,"def max_diff(arr):
    max_diff = 0
    min_element = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",74
29096674340,count_consecutive_sums,"def count_consecutive_sums(n):
    count = 0
    i = 1
    while i * (i - 1) // 2 < n:
        if (n - i * (i - 1) // 2) % i == 0:
            count += 1
        i += 1
    return count",74
1801932031,maximum_nested_parentheses,"def maximum_nested_parentheses(s: str) -> int:
    max_nested = 0
    current_nested = 0
    for char in s:
        if char == '(':
            current_nested += 1
            max_nested = max(max_nested, current_nested)
        elif char == ')':
            current_nested -= 1
    return max_nested",74
73008676824,most_frequent_char,"def most_frequent_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    max_count = max(char_count.values())
    for char in s:
        if char_count[char] == max_count:
            return char",74
30884810397,longest_unique_subarray,"def longest_unique_subarray(arr):
    seen = {}
    max_len = start = 0
    for end, value in enumerate(arr):
        if value in seen:
            start = max(start, seen[value] + 1)
        seen[value] = end
        max_len = max(max_len, end - start + 1)
    return max_len",74
9396105523,maximum_difference,"def maximum_difference(arr):
    max_diff = 0
    min_element = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",74
40710202124,max_difference,"def max_difference(arr):
    max_diff = 0
    min_element = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_element > max_diff:
            max_diff = arr[i] - min_element
        if arr[i] < min_element:
            min_element = arr[i]
    return max_diff",74
5930830042,find_min_max,"def find_min_max(numbers):
  if not numbers:
    return (None, None)
  
  min_num = max_num = numbers[0]
  
  for num in numbers[1:]:
    if num < min_num:
      min_num = num
    elif num > max_num:
      max_num = num
  
  return (min_num, max_num)",74
12235810450,check_almost_equivalent,"def check_almost_equivalent(word1: str, word2: str) -> bool:
    """"""
    Check if two strings are almost equivalent.
    """"""
    letters = set(word1) | set(word2)
    for letter in letters:
        if abs(word1.count(letter) - word2.count(letter)) > 3:
            return False
    return True",74
6069620273,max_non_overlapping_intervals,"def max_non_overlapping_intervals(intervals):
    intervals.sort(key=lambda x: x[1])
    count = 1
    end = intervals[0][1]
    for i in range(1, len(intervals)):
        if intervals[i][0] >= end:
            count += 1
            end = intervals[i][1]
    return count",74
10734279359,max_diff,"def max_diff(nums):
    max_diff = 0
    min_element = nums[0]
    for i in range(1, len(nums)):
        if nums[i] - min_element > max_diff:
            max_diff = nums[i] - min_element
        if nums[i] < min_element:
            min_element = nums[i]
    return max_diff",74
41033524689,max_sum_subarray,"def max_sum_subarray(arr, k):
    if len(arr) < k:
        return None
    
    max_sum = current_sum = sum(arr[:k])
    for i in range(k, len(arr)):
        current_sum = current_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, current_sum)
    
    return max_sum",74
11016252676,convert_to_pig_latin,"def convert_to_pig_latin(word):
    vowels = ""aeiouAEIOU""
    if word[0] in vowels:
        return word + ""way""
    else:
        for i, letter in enumerate(word):
            if letter in vowels:
                return word[i:] + word[:i] + ""ay""
        return word + ""ay""",74
3320988682,count_pattern,"def count_pattern(text, pattern):
    if not pattern or not text:
        return 0
    
    count = start = 0
    while start < len(text):
        pos = text.find(pattern, start)
        if pos != -1:
            start = pos + 1
            count += 1
        else:
            break
    return count",74
44157155956,find_Max_Recursive,"def find_Max_Recursive(arr, start, end):
    if start == end:
        return arr[start]
    mid = (start + end) // 2
    max_left = find_Max_Recursive(arr, start, mid)
    max_right = find_Max_Recursive(arr, mid + 1, end)
    return max(max_left, max_right)",74
7551602880,find_first_unique_char,"def find_first_unique_char(s: str) -> str:
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return ""-""",74
29920056981,count_valid_parentheses,"def count_valid_parentheses(n):
    dp = [0]*(n+1)
    dp[0] = 1
    for i in range(2, n+1, 2):
        for j in range(0, i, 2):
            dp[i] += dp[j]*dp[i-j-2]
    return dp[n]",74
73699399447,move_zeros,"def move_zeros(nums):
    slow = fast = 0

    while fast < len(nums):
        if nums[fast] != 0:
            nums[slow] = nums[fast]
            slow += 1

        fast += 1

    for i in range(slow, len(nums)):
        nums[i] = 0

    return nums",74
36159309737,find_LIS,"def find_LIS(nums):
    if not nums:
        return 0

    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)",74
20382537114,count_consecutive_sums,"def count_consecutive_sums(n):
    count = 0
    i = 1
    while i * (i - 1) / 2 < n:
        if (n - i * (i - 1) / 2) % i == 0:
            count += 1
        i += 1
    return count",74
39659301140,max_non_overlapping_intervals,"def max_non_overlapping_intervals(intervals):
    intervals.sort(key=lambda x: x[1])
    count = 1
    end = intervals[0][1]
    for i in range(1, len(intervals)):
        if intervals[i][0] >= end:
            count += 1
            end = intervals[i][1]
    return count",74
4957629488,find_fibonacci,"def find_fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1 or n == 2:
        return 1
    else:
        a, b = 1, 1
        for _ in range(n - 2):
            a, b = b, a + b
        return b",74
566536541,max_non_overlapping_intervals,"def max_non_overlapping_intervals(intervals):
    intervals.sort(key=lambda x: x[1])
    count = 1
    end = intervals[0][1]
    for i in range(1, len(intervals)):
        if intervals[i][0] >= end:
            count += 1
            end = intervals[i][1]
    return count",74
33495843896,max_diff,"def max_diff(lst):
    max_difference = 0
    min_element = lst[0]
    for i in range(1, len(lst)):
        if lst[i] - min_element > max_difference:
            max_difference = lst[i] - min_element
        if lst[i] < min_element:
            min_element = lst[i]
    return max_difference",74
27341230878,filter_evens,"def filter_evens(nums):
    """"""
    Filters out the even numbers from a list of integers.
    
    :param nums: List[int] - a list of integers
    :return: List[int] - a list containing only the even numbers from the input list
    """"""
    return [num for num in nums if num % 2 == 0]",74
70452231892,min_and_max,"def min_and_max(numbers):
    if not numbers:
        return None, None
    min_num = numbers[0]
    max_num = numbers[0]
    for num in numbers[1:]:
        if num < min_num:
            min_num = num
        elif num > max_num:
            max_num = num
    return min_num, max_num",74
30805049152,max_difference,"def max_difference(arr):
    max_diff = 0
    min_val = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_val > max_diff:
            max_diff = arr[i] - min_val
        if arr[i] < min_val:
            min_val = arr[i]
    return max_diff",74
29840105350,count_ones_substrings,"def count_ones_substrings(s):
    count, consecutive_ones, total_ones = 0, 0, 0
    for char in s:
        if char == '1':
            consecutive_ones += 1
            total_ones += consecutive_ones
        else:
            consecutive_ones = 0
    return total_ones",74
20001278754,generate_n_pairs,"def generate_n_pairs(lst, n):
    if n == 1:
        return [[i] for i in lst]
    res = []
    for i in range(len(lst)):
        for sub_pair in generate_n_pairs(lst[:i] + lst[i+1:], n - 1):
            res.append([lst[i]] + sub_pair)
    return res",74
38910643879,first_non_repeating_char,"def first_non_repeating_char(given_string):
    char_count = {}
    for char in given_string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    
    for char in given_string:
        if char_count[char] == 1:
            return char
    return None",74
33972216655,find_satisfied_children,"def find_satisfied_children(g, s):
    g.sort()
    s.sort()
    glen, slen = len(g), len(s)
    i = j = 0

    while i < glen and j < slen:
        if g[i] <= s[j]:
            i += 1

        j += 1

    return i",74
23123820812,find_target,"def find_target(nums, target):
    track = {}
    for i in range(len(nums)):
        if nums[i] in track:
            return ""Target number "" + str(nums[i]) + "" is found at index "" + str(i)
        track[target] = None
    return ""Target number "" + str(target) + "" is not in the list""",74
7737327396,lucas,"def lucas(n):
    if n == 0:
        return 2
    if n == 1:
        return 1

    x = 2
    y = 1

    for _ in range(2, n + 1):
        temp = x
        x = y
        y = temp + y

    return y",74
15095958047,prime_sum,"def prime_sum(num_list):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return sum([i for i in num_list if is_prime(i)])",74
25395028422,move_negative_positive_zero,"def move_negative_positive_zero(arr, N):
    negative = []
    positive = []
    zero = []
    for i in range(N):
        if arr[i] < 0:
            negative.append(arr[i])
        elif arr[i] > 0:
            positive.append(arr[i])
        else:
            zero.append(arr[i])
    return negative + positive + zero",74
20005460587,group_anagrams,"from collections import defaultdict

def group_anagrams(strs):
    res = defaultdict(list)

    for s in strs:
        char_array = [0] * 26
        for c in s:
            char_array[ord(c) - ord(""a"")] += 1

        res[tuple(char_array)].append(s)

    return list(res.values())",74
40066287964,find_fibonacci,"def find_fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1 or n == 2:
        return 1
    else:
        a, b = 1, 1
        for _ in range(2, n):
            a, b = b, a + b
        return b",74
34425361968,find_longest_increasing_subsequence,"from bisect import bisect_left

def find_longest_increasing_subsequence(nums):
    sub = []
    for num in nums:
        if len(sub) == 0 or sub[-1] < num:
            sub.append(num)
        else:
            idx = bisect_left(sub, num)
            sub[idx] = num
    return len(sub)",74
26215808571,find_first_non_repeating_char,"def find_first_non_repeating_char(str1):
    char_count = {}
    for c in str1:
        if c in char_count:
            char_count[c] += 1
        else:
            char_count[c] = 1
    for c in str1:
        if char_count[c] == 1:
            return c
    return None",74
38727096981,move_zeros,"def move_zeros(nums):
    count, j = 0, 0
    for i in nums:
        if i == 0:
            count += 1
        else:
            nums[j] = i
            j+=1
    for i in range(1, count+1):
        nums[-i] = 0
    return nums",74
74188041997,count_pairs_with_sum,"def count_pairs_with_sum(nums, target):
    count = 0
    seen = {}
    for num in nums:
        complement = target - num
        if complement in seen:
            count += seen[complement]
        if num in seen:
            seen[num] += 1
        else:
            seen[num] = 1
    return count",74
33357291266,max_difference,"def max_difference(arr):
    max_diff = -1
    min_val = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_val > max_diff:
            max_diff = arr[i] - min_val
        if arr[i] < min_val:
            min_val = arr[i]
    return max_diff",74
13888950038,find_pattern,"def find_pattern(s, pattern):
    if not pattern or not s:
        return 0
    count = start = 0
    while start < len(s):
        pos = s.find(pattern, start)
        if pos != -1:
            start = pos + 1
            count += 1
        else:
            break
    return count",74
74863935095,find_unique_pairs,"def find_unique_pairs(arr, target):
    seen = {}
    output = set()
    for num in arr:
        target_num = target - num
        if target_num not in seen:
            seen[num] = 1
        else:
            output.add( (min(num, target_num),  max(num, target_num)) )
    return len(output)",74
28705874918,numberOfPairs,"def numberOfPairs(nums):
    numSeen = {}

    pairs = 0
    for idx in range(len(nums)):

        if nums[idx] in numSeen:
            del numSeen[nums[idx]]
            pairs += 1
        else:
            numSeen[nums[idx]] = 1

    return [pairs, sum(list(numSeen.values()))]",74
34446741287,find_longest_gap,"def find_longest_gap(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0

    for bit in binary:
        if bit == '0':
            current_gap += 1
        else:
            max_gap = max(max_gap, current_gap)
            current_gap = 0

    return max_gap",74
69878242027,max_sum_subarray,"def max_sum_subarray(arr, k):
    if len(arr) < k:
        return None

    max_sum = sum(arr[:k])
    current_sum = max_sum

    for i in range(k, len(arr)):
        current_sum += arr[i] - arr[i-k]
        max_sum = max(max_sum, current_sum)

    return max_sum",74
18888495357,count_substring_occurrences,"def count_substring_occurrences(main_string, sub_string):
    count = 0
    start = 0
    while start < len(main_string):
        pos = main_string.find(sub_string, start)
        if pos != -1:
            count += 1
            start = pos + len(sub_string)
        else:
            break
    return count",74
11092861362,smallest_char_occurrences,"def smallest_char_occurrences(s):
    if not s:
        return 0

    char_count = {}
    min_char = s[0]

    for char in s:
        if char < min_char:
            min_char = char
        char_count[char] = char_count.get(char, 0) + 1

    return char_count[min_char]",74
18587767111,sum_of_divisors,"def sum_of_divisors(n):
    total = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            if n//i == i:
                total = total + i
            else:
                total = total + (i + n//i)
    return total",74
34815474133,valid_parentheses_strings,"def valid_parentheses_strings(n):
    if n == 0:
        return 1
    elif n == 1:
        return 1
    else:
        result = 0
        for i in range(n):
            result += valid_parentheses_strings(i) * valid_parentheses_strings(n - 1 - i)
        return result",74
40014210748,find_unique,"def find_unique(nums):
    ans = 0
    for i in range(32):
        total = sum((num >> i) & 1 for num in nums)
        if total % 3:
            if i == 31:
                ans -= (1 << i)
            else:
                ans |= (1 << i)
    return ans",74
5487018600,common_chars,"from collections import Counter

def common_chars(A):
    dict1 = Counter(A[0])
    dict2 = Counter()
    
    for word in A[1:]:
        dict2 = dict1 & Counter(word)
        dict1 = dict2
    
    result = [letter for letter, cnt in dict1.items() for _ in range(cnt)]
    return result",74
204911000,longest_increasing_subsequence,"def longest_increasing_subsequence(arr):
    n = len(arr)
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if arr[j] < arr[i] and dp[j] >= dp[i]:
                dp[i] = dp[j] + 1
    return max(dp)",74
72835618426,length_of_increasing_subsequence,"def length_of_increasing_subsequence(nums):
    if not nums:
        return 0

    dp = [1] * len(nums)

    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)",74
26476775865,sum_of_two_largest_odd_digits,"def sum_of_two_largest_odd_digits(num: int) -> int:
    odd_numbers = [int(i) for i in str(num) if int(i) % 2 != 0]
    if len(odd_numbers) < 2:
        return -1
    odd_numbers.sort()
    return odd_numbers[-1] + odd_numbers[-2]",74
17756064823,find_max_product,"def find_max_product(number, k):
    max_product = 0
    num_str = str(number)
    for i in range(len(num_str) - k + 1):
        product = 1
        for j in range(k):
            product *= int(num_str[i + j])
        max_product = max(max_product, product)
    return max_product",74
23106879306,stock_profit,"def stock_profit(prices):
    if len(prices) < 2:
        return 0
    maxprofit = 0
    minbuy = prices[0]
    for price in prices:
        minbuy = min(minbuy, price)
        profit = price - minbuy
        maxprofit = max(maxprofit, profit)
    return maxprofit",74
5147063439,min_meeting_rooms,"def min_meeting_rooms(meetings):
    events = []
    for start, end in meetings:
        events.append((start, 1))
        events.append((end, -1))
    events.sort()
    ans = need = 0
    for _, delta in events:
        need += delta
        ans = max(ans, need)
    return ans",74
21816574002,firstNonRepeatingChar,"def firstNonRepeatingChar(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for i in range(len(s)):
        if char_count[s[i]] == 1:
            return i
    return -1",74
13706327299,find_largest_fibonacci,"def is_fibonacci(n):
    a, b = 0, 1
    while b < n:
        a, b = b, a + b
    return b == n

def find_largest_fibonacci(lst):
    fib_lst = [i for i in lst if is_fibonacci(i)]
    return max(fib_lst)",74
38385624791,insertion_sort,"def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr",73
73096165784,longest_increasing_subsequence,"def longest_increasing_subsequence(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",73
15210894809,min_moves_to_target,"def min_moves_to_target(target: int) -> int:
    target = abs(target)
    s = n = 0
    while s < target or (s - target) % 2:  # 没有到达（越过）终点，或者相距奇数
        n += 1
        s += n
    return n",73
2029954681,diagonal_sum,"def diagonal_sum(mat):
    ans, n = 0, len(mat)
    for i in range(n): 
        ans += mat[i][i] + mat[i][n-i-1]
    if n % 2 != 0: 
        i = int(n/2) 
        ans -= mat[i][i] 
    return ans",73
17490157613,find_second_highest,"def find_second_highest(arr):
    if len(arr) < 2:
        return None
    first, second = float('-inf'), float('-inf')
    for num in arr:
        if num > first:
            second = first
            first = num
        elif num > second and num != first:
            second = num
    return second",73
10576458771,sort_operations,"def sort_operations(arr):
    n = len(arr)
    sorted_arr = sorted(arr)
    count = 0
    for i in range(n):
        if arr[i] != sorted_arr[i]:
            j = arr.index(sorted_arr[i])
            arr[i], arr[j] = arr[j], arr[i]
            count += 1
    return count",73
38432575056,find_permutations,"def find_permutations(s):
    if len(s) == 1:
        return [s]
    permutations = []
    for i in range(len(s)):
        char = s[i]
        remaining_chars = s[:i] + s[i+1:]
        for perm in find_permutations(remaining_chars):
            permutations.append(char + perm)
    return permutations",73
34135633550,max_sum_subarray_k,"def max_sum_subarray_k(arr,k):
    if len(arr) < k:
        return None
    max_sum = window_sum = sum(arr[:k])
    for i in range(len(arr)-k):
        window_sum = window_sum - arr[i] + arr[i+k]
        max_sum = max(max_sum, window_sum)
    return max_sum",73
73823269867,unique_k,"def unique_k(arr, k):
    answer = []
    num_set = set()
    
    for num in arr:
        if num not in num_set:
            num_set.add(num)
            answer.append(num)
        
        if len(answer) == k:
            break
    
    while len(answer) < k:
        answer.append(-1)
    
    return answer",73
15615608049,median_two_sorted_arrays,"def median_two_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2.0
    else:
        return nums[length // 2]",73
40742948039,maxProfit,"def maxProfit(prices):
    if not prices:
        return 0
    min_price = prices[0]
    max_profit = 0
    for price in prices:
        if price < min_price:
            min_price = price
        elif price - min_price > max_profit:
            max_profit = price - min_price
    return max_profit",73
22049176651,find_first_unique_char,"def find_first_unique_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for i, char in enumerate(s):
        if char_count[char] == 1:
            return i
    return -1",73
4875651929,print_permutations,"def print_permutations(string):
    if len(string) == 1:
        return [string]

    permutations = []
    for i in range(len(string)):
        char = string[i]
        remaining_string = string[:i] + string[i+1:]
        for permutation in print_permutations(remaining_string):
            permutations.append(char + permutation)
    return permutations",73
37303648514,find_median_of_two_sorted_arrays,"def find_median_of_two_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2
    else:
        return nums[length // 2]",73
24491339844,max_profit,"def max_profit(prices):
    if not prices:
        return 0
    min_price = prices[0]
    max_profit = 0
    for price in prices:
        if price < min_price:
            min_price = price
        elif price - min_price > max_profit:
            max_profit = price - min_price
    return max_profit",73
16908560539,find_max_nested_list,"def find_max_nested_list(l):
    max_depth = 0
    def dfs(l, depth):
        nonlocal max_depth
        for i in l:
            if isinstance(i, list):
                dfs(i, depth + 1)
                max_depth = max(max_depth, depth + 1)
    dfs(l, 0)
    return max_depth",73
36714125636,find_first_non_repeating_character,"def find_first_non_repeating_character(string): 
    count = {} 
    for char in string: 
        if char in count: 
            count[char] += 1
        else: 
            count[char] = 1 
    for char in string: 
        if count[char] == 1: 
            return char 
    return ""-""",73
20327440501,first_non_repeating,"def first_non_repeating(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for index, char in enumerate(s):
        if char_count[char] == 1:
            return index
    return -1",73
28749305,dec_to_base,"def dec_to_base(num, base):
    if base < 2 or base > 36:
        return ""Invalid base""
    digits = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    result = """"
    while num > 0:
        result = digits[num % base] + result
        num //= base
    return result",73
20854973713,length_of_longest_increasing_subsequence,"def length_of_longest_increasing_subsequence(nums):
    if not nums:
        return 0
    dp = [1]*len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j]+1)
    return max(dp)",73
15803788457,largest_number,"def largest_number(n):
    if n == 0:
        return 0
    digits = []
    while n:
        digits.append(n % 10)
        n //= 10
    digits.sort(reverse=True)
    result = 0
    for digit in digits:
        result = result * 10 + digit
    return result",73
24125359057,sum_of_primes,"def sum_of_primes(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return sum(i for i in lst if is_prime(i))",73
75561070135,filter_prime_numbers,"def filter_prime_numbers(numbers):
  def is_prime(n):
    if n < 2:
      return False
    for i in range(2, int(n ** 0.5) + 1):
      if n % i == 0:
        return False
    return True
  return [n for n in numbers if is_prime(n)]",73
19098051712,find_same_number_pairs,"from collections import Counter

def find_same_number_pairs(nums):
    count=Counter(nums)
    output=[]
    remain=0
    total=0
    for i in count:
        if count[i]:
            total+=count[i]//2
            remain+=count[i]%2
    output.append(total)
    output.append(remain)
    return output",73
21372918963,largest_binary_gap,"def largest_binary_gap(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0

    for bit in binary:
        if bit == '0':
            current_gap += 1
        else:
            max_gap = max(max_gap, current_gap)
            current_gap = 0

    return max_gap",73
35572073019,sum_of_primes,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def sum_of_primes(arr):
    return sum([i for i in arr if is_prime(i)])",73
5643769237,minimum_path_sum,"def minimum_path_sum(triangle):
    for row in range(len(triangle) - 1, 0, -1):
        for col in range(len(triangle[row]) - 1):
            triangle[row - 1][col] += min(triangle[row][col], triangle[row][col + 1])
    return triangle[0][0]",73
16779532374,next_pascal_row,"def next_pascal_row(prev_row):
    if len(prev_row) == 1:
        return [1, 1]
    next_row = [1]
    for i in range(len(prev_row) - 1):
        next_row.append(prev_row[i] + prev_row[i + 1])
    next_row.append(1)
    return next_row",73
24012545816,find_first_unique_char,"def find_first_unique_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for i in range(len(s)):
        if char_count[s[i]] == 1:
            return i
    return -1",73
44878332614,sum_of_primes,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def sum_of_primes(numbers):
    return sum([num for num in numbers if is_prime(num)])",73
43532604505,is_consecutive_sequences,"from collections import Counter
def is_consecutive_sequences(nums):
    count = Counter(nums)
    for n in sorted(count):
        if count[n] > 0:
            need = count[n]
            for m in range(n, n+3):
                if count[m] < need:
                    return False
                count[m] -= need
    return True",73
10304824859,firstUniqChar,"def firstUniqChar(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for i, char in enumerate(s):
        if char_count[char] == 1:
            return i
    return -1",73
32848531360,filter_primes,"def filter_primes(nums):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

    return [num for num in nums if is_prime(num)]",73
6664650015,min_path_sum_triangle,"def min_path_sum_triangle(triangle):
    for row in range(len(triangle) - 2, -1, -1):
        for col in range(len(triangle[row])):
            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])
    return triangle[0][0]",73
20928386201,sum_of_primes,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def sum_of_primes(numbers):
    return sum([num for num in numbers if is_prime(num)])",73
42864678609,string_permutation,"def string_permutation(s):
    if len(s) == 1:
        return [s]

    permutations = []
    for i in range(len(s)):
        char = s[i]
        remaining_chars = s[:i] + s[i+1:]
        for p in string_permutation(remaining_chars):
            permutations.append(char + p)

    return permutations",73
4307758648,power,"def power(x, n):
    if n == 0:
        return 1
    elif n < 0:
        return 1 / power(x, -n)
    elif n % 2 == 0:
        return power(x * x, n // 2)
    else:
        return x * power(x, n - 1)",73
7834018040,num_valid_parentheses,"def num_valid_parentheses(n):
    dp = [0 for i in range(n + 1)]
    dp[0] = 1
    for i in range(1, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",73
5809096021,permutations,"def permutations(lst):
    if len(lst) == 1:
        return [lst]
    result = []
    for i in range(len(lst)):
       m = lst[i]
       remLst = lst[:i] + lst[i+1:]
       for p in permutations(remLst):
           result.append([m] + p)
    return result",73
3625220147,remove_value,"def remove_value(nums, val):
    i = 0
    count = len(nums)
    temp = nums.count(val)
    limit = count - temp

    while(count > limit):
        if nums[i] == val:
            nums.remove(nums[i])
            count -= 1
        else:
            i += 1
    return len(nums)",73
39870705373,filter_primes,"def filter_primes(numbers):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

    return [num for num in numbers if is_prime(num)]",73
29180562736,most_common_letter,"def most_common_letter(text):
    char_count = {}
    for char in text:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    max_count = max(char_count.values())
    for char in text:
        if char_count[char] == max_count:
            return char",73
6566016858,verify_rotation,"def verify_rotation(nums):
    count = 0
    if nums[0]<nums[-1]:
        count += 1
    for i in range(1,len(nums)):
        if nums[i-1]>nums[i]:
            count += 1
        else:
            continue
    if count <= 1:
        return True
    return False",73
70336894151,count_target_pairs,"def count_target_pairs(nums, target):
    count = 0
    seen = {}
    for num in nums:
        complement = target - num
        if complement in seen:
            count += seen[complement]
        if num in seen:
            seen[num] += 1
        else:
            seen[num] = 1
    return count",73
72405205512,is_valid_identifier,"import keyword

def is_valid_identifier(s):
    if keyword.iskeyword(s):
        return False
    if not s or not s[0].isalpha() and s[0] != '_':
        return False
    for char in s[1:]:
        if not (char.isalnum() or char == '_'):
            return False
    return True",73
20602764683,unique_bst,"def unique_bst(n):
    dp = [0] * (n+1)
    dp[0], dp[1] = 1, 1
    for i in range(2, n+1):
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]
    return dp[n]",73
37131787105,max_profit,"def max_profit(prices):
    if not prices:
        return 0

    min_price = prices[0]
    max_profit = 0

    for price in prices:
        if price < min_price:
            min_price = price
        elif price - min_price > max_profit:
            max_profit = price - min_price

    return max_profit",73
3914940511,count_consecutive_sums,"def count_consecutive_sums(n):
    answer = 0
    
    for i in range(1, n+1):
        s = i 
        for j in range(i+1, n+1):
            if s == n :
                answer += 1 
            s += j 
            if s > n :
                break 
            
    return answer",73
35509566793,number_of_valid_parentheses,"def number_of_valid_parentheses(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",73
27879775456,secondLargest,"def secondLargest(arr): 
    first, second = 0, 0
    for i in range(len(arr)): 
        if arr[i] > first: 
            second = first 
            first = arr[i] 
        elif arr[i] > second and arr[i] != first: 
            second = arr[i] 
    return second",73
25607665589,find_max_consecutive_zeros,"def find_max_consecutive_zeros(nums):
    count, tmp = 0, 0
    for s in nums:
        if s == 0:
            tmp += 1
        elif tmp > count:
            count = tmp
            tmp = 0
        else:
            tmp = 0
    return count if count > tmp else tmp",73
34057259998,primes_sieve,"def primes_sieve(limit):
    limitn = limit+1
    not_prime = set()
    primes = []

    for i in range(2, limitn):
        if i in not_prime:
            continue

        for f in range(i*2, limitn, i):
            not_prime.add(f)

        primes.append(i)

    return primes",73
74227460794,prime_number_status,"def prime_number_status(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return [(n, is_prime(n)) for n in numbers]",73
70215244837,find_binary_gap,"def find_binary_gap(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0
    for b in binary:
        if b == '1':
            max_gap = max(max_gap, current_gap)
            current_gap = 0
        else:
            current_gap += 1
    return max_gap",73
6931075216,count_BST,"def count_BST(n): 
    if n == 0: 
        return 1
    result = 0
    for i in range(1, n + 1): 
        left = count_BST(i - 1) 
        right = count_BST(n - i) 
        result += left * right 
    return result",73
852142872,fibonacci_numbers,"def fibonacci_numbers(a, b):
    fibonacci_list = [1, 1]
    while fibonacci_list[-1] + fibonacci_list[-2] <= b:
        fibonacci_list.append(fibonacci_list[-1] + fibonacci_list[-2])
    
    result = [i for i in fibonacci_list if i >= a and i <= b]
    return result",73
27310442110,get_prime_numbers,"def get_prime_numbers(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True
    return [n for n in numbers if is_prime(n)]",73
7116786356,longest_increasing_subsequence,"def longest_increasing_subsequence(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",73
75246632345,find_second_highest,"def find_second_highest(nums):
    if len(nums) < 2:
        return None
    first, second = float('-inf'), float('-inf')
    for num in nums:
        if num > first:
            second = first
            first = num
        elif num > second and num != first:
            second = num
    return second",73
74013566469,filter_prime_numbers,"def filter_prime_numbers(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

    return [num for num in numbers if is_prime(num)]",73
12286719601,find_penultimate_max,"def find_penultimate_max(arr):
    if len(arr) < 2:
        return None
    max_val = max(arr)
    penultimate_max = None
    for num in arr:
        if num != max_val:
            if penultimate_max is None or num > penultimate_max:
                penultimate_max = num
    return penultimate_max",73
31907712746,largest_non_adjacent_sum,"def largest_non_adjacent_sum(numbers):
    if not numbers:
        return 0
    elif len(numbers) <= 2:
        return max(0, max(numbers))
    else:
        prev, curr = 0, 0
        for num in numbers:
            prev, curr = curr, max(prev + num, curr)
        return curr",73
37065670455,find_median_sorted_arrays,"def find_median_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        median = (nums[length//2] + nums[length//2 - 1]) / 2
    else:
        median = nums[length//2]
    return median",73
25272663912,calculate_elements,"def calculate_elements(arr):
    positive = 0
    negative = 0
    zero = 0
    for num in arr:
        if num > 0:
            positive += 1
        elif num < 0:
            negative += 1
        else:
            zero += 1
    return (positive, negative, zero)",73
18926824532,is_perfect_power,"def is_perfect_power(num):
    if num < 2:
        return False
    for base in range(2, int(num ** 0.5) + 1):
        power = 2
        while base ** power <= num:
            if base ** power == num:
                return True
            power += 1
    return False",73
42074212514,max_sum_subarray,"def max_sum_subarray(arr, k):
    if len(arr) < k:
        return None

    current_sum = max_sum = sum(arr[:k])
    for i in range(k, len(arr)):
        current_sum = current_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, current_sum)

    return max_sum",73
27841140759,power,"def power(x, n):
    if n == 0:
        return 1
    elif n < 0:
        return 1 / power(x, -n)
    elif n % 2 == 0:
        return power(x * x, n // 2)
    else:
        return x * power(x, n - 1)",73
71364652304,staircase_ways,"def staircase_ways(n, steps):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        for step in steps:
            if i - step >= 0:
                dp[i] += dp[i - step]
    return dp[n]",73
74612516411,first_non_repeating_character,"def first_non_repeating_character(input_string):
    char_count = {}
    for char in input_string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in input_string:
        if char_count[char] == 1:
            return char
    return None",73
41383955138,median_Two_Sorted_Arrays,"def median_Two_Sorted_Arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",73
12964594303,max_sum_subarray,"def max_sum_subarray(arr, k):
    if len(arr) < k:
        return None
    max_sum = current_sum = sum(arr[:k])
    for i in range(k, len(arr)):
        current_sum = current_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, current_sum)
    return max_sum",73
34548521551,permute,"def permute(nums):
    if len(nums) == 1:
        return [nums]
    permutations = []
    for i in range(len(nums)):
        m = nums[i]
        remList = nums[:i] + nums[i+1:]
        for p in permute(remList):
            permutations.append([m] + p)
    return permutations",73
25649539529,unique_characters,"def unique_characters(s):
    if len(s) > 26:
        return False
    char_set = [False] * 26
    for char in s:
        if char_set[ord(char) - ord('a')]:
            return False
        char_set[ord(char) - ord('a')] = True
    return True",73
3677828546,find_pairs,"from collections import Counter

def find_pairs(nums, k):
    counts = Counter(nums)
    ans = 0
    for num in counts:
        if k > 0 and num + k in counts:
            ans += 1
        elif k == 0 and counts[num] > 1:
            ans += 1
    return ans",72
73411990325,string_to_int,"def string_to_int(s):
  if s[0] == '-':
    s = s[1:]
    sign = -1
  else:
    sign = 1
  result = 0
  for char in s:
    result = result * 10 + (ord(char) - ord('0'))
  return result * sign",72
893965871,nth_fibonacci,"def nth_fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b",72
15104941492,binary_gap,"def binary_gap(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0
    for bit in binary:
        if bit == '0':
            current_gap += 1
        else:
            max_gap = max(max_gap, current_gap)
            current_gap = 0
    return max_gap",72
12725641488,max_nested_lists,"def max_nested_lists(lst):
  max_depth = 0
  stack = [(lst, 1)]
  while stack:
    current, depth = stack.pop()
    if isinstance(current, list):
      max_depth = max(max_depth, depth)
      for item in current:
        stack.append((item, depth + 1))
  return max_depth",72
855932316,max_product_three,"def max_product_three(nums):
    nums.sort()
    # The maximum product can be either (the product of the three largest numbers) or (the product of the two smallest numbers and the largest number)
    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])",72
37159742207,factorialDigitSum,"def factorialDigitSum(n):
    if n < 0:
        return None
    factorial = 1
    for i in range(1, n+1):
        factorial *= i
    sum = 0
    while factorial > 0:
        sum += factorial % 10
        factorial //= 10
    return sum",72
23126696266,median_of_two_sorted_arrays,"def median_of_two_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",72
70392677749,contains_target_sum,"def contains_target_sum(nums, target):
    """"""
    :type nums: List[int]
    :type target: int
    :rtype: bool
    """"""
    
    n_dict = {}
    for i in nums:
        if target - i in n_dict:
            return True
        else:
            n_dict[i] = True
    return False",72
43084116032,fib_iterative,"def fib_iterative(n):
    if n == 0: 
        return 0
    elif n == 1: 
        return 1
    else:
        a, b = 0, 1
        for i in range(2, n+1):
            a, b = b, a + b
        return b",72
489838793,find_non_repeating,"from collections import OrderedDict

def find_non_repeating(s):
    char_count = OrderedDict()
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char, count in char_count.items():
        if count == 1:
            return char",72
74354458061,median,"def median(lst):
    sortedLst = sorted(lst)
    lstLen = len(lst)
    index = (lstLen - 1) // 2

    if (lstLen % 2):
        return sortedLst[index]
    else:
        return (sortedLst[index] + sortedLst[index + 1])/2.0",72
21457812468,prime_numbers,"def prime_numbers(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

    return [number for number in numbers if is_prime(number)]",72
48068746478,count_digit,"def count_digit(number, digit):
    """"""
    :type number: int
    :type digit: int
    :rtype: int
    """"""
    count = 0
    while number > 0:
        if number % 10 == digit:
            count += 1
        number = number // 10
    return count",72
18815569798,longest_Increasing_Subsequence,"def longest_Increasing_Subsequence(nums):
    if not nums: return 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",72
20382841084,find_primes,"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def find_primes(numbers):
    return [num for num in numbers if is_prime(num)]",72
17086770685,filter_primes,"def filter_primes(lst):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return [num for num in lst if is_prime(num)]",72
39011814799,count_parentheses,"def count_parentheses(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    
    for i in range(1, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    
    return dp[n]",72
14256021818,maximum_subarray_sum,"def maximum_subarray_sum(nums):
    if not nums:
        return 0
    max_current = max_global = nums[0]
    for i in range(1, len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",72
74886080447,first_unique_char,"def first_unique_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for index, char in enumerate(s):
        if char_count[char] == 1:
            return index
    return -1",72
8354929873,count_anagrams,"from math import factorial

def count_anagrams(word1, word2):
    if sorted(word1) != sorted(word2) or len(word1) != len(word2):
        return 0
    else:
        count = factorial(len(word1))
        for char in set(word1):
            count //= factorial(word1.count(char))
        return count",72
7859111364,lcm,"from math import gcd

def lcm(numbers): 
    if len(numbers) == 0:
        return 1
    elif len(numbers) == 1:
        return numbers[0]
    else:
        lcm = numbers[0]
        for i in numbers[1:]:
            lcm = lcm*i//gcd(lcm, i)
        return lcm",72
32324565815,find_fibonacci,"def find_fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b",72
23289006723,find_primes,"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def find_primes(nums):
    return [num for num in nums if is_prime(num)]",72
71920996516,median_of_two_sorted_arrays,"def median_of_two_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2
    else:
        return nums[length // 2]",72
20014720719,check_perfect_number,"def check_perfect_number(n):
    divisors = [1]
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    return sum(divisors) == n",72
69811569425,sum_of_proper_divisors,"def sum_of_proper_divisors(n):
    divisors = [1]
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    return sum(divisors)",72
17860885828,fibonacci_sum,"def fibonacci_sum(n):
    if n <= 0:
        return 0
    fib = [0, 1]
    sum_fib = 1
    for i in range(2, n):
        fib.append(fib[i-1] + fib[i-2])
        sum_fib += fib[i]
    return sum_fib",72
16288035932,find_max_subarray,"def find_max_subarray(nums):
    if not nums:
        return 0
    current_max = global_max = nums[0]
    for i in range(1, len(nums)):
        current_max = max(nums[i], current_max + nums[i])
        if current_max > global_max:
            global_max = current_max
    return global_max",72
15590441930,sum_Consecutive,"def sum_Consecutive(n):
    count = 0
    i = 1
    while i * (i - 1) // 2 < n:
        if (n - i * (i - 1) // 2) % i == 0:
            count += 1
        i += 1
    return count",72
27046514842,first_unique_char,"def first_unique_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for i in range(len(s)):
        if char_count[s[i]] == 1:
            return i
    return -1",72
14511130801,find_max_sum_subarray,"def find_max_sum_subarray(arr, k):
    if len(arr) < k:
        return None
    
    max_sum = current_sum = sum(arr[:k])
    for i in range(k, len(arr)):
        current_sum += arr[i] - arr[i-k]
        max_sum = max(max_sum, current_sum)
        
    return max_sum",72
17171453489,binary_gap,"def binary_gap(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0
    for bit in binary:
        if bit == '0':
            current_gap += 1
        else:
            max_gap = max(max_gap, current_gap)
            current_gap = 0
    return max_gap",72
74404692615,find_shortest_repeating_pattern,"def find_shortest_repeating_pattern(s: str) -> str:
    length = len(s)
    for cut in range(1, length // 2 + 1):
        if length % cut != 0:
            continue
        if s[:cut] * (length // cut) == s:
            return s[:cut]
    return s",72
12283423878,missingNumber,"from typing import List


def missingNumber(nums: List[int]) -> int:
    """"""
    Time: O(n)
    Space: O(1)
        n - number of elements in the array
    """"""
    s = sum(nums)
    n = len(nums)
    return ((n * (n + 1)) // 2) - s",72
17373061297,sum_of_proper_divisors,"def sum_of_proper_divisors(n):
    divisors = [1]
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    return sum(divisors)",72
23845210076,find_median_sorted_arrays,"def find_median_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 1:
        return nums[length // 2]
    else:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2.0",72
38616537599,median_of_two_sorted_arrays,"def median_of_two_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",72
33699558485,findDuplicate,"def findDuplicate(nums):
    slow = nums[0]
    fast = nums[nums[0]]
    while slow != fast:
        slow = nums[slow]
        fast = nums[nums[fast]]
    fast = 0
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    return slow",72
3390723813,filter_prime_numbers,"def filter_prime_numbers(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return [number for number in numbers if is_prime(number)]",72
7363473142,get_prime_numbers,"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def get_prime_numbers(numbers):
    return [num for num in numbers if is_prime(num)]",72
3407303377,count_primes,"def count_primes(numbers):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

    return sum(is_prime(num) for num in numbers)",72
33216340465,stairClimb,"def stairClimb(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    else:
        a, b = 1, 2
        for i in range(3, n + 1):
            a, b = b, a + b
        return b",72
14347124086,find_min_rotated,"def find_min_rotated(nums):
    l, r = 0, len(nums) - 1
    while l < r:
        m = l + (r - l) // 2
        if nums[m] < nums[r]:
            r = m
        else:
            l = m + 1
    return nums[l]",72
43149704824,max_Formed,"from collections import Counter

def max_Formed(s,words):
    s_counter = Counter(s)
    word_counter = Counter()
    for word in words:
        word_counter += Counter(word)
    result = 0
    for letter,count in s_counter.items():
        result += min(count,word_counter[letter]) * len(letter)
    return result",72
72464409588,primes_only,"def primes_only(lst):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True
    return [num for num in lst if is_prime(num)]",72
73213991932,max_Subarray_Sum,"def max_Subarray_Sum(arr):
    max_sum = 0
    current_sum = 0
    
    for i in range(len(arr)):
        current_sum += arr[i]
        
        if current_sum < 0:
            current_sum = 0
        elif current_sum > max_sum:
            max_sum = current_sum
    
    return max_sum",72
72465957428,min_moves,"def min_moves(arr):
    n = len(arr)
    moves = 0
    for i in range(n):
        for j in range(n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                moves += 1
    return moves",72
73642052190,find_Longest_Common_Prefix,"def find_Longest_Common_Prefix(strs): 
    if not strs: 
        return """" 
    shortest_str = min(strs,key=len) 
    for i, char in enumerate(shortest_str): 
        for other in strs: 
            if other[i] != char: 
                return shortest_str[:i] 
    return shortest_str",72
73096810618,majority_element,"def majority_element(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    if nums.count(candidate) > len(nums) // 2:
        return candidate
    else:
        return -1",72
30471827571,median_of_two_sorted_arrays,"def median_of_two_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2
    else:
        return nums[length // 2]",72
10783875428,count_palindrome_substrings,"def count_palindrome_substrings(s):
    def is_palindrome(s):
        return s == s[::-1]

    count = 0
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            if is_palindrome(s[i:j]):
                count += 1
    return count",72
71842520065,binary_gap,"def binary_gap(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0

    for bit in binary:
        if bit == '1':
            max_gap = max(max_gap, current_gap)
            current_gap = 0
        else:
            current_gap += 1

    return max_gap",72
14514509124,length_of_LIS,"def length_of_LIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",72
148277753,count_character,"def count_character(s, c):
    # Initialize the count to 0
    count = 0
    # Loop through the string
    for char in s:
        # If the current character matches the input character, increment the count
        if char == c:
            count += 1
    # Return the final count
    return count",72
36889177651,median_of_two_sorted_arrays,"def median_of_two_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",72
42168295111,find_majority_element,"def find_majority_element(arr):
    count = 0
    result = 0
    for i in range(len(arr)):
        if count == 0:
            result = arr[i]
            count = 1
        elif arr[i] == result:
            count += 1
        else:
            count -= 1
    return result",72
9838706198,longestConsecutive,"def longestConsecutive(nums):
    numSet = set(nums)
    longest = 0
    for n in nums:
        if (n - 1) not in numSet:
            length = 0
            while (n + length) in numSet:
                length += 1
            longest = max(length, longest)
    return longest",72
44680794513,median,"def median(lst):
    sortedLst = sorted(lst)
    lstLen = len(lst)
    index = (lstLen - 1) // 2

    if (lstLen % 2):
        return sortedLst[index]
    else:
        return (sortedLst[index] + sortedLst[index + 1])/2.0",72
9643000450,lis,"def lis(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",72
30514335579,generate_permutations,"def generate_permutations(lst):
    if len(lst) == 0:
        return [[]]
    result = []
    for i in range(len(lst)):
        current = lst[i]
        remaining = lst[:i] + lst[i+1:]
        for permutation in generate_permutations(remaining):
            result.append([current] + permutation)
    return result",72
73798134751,filter_prime_numbers,"def filter_prime_numbers(numbers):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    return [num for num in numbers if is_prime(num)]",72
72903955864,smallest_Number,"from itertools import permutations

def smallest_Number(n):
    digits = [int(d) for d in str(n)]
    smallest = float('inf')
    for perm in permutations(digits):
        num = int(''.join(map(str, perm)))
        if num < smallest and sorted(str(num)) == sorted(str(n)):
            smallest = num
    return smallest",72
15733792678,max_sum_k,"def max_sum_k(arr, k):
    if k == len(arr):
        return sum(arr)
    maxSum = sum(arr[:k])
    total = maxSum
    for i in range(k, len(arr)):
        maxSum = maxSum - arr[i-k] + arr[i]
        total = max(total, maxSum)
    return total",72
2072635224,binary_gap,"def binary_gap(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0

    for bit in binary:
        if bit == '0':
            current_gap += 1
        else:
            max_gap = max(max_gap, current_gap)
            current_gap = 0

    return max_gap",72
72309819225,frequent_char,"def frequent_char(s):
    char_freq = {}
    for char in s:
        if char in char_freq:
            char_freq[char] += 1
        else:
            char_freq[char] = 1
    max_freq = max(char_freq.values())
    return [char for char, freq in char_freq.items() if freq == max_freq]",72
17461118249,prime_numbers,"def prime_numbers(nums):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

    return [num for num in nums if is_prime(num)]",72
8919842690,days_between_dates,"from datetime import datetime

def days_between_dates(date1: str, date2: str) -> int:
    date_format = ""%Y-%m-%d""
    d1 = datetime.strptime(date1, date_format)
    d2 = datetime.strptime(date2, date_format)
    delta = d2 - d1
    return abs(delta.days)",72
8648522828,binary_gap,"def binary_gap(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0

    for bit in binary:
        if bit == '1':
            max_gap = max(max_gap, current_gap)
            current_gap = 0
        else:
            current_gap += 1

    return max_gap",72
17739734996,find_missing_positive,"def find_missing_positive(A):
    A = [x for x in A if x > 0]
    A = sorted(set(A))
    if not A:
        return 1
    for i, num in enumerate(A):
        if num != i + 1:
            return i + 1
    return A[-1] + 1",72
16938928159,binary_gap,"def binary_gap(N):
    binary = bin(N)[2:]
    max_gap = 0
    current_gap = 0

    for bit in binary:
        if bit == '0':
            current_gap += 1
        else:
            max_gap = max(max_gap, current_gap)
            current_gap = 0

    return max_gap",72
20054260200,first_unique_char,"def first_unique_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for i in range(len(s)):
        if char_count[s[i]] == 1:
            return i
    return -1",72
42744971652,count_Ways,"def count_Ways(n): 
    if (n == 1 or n == 0): 
        return 1
    elif (n == 2): 
        return 2
    else: 
        return count_Ways(n - 1) + count_Ways(n - 2) + count_Ways(n - 3)",72
73087802945,find_first_non_repeating_char,"def find_first_non_repeating_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",71
44069714181,rotate_list,"def rotate_list(nums, k):
    n = len(nums)
    k = k % n  # In case the rotation is larger than the list length
    if k < 0:
        k += n  # If k is negative, rotate to the left
    nums[:] = nums[-k:] + nums[:-k]
    return nums",71
6952002474,prime_identifier,"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def prime_identifier(nums):
    return [(num, is_prime(num)) for num in nums]",71
24461096213,max_product,"def max_product(arr):
    arr.sort()
    # The maximum product can be either (the product of the three largest numbers) or (the product of the two smallest numbers and the largest number)
    return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])",71
71274303480,find_second_largest,"def find_second_largest(arr):
    max_element = second_max_element = float('-inf')
    for num in arr:
        if num > max_element:
            second_max_element = max_element
            max_element = num
        elif num > second_max_element and num < max_element:
            second_max_element = num
    return second_max_element",71
29242376434,median_of_sorted_arrays,"def median_of_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2
    else:
        return nums[length // 2]",71
23955513763,check_anagram_palindrome,"def check_anagram_palindrome(s):
    counter = [0]*256
    for i in s:
        counter[ord(i)]+=1
    odd = 0
    for i in counter:
        if i%2!=0:
            odd+=1
        if odd>1:
            return False
    return True",71
14557638738,count_unique_bst,"def count_unique_bst(n):
    if n == 0:
        return 1
    result = 0
    for i in range(1, n + 1):
        left = count_unique_bst(i - 1)
        right = count_unique_bst(n - i)
        result += left * right
    return result",71
42832858996,diagonal_sum,"def diagonal_sum(mat):
    sum=0
    idx=0
        
    for lst in mat :
        sum+=lst[idx]+lst[len(mat)-idx-1]
        idx+=1
    
    if len(mat) % 2 == 0:
        return sum
    return sum - mat[len(mat)//2][len(mat)//2]",71
36533648654,firstNonRepeatingCharacter,"def firstNonRepeatingCharacter(string):
    char_count = {}
    for char in string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in string:
        if char_count[char] == 1:
            return char
    return -1",71
40710836964,largest_sum_non_adjacent,"def largest_sum_non_adjacent(nums):
    if not nums:
        return 0
    incl = 0
    excl = 0
    for num in nums:
        new_excl = excl if excl > incl else incl
        incl = excl + num
        excl = new_excl
    return max(incl, excl)",71
15590275150,find_second_largest,"def find_second_largest(nums):
    max_num = second_max_num = float('-inf')
    for num in nums:
        if num > max_num:
            second_max_num = max_num
            max_num = num
        elif num > second_max_num and num != max_num:
            second_max_num = num
    return second_max_num",71
71563806839,longestConsecutive,"def longestConsecutive(nums):
    numset = set(nums)
    longest = 0
    for num in nums:
        if (num-1) not in numset:
            length = 1
            while (num + length) in numset:
                length += 1
            longest = max(length, longest)
    return longest",71
32383392476,combination,"def combination(nums, k):
    def backtrack(start=0, current=[]):
        if len(current) == k:
            result.append(current[:])
            return
        for i in range(start, len(nums)):
            current.append(nums[i])
            backtrack(i+1, current)
            current.pop()
    result = []
    backtrack()
    return result",71
24828176452,findMedianSortedArrays,"def findMedianSortedArrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",71
13420201854,find_max_diff,"def find_max_diff(arr):
    diff = 0
    min_val = arr[0]
    for i in range(1, len(arr)):
        if arr[i] - min_val > diff:
            diff = arr[i] - min_val
        if arr[i] < min_val:
            min_val = arr[i]
    return diff",71
24464111486,lucas_number,"def lucas_number(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        a, b = 2, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b",71
74228772544,filter_primes,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def filter_primes(numbers):
    return [num for num in numbers if is_prime(num)]",71
33021704012,median_two_sorted_arrays,"def median_two_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2
    else:
        return nums[length // 2]",71
12625117512,length_of_lis,"from bisect import bisect_left

def length_of_lis(nums):
    result = [nums[0]]
    
    for ele in nums[1:]:
        idx = bisect_left(result, ele)
        
        if idx == len(result):
            result.append(ele)
            
        else:
            result[idx] = ele
            
    return len(result)",71
42301642282,permute,"def permute(nums):
    if len(nums) == 1:
        return [nums]
    permutations = []
    for i in range(len(nums)):
        m = nums[i]
        rem = nums[:i] + nums[i+1:]
        for p in permute(rem):
            permutations.append([m] + p)
    return permutations",71
37568020583,valid_word_square,"def valid_word_square(words):
    def column(n):
        n_c = ''
        for i in words:
            if len(i) > n:
                n_c += i[n]
        return n_c
    m = len(words)
    for i in range(m):
        if words[i] != column(i):
            return False
    return True",71
35104014012,find_median_sorted_arrays,"def find_median_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2
    else:
        return nums[length // 2]",71
33623803879,largest_sum_non_adjacent,"def largest_sum_non_adjacent(arr):
    if not arr:
        return 0
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return max(incl, excl)",71
12233534710,max_stock_profit,"def max_stock_profit(prices):
    if not prices:
        return 0

    min_price = prices[0]
    max_profit = 0

    for price in prices:
        if price < min_price:
            min_price = price
        else:
            max_profit = max(max_profit, price - min_price)

    return max_profit",71
11860768217,filter_primes,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def filter_primes(numbers):
    return [num for num in numbers if is_prime(num)]",71
25771004990,power,"def power(x, y):
    if y == 0:
        return 1
    if y % 2 == 0:
        return power(x, y // 2) * power(x, y // 2)
    else:
        return x * power(x, y // 2) * power(x, y // 2)",71
39005738038,findMedianSortedArrays,"def findMedianSortedArrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2
    else:
        return nums[length // 2]",71
11622368774,find_first_non_repeating_char,"def find_first_non_repeating_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",71
41608488185,median_two_sorted_arrays,"def median_two_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",71
42823867589,max_of_two,"def max_of_two(a, b):
    return (a + b + abs(a - b)) // 2

assert max_of_two(10, 20) == 20
assert max_of_two(5, 5) == 5
assert max_of_two(-10, -20) == -10",71
28749079042,find_first_non_repeating_character,"def find_first_non_repeating_character(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return """"",71
31447407037,balanced_parentheses,"def balanced_parentheses(string):
    stack = []
    mapping = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}

    for char in string:
        if char in mapping.values():
            stack.append(char)
        elif char in mapping:
            if not stack or stack.pop() != mapping[char]:
                return False
    return not stack",71
13725284390,lucas_number,"def lucas_number(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        a, b = 2, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b",71
70575655319,largest_sum_non_adjacent,"def largest_sum_non_adjacent(nums):
    if not nums:
        return 0
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl>incl else incl
        incl = excl + i
        excl = new_excl
    return max(incl, excl)",71
11516087506,first_factorial_perfect_square,"import math

def is_perfect_square(n):
    return math.sqrt(n) % 1 == 0

def first_factorial_perfect_square(x):
    i = 1
    fact = 1
    while True:
        fact *= i
        if is_perfect_square(fact):
            return i
        i += 1",71
28609211431,findMedianSortedArrays,"def findMedianSortedArrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",71
20187685031,unique_paths,"def unique_paths(m, n):
    dp = [[1] * n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",71
73383564870,filter_primes,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def filter_primes(numbers):
    return [num for num in numbers if is_prime(num)]",71
7146864021,fibonacci_memoization,"def fibonacci_memoization(n, memo = {}):
    if n in memo:
        return memo[n]
    if n <= 1:
        result = n
    else:
        result = fibonacci_memoization(n-1, memo) + fibonacci_memoization(n-2, memo)
    memo[n] = result
    return result",71
35023846645,find_prime_numbers,"def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def find_prime_numbers(numbers):
    return [num for num in numbers if is_prime(num)]",71
347383763,nth_lucas,"def nth_lucas(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        a, b = 2, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b",71
38421121338,stock_profit,"def stock_profit(prices):
    sold, held, reset = float('-inf'), float('-inf'), 0

    for price in prices:
        pre_sold = sold
        sold = held + price
        held = max(held, reset-price)
        reset = max(reset, pre_sold)

    return max(sold, reset)",71
36274207876,findMedianSortedArrays,"def findMedianSortedArrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",71
71691549301,get_prime_numbers,"def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def get_prime_numbers(numbers):
    return [num for num in numbers if is_prime(num)]",71
18278494102,filter_primes,"def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def filter_primes(numbers):
    return [num for num in numbers if is_prime(num)]",71
38728097661,filter_prime_numbers,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def filter_prime_numbers(numbers):
    return [num for num in numbers if is_prime(num)]",71
3553574903,find_median_sorted_arrays,"def find_median_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",71
9352916847,findMedianSortedArrays,"def findMedianSortedArrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2
    else:
        return nums[length // 2]",71
5985302610,sum_proper_divisors,"def sum_proper_divisors(n):
    divisors = [1]
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    return sum(divisors)",71
38430214104,product_of_fibonacci,"def product_of_fibonacci(n):
    if n == 0:
        return 0
    fib = [0, 1]
    product = 0
    for i in range(2, n+1):
        fib.append(fib[i-1] + fib[i-2])
        product *= fib[i]
    return product",71
28450793485,length_of_lis,"def length_of_lis(nums):
    if not nums:
        return 0
    dp = [1]*len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",71
33178911831,length_of_LIS,"def length_of_LIS(nums):
    if not nums:
        return 0
    dp = [1]*len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",71
27840764159,find_first_non_repeating_char,"def find_first_non_repeating_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return ''",71
73008195023,find_smallest_difference,"def find_smallest_difference(nums):
    nums.sort()
    smallest_diff = abs(nums[0] - nums[1])
    for i in range(1, len(nums) - 1):
        diff = abs(nums[i] - nums[i + 1])
        if diff < smallest_diff:
            smallest_diff = diff
    return smallest_diff",71
72541916580,find_non_repeating,"def find_non_repeating(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return ""-1""",71
19776390569,median_two_sorted_arrays,"def median_two_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",71
32321773769,find_median_sorted_arrays,"def find_median_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2
    else:
        return nums[length // 2]",71
6733893977,find_median_sorted_lists,"def find_median_sorted_lists(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",71
13333182137,first_non_repeating,"def first_non_repeating(s: str):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",71
1694500296,non_repeating_char,"def non_repeating_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return ""None""",71
73776423637,prime_filter,"def prime_filter(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return [num for num in numbers if is_prime(num)]",71
13749115876,find_LIS,"def find_LIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",71
17008480980,find_first_non_repeating_character,"def find_first_non_repeating_character(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return ""-""",71
7356539077,max_bottles,"def max_bottles(numBottles, numExchange):
    drank = numBottles
    empty = numBottles

    while empty >= numExchange:
        new_bottles = empty // numExchange
        drank += new_bottles
        empty = empty % numExchange + new_bottles

    return drank",71
3777352734,get_prime_numbers,"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def get_prime_numbers(numbers):
    return [num for num in numbers if is_prime(num)]",71
70484882687,find_median_sorted_arrays,"def find_median_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",71
44462828896,wordBreak,"def wordBreak(s, wordDict):
    dp = [True] + [False]*len(s)
    for i in range(1, len(s)+1):
        for word in wordDict:
            if dp[i - len(word)] and s[:i].endswith(word):
                dp[i] = True
    return dp[-1]",71
74267637430,find_unique_paths,"def find_unique_paths(m, n):
    dp = [[1]*n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",71
37236218280,count_consecutive_char,"def count_consecutive_char(char, string):
    count = 0
    max_count = 0
    for i in range(len(string)):
        if string[i] == char:
            count += 1
        else:
            max_count = max(max_count, count)
            count = 0
    return max(max_count, count)",71
25894944979,find_first_non_repeating_char,"def find_first_non_repeating_char(s):
  char_count = {}
  for char in s:
    if char in char_count:
      char_count[char] += 1
    else:
      char_count[char] = 1
  for char in s:
    if char_count[char] == 1:
      return char
  return """"",71
73782801491,is_hex_color_code,"def is_hex_color_code(color_code):
    if len(color_code) != 7 or color_code[0] != '#':
        return False
    for i in range(1, 7):
        if color_code[i] not in ""0123456789abcdefABCDEF"":
            return False
    return True",71
3384948980,max_xor_subarray,"def max_xor_subarray(nums):
    xor = 0
    max_xor = 0
    n = len(nums)
    for i in range(n):
        current_xor = 0
        for j in range(i, n):
            current_xor ^= nums[j]
            max_xor = max(max_xor, current_xor)
    return max_xor",71
10575982641,is_valid_identifier,"import keyword

def is_valid_identifier(s):
    if keyword.iskeyword(s):
        return False
    if not s or not s[0].isalpha() and s[0] != '_':
        return False
    for char in s:
        if not (char.isalnum() or char == '_'):
            return False
    return True",71
34531682136,fabric_cuts,"def fabric_cuts(length, piece):
    left = 0
    right = length + 1
    
    while right - left > 1:
        mid = left + (right - left) // 2
        if length // mid < piece:
            right = mid
        else:
            left = mid
    
    return length // left",71
6106849642,first_non_repeating_char,"def first_non_repeating_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return -1",71
42599263493,sum_proper_divisors,"def sum_proper_divisors(n):
    divisors = [1]
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    return sum(divisors)",71
27111547969,prime_filter,"def prime_filter(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return [num for num in numbers if is_prime(num)]",71
74080244271,filter_prime_numbers,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def filter_prime_numbers(numbers):
    return [n for n in numbers if is_prime(n)]",71
21548645968,findMedianSortedArrays,"def findMedianSortedArrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2 - 1] + nums[length // 2]) / 2
    else:
        return nums[length // 2]",71
36482055397,count_primes,"def count_primes(nums):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    return sum(is_prime(num) for num in nums)",71
20020951526,binary_search_max,"def binary_search_max(arr):
    low, high = 0, len(arr) - 1
    while low < high:
        mid = (low + high) // 2
        if arr[mid] < arr[high]:
            low = mid + 1
        else:
            high = mid
    return arr[low]",71
73642051550,find_first_non_repeating,"from collections import OrderedDict

def find_first_non_repeating(s):
    count = OrderedDict()
    for i in s:
        if i in count:
            count[i] += 1
        else:
            count[i] = 1
    for i in count:
        if count[i] == 1:
            return i
    return None",71
39885556663,fibonacci_sum,"def fibonacci_sum(n):
    if n <= 0:
        return 0
    fib = [0, 1]
    sum_fib = 1
    for i in range(2, n):
        fib.append(fib[-1] + fib[-2])
        sum_fib += fib[-1]
    return sum_fib",71
22787325467,isMonotonic,"def isMonotonic(nums):
    increase = True
    decrease = True
    
    for idx in range(1, len(nums)):
        current = nums[idx]
        previous = nums[idx - 1]
        
        if previous > current:
            increase = False
        elif previous < current:
            decrease = False
            
    return increase or decrease",71
11415488862,is_valid_password,"import re

def is_valid_password(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    return True",71
22795542486,count_target_subsequences,"def count_target_subsequences(s, target):
    dp = [1] + [0] * len(target)
    for char in s:
        for i in range(len(target) - 1, -1, -1):
            if char == target[i]:
                dp[i + 1] += dp[i]
    return dp[-1]",71
35537352233,max_adjacent_product,"def max_adjacent_product(input_array):
    max_product = input_array[0] * input_array[1]
    for i in range(1, len(input_array) - 1):
        product = input_array[i] * input_array[i + 1]
        if product > max_product:
            max_product = product
    return max_product",71
32324657275,findMedianSortedArrays,"def findMedianSortedArrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",71
24485427332,first_non_repeating_char,"def first_non_repeating_char(string):
    char_count = {}
    
    for char in string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

    for char in string:
        if char_count[char] == 1:
            return char

    return None",71
17677906855,count_parentheses,"def count_parentheses(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i - j - 1]
    return dp[n]",71
18631652342,find_first_non_repeating_char,"def find_first_non_repeating_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",71
23519622591,largest_sum_non_adjacent,"def largest_sum_non_adjacent(nums):
    if not nums:
        return 0
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return max(incl, excl)",71
10103364527,next_power_of_2,"def next_power_of_2(n):
    if n == 0:
        return 1
    elif n and not(n & (n - 1)):
        return n
    else:
        position = 0
        while n > 0:
            n >>= 1
            position += 1
        return 1 << position",71
33958771730,sum_proper_divisors,"def sum_proper_divisors(n):
    divisors = [1]
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    return sum(divisors)",71
14636980216,max_adjacent_product,"def max_adjacent_product(input_list):
    max_product = input_list[0] * input_list[1]
    for i in range(1, len(input_list) - 1):
        product = input_list[i] * input_list[i + 1]
        if product > max_product:
            max_product = product
    return max_product",71
72637114839,can_reach_end,"def can_reach_end(nums):
    max_reach = 0
    for i in range(len(nums)):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + nums[i])
        if max_reach >= len(nums) - 1:
            return True
    return False",70
21118500719,first_non_repeated_char,"def first_non_repeated_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return """"",70
43716220646,rotate_matrix,"def rotate_matrix(matrix):
    n = len(matrix)
    for i in range(n):
        for j in range(i, n):
            matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i]
    for i in range(n):
        matrix[i] = matrix[i][::-1]
    return matrix",70
26153549677,rotate_matrix,"def rotate_matrix(matrix):
    n = len(matrix)
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    for i in range(n):
        matrix[i] = matrix[i][::-1]
    return matrix",70
41672286774,max_min_value,"def max_min_value(dict_list, key):
    if not dict_list or key not in dict_list[0]:
        return None, None
    max_value = max(dict_list, key=lambda x: x[key])[key]
    min_value = min(dict_list, key=lambda x: x[key])[key]
    return max_value, min_value",70
40219722122,to_uppercase,"def to_uppercase(s):
    uppercase_str = """"
    for char in s:
        if 'a' <= char <= 'z':
            # Convert lowercase to uppercase by subtracting 32 from ASCII value
            uppercase_str += chr(ord(char) - 32)
        else:
            uppercase_str += char
    return uppercase_str",70
71740102,validate_password,"import re

def validate_password(password):
    if len(password) < 8:
        return False
    if not re.search(""[a-z]"", password):
        return False
    if not re.search(""[A-Z]"", password):
        return False
    if not re.search(""[0-9]"", password):
        return False
    return True",70
1510425611,armstrong_num,"def armstrong_num(n):
    temp = n
    order = len(str(n))
    sum = 0
    while temp > 0:
        digit = temp % 10
        sum += digit ** order
        temp //= 10
    if n == sum:
        return True
    else:
        return False",70
70986711086,mountain_array_peak,"def mountain_array_peak(arr):
    left, right = 0, len(arr) - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < arr[mid + 1]:
            left = mid + 1
        else:
            right = mid
    return left",70
42496997902,find_duplicate_characters,"def find_duplicate_characters(str):
    char_count = {}
    for char in str:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    duplicates = {char: count for char, count in char_count.items() if count > 1}
    return duplicates",70
21584862959,maxSubArray,"def maxSubArray(nums):
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    curr_sum = max_sum = nums[0]
    for num in nums[1:]:
        curr_sum = max(num, curr_sum + num)
        max_sum = max(max_sum, curr_sum)
    return max_sum",70
11747922224,uniquePaths,"def uniquePaths(m, n):
    dp = [[1]*n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",70
30825285432,max_coins,"def max_coins(piles):
    piles.sort()
    n = len(piles)
    k = n // 3
    i, j = 0, 2
    ans = 0
    while i < k:
        ans += piles[n-j]
        j += 2
        i +=1
    return ans",70
15229476235,largest_Sum_Non_Adjacent,"def largest_Sum_Non_Adjacent(arr):
    incl = 0
    excl = 0
     
    for i in arr:
        new_excl = excl if excl>incl else incl
         
        incl = excl + i
        excl = new_excl
         
    return (excl if excl>incl else incl)",70
31108030852,unique_paths,"def unique_paths(m, n):
    dp = [[1]*n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",70
70105392253,most_frequent,"def most_frequent(nums):
    memo = {}
    for n in nums:
        if n not in memo:
            memo[n] = 0
        memo[n] += 1

    max_freq = max(memo.values())
    result = [k for k, v in memo.items() if v == max_freq]

    return result",70
27757244829,unique_paths,"def unique_paths(m, n):
    dp = [[1]*n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",70
40731310262,find_smallest_missing_positive,"def find_smallest_missing_positive(nums):
    if not nums:
        return 1
    nums = list(set(nums))
    nums.sort()
    smallest_missing = 1
    for num in nums:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",70
29720516175,find_first_non_repeated,"def find_first_non_repeated(string):
    char_count = {}
    for char in string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in string:
        if char_count[char] == 1:
            return char
    return None",70
22954670216,first_non_repeating_character,"def first_non_repeating_character(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",70
3266875950,max_consecutive_ones,"def max_consecutive_ones(n):
    binary = bin(n)[2:]
    count, max_count = 0, 0
    for bit in binary:
        if bit == '1':
            count += 1
            max_count = max(max_count, count)
        else:
            count = 0
    return max_count",70
31928777988,first_non_repeating_char,"def first_non_repeating_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return """"",70
74956475335,find_first_non_repeating,"def find_first_non_repeating(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",70
29451525854,unique_substrings,"def unique_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return sorted(list(substrings))

print(unique_substrings(""abc""))
print(unique_substrings(""xyz""))
print(unique_substrings(""a""))",70
30342853057,counting_sort,"def counting_sort(arr):
    max_val = max(arr)
    count = [0] * (max_val + 1)
    
    for num in arr:
        count[num] += 1
    
    sorted_arr = []
    for i, freq in enumerate(count):
        sorted_arr.extend([i] * freq)
    
    return sorted_arr",70
17682708251,find_odd,"def find_odd(integers):
    integer_counts = {}
    for integer in integers:
        if integer in integer_counts:
            integer_counts[integer] += 1
        else:
            integer_counts[integer] = 1
    
    for integer, count in integer_counts.items():
        if count % 2 == 1:
            return integer",70
73980170450,first_non_repeating_char,"def first_non_repeating_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",70
9372723414,duplicates,"def duplicates(arr):
    a = []
    for i in range(len(arr)):
        if arr.count(arr[i]) >1:
            a.append(arr[i])
    if len(a) >0:
        b=set(a)
        b=list(b)
        b.sort()
        return b
    else:
        a.append(-1)
        return a",70
13115513242,find_two_largest,"def find_two_largest(numbers):
    numbers_set = set(numbers)
    if len(numbers_set) < 2:
        raise ValueError(""At least two distinct numbers are required."")
    highest = max(numbers_set)
    numbers_set.remove(highest)
    second_highest = max(numbers_set)
    return tuple(sorted([highest, second_highest]))",70
3728001370,combine_first_last,"def combine_first_last(sentence_list):
    combined_words = []
    for sentence in sentence_list:
        words = sentence.split()
        if len(words) > 1:
            combined_word = words[0] + words[-1]
            combined_words.append(combined_word)
        else:
            combined_words.append(words[0])
    return combined_words",70
36260130655,stock_profit,"def stock_profit(prices):
    if not prices:
        return 0
    min_price = prices[0]
    max_profit = 0
    for price in prices:
        if price < min_price:
            min_price = price
        else:
            max_profit = max(max_profit, price - min_price)
    return max_profit",70
74222785768,largest_non_adjacent,"def largest_non_adjacent(nums):
    if not nums:
        return 0
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return max(incl, excl)",70
32240330327,fibo,"def fibo(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b",70
5688329915,length_of_LIS,"from bisect import bisect_left

def length_of_LIS(nums):
    sub = []
    for num in nums:
        if len(sub) == 0 or num > sub[-1]:
            sub.append(num)
        else:
            idx = bisect_left(sub, num)
            sub[idx] = num
    return len(sub)",70
17771299685,transpose_matrix,"def transpose_matrix(matrix):
    """"""
    :type matrix: List[List[int]]
    :rtype: List[List[int]]
    """"""
    transposed = []
    for i in range(len(matrix[0])):
        new_row = []
        for row in matrix:
            new_row.append(row[i])
        transposed.append(new_row)
    return transposed",70
37281531648,lucas,"def lucas(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        a, b = 2, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b",70
30349903347,first_non_repeated_character,"def first_non_repeated_character(string):
    char_count = {}
    for char in string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in string:
        if char_count[char] == 1:
            return char
    return None",70
15951618361,count_pairs,"def count_pairs(arr, k):
    seen = {}
    count = 0
    for num in arr:
        target = k - num
        if target in seen:
            count += seen[target]
        if num in seen:
            seen[num] += 1
        else:
            seen[num] = 1
    return count",70
39756492371,unique_paths,"def unique_paths(m, n):
    dp = [[1]*n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",70
18616432739,min_operations_to_one,"def min_operations_to_one(n):
    if n == 1:
        return 0
    if n % 2 == 0:
        return 1 + min_operations_to_one(n // 2)
    else:
        return 1 + min(min_operations_to_one(n + 1), min_operations_to_one(n - 1))",70
73087829185,count_ways,"def count_ways(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    elif n == 3:
        return 4
    else:
        return count_ways(n-1) + count_ways(n-2) + count_ways(n-3)",70
34534964549,first_non_repeating_char,"def first_non_repeating_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",70
40747495279,decimal_to_binary,"def decimal_to_binary(decimal):
    if decimal == 0:
        return ""0""
    elif decimal < 0:
        return ""-"" + decimal_to_binary(-decimal)
    
    binary = """"
    while decimal > 0:
        binary = str(decimal % 2) + binary
        decimal = decimal // 2

    return binary",70
28809692656,mode,"def mode(nums):
    counts = {}
    for num in nums:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1
    max_count = max(counts.values())
    modes = [k for k, v in counts.items() if v == max_count]
    return modes",70
12538296348,pascals_triangle,"def pascals_triangle(n):
    triangle = []
    for i in range(n):
        row = [1] * (i+1)
        for j in range(1, i):
            row[j] = triangle[i-1][j-1] + triangle[i-1][j]
        triangle.append(row)
    return triangle",70
7734058771,is_valid_ipv4_address,"def is_valid_ipv4_address(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        num = int(part)
        if num < 0 or num > 255:
            return False
    return True",70
74992082039,max_stock_profit,"def max_stock_profit(prices):
    if not prices:
        return 0

    min_price = prices[0]
    max_profit = 0

    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)

    return max_profit",70
21556778450,frog_jump,"def frog_jump(X, Y, D):
    # write your code in Python 3.6
    d, m = divmod(Y-X, D)
    if d == 0 and m == 0:
        return 0
    elif m == 0:
        return d
    else:
        return d + 1",70
42101926330,maxAdjacentProduct,"def maxAdjacentProduct(inputArray):
    max_product = inputArray[0] * inputArray[1]
    for i in range(1, len(inputArray) - 1):
        product = inputArray[i] * inputArray[i + 1]
        if product > max_product:
            max_product = product
    return max_product",70
14838654452,find_consecutive_sums,"def find_consecutive_sums(n):
    count = 0
    for i in range(1, n):
        total = 0
        while total < n:
            total += i
            i += 1
        if total == n:
            count += 1
    return count + 1 # include the number itself",70
44811312014,cal_binary_ones_sum,"def cal_binary_ones_sum(n):
    dp = [0] * (n + 1)
    offset = 1
    for i in range(1, n + 1):
        if offset * 2 == i:
            offset = i
        dp[i] = 1 + dp[i - offset]
    return dp",70
70928292986,longest_increasing_subseq,"def longest_increasing_subseq(nums):
    if not nums:
        return 0
    dp = [1]*len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j]+1)
    return max(dp)",70
38987977842,count_distinct_prime_factors,"def count_distinct_prime_factors(n):
    i = 2
    factors = set()
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.add(i)
    if n > 1:
        factors.add(n)
    return len(factors)",70
10452743434,average_except_extremes,"def average_except_extremes(lst):
    mx = max(lst)
    mn = min(lst)
    curr = 0
    cnt = 0
    for i in lst:
        if i == mx or i == mn:
            continue
        else:
            curr += i
            cnt += 1
    return curr/cnt",70
9456486032,sum_of_divisors,"def sum_of_divisors(n):
    sum_div = 1 + n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            sum_div += i
            if i != n // i:
                sum_div += n // i
    return sum_div",70
7112850590,first_non_repeating_character,"def first_non_repeating_character(string):
    char_count = {}
    for char in string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in string:
        if char_count[char] == 1:
            return char
    return None",70
33273262536,uniquePaths,"def uniquePaths(m, n):
    dp = [[1]*n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",70
9360738890,second_highest,"def second_highest(nums):
    max_num = second_max_num = float('-inf')
    for num in nums:
        if num > max_num:
            second_max_num = max_num
            max_num = num
        elif num > second_max_num and num != max_num:
            second_max_num = num
    return second_max_num",70
22505938254,carPooling,"def carPooling(trips, capacity):
    lst = []
    for n, start, end in trips:
        lst.append((start, n))
        lst.append((end, -n))
    lst.sort()
    for loc in lst:
        capacity -= loc[1]
        if capacity < 0:
            return False
    return True",70
14622940517,count_bst,"def count_bst(n):
    if n == 0 or n == 1:
        return 1
    count = 0
    for i in range(1, n+1):
        left = count_bst(i-1)
        right = count_bst(n-i)
        count += left*right
    return count",70
4689415857,max_divide_conquer,"def max_divide_conquer(arr):
    if len(arr) == 1:
        return arr[0]
    else:
        mid = len(arr) // 2
        left_max = max_divide_conquer(arr[:mid])
        right_max = max_divide_conquer(arr[mid:])
        return max(left_max, right_max)",70
20435977275,encode_string,"def encode_string(s):
    result = ''
    for char in s:
        if char.isalpha():
            start = ord('a') if char.islower() else ord('A')
            result += chr((ord(char) - start + 3) % 26 + start)
        else:
            result += char
    return result",70
31083212234,adjacentMaxProduct,"def adjacentMaxProduct(inputList):
    max_product = inputList[0] * inputList[1]
    for i in range(1, len(inputList) - 1):
        product = inputList[i] * inputList[i + 1]
        if product > max_product:
            max_product = product
    return max_product",70
13980396261,first_non_repeating_character,"def first_non_repeating_character(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",70
14636956006,first_non_repeated_char,"def first_non_repeated_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",70
5573059535,first_non_repeating_char,"def first_non_repeating_char(string):
    char_count = {}
    for char in string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in string:
        if char_count[char] == 1:
            return char
    return None",70
71297595959,count_set_bits,"def count_set_bits(n: int):
    dp = [0] * (n + 1)
    offset = 1

    for i in range(1, n + 1):
        if offset * 2 == i:
            offset = i
        dp[i] = 1 + dp[i - offset]

    return dp",70
8238625434,lucas,"def lucas(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        a, b = 2, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b",70
71779516681,can_reach_end,"def can_reach_end(nums):
    size = len(nums)
    end = 0
    for i in range(size):
        if i > end:
            return False
        end_tmp = i + nums[i]
        end = end_tmp if end_tmp > end else end
        if end >= size - 1:
            return True",70
12283908078,largest_sum_after_k_negations,"from typing import List
import heapq


def largest_sum_after_k_negations(A: List[int], K: int) -> int:
    heapq.heapify(A)
    for _k in range(0, K):
        el = heapq.heappop(A)
        heapq.heappush(A, el * -1)
    return sum(A)",70
20374208117,max_abs_difference,"def max_abs_difference(arr): 
    max_diff = abs(arr[0] - arr[1])
    for i in range(len(arr)):
        for j in range(i+1,len(arr)):
            if abs(arr[i] - arr[j]) > max_diff:
                max_diff = abs(arr[i] - arr[j])
    return max_diff",70
24491382884,unique_paths,"def unique_paths(m, n):
    dp = [[1]*n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]",70
2270170483,max_Profit,"def max_Profit(prices):
    if not prices:
        return 0

    min_price = float('inf')
    max_profit = 0

    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)

    return max_profit",70
12283405048,canAttendMeetings,"from typing import List

def canAttendMeetings(intervals: List[List[int]]) -> bool:
    """"""
    O(n * log(n))
    """"""
    intervals.sort()
    for i in range(1, len(intervals)):
        if intervals[i - 1][1] > intervals[i][0]:
            return False
    return True",70
74478369471,is_armstrong,"def is_armstrong(num):
    order = len(str(num))
    sum = 0
    temp = num
    while temp > 0:
        digit = temp % 10
        sum += digit ** order
        temp //= 10
    if num == sum:
        return True
    else:
        return False",70
11524821306,get_max_profit,"def get_max_profit(prices):
    if not prices:
        return 0

    min_price = prices[0]
    max_profit = 0

    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)

    return max_profit",70
28002920197,max_Profit,"def max_Profit(prices):
    if not prices:
        return 0
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)
    return max_profit",70
70474761949,subarray_Largest_Sum,"def subarray_Largest_Sum(nums):
    if not nums:
        return 0

    cur_sum = max_sum = nums[0]
    for i in range(1, len(nums)):
        cur_sum = max(nums[i], cur_sum + nums[i])
        max_sum = max(max_sum, cur_sum)

    return max_sum",70
27270082885,count_formable_strings,"from collections import Counter

def count_formable_strings(words, chars):
    chars_count = Counter(chars)
    total_length = 0
    for word in words:
        word_count = Counter(word)
        if all(word_count[char] <= chars_count[char] for char in word_count):
            total_length += len(word)
    return total_length",70
41033215431,find_max_difference,"def find_max_difference(nums):
    if not nums:
        return 0

    min_val = nums[0]
    max_diff = 0

    for num in nums:
        if num < min_val:
            min_val = num
        else:
            max_diff = max(max_diff, num - min_val)

    return max_diff",70
43600626641,count_a_in_repeated_string,"def count_a_in_repeated_string(s: str, n: int) -> int:
    single_count = s.count('a')
    full_repeats = n // len(s)
    full_count = single_count * full_repeats
    remainder_count = s[:n % len(s)].count('a')
    return full_count + remainder_count",70
8617448257,first_non_repeating_char,"def first_non_repeating_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",70
26499022577,longest_increasing_subseq,"def longest_increasing_subseq(nums):
    n = len(nums)
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",70
17084446566,count_similar_rectangles,"from collections import defaultdict

def count_similar_rectangles(rectangles):
    l = defaultdict(int)
    ans = 0
    for i in rectangles:
        l[i[1]/i[0]] += 1
    for i in l.values():
        ans += (i - 1) * i//2
    return ans",70
37591760841,max_stock_profit,"def max_stock_profit(prices):
    if not prices:
        return 0
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)
    return max_profit",70
2291128909,find_length_of_lis,"def find_length_of_lis(nums):
    if not nums:
        return 0
    dp = [1]*len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j]+1)
    return max(dp)",70
17632773280,searchRange,"def searchRange(nums, target):
    if target not in nums:
        return [-1,-1]
    else:
        a = nums.index(target)
        b=-1
        for i in range(len(nums)-1,-1,-1):
            if nums[i]==target:
                b=i
                break
    return [a,b]",70
2290472549,first_non_repeating_character,"def first_non_repeating_character(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return """"",70
70399015469,find_max_difference,"def find_max_difference(arr):
    if not arr:
        return 0
    min_val = arr[0]
    max_diff = 0
    for num in arr:
        if num < min_val:
            min_val = num
        else:
            max_diff = max(max_diff, num - min_val)
    return max_diff",70
18139028748,max_Sum_Non_Adjacent,"def max_Sum_Non_Adjacent(nums): 
    incl = 0
    excl = 0
  
    for i in nums: 
        new_excl = excl if excl>incl else incl 
  
        incl = excl + i 
        excl = new_excl 
  
    return (excl if excl>incl else incl)",70
23247838336,find_first_non_repeating,"def find_first_non_repeating(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return """"",70
27703422888,is_subsequence,"def is_subsequence(s, t):
    s_index = 0
    t_index = 0

    while s_index < len(s) and t_index < len(t):
        if s[s_index] == t[t_index]:
            s_index += 1
        t_index += 1

    return s_index == len(s)",70
786501958,lucas_number,"def lucas_number(N):
    start = [2, 1]
    if N <= 1:
        return start[N]
    N = N-2
    while N >= 0:
        start.append(start[0]+start[1])
        start.pop(0)
        N -= 1
    return start[-1]",70
34113096550,find_max_profit,"def find_max_profit(prices):
    if not prices:
        return 0

    min_price = prices[0]
    max_profit = 0

    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)

    return max_profit",70
27856600954,first_non_repeated_char,"def first_non_repeated_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return None",70
30231088399,partition_ways,"def partition_ways(n, k):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, k + 1):
        for j in range(i, n + 1):
            dp[j] += dp[j - i]
    return dp[n]",70
18120111633,fib_sequence,"def fib_sequence(n):
    fib_list = [0, 1]
    if n == 0:
        return []
    elif n == 1:
        return [0]
    else:
        for i in range(2, n):
            fib_list.append(fib_list[-1] + fib_list[-2])
        return fib_list",70
40641246190,min_adj_diff,"def min_adj_diff(test_list):
  test_list.sort()
  result = test_list[1] - test_list[0]
  for i in range(1,len(test_list)):
    if test_list[i] - test_list[i-1] < result:
      result = test_list[i] - test_list[i-1]
  return result",70
7677155036,find_target_pairs,"def find_target_pairs(nums: list[int], target: int) -> int:
    seen = set()
    pairs = set()
    for num in nums:
        complement = target - num
        if complement in seen:
            pairs.add((min(num, complement), max(num, complement)))
        seen.add(num)
    return len(pairs)",70
35081802661,find_first_non_repeating,"def find_first_non_repeating(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return """"",70
35732244869,check_armstrong,"def check_armstrong(num):
    order = len(str(num))
    sum = 0
    temp = num
    while temp > 0:
        digit = temp % 10
        sum += digit ** order
        temp //= 10
    if num == sum:
        return True
    else:
        return False",70
26379897183,first_non_repeated_char,"def first_non_repeated_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return '_'",70
9625716527,primes,"def primes(numbers):
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return [number for number in numbers if is_prime(number)]",70
44070176861,sum_of_digits,"def sum_of_digits(number):
    if number < 0:
        number = abs(number)
    return sum(int(digit) for digit in str(number))

assert sum_of_digits(123) == 6
assert sum_of_digits(-456) == 15
assert sum_of_digits(0) == 0",69
25991621332,find_prime_numbers,"def find_prime_numbers(start, end):
  prime_numbers = []
  for num in range(start, end + 1):
    if num > 1:
      for i in range(2, num):
        if (num % i) == 0:
          break
      else:
        prime_numbers.append(num)
  return prime_numbers",69
31042374200,find_largest_sum,"def find_largest_sum(arr):
    max_so_far = arr[0]
    curr_max = arr[0]
 
    for i in range(1, len(arr)):
        curr_max = max(arr[i], curr_max + arr[i])
        max_so_far = max(max_so_far, curr_max)
 
    return max_so_far",69
26380147353,is_hex_color,"def is_hex_color(code):
    if len(code) != 7 or code[0] != '#':
        return False
    hex_chars = set('0123456789ABCDEFabcdef')
    for char in code[1:]:
        if char not in hex_chars:
            return False
    return True",69
3826356249,find_next_greater,"def find_next_greater(arr):
    n = len(arr)
    res = [0] * n
    stack = []
    for i in range(n):
        while stack and arr[i] > arr[stack[-1]]:
            small = stack.pop()
            res[small] = arr[i]
        stack.append(i)
    return res",69
15589638348,majority_element,"def majority_element(arr):
    count = 0
    result = 0
    for i in range(len(arr)):
        if count == 0:
            result = arr[i]
            count = 1
        elif result == arr[i]:
            count += 1
        else:
            count -= 1
    return result",69
19011315312,find_first_non_repeating,"def find_first_non_repeating(input_string):
    char_count = {}
    for char in input_string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in input_string:
        if char_count[char] == 1:
            return char",69
41202646495,min_flips,"def min_flips(s):
    zero , one = s.count(""0""), 0
    output = zero
    for d in s:
        if d=='0':
            zero -= 1
        if d == '1':
            one += 1
        output = min (output, zero+one)
    return output",69
14334880360,length_of_LIS,"def length_of_LIS(nums):
    if not nums:
        return 0
    dp = [1]*len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j]+1)
    return max(dp)",69
37261937208,find_median,"def find_median(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length // 2] + nums[length // 2 - 1]) / 2
    else:
        return nums[length // 2]",69
28230194726,num_of_ways,"def num_of_ways(n):
    count = 0
    for i in range(1, n):
        sum = 0
        while sum < n:
            sum += i
            i += 1
        if sum == n:
            count += 1
    return count + 1 # including the number itself",69
23840546531,permute,"def permute(s):
    if len(s) == 1:
        return [s]
    result = []
    for i in range(len(s)):
        char = s[i]
        remaining = s[:i] + s[i+1:]
        for perm in permute(remaining):
            result.append(char + perm)
    return result",69
34054287221,fibonacci,"def fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        a, b = 0, 1
        for i in range(2, n + 1):
            a, b = b, a + b
        return b",69
14150221356,minimumSwaps,"def minimumSwaps(arr):
    n = len(arr)
    answer = 0

    for i in range(n):
        while arr[i] != i + 1:
            temp = arr[i]
            arr[i], arr[temp-1] = arr[temp-1], arr[i]
            answer += 1

    return answer",69
41694018736,minMovesPalindrome,"def minMovesPalindrome(s: str) -> int:
    moves = 0
    left = 0
    right = len(s) - 1
    while left < right:
        if s[left] != s[right]:
            moves += 1
        left += 1
        right -= 1
    return moves",69
1405914387,max_Profit,"def max_Profit(prices):
    if not prices:
        return 0

    min_Price = float('inf')
    max_Profit = 0

    for price in prices:
        min_Price = min(min_Price, price)
        max_Profit = max(max_Profit, price - min_Price)

    return max_Profit",69
37591970661,int_to_binary,"def int_to_binary(n):
    """"""
    :type n: int
    :rtype: str
    """"""
    if n == 0:
        return ""0""
    binary = """"
    while n > 0:
        binary = str(n % 2) + binary
        n = n // 2
    return binary",69
73609098440,find_min_max,"def find_min_max(arr):
    if not arr:
        return None
    min_val = max_val = arr[0]
    for num in arr[1:]:
        if num < min_val:
            min_val = num
        elif num > max_val:
            max_val = num
    return (min_val, max_val)",69
43212580728,can_jump,"def can_jump(nums):
    target = len(nums) - 1
    max_reach = 0
    for i in range(len(nums)):
        if i <= max_reach:
            max_reach = max(max_reach, i + nums[i])
        if max_reach >= target:
            return True
    return False",69
15401502005,reverse_concat,"def reverse_concat(str1, str2):
    return str2[::-1] + str1[::-1]

assert reverse_concat(""abc"", ""def"") == ""fedcba""
assert reverse_concat(""hello"", ""world"") == ""dlrowolleh""
assert reverse_concat(""python"", ""java"") == ""avajnohtyp""",69
70027560090,find_smallest_divisible,"from math import gcd

def lcm(a, b):
    return a * b // gcd(a, b)

def find_smallest_divisible(n):
    smallest_divisible = 1
    for i in range(1, n + 1):
        smallest_divisible = lcm(smallest_divisible, i)
    return smallest_divisible",69
15520818559,score_parentheses,"def score_parentheses(S):
    stack = []
    current_score = 0

    for c in S:
        if c == '(':
            stack.append(current_score)
            current_score = 0
        else:
            current_score = stack.pop() + max(2*current_score, 1)
    
    return current_score",69
35025043695,max_operations,"from collections import defaultdict

def max_operations(nums, k):
    operations, d = 0, defaultdict(int)
    for v in nums:
        res = k - v
        if d[res]:
            operations += 1
            d[res] -= 1
        else:
            d[v] += 1
    return operations",69
73651248117,isValidIPv4,"def isValidIPv4(ip):
    parts = ip.split(""."")
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        num = int(part)
        if num < 0 or num > 255:
            return False
    return True",69
4314676519,check_anagrams,"def check_anagrams(str1, str2):
    # Remove any spaces and convert strings to lowercase
    str1 = str1.replace("" "", """").lower()
    str2 = str2.replace("" "", """").lower()

    # Check if the sorted characters of both strings are equal
    return sorted(str1) == sorted(str2)",69
21288385477,can_make_arithmetic_progression,"def can_make_arithmetic_progression(A):
    if len(A) == 2: return True
    A.sort()
    for i in range(1, len(A) - 1):
        if A[i + 1] - A[i] != A[i] - A[i - 1]: return False
    return True",69
71598260837,max_binary_ones,"def max_binary_ones(nums):
    max_ones = 0
    max_num = 0
    for num in nums:
        binary = bin(num)[2:]
        ones = binary.count('1')
        if ones > max_ones:
            max_ones = ones
            max_num = num
    return max_num",69
40988368132,find_next_greater,"def find_next_greater(arr):
    n = len(arr)
    result = [-1] * n
    stack = []

    for i in range(n):
        while stack and arr[i] > arr[stack[-1]]:
            result[stack[-1]] = arr[i]
            stack.pop()
        stack.append(i)

    return result",69
25875364369,is_harshad,"def is_harshad(num):
    # Calculate the sum of digits
    sum_of_digits = sum(int(digit) for digit in str(num))
    
    # Check if the number is divisible by the sum of its digits
    if num % sum_of_digits == 0:
        return True
    else:
        return False",69
7604034264,first_non_repeating,"def first_non_repeating(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return """"",69
70027526170,unique_chars,"def unique_chars(string):
    unique = 0
    for i in range(len(string)):
        unique_flag = True
        for j in range(i+1, len(string)):
            if string[i] == string[j]:
                unique_flag = False
                break
        if unique_flag:
            unique += 1
    return unique",69
71924654006,find_prime_numbers,"def find_prime_numbers(start, end):
    prime_numbers = []
    for num in range(start, end + 1):
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                prime_numbers.append(num)
    return prime_numbers",69
23385165674,max_nested_parentheses,"def max_nested_parentheses(s):
    max_depth = 0
    current_depth = 0
    for char in s:
        if char == '(':
            current_depth += 1
            max_depth = max(max_depth, current_depth)
        elif char == ')':
            current_depth -= 1
    return max_depth",69
41579697733,find_target_positions,"def find_target_positions(nums, target):
    positions = [-1, -1]
    try:
        first_pos = nums.index(target)
        positions[0] = first_pos
        positions[1] = len(nums) - nums[::-1].index(target) - 1
    except ValueError:
        return positions
    return positions",69
74430945105,two_sum,"from typing import List

def two_sum(nums: List[int], target: int) -> List[int]:
    dic = {}
    for i in range(0, len(nums)):
        if dic.get(nums[i]) is not None:
            return [dic[nums[i]], i]
        else:
            dic[target - nums[i]] = i",69
24089045749,byte_string_to_text,"def byte_string_to_text(byte_string):
    return byte_string.decode('utf-8')

assert byte_string_to_text(b'Hello World') == 'Hello World'
assert byte_string_to_text(b'\xc3\xa9') == 'é'
assert byte_string_to_text(b'\xe2\x98\x83') == '☃'",69
41440547692,primeChecker,"def is_prime(n):
    if n == 1 or n == 0:
        return False
    for i in range(2, n):
        if n % i == 0:
            return False
    return True

def primeChecker(int_list):
    return [(i, is_prime(i)) for i in int_list]",69
18513880882,sum_of_primes,"def sum_of_primes(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return sum(filter(is_prime, numbers))",69
40968919573,first_non_repeating,"def first_non_repeating(s):
    char_count = {}
    for ch in s:
        if ch in char_count:
            char_count[ch] += 1
        else:
            char_count[ch] = 1
    for ch in s:
        if char_count[ch] == 1:
            return ch
    return None",69
5970451218,is_arithmetic_progression,"def is_arithmetic_progression(arr):
    if len(arr) < 2:
        return False
    arr.sort()
    diff = arr[1] - arr[0]
    for i in range(2, len(arr)):
        if arr[i] - arr[i-1] != diff:
            return False
    return True",69
33496637446,most_common_letter,"def most_common_letter(s):
    s = s.lower()
    letters = [0]*26
    for char in s:
        if char.isalpha():
            letters[ord(char)-ord('a')] += 1
    max_count = max(letters)
    return chr(letters.index(max_count) + ord('a'))",69
4776622710,largest_non_adjacent_sum,"def largest_non_adjacent_sum(nums):
    if not nums:
        return 0

    incl = 0
    excl = 0

    for i in nums:
        new_excl = max(incl, excl)
        incl = excl + i
        excl = new_excl

    return max(incl, excl)",69
21744513802,most_frequent_character,"def most_frequent_character(s):
    freq = {}
    for char in s:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1
    max_freq = max(freq.values())
    for char, freq in freq.items():
        if freq == max_freq:
            return char",69
44501029499,generate_permutations,"def generate_permutations(elements):
    if len(elements) <=1:
        return [elements]
    else:
        permutations = []
        for i in range(len(elements)):
            rest = elements[:i] + elements[i+1:]
            for p in generate_permutations(rest):
                permutations.append([elements[i]] + p)
        return permutations",69
70015651967,find_distance_value,"def find_distance_value(arr1, arr2, d):
    def check(number,arr,d):
        for i in arr:
            if abs(number-i)<=d:
                return False
        return True
    count=0
    for i in arr1:
        if check(i,arr2,d):
            count+=1
    return count",69
8673239321,sum_two_smallest_numbers,"from typing import List

def sum_two_smallest_numbers(numbers: List[int]) -> int:
    positive_numbers = [n for n in numbers if n > 0]
    if len(positive_numbers) < 2:
        return -1
    positive_numbers.sort()
    return positive_numbers[0] + positive_numbers[1]",69
4207100090,is_rotation_palindrome,"def is_palindrome(s):
    return s == s[::-1]

def is_rotation_palindrome(s):
    if is_palindrome(s):
        return True

    for i in range(1, len(s)):
        rotated = s[i:] + s[:i]
        if is_palindrome(rotated):
            return True

    return False",69
72627011008,prime_count,"def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def prime_count(lst):
    return sum(is_prime(i) for i in lst)",69
22647517944,num_ways_to_climb,"def num_ways_to_climb(n, m):
    memo = [0] * (n + 1)
    memo[0] = 1
    for i in range(1, n + 1):
        memo[i] = sum(memo[max(0, i - m):i])
    return memo[n]",69
33211285130,top_k_frequent_words,"from collections import Counter

def top_k_frequent_words(words, k):
    freq_table = Counter(words)
    ans_table = freq_table.most_common()
    ans = []
    for key, _ in ans_table:
        if k <= 0:
            break
        k -= 1
        ans.append(key)
    return ans",69
5570254368,kadane_algorithm,"def kadane_algorithm(arr):
    max_so_far = max_ending_here = arr[0]
    for i in range(1, len(arr)):
        max_ending_here = max(arr[i], max_ending_here + arr[i])
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far",69
6809905728,find_first_unique_char,"def find_first_unique_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return """"",69
30845775281,find_prime_factors,"def find_prime_factors(n):
    factors = []
    for i in range(2, int(n ** 0.5) + 1):
        while n % i == 0:
            factors.append(str(i))
            n //= i
    if n != 1:
        factors.append(str(n))
    return sorted(factors)",69
23588730107,length_of_LIS,"def length_of_LIS(nums):
    if not nums:
        return 0
    dp = [1]*len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j]+1)
    return max(dp)",69
74352624637,unique_emails,"def unique_emails(emails):
    unique_emails_set = set()
    for email in emails:
        local, domain = email.split('@')
        if '+' in local:
            local = local[:local.index('+')]
        local = local.replace('.', '')
        unique_emails_set.add(local + '@' + domain)
    return len(unique_emails_set)",69
39458187850,remove_duplicates,"def remove_duplicates(nums):
    if len(nums) <= 2:
        return len(nums)
    slow = 2
    for fast in range(2, len(nums)):
        if nums[fast] != nums[slow - 2]:
            nums[slow] = nums[fast]
            slow += 1
    return slow",69
2001266400,primes,"def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def primes(numbers):
    return [n for n in numbers if is_prime(n)]",69
785509348,find_substring_occurrences,"def find_substring_occurrences(string, substring):
    count = 0
    start = 0
    while start < len(string):
        pos = string.find(substring, start)
        if pos != -1:
            count += 1
            start = pos + 1
        else:
            break
    return count",69
16233244329,fibonacci,"def fibonacci(n):
    if n <= 1:
        return n
    fib = [0] * (n+1)
    fib[1] = 1
    for i in range(2, n+1):
        fib[i] = fib[i-1] + fib[i-2]
    return fib[n]",69
10896638796,find_max_min,"def find_max_min(numbers):
    if not numbers:
        return None, None
    max_num = min_num = numbers[0]
    for num in numbers[1:]:
        if num > max_num:
            max_num = num
        elif num < min_num:
            min_num = num
    return max_num, min_num",69
15774711291,find_substring_occurrences,"def find_substring_occurrences(string, substring):
    count = 0
    start = 0
    while start < len(string):
        pos = string.find(substring, start)
        if pos != -1:
            start = pos + 1
            count += 1
        else:
            break
    return count",69
72464880948,longest_consecutive_ones,"def longest_consecutive_ones(binary_list):
    max_count = 0
    current_count = 0
    for num in binary_list:
        if num == 1:
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count",69
23031855807,find_substring_occurrences,"def find_substring_occurrences(string, substring):
    count = 0
    start = 0
    while start < len(string):
        pos = string.find(substring, start)
        if pos != -1:
            count += 1
            start = pos + 1
        else:
            break
    return count",69
38614372936,valid_parentheses,"def valid_parentheses(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]
    return dp[n]",69
26836244063,capitalize_words,"def capitalize_words(s):
    answer = ''
    answer += s[0].upper()
    for i in range(1, len(s)):
        if s[i-1] == "" "" and s[i] != "" "":
            answer += s[i].upper()
        else:
            answer += s[i].lower()
    return answer",69
28711040941,find_prime_numbers,"def find_prime_numbers(start, end):
    prime_numbers = []
    for num in range(start, end + 1):
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                prime_numbers.append(num)
    return prime_numbers",69
70726281597,length_of_LIS,"def length_of_LIS(nums):
    if not nums:
        return 0
    dp = [1]*len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j]+1)
    return max(dp)",69
1433666566,max_consecutive_sum,"def max_consecutive_sum(s):
    max_sum = 0
    current_sum = 0
    for i in range(len(s)):
        current_sum = 0
        for j in range(i, len(s)):
            current_sum += int(s[j])
            max_sum = max(max_sum, current_sum)
    return max_sum",69
23862375124,max_nested_parentheses,"def max_nested_parentheses(s):
    max_depth = 0
    current_depth = 0

    for char in s:
        if char == '(':
            current_depth += 1
            max_depth = max(max_depth, current_depth)
        elif char == ')':
            current_depth -= 1

    return max_depth",69
16562966513,find_smallest_divisible,"from math import gcd

def lcm(a, b):
    return a * b // gcd(a, b)

def find_smallest_divisible(n):
    smallest_divisible = 1
    for i in range(1, n + 1):
        smallest_divisible = lcm(smallest_divisible, i)
    return smallest_divisible",69
11795511807,find_most_frequent_char,"def find_most_frequent_char(s):
    char_frequency = {}
    for char in s:
        if char in char_frequency:
            char_frequency[char] += 1
        else:
            char_frequency[char] = 1
    most_frequent_char = max(char_frequency, key=char_frequency.get)
    return most_frequent_char",69
30074530809,max_nested_parentheses,"def max_nested_parentheses(s):
    max_depth = 0
    current_depth = 0
    for char in s:
        if char == '(':
            current_depth += 1
            max_depth = max(max_depth, current_depth)
        elif char == ')':
            current_depth -= 1
    return max_depth",69
69901940795,smallest_positive,"def smallest_positive(A):
    target = 1
    A = myfunc(list(set(A)))

    for i in A:
        if target != i:
            break
        target += 1

    return target

def myfunc(mylist1):
    return sorted([x for x in mylist1 if x > 0])",69
25912637182,decToBin,"def decToBin(num):
    """"""
    :type num: int
    :rtype: str
    """"""
    if num == 0:
        return '0'
    binary = ''
    while num > 0:
        binary = str(num % 2) + binary
        num = num // 2
    return binary",69
3754889879,find_largest_digit,"def find_largest_digit(n):
    if n < 0:
        n = -n
    largest_digit = 0
    while n > 0:
        digit = n % 10
        if digit > largest_digit:
            largest_digit = digit
        n = n // 10
    return largest_digit",69
44152260156,check_rotation,"def check_rotation(nums):
    if len(nums) == 1:
        return True

    s_nums = sorted(nums)
    if s_nums == nums:
        return True

    for i in range(len(nums)):
        new = nums[i:] + nums[:i]
        if new == s_nums:
            return True
    return False",69
27382853424,check_anagram,"def check_anagram(str1, str2):
    # Remove spaces and convert both strings to lowercase
    str1 = str1.replace("" "", """").lower()
    str2 = str2.replace("" "", """").lower()

    # Check if the sorted versions of the strings are equal
    return sorted(str1) == sorted(str2)",69
16688067476,find_Largest_Subarray_Sum,"def find_Largest_Subarray_Sum(arr):
    max_so_far = arr[0]
    curr_max = arr[0]

    for i in range(1,len(arr)):
        curr_max = max(arr[i], curr_max + arr[i])
        max_so_far = max(max_so_far, curr_max)

    return max_so_far",69
9253649791,max_nested_parentheses,"def max_nested_parentheses(s):
    max_depth = 0
    current_depth = 0
    for char in s:
        if char == '(':
            current_depth += 1
            max_depth = max(max_depth, current_depth)
        elif char == ')':
            current_depth -= 1
    return max_depth",69
17232512526,largest_non_adjacent_sum,"def largest_non_adjacent_sum(nums):
    if not nums:
        return 0
    incl = 0
    excl = 0
    for num in nums:
        new_excl = max(incl, excl)
        incl = excl + num
        excl = new_excl
    return max(incl, excl)",69
40251002475,next_greater_element,"def next_greater_element(arr):
    stack = []
    result = [-1] * len(arr)
    for i in range(len(arr)):
        while len(stack) > 0 and arr[i] > arr[stack[-1]]:
            index = stack.pop()
            result[index] = arr[i]
        stack.append(i)
    return result",69
4217883157,first_non_repeating,"def first_non_repeating(string):
    char_count = {}
    for char in string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in string:
        if char_count[char] == 1:
            return char
    return None",69
24227520850,min_operations,"def min_operations(X, Y):
    operations = 0
    while X != Y:
        if X > Y:
            X -= 1
        elif X < Y and Y % 2 == 0:
            Y //= 2
        else:
            Y += 1
        operations += 1
    return operations",69
32025394558,most_frequent_character,"def most_frequent_character(s):
    freq = {}
    for char in s:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1
    max_freq = max(freq.values())
    for char, count in freq.items():
        if count == max_freq:
            return char",69
3779393151,odd_occurrence,"def odd_occurrence(arr):
    num_counts = {}
    for num in arr:
        if num in num_counts:
            num_counts[num] += 1
        else:
            num_counts[num] = 1
    for num, count in num_counts.items():
        if count % 2 != 0:
            return num",68
8607328885,distinct_prime_factors,"def distinct_prime_factors(n):
    i = 2
    factors = set()
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.add(i)
    if n > 1:
        factors.add(n)
    return len(factors)",68
34519145527,valid_ipv4,"def valid_ipv4(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        num = int(part)
        if num < 0 or num > 255:
            return False
    return True",68
38940149008,find_Max_Subarray_Sum,"def find_Max_Subarray_Sum(arr): 
    max_current = max_global = arr[0] 
    for i in range(1,len(arr)): 
        max_current = max(arr[i], max_current + arr[i]) 
        if max_current > max_global: 
            max_global = max_current 
    return max_global",68
73812843575,find_MostFrequentChar,"def find_MostFrequentChar(s):
    char_frequency = {}
    for char in s:
        if char in char_frequency:
            char_frequency[char] += 1
        else:
            char_frequency[char] = 1
    max_freq_char = max(char_frequency, key=char_frequency.get)
    return max_freq_char",68
15808991792,count_subsequence,"def count_subsequence(seq, subseq):
    count = 0
    pos = 0
    while pos < len(seq):
        found = seq.find(subseq, pos)
        if found != -1:
            count += 1
            pos = found + 1
        else:
            break
    return count",68
22525770297,climb_stairs,"def climb_stairs(n):
    if n == 1:
        return 1
    if n == 2:
        return 2
    a, b = 1, 2
    for _ in range(3, n + 1):
        a, b = b, a + b
    return b",68
20772980212,validate_url,"import re

def validate_url(url):
    pattern = r""^(http|https)://[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)+(/[a-zA-Z0-9-.]*)?$""
    if re.match(pattern, url):
        return True
    else:
        return False",68
2803218471,maximum_difference,"def maximum_difference(nums):
    output = float('-inf')
    min_val = nums[0]
    for j in range(1, len(nums)):
        output = max(output, nums[j] - min_val)
        min_val = min(min_val, nums[j])
    return output if output != float('-inf') else -1",68
24010447069,are_anagrams,"def are_anagrams(str1, str2):
    if len(str1) != len(str2):
        return False
    str1 = sorted(str1)
    str2 = sorted(str2)
    for i in range(len(str1)):
        if str1[i] != str2[i]:
            return False
    return True",68
71575856825,find_first_non_repeating,"def find_first_non_repeating(str1):
    count = {}
    for c in str1:
        if c in count:
            count[c] += 1
        else:
            count[c] = 1
    for c in str1:
        if count[c] == 1:
            return c
    return None",68
70084947411,smallest_num,"def smallest_num(n):
    if n < 0:
        return None
    if n == 0:
        return 0
    result = """"
    while n > 9:
        result = '9' + result
        n -= 9
    result = str(n) + result
    return int(result)",68
7596619340,lucas_number,"def lucas_number(n):
    if n == 0:
        return 2
    if n == 1:
        return 1
    a, b = 2, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b",68
8357804541,find_min_distance,"def find_min_distance(arr):
    min_distance = float('inf')
    indices = {}

    for idx, val in enumerate(arr):
        if val in indices:
            min_distance = min(min_distance, idx - indices[val])
        indices[val] = idx

    return min_distance if min_distance != float('inf') else -1",68
41010832065,min_abs_diff,"def min_abs_diff(arr):
    arr.sort()
    min_diff = abs(arr[1] - arr[0])
    for i in range(2,len(arr)):
        if abs(arr[i] - arr[i-1]) < min_diff:
            min_diff = abs(arr[i] - arr[i-1])
    return min_diff",68
24790454757,list_to_dict,"def list_to_dict(keys, values):
    result = {}
    for key, value in zip(keys, values):
        if key in result:
            result[key].append(value)
        else:
            result[key] = [value]
    for key in set(keys) - set(result.keys()):
        result[key] = []
    return result",68
74520883645,is_arithmetic_sequence,"def is_arithmetic_sequence(nums):
    if len(nums) < 2:
        return True
    nums.sort()
    dif = nums[1] - nums[0]
    for i in range(2, len(nums)):
        if nums[i] - nums[i-1] != dif:
            return False
    return True",68
9822219259,count_Parentheses,"def count_Parentheses(n):
    if n == 0:
        return 1
    if n == 1:
        return 1
    result = 0
    for i in range(n):
        result += count_Parentheses(i) * count_Parentheses(n - 1 - i)
    return result",68
33830552577,num_valid_parentheses,"def num_valid_parentheses(n):
    dp = [0] * (n+1)
    dp[0] = 1
    for i in range(1, n+1):
        for j in range(i):
            dp[i] += dp[j] * dp[i-j-1]
    return dp[n]",68
15945296167,is_valid_ip,"def is_valid_ip(ip):
    ip = ip.split('.')
    if len(ip) != 4:
        return False
    for i in ip:
        if not i.isdigit():
            return False
        i = int(i)
        if i < 0 or i > 255:
            return False
    return True",68
73330354037,check_overlap,"def check_overlap(meetings):
  # Sort the meetings by start time
  meetings.sort(key=lambda x: x[0])
  # Check for overlap
  for i in range(1, len(meetings)):
    if meetings[i][0] < meetings[i-1][1]:
      return True
  return False",68
10566027039,count_substring,"def count_substring(string, sub_string):
    count = 0
    start = 0
    while start < len(string):
        pos = string.find(sub_string, start)
        if pos != -1:
            count += 1
            start = pos + 1
        else:
            break
    return count",68
27798758659,are_anagrams,"def are_anagrams(str1, str2):
    if len(str1) != len(str2):
        return False
    str1 = sorted(str1)
    str2 = sorted(str2)
    for i in range(len(str1)):
        if str1[i] != str2[i]:
            return False
    return True",68
23235787434,is_anagram,"def is_anagram(str1, str2):
    # Remove spaces and convert strings to lowercase
    str1 = str1.replace("" "", """").lower()
    str2 = str2.replace("" "", """").lower()

    # Check if the sorted characters of both strings are equal
    return sorted(str1) == sorted(str2)",68
33186387679,find_minimum,"def find_minimum(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]",68
31556774116,most_frequent_word,"from collections import Counter
import re

def most_frequent_word(paragraph, banned):
	words = [word for word in re.sub(r""[^\w]"", ' ', paragraph)
			.lower().split()
				if word not in banned]

	counts = Counter(words)
	return counts.most_common(1)[0][0]",68
22003614037,find_kth_largest,"import heapq

def find_kth_largest(nums, k):
    hp=[]
    for el in nums:
        if len(hp)<k or hp[0]<el:
            heapq.heappush(hp,el)
        if len(hp)>k:
            heapq.heappop(hp)
    return hp[0]",68
11853348756,find_max_consecutive_ones,"def find_max_consecutive_ones(nums):
    max_count = 0
    current_count = 0
    for num in nums:
        if num == 1:
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count",68
31900606526,reverse_num,"def reverse_num(num):
    reversed_num = 0
    sign = -1 if num < 0 else 1
    num *= sign

    while num > 0:
        reversed_num = reversed_num * 10 + num % 10
        num //= 10

    return reversed_num * sign",68
71901637874,reverse_pairs,"from bisect import bisect_right, insort

def reverse_pairs(nums):
    arr = []
    res = 0
    for each_num in nums:
        index = bisect_right(arr, each_num * 2)
        res += len(arr) - index
        insort(arr, each_num)
            
    return res",68
29262899179,fibo,"def fibo(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        a, b = 0, 1
        for i in range(2, n+1):
            a, b = b, a+b
        return b",68
18973237187,can_construct,"from collections import Counter

def can_construct(ransomNote: str, magazine: str) -> bool:
    ransomNote_count = Counter(ransomNote)
    magazine_count = Counter(magazine)
    
    for char, count in ransomNote_count.items():
        if magazine_count[char] < count:
            return False
    return True",68
23099784630,maxSubarraySum,"def maxSubarraySum(nums):
    if not nums:
        return 0
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max(max_sum, 0)",68
12190050157,shortest_repeating_pattern,"def shortest_repeating_pattern(str):
    n = len(str)
    for i in range(1, n//2 + 1):
        if n % i == 0:
            pattern = str[:i]
            if pattern * (n//i) == str:
                return (pattern, n//i)
    return None",68
35023685245,nextGreaterElement,"def nextGreaterElement(array):
    n = len(array)
    ans = [-1] * n
    st = []
    for i in range(n):
        while st and array[st[-1]] < array[i]:
            ind = st.pop()
            ans[ind] = array[i]
        st.append(i)
    return ans",68
36287028133,largest_sum,"def largest_sum(arr):
    if not arr:
        return 0
    incl = 0
    excl = 0

    for i in arr:
        new_excl = excl if excl>incl else incl

        incl = excl + i
        excl = new_excl

    return max(incl, excl)",68
36902749125,longest_harmonious_subsequence,"from collections import Counter

def longest_harmonious_subsequence(nums):
    c = Counter(nums)
    res = 0
    for k in c:
        count = c[k]+c[k+1] if c[k+1] else 0
        if count>res:
            res = count
    return res",68
14556901678,smallest_diff,"def smallest_diff(arr):
    arr.sort()
    diff = abs(arr[0] - arr[1])
    for i in range(1, len(arr) - 1):
        curr_diff = abs(arr[i] - arr[i + 1])
        if curr_diff < diff:
            diff = curr_diff
    return diff",68
42899249989,fibonacci_iterative,"def fibonacci_iterative(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b",68
40053115552,maxSubArray,"def maxSubArray(nums):
    if not nums:
        return 0

    current_sum = max_sum = nums[0]
    for i in range(1, len(nums)):
        current_sum = max(nums[i], current_sum + nums[i])
        max_sum = max(max_sum, current_sum)
    
    return max_sum",68
12249146,isAnagram,"def isAnagram(str1, str2):
    # Remove spaces and convert strings to lowercase
    str1 = str1.replace("" "", """").lower()
    str2 = str2.replace("" "", """").lower()

    # Check if the sorted characters of both strings are equal
    return sorted(str1) == sorted(str2)",68
29995962950,top_k_frequent_elements,"def top_k_frequent_elements(nums, k):
    nums_set = set(nums)
    result = []
    ans = []
    for i in nums_set:
        result.append([nums.count(i), i])
    result.sort()
    result.reverse()
    for j in range(k):
        ans.append(result[j][1])
    return ans",68
40713564624,climbStairs,"def climbStairs(n: int) -> int:
    if n <= 2:
        return n
    a, b, c = 1, 2, 4
    for i in range(3, n):
        a, b, c = b, c, a + b + c
    return c",68
2246328051,min_time_to_visit_points,"def min_time_to_visit_points(points):
    t = 0
    for l in range(len(points)):
        if l < len(points) - 1:
            t += max(abs(points[l+1][0] - points[l][0]), abs(points[l+1][1] - points[l][1]))
    return t",68
1057136587,factorial_series_sum,"def factorial_series_sum(n):
    def factorial(num):
        if num == 0 or num == 1:
            return 1
        else:
            return num * factorial(num-1)
    
    total = 0
    for i in range(1, n+1):
        total += factorial(i)
    return total",68
7928021142,remove_start_chars,"def remove_start_chars(s, n):
    """"""
    Remove n characters from the start of the string s.

    :param s: The input string.
    :param n: The number of characters to remove from the start.
    :return: The modified string with n characters removed from the start.
    """"""
    return s[n:]",68
37062767267,is_Anagram,"def is_Anagram(str1, str2):
    if len(str1) != len(str2):
        return False
    str1 = sorted(str1)
    str2 = sorted(str2)
    for i in range(len(str1)):
        if str1[i] != str2[i]:
            return False
    return True",68
25875407409,check_ipv4,"def check_ipv4(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        num = int(part)
        if num < 0 or num > 255:
            return False
    return True",68
365623247,can_jump,"def can_jump(nums):
    max_reach = 0
    for i in range(len(nums)):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + nums[i])
        if max_reach >= len(nums) - 1:
            return True
    return False",68
41489335468,find_max_subarray_sum,"def find_max_subarray_sum(arr):
    max_so_far = arr[0]
    curr_max = arr[0]

    for i in range(1, len(arr)):
        curr_max = max(arr[i], curr_max + arr[i])
        max_so_far = max(max_so_far, curr_max)

    return max_so_far",68
4132643270,check_anagram,"def check_anagram(str1, str2):
    if len(str1) != len(str2):
        return False
    str1 = sorted(str1)
    str2 = sorted(str2)
    for i in range(len(str1)):
        if str1[i] != str2[i]:
            return False
    return True",68
71551161367,find_substring_count,"def find_substring_count(string, substring):
    count = 0
    start = 0
    while start < len(string):
        pos = string.find(substring, start)
        if pos != -1:
            count += 1
            start = pos + 1
        else:
            break
    return count",68
13049162389,first_unique_char,"def first_unique_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in s:
        if char_count[char] == 1:
            return char
    return ""-""",68
40162986680,is_anagram,"def is_anagram(str1, str2):
    if len(str1) != len(str2):
        return False

    str1 = sorted(str1)
    str2 = sorted(str2)

    for i in range(len(str1)):
        if str1[i] != str2[i]:
            return False

    return True",68
30315524734,max_Subarray_Sum,"def max_Subarray_Sum(arr):
    max_so_far = arr[0]
    current_max = arr[0]
    for i in range(1, len(arr)):
        current_max = max(arr[i], current_max + arr[i])
        max_so_far = max(max_so_far, current_max)
    return max_so_far",68
6285286039,find_min_max,"def find_min_max(numbers):
    if not numbers:
        return None
    
    min_num = max_num = numbers[0]
    
    for num in numbers:
        if num < min_num:
            min_num = num
        elif num > max_num:
            max_num = num
            
    return (min_num, max_num)",68
15404902520,frog_jump,"def frog_jump(X, Y, D):
    jumps = (Y - X) / D
    if (Y - X) % D == 0:
        return int(jumps)
    else:
        return int(jumps) + 1

print(frog_jump(10, 85, 30))",68
11805257141,longest_ones_sequence,"def longest_ones_sequence(binary_string):
    max_length = 0
    current_length = 0
    for char in binary_string:
        if char == '1':
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 0
    return max_length",68
23126658606,climb_Stairs,"def climb_Stairs(n): 
    if n == 1:
        return 1
    if n == 2:
        return 2
    a, b = 1, 2
    for i in range(3, n+1):
        a, b = b, a + b
    return b",68
21322009069,word_construct,"from collections import Counter

def word_construct(tiles, word):
    if len(word) > len(tiles):
        return False
    tiles_counter = Counter(tiles)
    word_counter = Counter(word)
    for char, count in word_counter.items():
        if tiles_counter[char] < count:
            return False
    return True",68
28086054435,is_valid_ip,"def is_valid_ip(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        num = int(part)
        if num < 0 or num > 255:
            return False
    return True",68
34249093591,sum_tree,"class Node:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

def sum_tree(root):
    if root is None:
        return 0
    return root.value + sum_tree(root.left) + sum_tree(root.right)",68
18944209474,uniquePaths,"def uniquePaths(m, n):
    if m < n:
        m, n = n, m
    dp = [1] * n
    for i in range(1, m):
        for j in range(1, n):
            dp[j] += dp[j - 1]
    return dp[-1]",68
15731783253,count_digit_occurrences,"import re

def count_digit_occurrences(input_string):
    digit_counts = {}
    digits = re.findall(r'\d', input_string)
    for digit in digits:
        if digit in digit_counts:
            digit_counts[digit] += 1
        else:
            digit_counts[digit] = 1
    return digit_counts",68
7446288389,find_dominant_element,"def find_dominant_element(arr):
    count = 0
    result = 0
    for i in arr:
        if count == 0:
            result = i
            count += 1
        elif result == i:
            count += 1
        else:
            count -= 1
            
    return result",68
39658932610,num_ways_to_make_change,"def num_ways_to_make_change(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]
    return dp[amount]",68
1448376947,valid_parentheses,"def valid_parentheses(n):
    if n == 0:
        return 1
    if n == 1:
        return 1
    result = 0
    for i in range(n):
        result += valid_parentheses(i) * valid_parentheses(n - 1 - i)
    return result",68
270855989,reverse_integer,"def reverse_integer(number):
    reversed_number = 0
    while number > 0:
        reversed_number = (reversed_number * 10) + (number % 10)
        number = number // 10
    return reversed_number if reversed_number <= 2**31 - 1 else 0",68
14032832638,find_max_subarray_sum,"def find_max_subarray_sum(arr):
    max_so_far = arr[0]
    curr_max = arr[0]

    for i in range(1, len(arr)):
        curr_max = max(arr[i], curr_max + arr[i])
        max_so_far = max(max_so_far, curr_max)

    return max_so_far",68
11908722663,filter_prime_numbers,"def filter_prime_numbers(numbers):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    return list(filter(is_prime, numbers))",68
71155097766,find_prime_factors,"def find_prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return list(set(factors))",68
3303517533,is_harshad_number,"def is_harshad_number(num):
    if num == 0:
        return False
    temp = num
    sum_of_digits = 0
    while temp > 0:
        sum_of_digits += temp % 10
        temp //= 10
    return num % sum_of_digits == 0",68
30532771004,count_unique_characters,"def count_unique_characters(s):
    unique_count = 0
    for i in range(len(s)):
        is_unique = True
        for j in range(i):
            if s[i] == s[j]:
                is_unique = False
                break
        if is_unique:
            unique_count += 1
    return unique_count",68
25584938216,count_substring,"def count_substring(string, sub_string):
    count = 0
    start = 0
    while start < len(string):
        pos = string.find(sub_string, start)
        if pos != -1:
            count += 1
            start = pos + 1
        else:
            break
    return count",68
20907555365,first_repeating,"def first_repeating(arr):
    seen = set()
    repeat = None
    for i in range(len(arr) - 1, -1, -1):
        if arr[i] in seen:
            repeat = arr[i]
            break
        else:
            seen.add(arr[i])
    return repeat if repeat else -1",68
43147415980,distinct_prime_factors,"def distinct_prime_factors(n):
    i = 2
    factors = set()
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.add(i)
    if n > 1:
        factors.add(n)
    return len(factors)",68
36908625896,count_bst,"def count_bst(n):
    if n <= 1:
        return 1
    total = 0
    for i in range(1, n + 1):
        left = count_bst(i - 1)
        right = count_bst(n - i)
        total += left * right
    return total",68
17945480823,find_dominant_index,"def find_dominant_index(nums):
    if len(nums) == 1:
        return 0
    max_num = max(nums)
    max_idx = nums.index(max_num)
    for num in nums:
        if num != max_num and max_num < num * 2:
            return -1
    return max_idx",68
14041139859,bubble_sort,"def bubble_sort(nums):
    n = len(nums)
    for i in range(n):
        for j in range(0, n - i - 1):
            if nums[j] > nums[j + 1]:
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
    return nums",68
27733486273,intersect_lists,"from collections import Counter

def intersect_lists(nums1, nums2):
    counter1 = Counter(nums1)
    counter2 = Counter(nums2)
    res = []
    for num, count in counter1.items():
        if num in counter2:
            res.extend([num] * min(count, counter2[num]))
    return res",68
26089609009,median_two_sorted_arrays,"def median_two_sorted_arrays(nums1, nums2):
    nums = sorted(nums1+nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length//2] + nums[length//2 - 1]) / 2
    else:
        return nums[length//2]",68
7602408235,find_second_max,"def find_second_max(arr):
    if len(set(arr)) < 2:  # If the array has less than 2 unique elements, return None
        return None
    unique_arr = list(set(arr))
    unique_arr.sort()
    return unique_arr[-2]  # Return the second last element in the sorted unique array",68
10457544973,can_pair,"from typing import List

def can_pair(nums: List[int]) -> bool:
    buckets = [0] * 500
    
    for x in nums:
        buckets[x - 1] += 1
    
    for x in buckets:
        if x % 2 != 0:
            return False
        
    return True",68
4997198610,max_consecutive_chars,"def max_consecutive_chars(s):
    result = float(""-inf"")
    cons = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            cons += 1
        else:
            cons = 1
        result = max(result, cons)
    return result",68
4319460628,odd_product_pairs,"def odd_product_pairs(nums):
    odd_nums = [num for num in nums if num % 2 != 0]
    result = []
    for i in range(len(odd_nums)):
        for j in range(i+1, len(odd_nums)):
            result.append((odd_nums[i], odd_nums[j]))
    return result",68
74971318651,remove_bracketed_substrings,"def remove_bracketed_substrings(s: str) -> str:
    stack = []
    result = []
    for char in s:
        if char == '[':
            stack.append(char)
        elif char == ']' and stack:
            stack.pop()
        elif not stack:
            result.append(char)
    return ''.join(result)",68
39509542493,max_consecutive_diff,"def max_consecutive_diff(arr):
    if len(arr) < 2:
        return 0
    max_diff = 0
    for i in range(len(arr) - 1):
        diff = abs(arr[i] - arr[i + 1])
        max_diff = max(max_diff, diff)
    return max_diff",68
18453009644,find_max_subarray,"def find_max_subarray(list1):
    max_ending_here = max_so_far = list1[0]
    for x in list1[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far",68
27615888666,find_smallest_missing,"def find_smallest_missing(nums):
    nums = list(filter(lambda x: x > 0, nums))
    nums.sort()
    smallest_missing = 1
    for num in nums:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",67
30378037755,set,"def permutations(s: str) -> list:
    def dfs(path, t):
        if not t:
            ans.add(path)
        for i in range(len(t)):
            dfs(path + t[i], t[:i] + t[i + 1:])
    ans = set()
    dfs('', s)
    return list(ans)",67
5139203387,middle_element,"def middle_element(lst):
    length = len(lst)
    if length % 2 == 0:
        mid1 = length // 2
        mid2 = mid1 - 1
        return [lst[mid2], lst[mid1]]
    else:
        mid = length // 2
        return lst[mid]",67
21564505673,gcd_lcm,"def gcd_lcm(a, b):
    def gcd(a, b):
        while b != 0:
            a, b = b, a % b
        return a
    def lcm(a, b):
        return a * b // gcd(a, b)
    return gcd(a, b), lcm(a, b)",67
25841225171,two_largest,"def two_largest(numbers):
    max1 = max(numbers)
    index1 = numbers.index(max1)
    numbers[index1] = -float('inf') # Set the max number to negative infinity 
    max2 = max(numbers)
    index2 = numbers.index(max2)
    return [index1, index2]",67
37303594714,count_consecutive_ones,"def count_consecutive_ones(nums):
    max_count = 0
    current_count = 0
    for num in nums:
        if num == 1:
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count",67
8139079378,is_valid_identifier,"import keyword

def is_valid_identifier(identifier):
    if keyword.iskeyword(identifier):
        return False
    if not identifier[0].isalpha() and identifier[0] != '_':
        return False
    for char in identifier:
        if not char.isalnum() and char != '_':
            return False
    return True",67
1368909820,pascal_row,"def pascal_row(n):
    row = [1] * (n + 1)
    for i in range(1, n // 2 + 1):
        row[i] = row[n - i] = row[i - 1] * (n - i + 1) // i
    return row",67
28346863788,find_smallest_missing,"def find_smallest_missing(nums):
    nums = [num for num in nums if num > 0]
    nums.sort()
    smallest_missing = 1
    for num in nums:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",67
11331162557,intersection,"from collections import Counter

def intersection(nums1, nums2):
    counter1 = Counter(nums1)
    counter2 = Counter(nums2)
    result = []
    for num, count in counter1.items():
        if num in counter2:
            result.extend([num] * min(count, counter2[num]))
    return result",67
38556384080,make_change,"def make_change(amount, denominations):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for denom in denominations:
        for i in range(denom, amount + 1):
            dp[i] += dp[i - denom]
    return dp[amount]",67
16429296937,findKthLargest,"import heapq

def findKthLargest(nums, k):
    if not nums or k <= 0:
        return None

    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)

    return heap[0]",67
22886534211,find_max_subarray_sum,"def find_max_subarray_sum(arr):
    max_so_far = arr[0]
    curr_max = arr[0]
    for i in range(1,len(arr)):
        curr_max = max(arr[i], curr_max + arr[i])
        max_so_far = max(max_so_far,curr_max)
    return max_so_far",67
33157517236,smallest_missing_positive_integer,"def smallest_missing_positive_integer(nums):
    nums = [num for num in nums if num > 0]
    nums.sort()
    smallest_missing = 1
    for num in nums:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",67
29895203388,has_majority_element,"def has_majority_element(arr):
    element_count = {}
    for num in arr:
        if num in element_count:
            element_count[num] += 1
        else:
            element_count[num] = 1
        if element_count[num] > len(arr) / 2:
            return True
    return False",67
24379285153,substring_count,"def substring_count(string, sub_string):
    count = 0
    start = 0
    while start < len(string):
        pos = string.find(sub_string, start)
        if pos != -1:
            count += 1
            start = pos + 1
        else:
            break
    return count",67
18413706262,adjacent_max_product,"def adjacent_max_product(lst):
    max_product = lst[0] * lst[1]
    for i in range(1, len(lst) - 1):
        current_product = lst[i] * lst[i + 1]
        if current_product > max_product:
            max_product = current_product
    return max_product",67
15681879130,is_valid_identifier,"import keyword

def is_valid_identifier(s):
    if keyword.iskeyword(s):
        return False
    if not s:
        return False
    if s[0].isdigit():
        return False
    for char in s:
        if not (char.isalnum() or char == '_'):
            return False
    return True",67
1339260129,num_ways_change,"def num_ways_change(coins, amount):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]
    return dp[amount]",67
23040390854,find_repeating_unit,"def find_repeating_unit(s):
    for i in range(1, len(s)//2 + 1):
        if len(s) % i == 0:
            if s[:i] * (len(s)//i) == s:
                return s[:i], len(s)//i
    return s, 1",67
27612693599,capitalize_words,"def capitalize_words(s):
    return ' '.join(word.capitalize() for word in s.split())

# Check function with provided data points
assert capitalize_words(""hello world"") == ""Hello World""
assert capitalize_words(""this is a test"") == ""This Is A Test""
assert capitalize_words(""python programming"") == ""Python Programming""",67
28127868074,count_balanced_parentheses,"def count_balanced_parentheses(s):
    count = 0
    balance = 0
    for char in s:
        if char == '(':
            balance += 1
        elif char == ')':
            balance -= 1
            if balance == 0:
                count += 1
    return count",67
17837635998,is_subsequence,"def is_subsequence(s1, s2):
    i, j = 0, 0
    while i < len(s1) and j < len(s2):
        if s1[i] == s2[j]:
            i += 1
        j += 1
    return i == len(s1)",67
1448680917,find_Smallest_Greater,"def find_Smallest_Greater(array, target):
    smallest_greater = None
    index = -1
    for i, num in enumerate(array):
        if num > target:
            if smallest_greater is None or num < smallest_greater:
                smallest_greater = num
                index = i
    return smallest_greater, index",67
22205116046,nth_missing,"def nth_missing(arr, n):
    missing = 0
    i = 0
    while n > 0:
        if i >= len(arr) or arr[i] > missing + 1:
            n -= 1
        else:
            i += 1
        missing += 1
    return missing",67
15043418875,find_odd_one_out,"def find_odd_one_out(integers):
    bit = ((integers[0] & 1) + (integers[1] & 1) + (integers[2] & 1)) >> 1
    for n in integers:
        if (n & 1) ^ bit:
            return n",67
32566066569,maxSubArraySum,"def maxSubArraySum(arr):
    max_so_far = arr[0]
    curr_max = arr[0]

    for i in range(1, len(arr)):
        curr_max = max(arr[i], curr_max + arr[i])
        max_so_far = max(max_so_far, curr_max)

    return max_so_far",67
35128645659,can_be_sum_of_two_squares,"def can_be_sum_of_two_squares(n: int) -> bool:
    squares = [i**2 for i in range(1, int(n**0.5) + 1)]
    for i in squares:
        if n - i in squares and n != 2*i:
            return True
    return False",67
20000546549,missing_int,"def missing_int(nums):
    nums = [num for num in nums if num > 0]
    nums.sort()
    smallest_missing = 1
    for num in nums:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            return smallest_missing
    return smallest_missing",67
2522522147,min_number,"from functools import cmp_to_key

def min_number(nums):
    def compare(a, b):
        return int(str(a) + str(b)) - int(str(b) + str(a))
    
    nums = list(map(str, nums))
    nums.sort(key=cmp_to_key(compare))
    return str(int(''.join(nums)))",67
40220367722,count_balanced_parentheses,"def count_balanced_parentheses(s: str) -> int:
    stack = []
    count = 0
    
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')' and stack:
            stack.pop()
            if not stack:
                count += 1
    
    return count",67
7002381898,largest_difference,"def largest_difference(num_list):
    min_val = num_list[0]
    max_diff = 0
    for n in num_list[1:]:
        if n < min_val:
            min_val = n
        elif n - min_val > max_diff:
            max_diff = n - min_val
    return max_diff",67
30469580888,find_no_incoming_nodes,"from collections import defaultdict

def find_no_incoming_nodes(n, edges):
    answer = []
    graph = defaultdict(list)
    
    for edge in edges:
        graph[edge[1]].append(edge[0])
    
    for x in range(n):
        if x not in graph:
            answer.append(x)
    
    return answer",67
7056900824,ways_to_make_change,"def ways_to_make_change(coins, amount):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]
    return dp[amount]",67
45176070003,can_construct,"def can_construct(s: str) -> bool:
    n = len(s)
    for i in range(1, n // 2 + 1):
        if n % i == 0:
            sub = s[:i]
            if sub * (n // i) == s:
                return True
    return False",67
10945164094,find_consecutive_ones,"def find_consecutive_ones(nums):
    max_count = 0
    current_count = 0
    for num in nums:
        if num == 1:
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count",67
27755585531,smallest_missing_positive_integer,"def smallest_missing_positive_integer(arr):
    arr = [i for i in arr if i > 0]
    arr.sort()
    smallest_missing = 1
    for num in arr:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",67
14558588308,num_ways_to_climb,"def num_ways_to_climb(n): 
    if n <= 1: 
        return 1
    first, second = 1, 1
    for i in range(2, n + 1): 
        third = first + second 
        first, second = second, third 
    return second",67
11456780881,max_absolute_difference,"def max_absolute_difference(arr):
    if len(arr) < 2:
        return 0
    max_diff = 0
    for i in range(len(arr)-1):
        diff = abs(arr[i] - arr[i+1])
        if diff > max_diff:
            max_diff = diff
    return max_diff",67
27438634691,median_of_three,"def median_of_three(a: int, b: int, c: int) -> int:
    if (a - b) * (c - a) >= 0:
        return a
    elif (b - a) * (c - b) >= 0:
        return b
    else:
        return c",67
28733099459,maxNonAdjacentSum,"def maxNonAdjacentSum(nums):
    incl = 0
    excl = 0
     
    for i in nums: 
        new_excl = excl if excl>incl else incl 
     
        incl = excl + i 
        excl = new_excl 
     
    return (excl if excl>incl else incl)",67
26125522266,is_Palindrome,"def is_Palindrome(string): 
    left_pos = 0
    right_pos = len(string) - 1
  
    while right_pos >= left_pos:
        if not string[left_pos] == string[right_pos]:
            return False
        left_pos += 1
        right_pos -= 1
    return True",67
36797261519,max_subarray_sum,"def max_subarray_sum(arr):
    max_so_far = arr[0]
    curr_max = arr[0]

    for i in range(1, len(arr)):
        curr_max = max(arr[i], curr_max + arr[i])
        max_so_far = max(max_so_far, curr_max)
    return max_so_far",67
23559805638,find_Largest_Sum,"def find_Largest_Sum(arr):
    max_so_far = arr[0]
    curr_max = arr[0]
    for i in range(1,len(arr)):
        curr_max = max(arr[i], curr_max + arr[i])
        max_so_far = max(max_so_far,curr_max)
    return max_so_far",67
2968762302,count_pairs,"def count_pairs(arr, k):
    seen = {}
    count = 0
    for num in arr:
        if k - num in seen:
            count += seen[k - num]
        if num in seen:
            seen[num] += 1
        else:
            seen[num] = 1
    return count",67
71730391736,count_pairs,"def count_pairs(array, target):
    d = {}
    count = 0
    for i in array:
        if target - i in d:
            count += d[target - i]
        if i in d:
            d[i] += 1
        else:
            d[i] = 1
    return count",67
35797818793,find_smallest_repeating_pattern,"def find_smallest_repeating_pattern(s):
    for i in range(1, len(s) // 2 + 1):
        if len(s) % i == 0:
            if s[:i] * (len(s) // i) == s:
                return len(s) // i
    return 1",67
74117101621,is_ugly,"def is_ugly(num):
    if num<1:
        return False

    while num%5==0:
        num = num//5 
    while num%3==0:
        num = num//3
    while num%2==0:
        num = num//2
    return num==1",67
74960650425,largest_consecutive_sum,"def largest_consecutive_sum(arr):
    max_sum = 0
    current_sum = 0
    for num in arr:
        current_sum += num
        if current_sum > max_sum:
            max_sum = current_sum
        if current_sum < 0:
            current_sum = 0
    return max_sum",67
32593623226,permutations,"def permutations(string):
    if len(string) == 0:
        return [""""]
    result = []
    for i in range(len(string)):
        char = string[i]
        remaining = string[:i] + string[i+1:]
        for permutation in permutations(remaining):
            result.append(char + permutation)
    return result",67
8519217790,max_Subarray_Sum,"def max_Subarray_Sum(arr):
    max_so_far = arr[0]
    curr_max = arr[0]
    for i in range(1,len(arr)):
        curr_max = max(arr[i], curr_max + arr[i])
        max_so_far = max(max_so_far,curr_max)
    return max_so_far",67
34546703280,isPowerOfTwo,"def isPowerOfTwo(n):
    """"""
    :param n: int
    :return: bool
    """"""
    if n <= 0:
        return False

    while n != 1:
        if n % 2 != 0:
            return False
        n = n / 2

    return True",67
3718917452,removeConsecutiveDuplicates,"def removeConsecutiveDuplicates(arr):
    answer = []
    if len(arr) == 0:
        return answer
    temp = arr[0]
    answer.append(temp)
    for i in arr :
        if i != temp: # compare
            temp = i # update temp
            answer.append(i)
    return answer",67
25200456917,longest_decreasing,"def longest_decreasing(nums):
    n = len(nums)
    dp = [1]*n
    for i in range(1, n):
        for j in range(i):
            if nums[j] > nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",67
12287354441,can_form_triangle,"def can_form_triangle(sides):
    sides.sort()
    if sides[0] + sides[1] > sides[2] and sides[1] + sides[2] > sides[0] and sides[0] + sides[2] > sides[1]:
        return True
    else:
        return False",67
23228055711,tuple_to_dict,"def tuple_to_dict(tuples):
    result = {}
    for key, value in tuples:
        if key in result:
            if isinstance(result[key], list):
                result[key].append(value)
            else:
                result[key] = [result[key], value]
        else:
            result[key] = value
    return result",67
9821016829,find_majority_element,"def find_majority_element(arr):
    count = 0
    result = 0
    for i in arr:
        if count == 0:
            result = i
            count = 1
        elif result == i:
            count += 1
        else:
            count -= 1
    return result",67
2215291622,find_next_greater,"def find_next_greater(arr):
    n = len(arr)
    next_greater = [-1] * n
    stack = []
    for i in range(n):
        while stack and arr[stack[-1]] < arr[i]:
            next_greater[stack.pop()] = arr[i]
        stack.append(i)
    return next_greater",67
73871110930,count_pairs,"def count_pairs(arr, k):
    count = 0
    seen = {}
    for num in arr:
        if k - num in seen:
            count += seen[k - num]
        if num in seen:
            seen[num] += 1
        else:
            seen[num] = 1
    return count",67
23794732920,is_rotation_of_palindrome,"def is_rotation_of_palindrome(s: str) -> bool:
    def is_palindrome(s: str) -> bool:
        return s == s[::-1]

    for i in range(len(s)):
        rotated = s[i:] + s[:i]
        if is_palindrome(rotated):
            return True
    return False",67
29210298381,longest_consecutive_ones,"def longest_consecutive_ones(nums):
    max_count = 0
    current_count = 0
    for num in nums:
        if num == 1:
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count",67
34370043761,pattern_frequency,"def pattern_frequency(lists):
    frequency = {}
    for l in lists:
        if tuple(l) in frequency:
            frequency[tuple(l)] += 1
        else:
            frequency[tuple(l)] = 1
    return {k: v for k, v in frequency.items() if v > 1}",67
10208805189,next_greater,"def next_greater(arr):
    result = []
    for index in range(len(arr)):
        found = False
        for i in arr[index + 1:]:
            if arr[index] < i:
                result.append(i)
                found = True
                break
        if not found:
            result.append(-1)
    return result",67
34640486646,max_consecutive_ones,"def max_consecutive_ones(nums):
    max_count = 0
    current_count = 0
    for num in nums:
        if num == 1:
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count",67
15091566111,largest_sum_subarray,"def largest_sum_subarray(nums):
    if not nums:
        return None

    max_sum = current_sum = nums[0]
    for i in range(1, len(nums)):
        current_sum = max(nums[i], current_sum + nums[i])
        max_sum = max(max_sum, current_sum)
    return max_sum",67
12352015519,check_palindrome,"def check_palindrome(number):
    original_number = number
    reversed_number = 0
    while number > 0:
        digit = number % 10
        reversed_number = (reversed_number * 10) + digit
        number = number // 10
    return original_number == reversed_number",67
31827524826,find_max_product,"def find_max_product(arr):
    if len(arr) < 2:
        return None
    max_product = float('-inf')
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            max_product = max(max_product, arr[i] * arr[j])
    return max_product",67
71321229757,fibo,"def fibo(n):
   if n <= 0:
       return 0
   elif n == 1:
       return 1
   else:
       a, b = 0, 1
       for _ in range(1, n):
           a, b = b, a + b
       return b",67
71173839340,generate_binary_strings,"def generate_binary_strings(n):
    if n == 1:
        return ['0', '1']
    smallerStrings = generate_binary_strings(n - 1)
    newStrings = []
    for string in smallerStrings:
        newStrings.append(string + '0')
        newStrings.append(string + '1')
    return newStrings",67
11181342459,find_smallest_difference,"def find_smallest_difference(lst):
    lst.sort()
    diff = abs(lst[0] - lst[1])
    for i in range(len(lst) - 1):
        if abs(lst[i] - lst[i+1]) < diff:
            diff = abs(lst[i] - lst[i+1])
    return diff",67
11795339647,first_non_repeating_character,"def first_non_repeating_character(string):
  character_count = {}
  
  for char in string:
    if char in character_count:
      character_count[char] += 1
    else:
      character_count[char] = 1
  
  for char in string:
    if character_count[char] == 1:
      return char",67
22185098729,find_smallest_missing,"def find_smallest_missing(arr):
    arr = [x for x in arr if x > 0]
    arr.sort()
    smallest_missing = 1
    for num in arr:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",67
10572188417,is_rotation,"def is_rotation(sorted_arr, rotated_arr):
    if len(sorted_arr) != len(rotated_arr):
        return False

    double_sorted_arr = sorted_arr * 2

    if rotated_arr in (double_sorted_arr[i:i+len(rotated_arr)] for i in range(len(sorted_arr))):
        return True
    return False",67
36049807879,fibonacci_sum,"def fibonacci_sum(n):
  if n <= 0:
    return 0
  fib = [0, 1]
  for i in range(2, n + 1):
    fib.append(fib[i - 1] + fib[i - 2])
  return sum(fib[:n + 1])",67
74014731645,count_divisors,"def count_divisors(n):
    count = 0
    temp = n
    while n > 0:
        digit = n % 10
        n = n // 10
        if digit != 0 and temp % digit == 0:
            count = count + 1
    return count",67
491752503,largest_number,"from functools import cmp_to_key

def largest_number(nums):
    def compare(a, b):
        return int(b+a) - int(a+b)

    nums = [str(x) for x in nums]
    nums.sort(key=cmp_to_key(compare))
    return ''.join(nums).lstrip('0') or '0'",67
7435187836,generate_gray_code,"def generate_gray_code(n):
    if n == 1:
        return [""0"", ""1""]
    else:
        prev_gray = generate_gray_code(n-1)
        new_gray = [""0"" + code for code in prev_gray] + [""1"" + code for code in reversed(prev_gray)]
        return new_gray",67
787368138,find_frequent_elements,"from collections import Counter

def find_frequent_elements(arr):
    c = Counter(arr)
    cnt = c.most_common()
    maxx = cnt[0][1]
    ans = []
    for i in cnt:
        if i[1] != maxx:
            break
        ans.append(i[0])
    return ans",67
20764741556,oxford_comma,"def oxford_comma(list_items):
    if len(list_items) == 1:
        return list_items[0]
    elif len(list_items) == 2:
        return ' and '.join(list_items)
    else:
        return ', '.join(list_items[:-1]) + ', and ' + list_items[-1]",67
41440520792,longest_string_chain,"from collections import defaultdict

def longest_string_chain(words):
    dp = defaultdict(int)
    for word in sorted(words, key=len):
        for i in range(len(word)):
            dp[word] = max(dp[word], dp[word[:i] + word[i+1:]] + 1)
    return max(dp.values())",66
34159624469,firstNonRepeatedChar,"def firstNonRepeatedChar( s):
  dict = {}
  for i in s:
    if i in dict:
      dict[i] += 1
    else:
      dict[i] = 1
      
  for i in s:
    if dict[i] == 1:
      return i
  return -1",66
8666495621,sort_string,"from collections import Counter

def sort_string(s):
    if not s:
        return """"
    cnt = Counter(s)
    cnt = sorted(cnt.items(), key=lambda x: (-x[1], x[0]))
    res = ''
    for key, val in cnt:
        res += key * val
    return res",66
72465707508,largest_continuous_sum,"def largest_continuous_sum(arr):
    if len(arr) == 0:
        return 0
    max_sum = current_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(current_sum, max_sum)
    return max_sum",66
70944396920,countSubstrings,"def countSubstrings(text, pattern):
    count = 0
    index = 0
    while index < len(text):
        found = text.find(pattern, index)
        if found != -1:
            count += 1
            index = found + 1
        else:
            break
    return count",66
15906560228,find_palindromes,"def find_palindromes(words):
    """"""
    Takes a list of strings and returns a list of words that are palindromes.
    """"""
    palindromes = []
    for word in words:
        if word == word[::-1]:
            palindromes.append(word)
    return palindromes",66
23563889145,count_subarrays,"def count_subarrays(arr, k):
    count = 0
    n = len(arr)
    for i in range(n):
        sum = 0
        for j in range(i, n):
            sum += arr[j]
            if sum % k == 0:
                count += 1
    return count",66
15171122933,is_geometric_progression,"def is_geometric_progression(nums):
    if len(nums) < 2:
        return False
    ratio = nums[1] / nums[0]
    for i in range(2, len(nums)):
        if nums[i] / nums[i - 1] != ratio:
            return False
    return True",66
7643057771,find_longest_common_prefix,"def find_longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other_str in strs:
            if other_str[i] != char:
                return shortest_str[:i]
    return shortest_str",66
70707897069,fibonacci_modulo,"def fibonacci_modulo(n):
    MOD = 10**9 + 7
    fib = [0, 1]
    for i in range(2, n + 1):
        fib.append((fib[i-1] + fib[i-2]) % MOD)
    return sum(fib) % MOD",66
33495660976,length_of_longest_increasing_subsequence,"def length_of_longest_increasing_subsequence(arr):
    dp = [1]*len(arr)

    for i in range(1,len(arr)):
        for j in range(i):
            if arr[j] < arr[i]:
                dp[i] = max(dp[i], dp[j]+1)
    
    return max(dp)",66
36637272669,nth_fibonacci,"def nth_fibonacci(n):
    if n <= 0:
        return ""Invalid Input""
    elif n == 1:
        return 1
    elif n == 2:
        return 1
    else:
        return nth_fibonacci(n-1) + nth_fibonacci(n-2)",66
38484160948,smallest_missing,"def smallest_missing(list1):
    list1 = [x for x in list1 if x > 0]
    list1.sort()
    smallest = 1
    for i in list1:
        if i == smallest:
            smallest += 1
        elif i > smallest:
            return smallest
    return smallest",66
30563965702,smallestMissingPositive,"def smallestMissingPositive(arr):
    arr = [x for x in arr if x > 0]
    arr.sort()
    smallest_missing = 1
    for num in arr:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",66
39312086,count_coin_combinations,"def count_coin_combinations(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]

    return dp[amount]",66
37219652861,max_adjacent_diff,"def max_adjacent_diff(nums):
    if len(nums) < 2:
        return 0
    max_diff = 0
    for i in range(1, len(nums)):
        diff = abs(nums[i] - nums[i-1])
        max_diff = max(max_diff, diff)
    return max_diff",66
72219045256,can_form_palindrome,"from collections import Counter

def can_form_palindrome(arr):
    count_dict = Counter(arr)
    odd_count = 0
    for count in count_dict.values():
        if count % 2 != 0:
            odd_count += 1
        if odd_count > 1:
            return False
    return True",66
19764369271,smallest_missing_positive,"def smallest_missing_positive(arr):
    arr = list(filter(lambda x: x > 0, arr))
    arr.sort()
    smallest_missing = 1
    for num in arr:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",66
5678921888,find_substring,"def find_substring(haystack: str, needle: str) -> int:
    if not needle:
        return 0
    for i in range(len(haystack) - len(needle) + 1):
        if haystack[i:i+len(needle)] == needle:
            return i
    return -1",66
40818023712,largest_cont_sum,"def largest_cont_sum(arr):
    if len(arr) == 0:
        return 0
    current_sum = max_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(max_sum, current_sum)
    return max_sum",66
25426660262,find_reachable_vertices,"def find_reachable_vertices(n, edges):
    indegree = [0 for _ in range(n)]
    for start, end in edges:
        indegree[end] += 1

    ans = []

    for i, num in enumerate(indegree):
        if num==0:
            ans.append(i)

    return ans",66
38385533331,largest_cont_sum,"def largest_cont_sum(arr):
    if len(arr) == 0:
        return 0
    max_sum = cur_sum = arr[0]
    for num in arr[1:]:
        cur_sum = max(num, cur_sum + num)
        max_sum = max(max_sum, cur_sum)
    return max_sum",66
72014237757,sum_odd_length_subarrays,"def sum_odd_length_subarrays(arr):
    Sum = 0
    for i in range(len(arr)):
        Sum += (
            (
                (
                    (i + 1) * (len(arr) - i) + 1
                    ) // 2
                ) * arr[i]
            )
    return Sum",66
1437134320,largest_cont_sum,"def largest_cont_sum(arr):
    if len(arr) == 0:
        return 0
    current_sum = max_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(current_sum, max_sum)
    return max_sum",66
34036135869,height,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def height(root):
    if not root:
        return 0
    return 1 + max(height(root.left), height(root.right))",66
34760021193,largest_continuous_sum,"def largest_continuous_sum(arr):
    if len(arr) == 0:
        return 0
    current_sum = max_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(current_sum, max_sum)
    return max_sum",66
38044645950,find_pairs,"def find_pairs(arr, k):
    count = 0
    freq = {}
    for i in arr:
        if k - i in freq:
            count += freq[k-i]
        if i in freq:
            freq[i] += 1
        else:
            freq[i] = 1
    return count",66
1648536197,find_prime_numbers,"def find_prime_numbers(start, end):
    primes = []
    for num in range(start, end + 1):
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    return primes",66
70290419657,count_steps,"def count_steps(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    elif n == 3:
        return 4
    else:
        return count_steps(n-1) + count_steps(n-2) + count_steps(n-3)",66
70433708621,smallestMissingPositive,"def smallestMissingPositive(arr):
    arr = [x for x in arr if x > 0]
    arr.sort()
    smallest_missing = 1
    for num in arr:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",66
22958227233,max_subarray,"def max_subarray(arr):
    max_so_far = arr[0]
    curr_max = arr[0]
    for i in range(1, len(arr)):
        curr_max = max(arr[i], curr_max + arr[i])
        max_so_far = max(max_so_far, curr_max)
    return max_so_far",66
24341650562,intersect_freq,"from collections import Counter

def intersect_freq(str1, str2):
    freq1, freq2 = Counter(str1), Counter(str2)
    common_chars = freq1 & freq2
    result = []
    for char, freq in common_chars.items():
        result.append(char * freq)
    return ''.join(result)",66
31588228240,is_toeplitz,"def is_toeplitz(matrix):
    rows = len(matrix)
    cols = len(matrix[0])

    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][j] != matrix[i-1][j-1]:
                return False
    return True",66
6786214849,count_pairs,"from collections import defaultdict

def count_pairs(arr, target):
    count = 0
    freq_map = defaultdict(int)
    for num in arr:
        complement = target - num
        if complement in freq_map:
            count += freq_map[complement]
        freq_map[num] += 1
    return count",66
30549797443,count_non_decreasing_subarrays,"def count_non_decreasing_subarrays(nums):
    count = 0
    n = len(nums)
    for i in range(n):
        for j in range(i, n):
            if all(nums[k] <= nums[k+1] for k in range(i, j)):
                count += 1
    return count",66
32183457645,get_longest_common_prefix,"def get_longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other_str in strs:
            if other_str[i] != char:
                return shortest_str[:i]
    return shortest_str",66
30529117667,find_substring_occurrences,"def find_substring_occurrences(string, substring):
    occurrences = []
    index = 0
    while index < len(string):
        found = string.find(substring, index)
        if found != -1:
            occurrences.append(found)
            index = found + 1
        else:
            break
    return occurrences",66
25087206563,prime_sum,"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def prime_sum(lst):
    return sum(filter(is_prime, lst))",66
25200814687,get_permutations,"def get_permutations(s):
    if len(s) == 1:
        return [s]
    permutations = []
    for i in range(len(s)):
        rest = s[:i] + s[i+1:]
        for perm in get_permutations(rest):
            permutations.append(s[i] + perm)
    return permutations",66
12213154303,largest_continuous_sum,"def largest_continuous_sum(arr):
    if len(arr) == 0:
        return 0
    max_sum = current_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(max_sum, current_sum)
    return max_sum",66
18551899419,smallest_missing_pos,"def smallest_missing_pos(list1):
    list1 = [x for x in list1 if x > 0]
    list1.sort()
    missing = 1
    for num in list1:
        if num == missing:
            missing += 1
        elif num > missing:
            break
    return missing",66
4517035671,longest_increasing_subsequence,"def longest_increasing_subsequence(nums):
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",66
11410035010,balanced_parentheses,"def balanced_parentheses(n):
    if n == 0:
        return 1
    if n == 1:
        return 1
    result = 0
    for i in range(n):
        result += balanced_parentheses(i) * balanced_parentheses(n-1-i)
    return result",66
36465195058,find_combinations,"def find_combinations(coins, amount):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]
    return dp[amount]",66
35211413475,find_first_non_repeating,"def find_first_non_repeating(arr):
    counts = {}
    for num in arr:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1
    for num in arr:
        if counts[num] == 1:
            return num
    return -1",66
26789925421,large_cont_sum,"def large_cont_sum(arr):
    if len(arr) == 0:
        return 0
    current_sum = max_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(current_sum, max_sum)
    return max_sum",66
3606080321,gcd_lcm,"def gcd_lcm(a, b):
    def gcd(x, y):
        while(y):
            x, y = y, x % y
        return x
    def lcm(x, y):
        lcm = (x*y)//gcd(x,y)
        return lcm
    return gcd(a,b), lcm(a,b)",66
37881618808,rotate_matrix,"def rotate_matrix(matrix):
    n = len(matrix)
    if n == 0:
        return []
    rotated = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            rotated[j][n-i-1] = matrix[i][j]
    return rotated",66
29700406701,count_characters,"def count_characters(s):
    alphabets = digits = special = 0
    for char in s:
        if char.isalpha():
            alphabets += 1
        elif char.isdigit():
            digits += 1
        else:
            special += 1
    return alphabets, digits, special",66
12352034349,parse_ip,"def parse_ip(ip: str) -> list:
    ip = ip.strip()
    octets = ip.split(""."")
    ip_address = []
    for octet in octets:
        octet = octet.strip("", "")
        if octet.isnumeric():
            ip_address.append(int(octet))
    return ip_address",66
29417625617,median_sorted_arrays,"def median_sorted_arrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    length = len(nums)
    if length % 2 == 0:
        return (nums[length//2-1] + nums[length//2]) / 2
    else:
        return nums[length//2]",66
1520459693,is_permutation,"def is_permutation(A):
    n = len(A)
    if n == 1:
        return True
    A.sort()
    for i in range(n - 1):
        if A[i] == A[i + 1] or A[i] != i + 1:
            return False
    return True",66
31564431345,change_ways,"def change_ways(coins, amount):
    dp = [0] * (amount + 1)
    dp[0] = 1

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]

    return dp[amount]",66
12550613450,string_permutations,"def string_permutations(s):
    if len(s) == 1:
        return [s]
    permutations = []
    for i in range(len(s)):
        rest = s[:i] + s[i+1:]
        for p in string_permutations(rest):
            permutations.append(s[i] + p)
    return permutations",66
33624035219,create_dict,"def create_dict(keys, values, default=None):
    if len(keys) > len(values):
        values.extend([default] * (len(keys) - len(values)))
    elif len(values) > len(keys):
        keys.extend([default] * (len(values) - len(keys)))
    return dict(zip(keys, values))",66
10480609847,count_substring_occurrences,"def count_substring_occurrences(substring, string):
    count = start = 0
    while start < len(string):
        pos = string.find(substring, start)
        if pos != -1:
            start = pos + 1
            count += 1
        else:
            break
    return count",66
30363090024,count_ways,"def count_ways(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    a, b = 1, 2
    for i in range(3, n+1):
        a, b = b, a+b
    return b",66
74866386583,find_Largest_Subarray_Sum,"def find_Largest_Subarray_Sum(nums):
    if not nums:
        return 0
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",66
16454583065,max_consecutive_diff,"def max_consecutive_diff(lst):
    if len(lst) <= 1:
        return 0
    max_diff = 0
    for i in range(1, len(lst)):
        diff = abs(lst[i] - lst[i-1])
        max_diff = max(max_diff, diff)
    return max_diff",66
36171349082,reverse_even,"def reverse_even(lst):
    even_nums = [x for i, x in enumerate(lst) if x % 2 == 0]
    even_nums.reverse()
    for i, x in enumerate(lst):
        if x % 2 == 0:
            lst[i] = even_nums.pop(0)
    return lst",66
39212079508,num_ways,"def num_ways(n):
    if n == 1 or n == 0:
        return 1
    first, second = 1, 1
    for i in range(2, n + 1):
        third = first + second
        first, second = second, third
    return second",66
37953036593,find_longest_common_prefix,"def find_longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other_str in strs:
            if other_str[i] != char:
                return shortest_str[:i]
    return shortest_str",66
70658107509,find_odd,"def find_odd(nums):
    count = {}
    for num in nums:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
    for num, freq in count.items():
        if freq % 2 != 0:
            return num
    return None",66
27383757264,find_primes,"def find_primes(start, end):
    primes = []
    for num in range(start, end + 1):
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    return primes",66
5232713465,max_substring,"def max_substring(main_string, substring):
    count = 0
    index = 0
    while index < len(main_string):
        index = main_string.find(substring, index)
        if index == -1:
            break
        count += 1
        index += len(substring)
    return count",66
72740153081,largest_continuous_sum,"def largest_continuous_sum(arr):
    if len(arr) == 0:
        return 0

    max_sum = current_sum = arr[0]

    for num in arr[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(max_sum, current_sum)

    return max_sum",66
34613981241,find_repeating_unit,"def find_repeating_unit(s):
    n = len(s)
    for i in range(1, n//2 + 1):
        if n % i == 0:
            unit = s[:i]
            if unit * (n // i) == s:
                return n // i
    return 1",66
10816509631,prime_in_range,"def prime_in_range(start, end):
    primes = []
    for num in range(start, end + 1):
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    return primes",66
70439257631,prime_in_range,"def prime_in_range(start, end):
    primes = []
    for num in range(start, end + 1):
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    return primes",66
5850651681,move_zeroes,"def move_zeroes(nums):
    left = 0
    right = len(nums) - 1

    while(left < right):
        if(nums[left] == 0):
            nums.append(0)
            nums.pop(left)
            right -= 1
        else:
            left += 1

    return nums",66
35398754877,find_two_largest,"def find_two_largest(nums):
    max1 = max2 = float('-inf')
    for num in nums:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2:
            max2 = num
    return [max2, max1]",66
41734906783,shortest_palindrome,"def shortest_palindrome(s: str) -> str:
    if len(s) == 0:
        return """"

    for i in range(len(s), -1, -1):
        if s[:i] == s[:i][::-1]:
            return s[i:][::-1] + s

    return s",66
14636743496,fizz_buzz,"def fizz_buzz(n):
    if n % 3 == 0 and n % 5 == 0:
        return 'FizzBuzz'
    elif n % 3 == 0:
        return 'Fizz'
    elif n % 5 == 0:
        return 'Buzz'
    else:
        return n",66
786275998,check_palindrome,"import re

def check_palindrome(text):
    # Remove all non-alphanumeric characters and convert to lowercase
    cleaned_text = re.sub(r'[^A-Za-z0-9]', '', text).lower()
    # Check if the cleaned text is equal to its reverse
    return cleaned_text == cleaned_text[::-1]",66
6789465272,fibonacci_sum,"def fibonacci_sum(n):
    if n <= 0:
        return 0
    a, b = 0, 1
    sum_fib = 0
    for _ in range(n):
        sum_fib += a
        a, b = b, a + b
    return sum_fib",66
2165129779,fib_memo,"def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        memo[n] = n
    else:
        memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]",66
30844434087,find_primes,"def find_primes(start, end):
    primes = []
    for num in range(start, end + 1):
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    return primes",66
16288046692,find_next_greater_elements,"def find_next_greater_elements(arr):
    result = [-1] * len(arr)
    stack = []
    
    for i in range(len(arr)):
        while stack and arr[i] > arr[stack[-1]]:
            index = stack.pop()
            result[index] = arr[i]
        stack.append(i)
    return result",66
72686700622,find_pattern_count,"def find_pattern_count(text, pattern):
    count = 0
    index = 0
    while index < len(text):
        found = text.find(pattern, index)
        if found != -1:
            count += 1
            index = found + 1
        else:
            break
    return count",66
28637187303,coinChangeWays,"def coinChangeWays(coins, n):
    dp = [0] * (n + 1)
    dp[0] = 1

    for coin in coins:
        for i in range(coin, n + 1):
            dp[i] += dp[i - coin]

    return dp[n]",66
32042601179,substring_count,"def substring_count(string, substring):
    count = 0
    index = 0
    while index < len(string):
        found = string.find(substring, index)
        if found != -1:
            count += 1
            index = found + 1
        else:
            break
    return count",66
72693932690,count_combinations,"def count_combinations(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]
    return dp[amount]",65
38901940081,majority_element,"def majority_element(arr):
    count = 0
    candidate = None

    for num in arr:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    return candidate if arr.count(candidate) > len(arr) // 2 else -1",65
39035183278,smallest_abs_diff,"def smallest_abs_diff(numbers):
    numbers.sort()
    min_diff = abs(numbers[1] - numbers[0])
    for i in range(2, len(numbers)):
        diff = abs(numbers[i] - numbers[i-1])
        if diff < min_diff:
            min_diff = diff
    return min_diff",65
4502941583,first_non_repeated_integer,"def first_non_repeated_integer(list1):
    dic = {}
    for i in list1:
        if i not in dic:
            dic[i] = 1
        else:
            dic[i] += 1
    for i in list1:
        if dic[i] == 1:
            return i",65
386936730,calculate,"def calculate(a, b, operator):
  if operator == '+':
    return a + b
  elif operator == '-':
    return a - b
  elif operator == '*':
    return a * b
  elif operator == '/':
    return a / b
  else:
    return ""Invalid operator""",65
33073018857,is_valid_pin_name,"import re

def is_valid_pin_name(pin_name):
    pattern = r'^[a-zA-Z]+[a-zA-Z0-9]*(_[a-zA-Z0-9]+)?$|^[a-zA-Z]+[a-zA-Z0-9]*$'
    return bool(re.match(pattern, pin_name))",65
35128331643,find_leaders,"def find_leaders(array):
    max_right = array[-1]
    leaders = [max_right]
    for i in range(len(array)-2, -1, -1):
        if array[i] > max_right:
            leaders.append(array[i])
            max_right = array[i]
    return leaders[::-1]",65
40673625665,count_change,"def count_change(coins, amount):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]
    return dp[amount]",65
74188050317,max_Product,"def max_Product(arr):
    arr.sort()
    # The maximum product can be either (maximum * second maximum * third maximum)
    # or (minimum * second minimum * maximum) 
    return max(arr[0]*arr[1]*arr[-1], arr[-1]*arr[-2]*arr[-3])",65
9609252313,stock_Profit,"def stock_Profit(prices):
    if not prices:
        return 0
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit",65
14199307900,count_change,"def count_change(money, coins):
    ways = [0] * (money + 1)
    ways[0] = 1
    for coin in coins:
        for i in range(coin, money + 1):
            ways[i] += ways[i - coin]
    return ways[money]",65
11577779835,gray_to_binary,"def gray_to_binary(gray_code):
    binary = gray_code[0]
    for i in range(1, len(gray_code)):
        if gray_code[i] == binary[i-1]:
            binary += gray_code[i]
        else:
            binary += str(1 - int(binary[i-1]))
    return binary",65
13447823504,has_zero_sum_subarray,"def has_zero_sum_subarray(arr):
    sum_set = set()
    sum_set.add(0)
    curr_sum = 0
    for i in range(len(arr)):
        curr_sum += arr[i]
        if curr_sum in sum_set:
            return True
        sum_set.add(curr_sum)
    return False",65
3458550161,is_sorted_with_k_difference,"def is_sorted_with_k_difference(arr, k):
  if len(arr) <= 1:
    return True
  for i in range(1, len(arr)):
    if arr[i] <= arr[i-1] or arr[i] - arr[i-1] > k:
      return False
  return True",65
23479443230,find_Longest_Common_Prefix,"def find_Longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",65
33742092895,find_PrimeFactors,"def find_PrimeFactors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",65
20069519060,change_making,"def change_making(coins, target):
    ways = [0] * (target + 1)
    ways[0] = 1
    for coin in coins:
        for i in range(coin, target + 1):
            ways[i] += ways[i - coin]
    return ways[target]",65
34971591683,ways_to_change,"def ways_to_change(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]
    return dp[amount]",65
42346067132,convert_base,"def convert_base(num, to_base=10):
    conv_string = ""0123456789ABCDEF""
    if num < to_base:
        return conv_string[num]
    else:
        return convert_base(num // to_base, to_base) + conv_string[num % to_base]",65
35025008725,find_next_greater,"def find_next_greater(arr):
    stack = []
    result = [-1]*len(arr)
    
    for i in range(len(arr)):
        while stack and arr[i] > arr[stack[-1]]:
            prev = stack.pop()
            result[prev] = arr[i]
        stack.append(i)

    return result",65
33335303002,largest_adjacent_product,"def largest_adjacent_product(nums):
    max_product = nums[0] * nums[1]
    for i in range(1, len(nums) - 1):
        product = nums[i] * nums[i + 1]
        if product > max_product:
            max_product = product
    return max_product",65
23277629697,no_of_balanced_parentheses,"def no_of_balanced_parentheses(n):
    if n <= 0:
        return 1
    result = 0
    for i in range(n):
        result += no_of_balanced_parentheses(i) * no_of_balanced_parentheses(n - 1 - i)
    return result",65
28847838823,mode,"from collections import Counter

def mode(lst):
    num_counts = Counter(lst)
    max_count = max(num_counts.values())
    modes = [num for num, count in num_counts.items() if count == max_count]
    if len(modes) == len(lst):
        return None
    return max(modes)",65
18716423153,reverse_list_in_place,"def reverse_list_in_place(input_list):
    left = 0
    right = len(input_list) - 1
    while left < right:
        input_list[left], input_list[right] = input_list[right], input_list[left]
        left += 1
        right -= 1
    return input_list",65
6367732789,getPairsCount,"def getPairsCount(arr, n, k):
    h = {}
    count = 0
    for i in range(len(arr)):
        if k-arr[i] in h:
            count+=h[k-arr[i]]
        h[arr[i]] = h.get(arr[i],0)+1
    return count",65
3987578825,check_arithmetic_progression,"def check_arithmetic_progression(lst):
    if len(lst) < 2:
        return False
    diff = lst[1] - lst[0]
    for i in range(2, len(lst)):
        if lst[i] - lst[i-1] != diff:
            return False
    return True",65
21303509709,find_nearest_smaller,"def find_nearest_smaller(arr):
    stack = []
    result = []
    for num in arr:
        while stack and stack[-1] >= num:
            stack.pop()
        if not stack:
            result.append(None)
        else:
            result.append(stack[-1])
        stack.append(num)
    return result",65
6127366394,pattern_count,"def pattern_count(text, pattern):
    count = 0
    start = 0
    while start < len(text):
        index = text.find(pattern, start)
        if index != -1:
            count += 1
            start = index + 1
        else:
            break
    return count",65
31212605823,smallest_repeating_cycle,"def smallest_repeating_cycle(s):
    n = len(s)
    for i in range(1, n // 2 + 1):
        if n % i == 0:
            cycle = s[:i]
            if cycle * (n // i) == s:
                return i
    return -1",65
40450833462,majorityElement,"def majorityElement(nums):
    dict={}
    count=0
    res=0
    for num in nums:
        if num in dict:
            dict[num]+=1
        else:
            dict[num]=1
        if count < dict[num]:
            count=dict[num];
            res=num
    return res;",65
36814658125,count_subarrays_with_sum,"def count_subarrays_with_sum(arr, k):
    count = 0
    n = len(arr)
    for i in range(n):
        sum = 0
        for j in range(i, n):
            sum += arr[j]
            if sum == k:
                count += 1
    return count",65
7398690422,is_leap_year,"def is_leap_year(year):
    if year % 4 == 0:
        if year % 100 == 0:
            if year % 400 == 0:
                return True
            else:
                return False
        else:
            return True
    else:
        return False",65
70433904756,make_change,"def make_change(coins, amount):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]
    return dp[amount]",65
11384721241,change_making,"def change_making(amount, coins):
    ways = [0] * (amount + 1)
    ways[0] = 1
    for coin in coins:
        for i in range(coin, amount + 1):
            ways[i] += ways[i - coin]
    return ways[amount]",65
40285559947,ways_to_change,"def ways_to_change(amount, coins):
    ways = [0] * (amount + 1)
    ways[0] = 1
    for coin in coins:
        for i in range(coin, amount + 1):
            ways[i] += ways[i - coin]
    return ways[amount]",65
31941197410,min_operations_to_anagram,"def min_operations_to_anagram(str1: str, str2: str) -> int:
    from collections import Counter
    counter1 = Counter(str1)
    counter2 = Counter(str2)
    diff = (counter1 - counter2) + (counter2 - counter1)
    return sum(diff.values())",65
32254353376,lcm,"def lcm(x, y):
   if x > y:
       greater = x
   else:
       greater = y

   while(True):
       if((greater % x == 0) and (greater % y == 0)):
           lcm = greater
           break
       greater += 1

   return lcm",65
16311300850,consecutive_count,"def consecutive_count(lst, element):
    count = 0
    max_count = 0
    for i in range(len(lst)):
        if lst[i] == element:
            count += 1
            max_count = max(max_count, count)
        else:
            count = 0
    return max_count",65
70994593887,is_binary_list,"def is_binary_list(binary_str):
  k = 0
  while k < len(binary_str):
    if k == len(binary_str) - 1:
      return True
    if binary_str[k] == '0':
      k += 1
    else:
      k += 2
  return False",65
761734677,concatenate_neighbors,"def concatenate_neighbors(strings):
    if len(strings) == 1:
        return [strings[0] * 2]
    result = []
    for i in range(len(strings)):
        next_index = (i + 1) % len(strings)
        result.append(strings[i] + strings[next_index])
    return result",65
21878374286,find_longest_prefix,"def find_longest_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other_str in strs:
            if other_str[i] != char:
                return shortest_str[:i]
    return shortest_str",65
5981681939,max_adjacent_product,"def max_adjacent_product(numbers):
    max_product = numbers[0] * numbers[1]
    for i in range(1, len(numbers) - 1):
        product = numbers[i] * numbers[i + 1]
        if product > max_product:
            max_product = product
    return max_product",65
71634378648,max_stock_profit,"def max_stock_profit(prices):
    if not prices:
        return 0

    min_price = float('inf')
    max_profit = 0

    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)

    return max_profit",65
73187325560,combinations,"def combinations(arr, k):
    if k == 0:
        return [[]]
    if not arr:
        return []
    
    result = []
    for i in range(len(arr)):
        for sub in combinations(arr[i+1:], k-1):
            result.append([arr[i]] + sub)
    return result",65
35416216079,numTrees,"def numTrees(n):
    if n <= 1:
        return 1
    total = 0
    for i in range(1, n + 1):
        left = numTrees(i - 1)
        right = numTrees(n - i)
        total += left * right
    return total",65
27064419187,missing_positive,"def missing_positive(arr):
    arr = [x for x in arr if x > 0]
    arr.sort()
    smallest_positive = 1
    for num in arr:
        if num == smallest_positive:
            smallest_positive += 1
        elif num > smallest_positive:
            break
    return smallest_positive",65
42931549012,nearest_smaller_left,"def nearest_smaller_left(arr):
    stack = []
    result = []
    for x in arr:
        while stack and stack[-1] >= x:
            stack.pop()
        if not stack:
            result.append(-1)
        else:
            result.append(stack[-1])
        stack.append(x)
    return result",65
10294598577,second_largest,"def second_largest(numbers):
    max_num = second_max = float('-inf')
    for num in numbers:
        if num > max_num:
            second_max = max_num
            max_num = num
        elif num > second_max and num != max_num:
            second_max = num
    return second_max",65
33196572842,max_product_adjacent,"def max_product_adjacent(lst):
    max_product = lst[0] * lst[1]
    for i in range(1, len(lst) - 1):
        product = lst[i] * lst[i + 1]
        if product > max_product:
            max_product = product
    return max_product",65
72714551349,missing_positive,"def missing_positive(arr):
    arr = [x for x in arr if x > 0]
    arr.sort()
    smallest_missing = 1
    for num in arr:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",65
15630361739,rearrange_list,"def rearrange_list(A):
    i = 0
    odd = []
    even = []
    while i < len(A):
        if A[i] % 2 == 0:
            even.append(A[i])
        else:
            odd.append(A[i])
        i += 1
    return even + odd",65
40500023844,deck_revealed_increasing,"from collections import deque

def deck_revealed_increasing(deck):
    deck.sort(reverse = True)
    dq = deque()
    for n in deck:
        if not dq:
            dq.append(n)
        else:
            dq.appendleft(dq.pop())
            dq.appendleft(n)
    return list(dq)",65
38287037136,max_adjacent_product,"def max_adjacent_product(nums):
    max_product = nums[0] * nums[1]
    for i in range(1, len(nums) - 1):
        product = nums[i] * nums[i + 1]
        if product > max_product:
            max_product = product
    return max_product",65
21367093089,duplicate_count,"def duplicate_count(text):
    text = text.lower()
    count = {}
    for char in text:
        if char in count:
            count[char] += 1
        else:
            count[char] = 1
    return sum(1 for char, freq in count.items() if freq > 1)",65
11016255366,smallest_missing,"def smallest_missing(nums):
    nums = [num for num in nums if num > 0]
    nums.sort()
    smallest_missing = 1
    for num in nums:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",65
6289150954,count_pattern,"def count_pattern(text, pattern):
    count = 0
    index = 0
    while index < len(text):
        found = text.find(pattern, index)
        if found != -1:
            count += 1
            index = found + 1
        else:
            break
    return count",65
4730839424,max_product_adjacent,"def max_product_adjacent(arr):
    max_product = arr[0] * arr[1]
    for i in range(1, len(arr) - 1):
        product = arr[i] * arr[i + 1]
        if product > max_product:
            max_product = product
    return max_product",65
33960131947,bubble_sort_desc,"def bubble_sort_desc(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] < arr[j+1] :
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr",65
16168514826,find_next_greater,"def find_next_greater(arr):
    result = [-1]*len(arr)
    stack = []
    
    for i in range(len(arr)):
        while stack and arr[i] > arr[stack[-1]]:
            idx = stack.pop()
            result[idx] = arr[i]
        stack.append(i)
    
    return result",65
25428023058,is_monotonic,"def is_monotonic(A):
    increasing = decreasing = True
    for i in range(len(A) - 1):
        if A[i] > A[i + 1]:
            increasing = False
        if A[i] < A[i + 1]:
            decreasing = False
    return increasing or decreasing",65
39853574196,max_adjacent_product,"def max_adjacent_product(nums):
    max_product = nums[0] * nums[1]
    for i in range(1, len(nums) - 1):
        product = nums[i] * nums[i + 1]
        if product > max_product:
            max_product = product
    return max_product",65
35158817153,max_number_delete,"def max_number_delete(n):
    str_n = str(n)
    max_num = 0
    for i in range(len(str_n)):
        new_num = int(str_n[:i] + str_n[i+1:])
        if new_num > max_num:
            max_num = new_num
    return max_num",65
948465171,average_divisible,"def average_divisible(numbers, divisor):
    sum = 0
    count = 0
    for number in numbers:
        if number % divisor == 0:
            sum += number
            count += 1
    if count == 0:
        return 0.0
    return sum / count",65
3914897471,bubble_sort_desc,"def bubble_sort_desc(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] < arr[j+1] :
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr",65
10368252093,change_making,"def change_making(amount, coins):
    ways = [0] * (amount + 1)
    ways[0] = 1
    for coin in coins:
        for i in range(coin, amount + 1):
            ways[i] += ways[i - coin]
    return ways[amount]",65
29202581799,next_greatest_element,"def next_greatest_element(nums):
    stack = []
    result = [-1] * len(nums)
    for i in range(len(nums)):
        while stack and nums[i] > nums[stack[-1]]:
            index = stack.pop()
            result[index] = nums[i]
        stack.append(i)
    return result",65
22790846075,max_avg_subarray,"def max_avg_subarray(nums, k):
    if len(nums)==k: return sum(nums)/k
    largest=sum_=sum(nums[:k])
    for i in range(k,len(nums)):
        sum_=sum_+nums[i]-nums[i-k]
        largest=max(sum_,largest)
    return largest/k",65
23637014104,fibonacci_memo,"def fibonacci_memo(n, memo={}):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    elif n not in memo:
        memo[n] = fibonacci_memo(n-1) + fibonacci_memo(n-2)
    return memo[n]",65
7258846706,next_greater_elements,"def next_greater_elements(arr):
    stack = []
    res = [-1] * len(arr)

    for i, t in enumerate(arr):
        while stack and t > arr[stack[-1]]:
            stackInd = stack.pop()
            res[stackInd] = t
        stack.append(i)
    return res",65
17740649596,smallest_divisible,"def smallest_divisible(n):
    from math import gcd
    def lcm(a, b):
        return a * b // gcd(a, b)
    lcm_value = 1
    for i in range(1, n + 1):
        lcm_value = lcm(lcm_value, i)
    return lcm_value",65
27019924005,find_median,"def find_median(nums1, nums2):
    nums = sorted(nums1 + nums2)
    if len(nums) % 2 == 0:
        return (nums[len(nums)//2 - 1] + nums[len(nums)//2]) / 2
    else:
        return nums[len(nums)//2]",65
31083225684,check_ip,"def check_ip(ip):
    numbers = ip.split('.')
    if len(numbers) != 4:
        return False
    for num in numbers:
        if not num.isdigit():
            return False
        if int(num) < 0 or int(num) > 255:
            return False
    return True",65
35206895861,prime_in_range,"def prime_in_range(start, end):
    primes = []
    for num in range(start, end+1):
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    return primes",65
22525377557,maxSubArraySum,"def maxSubArraySum(nums):
    max_ending_here = max_so_far = nums[0]
    for x in nums[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far",65
1790207745,find_prime_numbers,"def find_prime_numbers(n):
    if n < 2:
        return []
    primes = [2]
    for num in range(3, n+1, 2):
        if all(num % p != 0 for p in primes if p * p <= num):
            primes.append(num)
    return primes",65
26632371978,coin_combinations,"def coin_combinations(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]
    return dp[amount]",65
3631881401,climbStairs,"def climbStairs(n: int) -> int:
    if n <= 2:
        return n
    first, second = 1, 2
    for _ in range(3, n + 1):
        third = first + second
        first, second = second, third
    return second",65
38432488976,find_max_profit,"def find_max_profit(stock_span):
    max_profit = 0
    for i in range(len(stock_span)):
        for j in range(i+1, len(stock_span)):
            profit = stock_span[j] - stock_span[i]
            if profit > max_profit:
                max_profit = profit
    return max_profit",65
33078482817,fibonacci_sum,"def fibonacci_sum(n):
    if n <= 0:
        return 0
    a, b = 0, 1
    total = 1
    for _ in range(2, n+1):
        a, b = b, a + b
        total += b
    return total",65
3474072484,num_consecutive_sum_ways,"def num_consecutive_sum_ways(n):
    ways = 0
    for i in range(1, n+1):
        sum = 0
        while sum < n:
            sum += i
            i += 1
        if sum == n:
            ways += 1
    return ways",65
16867445232,is_happy_number,"def is_happy_number(n):
    def get_next_number(n):
        return sum(int(char) ** 2 for char in str(n))
    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next_number(n)
    return n == 1",65
72751647105,climbStairs,"def climbStairs(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    a, b = 1, 2
    for i in range(2, n):
        a, b = b, a + b
    return b",65
31691853480,find_first_unique_char,"def find_first_unique_char(s):
    seen = {}
    duplicate = set()
    
    for char in s:
        if char in seen:
            duplicate.add(char)
        else:
            seen[char] = 1
    
    for char in s:
        if char not in duplicate:
            return char
    return """"",65
23506576069,ways_to_make_change,"def ways_to_make_change(n, coins):
    dp = [0] * (n + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, n + 1):
            dp[x] += dp[x - coin]
    return dp[n]",65
32882429108,multiply,"def multiply(x, y):
    result = 0
    positive = (x > 0) is (y > 0)
    x, y = abs(x), abs(y)
    while y > 0:
        result += x
        y -= 1
    return result if positive else -result",65
25273091082,count_odd_product_pairs,"def count_odd_product_pairs(nums):
    count = 0
    odd_nums = [num for num in nums if num % 2 != 0]
    for i in range(len(odd_nums)):
        for j in range(i+1, len(odd_nums)):
            count += 1
    return count",65
37235992320,max_stock_profit,"def max_stock_profit(prices):
    if not prices:
        return 0
    min_price = prices[0]
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit",65
43309544049,fib_seq,"def fib_seq(n):
    if n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    else:
        fib_list = fib_seq(n-1)
        fib_list.append(fib_list[-1] + fib_list[-2])
        return fib_list",65
74992079799,find_median,"def find_median(nums1, nums2):
    nums = sorted(nums1 + nums2)
    if len(nums) % 2 == 0:
        return (nums[len(nums)//2] + nums[len(nums)//2 - 1]) / 2
    else:
        return nums[len(nums)//2]",65
24790863637,min_diff,"def min_diff(arr):
    arr.sort()
    min_diff = arr[1] - arr[0]
    for i in range(1, len(arr)):
        if arr[i] - arr[i-1] < min_diff:
            min_diff = arr[i] - arr[i-1]
    return min_diff",65
34285716857,consecutive_count,"def consecutive_count(lst):
    counts = []
    count = 1
    for i in range(1, len(lst)):
        if lst[i] == lst[i-1]:
            count += 1
        else:
            counts.append(count)
            count = 1
    counts.append(count)
    return counts",65
28990372253,maxProfit,"def maxProfit(prices):
    if not prices:
        return 0
    
    min_price = prices[0]
    max_profit = 0
    
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    
    return max_profit",65
7354786733,is_Anagram,"def is_Anagram(str1, str2):
    # Removing spaces and converting strings to lowercase
    str1 = str1.replace("" "", """").lower()
    str2 = str2.replace("" "", """").lower()
    
    # Check if sorted strings are equal
    return sorted(str1) == sorted(str2)",65
7446116229,count_partitions,"def count_partitions(n, k):
    if n == 0:
        return 1
    if n < 0 or k == 0:
        return 0
    
    # Count the partitions including k and excluding k
    return count_partitions(n-k, k) + count_partitions(n, k-1)",65
13478429081,second_highest,"def second_highest(nums):
    highest = second_highest = float('-inf')
    for num in nums:
        if num > highest:
            second_highest = highest
            highest = num
        elif num > second_highest and num != highest:
            second_highest = num
    return second_highest",65
19822079704,count_divisible_pairs,"def count_divisible_pairs(arr, divisor):
    remainder_counts = [0] * divisor
    count = 0
    for num in arr:
        remainder = num % divisor
        count += remainder_counts[(divisor - remainder) % divisor]
        remainder_counts[remainder] += 1
    return count",65
39530521152,max_adjacent_product,"def max_adjacent_product(lst):
    max_product = lst[0] * lst[1]
    for i in range(1, len(lst) - 1):
        product = lst[i] * lst[i + 1]
        if product > max_product:
            max_product = product
    return max_product",65
20744584179,max_adjacent_product,"def max_adjacent_product(arr):
    max_product = arr[0] * arr[1]
    for i in range(1, len(arr) - 1):
        product = arr[i] * arr[i + 1]
        if product > max_product:
            max_product = product
    return max_product",65
42460289389,calculate_triangle_area,"import math

def calculate_triangle_area(a, b, c):
    # Calculate the semi-perimeter
    s = (a + b + c) / 2
    # Calculate the area using Heron's formula
    area = math.sqrt(s*(s-a)*(s-b)*(s-c))
    return area",65
75280908526,first_non_repeating_character,"def first_non_repeating_character(string):
    from collections import OrderedDict
    dictionary=OrderedDict()
    for i in string:
        if i in dictionary:
            dictionary[i]+=1
        else:
            dictionary[i]=1
    for key, value in dictionary.items():
        if value==1:
            return key",65
38099907052,isToeplitz,"def isToeplitz(matrix):
    m = len(matrix)
    n = len(matrix[0])
    for i in range(1, m):
        for j in range(1, n):
            if matrix[i][j] != matrix[i-1][j-1]:
                return False
    return True",65
25002940186,missing_positive,"def missing_positive(arr):
    arr = [num for num in arr if num > 0]
    arr.sort()
    smallest_missing = 1
    for num in arr:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",65
43572026226,smallest_missing,"def smallest_missing(arr):
    arr = [num for num in arr if num > 0]
    arr.sort()
    smallest_missing = 1
    for num in arr:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",65
31827091340,is_leap_year,"def is_leap_year(year):
    if year % 4 == 0:
        if year % 100 == 0:
            if year % 400 == 0:
                return True
            else:
                return False
        else:
            return True
    else:
        return False",65
11014985686,is_rotation,"def is_substring(str1, str2):
    return str1.find(str2) != -1

def is_rotation(str1, str2):
    if len(str1) != len(str2):
        return False
    temp = str1 + str1
    return is_substring(temp, str2)",65
72464140788,count_substring_occurrences,"def count_substring_occurrences(string, substring):
    count = 0
    index = 0
    while index < len(string):
        index = string.find(substring, index)
        if index == -1:
            break
        count += 1
        index += 1
    return count",64
1694465326,smallest_difference,"def smallest_difference(lst):
    lst.sort()
    min_diff = abs(lst[1] - lst[0])
    for i in range(2, len(lst)):
        diff = abs(lst[i] - lst[i-1])
        if diff < min_diff:
            min_diff = diff
    return min_diff",64
30409554062,find_max_sum,"def find_max_sum(k, arr):
    max_sum = sum(arr[:k])
    current_sum = max_sum
    for i in range(k, len(arr)):
        current_sum = current_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, current_sum)
    return max_sum",64
41441631449,is_valid_decimal,"def is_valid_decimal(s: str) -> bool:
    s = s.strip()
    try:
        if s.lower() == 'inf' or s.lower() == '-inf' or s.lower() == 'nan':
            return False
        float(s)
        return True
    except ValueError:
        return False",64
14444642452,bubble_sort,"def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1] :
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr",64
35630771839,is_monotonic,"def is_monotonic(lst):
    increasing = decreasing = True
    for i in range(1, len(lst)):
        if lst[i] > lst[i - 1]:
            decreasing = False
        elif lst[i] < lst[i - 1]:
            increasing = False
    return increasing or decreasing",64
32421446111,find_longest_common_prefix,"def find_longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",64
30413197555,next_greater_element,"def next_greater_element(lst):
    res = [-1] * len(lst)
    stack = []

    for i in range(len(lst)):
        while stack and lst[stack[-1]] < lst[i]:
            cur = stack.pop()
            res[cur] = lst[i]
        stack.append(i)

    return res",64
22962479512,padovan,"def padovan(n):
    if n <= 2:
        return 1
    a, b, c = 1, 1, 1
    for _ in range(3, n + 1):
        a, b, c = b, c, a + b
    return c",64
16044040810,count_ways_to_climb,"def count_ways_to_climb(n):
    if n <= 1:
        return 1
    first, second = 1, 1
    for i in range(2, n + 1):
        third = first + second
        first, second = second, third
    return second",64
73898640821,binary_representation,"def binary_representation(n):
    answer = []
    for num in range(n):
        bin_ = """"
        while num > 0:
            bin_ += str(num % 2)
            num = num // 2
        answer.append(bin_[::-1] if bin_ else '0')
    return answer",64
2804321371,max_elements_within_limit,"def max_elements_within_limit(arr, limit):
    arr.sort()
    count = 0
    sum = 0
    for i in range(len(arr)):
        if sum + arr[i] <= limit:
            sum += arr[i]
            count += 1
        else:
            break
    return count",64
22884677183,bubbleSort,"def bubbleSort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1] :
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr",64
21085478344,numberOfWays,"def numberOfWays(n):
    if n == 1 or n == 2:
        return n
    first, second = 1, 2
    for i in range(3, n+1):
        third = first + second
        first, second = second, third
    return second",64
72128299544,descending_sort,"def descending_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] < arr[j+1] :
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr",64
7210339914,is_monotonic,"def is_monotonic(array):
    increasing = decreasing = True
    
    for i in range(1, len(array)):
        if array[i] > array[i - 1]:
            decreasing = False
        if array[i] < array[i - 1]:
            increasing = False
            
    return increasing or decreasing",64
42388822623,is_arithmetic_sequence,"def is_arithmetic_sequence(nums):
    if len(nums) < 2:
        return False
    diff = nums[1] - nums[0]
    for i in range(2, len(nums)):
        if nums[i] - nums[i-1] != diff:
            return False
    return True",64
30646453521,adjacent_max_product,"def adjacent_max_product(lst):
    max_product = lst[0] * lst[1]
    for i in range(1, len(lst) - 1):
        product = lst[i] * lst[i + 1]
        if product > max_product:
            max_product = product
    return max_product",64
12352058559,make_change,"def make_change(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]

    return dp[amount]",64
40123400760,find_longest_palindrome,"def is_palindrome(word):
    return word == word[::-1]

def find_longest_palindrome(words):
    longest_palindrome = """"
    for word in words:
        if is_palindrome(word) and len(word) > len(longest_palindrome):
            longest_palindrome = word
    return longest_palindrome",64
702064076,fibonacci_series,"def fibonacci_series(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    fib = [0, 1]
    for i in range(2, n):
        fib.append(fib[i-1] + fib[i-2])
    return fib",64
28160155909,largest_Sum_Non_Adjacent,"def largest_Sum_Non_Adjacent(nums):
    incl = 0
    excl = 0

    for i in nums:
        new_excl = excl if excl>incl else incl

        incl = excl + i
        excl = new_excl

    return max(incl, excl)",64
10234880697,find_second_smallest,"def find_second_smallest(numbers):
    m1, m2 = float('inf'), float('inf')
    for x in numbers:
        if x <= m1:
            m1, m2 = x, m1
        elif x < m2:
            m2 = x
    return m2",64
14736329699,find_common_prefix,"def find_common_prefix(strlist):
    if not strlist:
        return ''
    shortest_str = min(strlist, key=len)
    for i, char in enumerate(shortest_str):
        for other in strlist:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",64
17125958517,find_longest_common_prefix,"def find_longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",64
74301114265,longestCommonPrefix,"def longestCommonPrefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other_str in strs:
            if other_str[i] != char:
                return shortest_str[:i]
    return shortest_str",64
15520845459,is_monotonic,"def is_monotonic(A):
    increasing = decreasing = True
    for i in range(1, len(A)):
        if A[i] > A[i - 1]:
            decreasing = False
        elif A[i] < A[i - 1]:
            increasing = False
    return increasing or decreasing",64
15465886166,twoSum,"def twoSum(nums, target):
    num_dict = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_dict:
            return [num_dict[complement] + 1, i + 1]
        num_dict[num] = i
    return []",64
1821813423,sum_of_squares,"def sum_of_squares(lst):
    """"""
    Calculate the sum of squares of all the elements in a given list.

    :param lst: A list of numbers
    :return: The sum of squares of all the numbers in the list
    """"""
    return sum(x ** 2 for x in lst)",64
20352392117,first_non_repeating_char,"def first_non_repeating_char(str1):
  dict = {}
  for i in str1:
    if i in dict:
      dict[i] += 1
    else:
      dict[i] = 1
  for i in str1:
    if dict[i] == 1:
      return i",64
35072768165,max_sub_array,"def max_sub_array(arr):
    max_ending_here = max_so_far = arr[0]
    for x in arr[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far",64
2731991067,largest_palindrome,"def largest_palindrome(numbers):
    def is_palindrome(number):
        return str(number) == str(number)[::-1]

    palindromes = [num for num in numbers if is_palindrome(num)]
    if not palindromes:
        return None
    return max(palindromes)",64
16969623151,find_prime_factors,"def find_prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",64
20528331260,sort_by_parity,"def sort_by_parity(nums):
    even_nums = [num for num in nums if num % 2 == 0]
    odd_nums = [num for num in nums if num % 2 != 0]
    even_nums.sort()
    odd_nums.sort(reverse=True)
    return even_nums + odd_nums",64
25208970380,find_non_repeated,"def find_non_repeated(s):
    count = {}

    for char in s:
        if char in count:
            count[char] += 1
        else:
            count[char] = 1

    for char in s:
        if count[char] == 1:
            return char

    return None",64
30146685856,check_parentheses,"def check_parentheses(a:str)->bool:
    result=[]
    for i in a:
        if i==""("":
            result.append(""("")
        else:
            try:
                result.pop()
            except:
                return False
    if len(result)==0:
        return True
    else:
        return False",64
14403131719,can_construct_ransom_note,"from collections import Counter

def can_construct_ransom_note(ransomNote, magazine):
    ransomNoteCount = Counter(ransomNote)
    magazineCount = Counter(magazine)
    
    for char in ransomNoteCount:
        if magazineCount[char] < ransomNoteCount[char]:
            return False
    return True",64
8047933707,maxProfit,"def maxProfit(prices):
    if not prices:
        return 0

    min_price = prices[0]
    max_profit = 0

    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)

    return max_profit",64
38413874182,change_making,"def change_making(target, coins):
    ways = [0] * (target + 1)
    ways[0] = 1
    for coin in coins:
        for i in range(coin, target + 1):
            ways[i] += ways[i - coin]
    return ways[target]",64
70670510932,next_greater_element,"def next_greater_element(arr):
    result = [-1] * len(arr)
    stack = []
    for i in range(len(arr)):
        while stack and arr[i] > arr[stack[-1]]:
            idx = stack.pop()
            result[idx] = arr[i]
        stack.append(i)
    return result",64
6504611486,largest_sum_contiguous_subarray,"def largest_sum_contiguous_subarray(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",64
18587820911,valid_parentheses,"def valid_parentheses(paren_str):
    stack = []
    for char in paren_str:
        if char == ""("":
            stack.append(char)
        elif char == "")"":
            if len(stack) == 0:
                return False
            else:
                stack.pop()
    return len(stack) == 0",64
34940599321,detect_duplicates,"def detect_duplicates(nums):
    mp = {}
    for n in nums:
        if n in mp:
            mp[n] += 1
        else:
            mp[n] = 1
    duplicates = {k: v for k, v in mp.items() if v > 1}
    return duplicates",64
19736060244,can_form_triangle,"def can_form_triangle(A):
    if len(A) < 3:
        return 0
    A.sort()
    for i in range(len(A) - 2):
        if A[i] + A[i + 1] > A[i + 2]:
            return 1
    return 0",64
31474674828,largest_cont_sum,"def largest_cont_sum(arr):
    if len(arr)==0:
        return 0
    max_sum = current_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(current_sum, max_sum)
    return max_sum",64
31368300286,change_making,"def change_making(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1
        
    for i in coins:
        for j in range(i, amount + 1):
            dp[j] += dp[j - i]
    return dp[amount]",64
15432615120,centered_heptagonal,"def centered_heptagonal(n):
    """"""
    Calculate the nth centered heptagonal number.
    
    :param n: The position of the number in the sequence.
    :return: The nth centered heptagonal number.
    """"""
    return 7 * n * n - 7 * n + 1",64
70223442557,find_max_subarray_sum,"def find_max_subarray_sum(nums):
    if not nums:
        return 0

    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",64
6279428306,find_longest_common_prefix,"def find_longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",64
72014225917,coin_change,"def coin_change(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]
    return dp[amount]",64
3399500307,largest_Fibonacci,"def largest_Fibonacci(n):
    if n == 0:
        return 0
    fib1, fib2 = 0, 1
    while fib2 <= n:
        temp = fib2
        fib1, fib2 = fib2, fib1 + fib2
    return temp",64
18022001305,distinct_count,"def distinct_count(A):
    A = sorted(A)
    counter = 1
    if len(A) > 0:
        for i in range (1, len(A)):
            if A[i] != A[i-1]:
                counter +=1
        return counter

    else:
        return 0",64
74239941847,largest_sum_after_k_negations,"import heapq as hq

def largest_sum_after_k_negations(nums, k):
    hq.heapify(nums)
    
    while k != 0:
        value = hq.heappop(nums)
        hq.heappush(nums, -value)
        k -= 1
        
    return sum(nums)",64
14668901899,sort_tuple_list,"def sort_tuple_list(lst, n):
    for i in range(n):
        for j in range(0, n-i-1):
            if lst[j][1] > lst[j+1][1]:
                lst[j], lst[j+1] = lst[j+1], lst[j]
    return lst",64
7210804137,substring_count,"def substring_count(main_string, substring):
    count = 0
    index = 0
    while index < len(main_string):
        index = main_string.find(substring, index)
        if index == -1:
            break
        count += 1
        index += 1
    return count",64
38900691921,coin_change,"def coin_change(total, coins):
    dp = [0] * (total + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, total + 1):
            dp[x] += dp[x - coin]
    return dp[total]",64
30334829611,max_subarray,"def max_subarray(arr):
    max_ending_here = max_so_far = arr[0]
    for x in arr[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far",64
26734799858,check_consecutive,"def check_consecutive(A):
    if len(A) == 1 and A[0] == 1:
        return True
    A.sort()
    count = 1
    for i in A:
        if count != i:
            return False
        count = count + 1
    return True",64
39620200473,find_prime_factors,"def find_prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",64
38372436292,count_ways_to_climb_stairs,"def count_ways_to_climb_stairs(n):
    if n <= 1:
        return n
    first, second = 1, 2
    for _ in range(3, n+1):
        third = first + second
        first, second = second, third
    return second",64
22710160855,stock_profit,"def stock_profit(prices):
    if not prices:
        return 0
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit",64
40581213993,change_making,"def change_making(target, coins):
    ways = [0] * (target + 1)
    ways[0] = 1
    for coin in coins:
        for x in range(coin, target + 1):
            ways[x] += ways[x - coin]
    return ways[target]",64
2705546423,has_zero_sum_subarray,"def has_zero_sum_subarray(nums):
    seen_sums = set()
    total_sum = 0
    for num in nums:
        total_sum += num
        if total_sum == 0 or total_sum in seen_sums:
            return True
        seen_sums.add(total_sum)
    return False",64
15073606457,highest_product,"def highest_product(list_of_ints):
    list_of_ints.sort()
    return max(list_of_ints[0] * list_of_ints[1] * list_of_ints[-1], list_of_ints[-1] * list_of_ints[-2] * list_of_ints[-3])",64
45142254807,maximum_profit,"def maximum_profit(prices):
    if not prices:
        return 0
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit",64
38645492341,snake_to_camel,"def snake_to_camel(snake_str):
    components = snake_str.split('_')
    # We capitalize the first letter of each component except the first one
    # with the 'title' method and join them together.
    return components[0] + ''.join(x.title() for x in components[1:])",64
29882318162,find_max_subarray_sum,"def find_max_subarray_sum(nums):
    if not nums:
        return 0
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",64
2251879481,is_arithmetic_sequence,"def is_arithmetic_sequence(nums):
    if len(nums) < 2:
        return False
    diff = nums[1] - nums[0]
    for i in range(2, len(nums)):
        if nums[i] - nums[i-1] != diff:
            return False
    return True",64
43850355281,staircase,"def staircase(n):
    if n == 1 or n == 2:
        return n
    first = 1
    second = 2
    for i in range(3, n+1):
        third = first + second
        first = second
        second = third
    return third",64
74896177746,next_greater_element,"def next_greater_element(arr):
    stack = []
    result = [-1] * len(arr)
    for i in range(len(arr)):
        while stack and arr[i] > arr[stack[-1]]:
            index = stack.pop()
            result[index] = arr[i]
        stack.append(i)
    return result",64
1185925844,make_change,"def make_change(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]
    return dp[amount]",64
4527473192,isPalindrome,"def isPalindrome(s):
    length = 0
    temp = s
    while temp:
        temp = temp[1:]
        length += 1
    for i in range(length // 2):
        if s[i] != s[length - 1 - i]:
            return False
    return True",64
41407067952,factorial_trailing_zeros,"def factorial_trailing_zeros(n):
    if n < 0:
        raise ValueError(""Input must be a non-negative integer"")
    count = 0
    i = 5
    while n/i >= 1:
        count += int(n/i)
        i *= 5
    return int(count)",64
73203104059,is_toeplitz,"def is_toeplitz(matrix):
    row = len(matrix)
    col = len(matrix[0])
    for i in range(1,row):
        for j in range(1,col):
            if matrix[i][j] != matrix[i-1][j-1]:
                return False
    return True",64
40582123466,sum_of_unique_elements,"def sum_of_unique_elements(lst):
    unique_elements = set()
    duplicate_elements = set()
    for element in lst:
        if element in unique_elements:
            unique_elements.remove(element)
            duplicate_elements.add(element)
        elif element not in duplicate_elements:
            unique_elements.add(element)
    return sum(unique_elements)",64
74982490386,stock_profit,"def stock_profit(prices):
    if not prices:
        return 0
    min_price = prices[0]
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit",64
1272121400,find_first_duplicate,"def find_first_duplicate(numbers):
    ns = []
    for i in numbers:
        if i < 0 or i > len(numbers) - 1:
            return None
    for i in numbers:
        if i not in ns:
            ns.append(i)
        else:
            return i
    return None",64
26707398382,stock_profit,"def stock_profit(prices):
    if not prices:
        return 0
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit",64
69869705367,is_arithmetic_sequence,"def is_arithmetic_sequence(sequence):
    if len(sequence) < 2:
        return False
    difference = sequence[1] - sequence[0]
    for i in range(2, len(sequence)):
        if sequence[i] - sequence[i-1] != difference:
            return False
    return True",64
5380284127,stair_climbing_ways,"def stair_climbing_ways(n):
    if n <= 1:
        return 1
    first, second = 1, 1
    for i in range(2, n + 1):
        third = first + second
        first, second = second, third
    return second",64
33322683403,coin_change,"def coin_change(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]
    return dp[amount]",64
37580877412,maxProfit,"def maxProfit(prices):
    if not prices:
        return 0
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit",64
12234809770,is_valid_parentheses,"def is_valid_parentheses(s: str) -> bool:
    stack = []
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack or stack[-1] != '(':
                return False
            stack.pop()
    return not stack",64
14621559855,bubble_sort,"def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1] :
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr",64
74599225298,get_longest_common_prefix,"def get_longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",64
28266641343,find_max_sum_subarray,"def find_max_sum_subarray(nums):
    max_sum = nums[0]
    current_sum = nums[0]
    for i in range(1, len(nums)):
        current_sum = max(nums[i], current_sum + nums[i])
        max_sum = max(max_sum, current_sum)
    return max_sum",64
26789789620,coin_change,"def coin_change(amount, coins):
    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]
    return dp[amount]",64
30274323614,maxSubsequenceSum,"def maxSubsequenceSum(arr):
    max_so_far = max_ending_here = arr[0]
    for x in arr[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far,max_ending_here)
    return max_so_far",64
40657031851,primeFactorization,"def primeFactorization(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",64
14611103899,max_profit,"def max_profit(prices):
    if not prices:
        return 0
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit",64
380381092,is_arithmetic_sequence,"def is_arithmetic_sequence(lst):
    if len(lst) < 2:
        return False
    diff = lst[1] - lst[0]
    for i in range(2, len(lst)):
        if lst[i] - lst[i-1] != diff:
            return False
    return True",64
41874743474,max_profit,"def max_profit(prices):
    if not prices:
        return 0
    min_price = prices[0]
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit",64
32720856949,first_non_repeating,"def first_non_repeating(s):
    seen = {}
    for char in s:
        if char in seen:
            seen[char] += 1
        else:
            seen[char] = 1
    for char in s:
        if seen[char] == 1:
            return char
    return """"",64
29029552435,is_isogram,"def is_isogram(string):
    string = string.lower() # Convert the string to lowercase to ignore case sensitivity
    for char in string:
        if string.count(char) > 1 and char.isalpha(): # Check if the character is a letter and appears more than once
            return False
    return True",64
71230414006,find_Largest_Subarray_Sum,"def find_Largest_Subarray_Sum(nums):
    max_current = max_global = nums[0]
    for i in range(1,len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if(max_current > max_global):
            max_global = max_current
    return max_global",64
5313681056,check_monotonic,"def check_monotonic(lst):
    increasing = decreasing = True

    for i in range(1, len(lst)):
        if lst[i] > lst[i - 1]:
            decreasing = False
        elif lst[i] < lst[i - 1]:
            increasing = False

    return increasing or decreasing",64
12693176550,integer_break,"def integer_break(n: int) -> int:
    if n == 2:
        return 1
    if n == 3:
        return 2

    product = 1
    while n > 4:
        product *= 3
        n -= 3

    return product * n",64
70944371960,max_profit,"def max_profit(prices):
    if not prices:
        return 0
    min_price = prices[0]
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit",64
20512878334,max_profit,"def max_profit(prices):
    if not prices:
        return 0

    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)

    return max_profit",64
24589344654,largest_cont_sum,"def largest_cont_sum(arr):
    if len(arr)==0:
        return 0
    max_sum = current_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(current_sum+num, num)
        max_sum = max(current_sum, max_sum)
    return max_sum",64
74923389640,smallest_repeating_cycle,"def smallest_repeating_cycle(s):
    for i in range(1, len(s) // 2 + 1):
        if len(s) % i == 0:
            cycle = s[:i]
            if cycle * (len(s) // i) == s:
                return cycle
    return s",64
19514965350,max_Sum_Non_Adjacent,"def max_Sum_Non_Adjacent(arr):
    incl = 0
    excl = 0

    for i in arr:
        new_excl = excl if excl>incl else incl

        incl = excl + i
        excl = new_excl

    return max(excl, incl)",64
17601537402,max_sub_array,"def max_sub_array(nums):
    if not nums:
        return 0
    
    cur_sum = max_sum = nums[0]
    for num in nums[1:]:
        cur_sum = max(num, cur_sum + num)
        max_sum = max(max_sum, cur_sum)
    
    return max_sum",63
40771448935,bubble_sort,"def bubble_sort(nums):
    n = len(nums)
    for i in range(n):
        for j in range(0, n-i-1):
            if nums[j] > nums[j+1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]
    return nums",63
70607704928,highest_product,"def highest_product(nums):
    if len(nums) < 3:
        raise ValueError(""Input list must have at least three numbers"")
        
    nums.sort()
    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])",63
71442234342,smallest_repeating_subsequence,"def smallest_repeating_subsequence(s):
    length = len(s)
    for i in range(1, length//2+1):
        sub = s[:i]
        if sub * (length//len(sub)) + sub[:length%len(sub)] == s:
            return sub
    return s",63
8975214762,find_element_indices,"def find_element_indices(list_of_lists, element):
    occurrence_count = 0
    index_list = []
    for i, sublist in enumerate(list_of_lists):
        if element in sublist:
            occurrence_count += sublist.count(element)
            index_list.append(i)
    return (occurrence_count, index_list)",63
12213781073,bubble_sort,"def bubble_sort(lst):
    n = len(lst)
    for i in range(n):
        for j in range(0, n-i-1):
            if lst[j] > lst[j+1]:
                lst[j], lst[j+1] = lst[j+1], lst[j]
    return lst",63
18552039299,maxSubArraySum,"def maxSubArraySum(nums):
    if not nums:
        return 0
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",63
30389921135,bubble_sort,"def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr",63
8840230817,Longest_Common_Prefix,"def Longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs,key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",63
36322121339,max_subsequence_sum,"def max_subsequence_sum(nums):
    max_sum = 0
    current_sum = 0
    for num in nums:
        current_sum += num
        if current_sum < 0:
            current_sum = 0
        max_sum = max(max_sum, current_sum)
    return max_sum",63
39096452517,make_change,"def make_change(target, coins):
    dp = [0] * (target + 1)
    dp[0] = 1
    for coin in coins:
        for x in range(coin, target + 1):
            dp[x] += dp[x - coin]
    return dp[target]",63
27843133832,generate_permutations,"def generate_permutations(nums):
    if len(nums) == 1:
        return [nums]
    result = []
    for i in range(len(nums)):
        for perm in generate_permutations(nums[:i] + nums[i+1:]):
            result.append([nums[i]] + perm)
    return result",63
74612499131,group_anagrams,"from collections import defaultdict

def group_anagrams(strs):
    anagrams = defaultdict(list)
    for word in strs:
        # Sort the characters in the word and use it as the key
        key = ''.join(sorted(word))
        anagrams[key].append(word)
    return list(anagrams.values())",63
7210326464,find_min_max,"def find_min_max(lst):
    min_num = lst[0]
    max_num = lst[0]
    for num in lst:
        if num < min_num:
            min_num = num
        if num > max_num:
            max_num = num
    return (min_num, max_num)",63
38424644061,smallest_repeating_cycle,"def smallest_repeating_cycle(s):
    length = len(s)
    for i in range(1, length//2 + 1):
        if length % i == 0:
            cycle = s[:i]
            if cycle * (length // i) == s:
                return cycle
    return s",63
72837271817,sum_even_fibonacci,"def sum_even_fibonacci(limit):
    a, b = 1, 2
    total_sum = 0
    while b <= limit:
        if b % 2 == 0:
            total_sum += b
        a, b = b, a + b
    return total_sum",63
19726328437,find_max_subarray,"def find_max_subarray(nums):
    if not nums:
        return 0
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",63
6793716637,group_anagrams,"from collections import defaultdict

def group_anagrams(strs):
  anagrams = defaultdict(list)
  for word in strs:
    # Sort the characters in the word to get the anagram key
    key = ''.join(sorted(word))
    anagrams[key].append(word)
  return list(anagrams.values())",63
73396501915,sum_even_fibonacci,"def sum_even_fibonacci(limit):
    a, b = 1, 2
    total_sum = 0
    while b <= limit:
        if b % 2 == 0:
            total_sum += b
        a, b = b, a + b
    return total_sum",63
38835917607,bubble_sort,"def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr",63
74011387991,sum_even_fibonacci,"def sum_even_fibonacci(limit):
    a, b = 1, 2
    total_sum = 0
    while b <= limit:
        if b % 2 == 0:
            total_sum += b
        a, b = b, a + b
    return total_sum",63
31511836651,count_substring,"def count_substring(string, sub_string):
    count = 0
    index = 0
    while index < len(string):
        index = string.find(sub_string, index)
        if index == -1:
            break
        count += 1
        index += 1
    return count",63
37338505161,find_odd,"def find_odd(integers):
    counts = {}
    for num in integers:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1
    for num, count in counts.items():
        if count % 2 != 0:
            return num",63
33581672405,find_max_subarray,"def find_max_subarray(arr):
    max_sum = 0
    current_sum = 0
    for num in arr:
        current_sum += num
        if current_sum < 0:
            current_sum = 0
        max_sum = max(max_sum, current_sum)
    return max_sum",63
31957185904,bubble_sort,"def bubble_sort(nums):
    n = len(nums)
    for i in range(n):
        for j in range(0, n-i-1):
            if nums[j] > nums[j+1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]
    return nums",63
73103151460,count_odd_xor_pairs,"def count_odd_xor_pairs(arr):
    odd_count = 0
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if (arr[i] ^ arr[j]) % 2 != 0:
                odd_count += 1
    return odd_count",63
38084338026,is_valid_hex_color,"def is_valid_hex_color(color):
    valid_hex_chars = set('0123456789ABCDEFabcdef')
    if len(color) != 7 or color[0] != '#':
        return False
    return all(c in valid_hex_chars for c in color[1:])",63
24857790519,prime_factors,"def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",63
15170245993,sum_even_fibonacci,"def sum_even_fibonacci(limit):
    a, b = 1, 2
    total_sum = 0
    while b <= limit:
        if b % 2 == 0:
            total_sum += b
        a, b = b, a + b
    return total_sum",63
70183213465,find_longest_common_prefix,"def find_longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs,key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",63
18303197671,count_overlapping_substrings,"def count_overlapping_substrings(s, pattern):
    count = 0
    pos = 0
    while pos < len(s):
        pos = s.find(pattern, pos)
        if pos == -1:
            break
        count += 1
        pos += 1
    return count",63
13297006928,count_palindrome_substrings,"def count_palindrome_substrings(s):
    n = len(s)
    result = 0
    for i in range(n):
        for j in range(i, n):
            if s[i:j+1] == s[i:j+1][::-1]:
                result += 1
    return result",63
38047449230,count_substring,"def count_substring(string, sub_string):
    count = 0
    index = 0
    while index < len(string):
        index = string.find(sub_string, index)
        if index == -1:
            break
        count += 1
        index += 1
    return count",63
70726589561,longest_Common_Prefix,"def longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",63
9770788455,gray_code_sequence,"def gray_code_sequence(n: int):
    if n == 0:
        return [0]
    previous_sequence = gray_code_sequence(n-1)
    result = previous_sequence[:]
    mirror = [x + (1 << (n-1)) for x in reversed(previous_sequence)]
    return result + mirror",63
28247664667,primeFactors,"def primeFactors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",63
71064741757,find_max_subarray_sum,"def find_max_subarray_sum(nums):
    max_current = max_global = nums[0]
    for i in range(1, len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",63
74462440955,sum_even_fibonacci,"def sum_even_fibonacci(limit):
    a, b = 1, 2
    total_sum = 0
    while b <= limit:
        if b % 2 == 0:
            total_sum += b
        a, b = b, a + b
    return total_sum",63
15209922056,descending_sort,"def descending_sort(lst):
    n = len(lst)
    for i in range(n):
        for j in range(0, n-i-1):
            if lst[j] < lst[j+1]:
                lst[j], lst[j+1] = lst[j+1], lst[j]
    return lst",63
23794490820,count_word_occurrences,"import string

def count_word_occurrences(words, target):
    count = 0
    target = target.lower()
    for word in words:
        word = word.translate(str.maketrans('', '', string.punctuation)).lower()
        if word == target:
            count += 1
    return count",63
23794528480,permute,"def permute(nums):
    res = []
    def backtrack(path, choices):
        if not choices:
            res.append(path)
            return
        for i in range(len(choices)):
            backtrack(path + [choices[i]], choices[:i] + choices[i+1:])
    backtrack([], nums)
    return res",63
19952161319,prime_factors,"def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",63
37591849611,coinChange,"def coinChange(n, coins):
    dp = [0] * (n + 1)
    dp[0] = 1
    for coin in coins:
        for i in range(coin, n + 1):
            dp[i] += dp[i - coin]
    return dp[n]",63
2045332559,count_pattern_occurrences,"def count_pattern_occurrences(text, pattern):
    count = start = 0
    while start < len(text):
        pos = text.find(pattern, start)
        if pos != -1:
            start = pos + 1
            count += 1
        else:
            break
    return count",63
26666014345,longest_Common_Prefix,"def longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",63
42489245667,max_sub_array,"def max_sub_array(nums):
    if not nums:
        return 0

    current_sum = max_sum = nums[0]

    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
        
    return max_sum",63
21514331078,count_ways_to_climb,"def count_ways_to_climb(n):
    if n <= 1:
        return n
    first, second = 1, 2
    for _ in range(3, n + 1):
        third = first + second
        first, second = second, third
    return second",63
16380673568,find_unique_elements,"def find_unique_elements(nums):
    counts = {}
    for num in nums:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1
    unique_elements = [num for num in nums if counts[num] == 1]
    return unique_elements",63
9125433829,smallest_repeating_subsequence,"def smallest_repeating_subsequence(str1):
    length = len(str1)
    for i in range(1, length//2 + 1):
        subsequence = str1[:i]
        if subsequence * (length // i) == str1:
            return subsequence
    return str1",63
20064243552,product_using_recursion,"def product_using_recursion(a, b):
    if b == 0:
        return 0
    if b > 0:
        return (a + product_using_recursion(a, b - 1))
    if b < 0:
        return -product_using_recursion(a, -b)",63
32514006156,find_min_max,"def find_min_max(arr):
    min_num = arr[0]
    max_num = arr[0]
    for num in arr:
        if num < min_num:
            min_num = num
        elif num > max_num:
            max_num = num
    return (min_num, max_num)",63
70676322697,prime_factors,"def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",63
33339017785,find_max_subarray,"def find_max_subarray(nums):
    if not nums:
        return 0

    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",63
17190929791,find_odd,"def find_odd(integers):
    counts = {}
    for num in integers:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1
    for num, count in counts.items():
        if count % 2 != 0:
            return num",63
71483630199,prime_factors,"def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",63
15608800905,word_square,"def word_square(words):
    if len(words) != len(words[0]):
        return False
    for i in range(len(words)):
        for j in range(len(words)):
            if j >= len(words[i]) or words[i][j] != words[j][i]:
                return False
    return True",63
31676466550,find_fibonacci,"def find_fibonacci(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = find_fibonacci(n-1, memo) + find_fibonacci(n-2, memo)
    return memo[n]",63
329999263,equilibriumIndex,"def equilibriumIndex(nums):
    total = sum(nums)
    leftSum = 0
    
    for i in range(len(nums)):
        if i != 0:
            leftSum += nums[i-1]
        total -= nums[i]
        if leftSum == total:
            return i
            
    return -1",63
40809981683,sum_even_fibonacci,"def sum_even_fibonacci(n):
    a, b = 0, 1
    total_sum = 0
    while a <= n:
        if a % 2 == 0:
            total_sum += a
        a, b = b, a + b
    return total_sum",63
18587995761,kadanemax,"def kadanemax(nums):
    if not nums:
        return 0

    current_sum = max_sum = nums[0]

    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
        
    return max_sum",63
18306215396,find_max_product,"def find_max_product(lst):
    if len(lst) < 3:
        raise ValueError(""List must contain at least 3 elements."")
    lst.sort()
    return max(lst[0] * lst[1] * lst[-1], lst[-1] * lst[-2] * lst[-3])",63
74241166509,sum_even_fibonacci,"def sum_even_fibonacci(limit):
    a, b = 1, 2
    total_sum = 0
    while b <= limit:
        if b % 2 == 0:
            total_sum += b
        a, b = b, a + b
    return total_sum",63
41319069753,Josephus_Problem,"def Josephus_Problem(n, k):
    circle = list(range(1, n+1))
    execution_order = []
    index = 0
    while circle:
        index = (index + k - 1) % len(circle)
        execution_order.append(circle.pop(index))
    return execution_order",63
13452886929,odd_Rotations,"def odd_Rotations(s,n): 
    count = 0
    for i in range(0, n):
        rotated = s[i:n] + s[0:i]
        if int(rotated, 2) % 2 != 0:
            count += 1
    return count",63
12832550124,find_difference,"def find_difference(values):
  if not values:
    return 0
  highest, lowest = values[0], values[0]
  for val in values[1:]:
    if val > highest:
      highest = val
    elif val < lowest:
      lowest = val
  return highest - lowest",63
6948017274,is_divisible_by_5,"def is_divisible_by_5(binary_str: str) -> bool:
    val = 0
    for bit in binary_str:
        val = (val * 2) % 5
        if bit == '1':
            val += 1
    return val % 5 == 0",63
2508972721,filter_primes,"def filter_primes(l):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, n):
            if n % i == 0:
                return False
        return True

    return [num for num in l if is_prime(num)]",63
36459003715,max_Subarray_Sum,"def max_Subarray_Sum(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",63
15951949231,max_contiguous_sum,"def max_contiguous_sum(nums):
    if not nums:
        return 0
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",63
40931567832,find_min_max,"def find_min_max(arr):
    min_val = arr[0]
    max_val = arr[0]
    for i in arr:
        if i < min_val:
            min_val = i
        if i > max_val:
            max_val = i
    return (min_val, max_val)",63
25389186648,product_array,"def product_array(n):
    n = str(n)
    max_product = 0
    for i in range(len(n)):
        product = 1
        for j in range(i, len(n)):
            product *= int(n[j])
            max_product = max(max_product, product)
    return max_product",63
8381843572,find_target_positions,"def find_target_positions(arr, target):
    first_pos = last_pos = -1
    for i in range(len(arr)):
        if arr[i] == target:
            if first_pos == -1:
                first_pos = i
            last_pos = i
    return [first_pos, last_pos]",63
73725856792,longest_Common_Prefix,"def longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",63
23461995606,find_largest_sum,"def find_largest_sum(nums):
    if not nums:
        return 0
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",63
7504226681,find_longest_prefix,"def find_longest_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",63
33357135246,largest_subarray_sum,"def largest_subarray_sum(nums):
    if not nums:
        return 0
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",63
16967995699,is_rotation_of_palindrome,"def is_rotation_of_palindrome(s):
    s = s.lower()
    if s == s[::-1]:
        return True
    for i in range(1, len(s)):
        rotated = s[i:] + s[:i]
        if rotated == rotated[::-1]:
            return True
    return False",63
931534709,second_smallest,"def second_smallest(numbers):
    m1, m2 = float('inf'), float('inf')
    for x in numbers:
        if x <= m1:
            m1, m2 = x, m1
        elif x < m2:
            m2 = x
    return m2",63
7654801145,find_min_max,"def find_min_max(arr):
    min_num = arr[0]
    max_num = arr[0]
    for num in arr:
        if num < min_num:
            min_num = num
        if num > max_num:
            max_num = num
    return (min_num, max_num)",63
23525571507,coinchange,"def coinchange(n, coins):
    dp = [0] * (n + 1)
    dp[0] = 1
    for coin in coins:
        for i in range(coin, n + 1):
            dp[i] += dp[i - coin]
    return dp[n]",63
23442367111,all_combinations,"def all_combinations(lst, length):
    if length == 1:
        return [[i] for i in lst]
    else:
        result = []
        for i in lst:
            for comb in all_combinations(lst, length-1):
                result.append([i] + comb)
        return result",63
35066330217,maxSubArraySum,"def maxSubArraySum(nums):
    if not nums:
        return 0
    cur_sum = max_sum = nums[0]
    for num in nums[1:]:
        cur_sum = max(num, cur_sum + num)
        max_sum = max(max_sum, cur_sum)
    return max_sum",63
18401901192,max_Subarray_Sum,"def max_Subarray_Sum(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",63
39134583078,count_unique_pairs,"def count_unique_pairs(arr, target):
    seen = {}
    pairs = set()
    for num in arr:
        complement = target - num
        if complement in seen:
            pairs.add((min(num, complement), max(num, complement)))
        seen[num] = True
    return len(pairs)",63
1233259069,generate_pascal_triangle,"def generate_pascal_triangle(numRows):
    res = [[1]]
    for i in range(1, numRows):
        res += [list(map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1]))]
    return res[:numRows]",63
17502978084,count_substring,"def count_substring(string, sub_string):
    count = 0
    pos = 0
    while pos < len(string):
        pos = string.find(sub_string, pos)
        if pos == -1:
            break
        count += 1
        pos += 1
    return count",63
28338530282,prime_factors,"def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",63
7086050041,scm,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def scm(arr):
    scm = arr[0]
    for i in arr[1:]:
        scm = (scm * i) // gcd(scm, i)
    return scm",63
8753217327,climb_stairs,"def climb_stairs(n):
    if n <= 2:
        return n
    a, b, c = 1, 2, 4
    for _ in range(3, n):
        a, b, c = b, c, a + b + c
    return c",63
710570625,number_of_divisors,"def number_of_divisors(N):
    factors = set()
    i = 1
    while i**2 <= N:
        if N % i == 0:
            factors.add(i)
            factors.add(N // i)
        i += 1
            
    result = len(factors)
    return result",63
37808572204,bubble_sort,"def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr",63
33322965853,find_max_subarray_sum,"def find_max_subarray_sum(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",63
40514111360,intersect,"from collections import Counter

def intersect(nums1, nums2):
    c1, c2 = Counter(nums1), Counter(nums2)
    result = []
    for key in c1.keys() & c2.keys():
        result.extend([key]*min(c1[key],c2[key]))
    return result",63
14404388991,find_max_min,"def find_max_min(numbers):
    max_num = numbers[0]
    min_num = numbers[0]
    for num in numbers:
        if num > max_num:
            max_num = num
        if num < min_num:
            min_num = num
    return (max_num, min_num)",63
75261578585,two_sum,"def two_sum(nums, target):
    num_dict = dict()
    for i in range(0, len(nums)):
        if num_dict.get(target - nums[i]) is not None:
            return [num_dict.get(target - nums[i]), i]
        else:
            num_dict[nums[i]] = i",63
21697465781,prime_factors,"def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",63
19521859786,find_largest_smallest,"def find_largest_smallest(lst):
    min_val = lst[0]
    max_val = lst[0]
    for num in lst:
        if num > max_val:
            max_val = num
        elif num < min_val:
            min_val = num
    return max_val, min_val",63
35367335246,find_odd,"def find_odd(integers):
    counts = {}
    for i in integers:
        if i in counts:
            counts[i] += 1
        else:
            counts[i] = 1
    for k, v in counts.items():
        if v % 2 != 0:
            return k",63
74586955025,find_longest_prefix,"def find_longest_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",63
5354117733,find_max_subarray,"def find_max_subarray(nums):
    if not nums:
        return 0
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",63
20603542093,prime_factors,"def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",63
70576361707,prime_factors,"def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",63
70726638201,max_subarray_sum,"def max_subarray_sum(nums):
    if not nums:
        return 0

    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",63
5644032857,find_max_difference,"def find_max_difference(nums):
    max_diff = 0
    min_val = nums[0]
    for num in nums:
        if num - min_val > max_diff:
            max_diff = num - min_val
        if num < min_val:
            min_val = num
    return max_diff",63
30362942074,prime_factors,"def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",63
35557757875,max_sum_non_adjacent_elements,"def max_sum_non_adjacent_elements(arr):
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl>incl else incl
        incl = excl + i
        excl = new_excl
    return max(incl, excl)",62
17479341682,is_valid_permutation,"def is_valid_permutation(lst):
    n = len(lst)
    seen = [False] * n
    for num in lst:
        if num < 1 or num > n or seen[num - 1]:
            return False
        seen[num - 1] = True
    return True",62
11922129273,find_max_subarray,"def find_max_subarray(nums):
    max_current = max_global = nums[0]
    for i in range(1, len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",62
41119623955,is_consecutive,"def is_consecutive(nums):
    if len(nums) <= 1:
        return True
    sorted_nums = sorted(nums)
    for i in range(1, len(sorted_nums)):
        if sorted_nums[i] != sorted_nums[i-1] + 1:
            return False
    return True",62
1759476212,longest_common_prefix,"def longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
21289932227,max_points,"def max_points(points):
    dp = [0] * (len(points) + 2)
    for i in range(len(points)-1, -1, -1):
        dp[i] = max(points[i] + dp[i+2], dp[i+1])
    return dp[0]",62
33495943426,largest_subarray_sum,"def largest_subarray_sum(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",62
35058569135,largest_subarray_sum,"def largest_subarray_sum(nums):
    max_current = max_global = nums[0]
    for i in range(1, len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",62
13519742447,find_days_between_dates,"from datetime import datetime

def find_days_between_dates(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return abs(delta.days)",62
16331117797,find_repeating_pattern,"def find_repeating_pattern(s):
    n = len(s)
    for i in range(1, n//2 + 1):
        if n % i == 0:
            if s[:i] * (n//i) == s:
                return n//i
    return 1",62
20515584491,find_max_non_adjacent_sum,"def find_max_non_adjacent_sum(arr):
    incl = 0
    excl = 0

    for i in arr:
        new_excl = excl if excl > incl else incl

        incl = excl + i
        excl = new_excl

    return max(incl, excl)",62
3963914517,smallest_subsequence,"def smallest_subsequence(s):
    length = len(s)
    for i in range(1, length//2 + 1):
        if length % i == 0:
            sub = s[:i]
            if sub * (length // i) == s:
                return sub
    return s",62
12693077020,stairs_climbing,"def stairs_climbing(n):
    if n <= 1:
        return n
    first, second = 1, 2
    for i in range(3, n + 1):
        third = first + second
        first = second
        second = third
    return second",62
12368169653,largest_subarray_sum,"def largest_subarray_sum(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",62
5913245077,can_construct_word,"from collections import Counter
def can_construct_word(word, magazine):
    w=Counter(word)
    m=Counter(magazine)
    for i in w.keys():
        if( i in m.keys()) and w[i]<=m[i]:
            continue
        else:
            return False
    return True",62
4433707090,longest_Common_Prefix,"def longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs,key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
2383261052,convert_to_camel_case,"def convert_to_camel_case(s):
    components = s.split('_')
    # We capitalize the first letter of each component except the first one
    # with the 'title' method and join them together.
    return components[0] + ''.join(x.title() for x in components[1:])",62
16119028593,maxSubArray,"def maxSubArray(nums):
    if not nums:
        return 0
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",62
43173615924,calculate_days_between_dates,"from datetime import datetime

def calculate_days_between_dates(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return abs(delta.days)",62
34279333179,maxSubArray,"def maxSubArray(nums):
    if not nums:
        return 0
    cur_sum = max_sum = nums[0]
    for num in nums[1:]:
        cur_sum = max(num, cur_sum + num)
        max_sum = max(max_sum, cur_sum)
    return max_sum",62
7551379610,prime_digit_sum,"def prime_digit_sum(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return sum(int(digit) for digit in str(n))",62
34687044524,count_palindrome_substrings,"def count_palindrome_substrings(s):
    n = len(s)
    count = 0
    for i in range(n):
        for j in range(i, n):
            substring = s[i:j+1]
            if substring == substring[::-1]:
                count += 1
    return count",62
70399017069,longest_common_prefix,"def longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
14735216431,sum_of_odd,"def sum_of_odd(lst):
    if len(lst) == 0:
        return 0
    else:
        if lst[0] % 2 == 1:
            return lst[0] + sum_of_odd(lst[1:])
        else:
            return sum_of_odd(lst[1:])",62
29039234808,find_smallest_largest,"def find_smallest_largest(list1):
    smallest = list1[0]
    largest = list1[0]
    for x in list1:
        if x < smallest:
            smallest = x
        if x > largest:
            largest = x
    return (smallest, largest)",62
73523225171,find_pattern,"def find_pattern(string, pattern): 
    count = start = 0
    while start < len(string):
        pos = string.find(pattern, start)
        if pos != -1:
            start = pos + 1
            count += 1
        else:
            break
    return count",62
30893317361,count_odd_xor_pairs,"def count_odd_xor_pairs(arr):
    odd_count = 0
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            if (arr[i] ^ arr[j]) % 2 != 0:
                odd_count += 1
    return odd_count",62
34745268247,pos_neg_count,"def pos_neg_count(lst):
    pos_count = 0
    neg_sum = 0
    for num in lst:
        if num > 0:
            pos_count += 1
        elif num < 0:
            neg_sum += num
    return [pos_count, neg_sum]",62
34461169636,count_substring_overlap,"def count_substring_overlap(text, pattern):
    count = 0
    pos = 0
    while pos < len(text):
        pos = text.find(pattern, pos)
        if pos == -1:
            break
        count += 1
        pos += 1
    return count",62
9129125962,find_anagrams,"from collections import defaultdict

def find_anagrams(words):
    anagrams = defaultdict(list)
    for word in words:
        sorted_word = ''.join(sorted(word))
        anagrams[sorted_word].append(word)
    return [group for group in anagrams.values() if len(group) > 1]",62
23069915257,reverse_linked_list,"class Node:
    def __init__(self, data, next=None):
        self.data = data
        self.next = next

def reverse_linked_list(head):
    reversed_list = []
    while head:
        reversed_list.append(head.data)
        head = head.next
    return reversed_list[::-1]",62
37617165676,findFirstMissPos,"def findFirstMissPos(num):
    map = {}
    for x in num:
        map[x] = x

    for i in range(1, len(num) + 2): #//from 1 to len(num)+1
        if map.get(i) == None:
            return i",62
28852027848,longest_common_prefix,"def longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
36205745604,next_pascal_row,"def next_pascal_row(prev_row):
    if not prev_row:
        return [1]
    row = [1]
    for i in range(len(prev_row) - 1):
        row.append(prev_row[i] + prev_row[i + 1])
    row.append(1)
    return row",62
71466214757,find_odd,"def find_odd(lst):
    counts = {}
    for num in lst:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1
    for num, count in counts.items():
        if count % 2 != 0:
            return num",62
11559399286,int_list_to_dict,"def int_list_to_dict(nums):
  result = {}
  for num in nums:
    if num in result:
      result[num] += 1
    else:
      result[num] = 1
  return {key: value for key, value in result.items() if value > 1}",62
14669080140,find_max_subarray,"def find_max_subarray(nums):
    max_current = max_global = nums[0]
    for i in range(1, len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",62
7530892125,smallest_repeating_cycle,"def smallest_repeating_cycle(lst):
    length = len(lst)
    for i in range(1, length // 2 + 1):
        if length % i == 0:
            if lst[:i] * (length // i) == lst:
                return lst[:i]
    return lst",62
73937236341,count_substring_occurrences,"def count_substring_occurrences(string: str, substring: str) -> int:
    count = start = 0
    while True:
        start = string.find(substring, start) + 1
        if start > 0:
            count += 1
        else:
            return count",62
73884219628,count_ways,"def count_ways(n): 
    if n <= 1: 
        return n 
    first = 1
    second = 2
    for i in range(2, n): 
        current = first + second 
        first = second 
        second = current 
    return current",62
35623734449,smallest_repeating_pattern,"def smallest_repeating_pattern(s):
    for i in range(1, len(s) // 2 + 1):
        if len(s) % i == 0:
            if s[:i] * (len(s) // i) == s:
                return s[:i]
    return s",62
44069673831,longest_common_prefix,"def longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
21258253291,ways_to_sum_consecutive,"def ways_to_sum_consecutive(n):
    count = 0
    for i in range(1, n):
        sum = 0
        while sum < n:
            sum += i
            i += 1
        if sum == n:
            count += 1
    return count",62
6308292921,longestCommonPrefix,"def longestCommonPrefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
8129889996,find_largest_digit,"def find_largest_digit(n):
    n = abs(n)
    largest_digit = 0
    while n > 0:
        current_digit = n % 10
        largest_digit = max(largest_digit, current_digit)
        n = n // 10
    return largest_digit",62
42806728104,ways_to_represent,"def ways_to_represent(n):
  if n == 0:
    return 1
  elif n < 0:
    return 0
  else:
    return ways_to_represent(n-1) + ways_to_represent(n-3) + ways_to_represent(n-4)",62
43212645288,valid_number,"import re

def valid_number(s):
    # Regular expression for matching valid numbers
    pattern = r'^\s*[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?\s*$'
    return bool(re.match(pattern, s))",62
8199853180,second_frequent_string,"from collections import Counter

def second_frequent_string(str_list):
    count = Counter(str_list)
    sorted_count = sorted(count.items(), key=lambda x: x[1], reverse=True)
    if len(sorted_count) < 2:
        return None
    return sorted_count[1][0]",62
26395061855,max_sub_array,"def max_sub_array(nums):
    if not nums:
        return 0
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",62
37413290220,longestCommonPrefix,"def longestCommonPrefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, ch in enumerate(shortest_str):
        for other in strs:
            if other[i] != ch:
                return shortest_str[:i]
    return shortest_str",62
5222599719,can_rearrange,"def can_rearrange(nums):
    positive = 0
    negative = 0
    for num in nums:
        if num > 0:
            positive += 1
        elif num < 0:
            negative += 1
    return abs(positive - negative) <= 1",62
18735732229,maximum_subarray_sum,"def maximum_subarray_sum(nums):
    if not nums: return 0
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",62
16096067839,longest_common_prefix,"def longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
40710129494,longest_common_prefix,"def longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
26470482635,find_first_non_repeating,"def find_first_non_repeating(s):
    dict = {}
    for letter in s:
        dict[letter] = dict.setdefault(letter, 0) + 1
    for index, letter in enumerate(s):
        if dict[letter] == 1:
            return letter
    return -1",62
22934870130,caesar_cipher,"def caesar_cipher(string, shift):
    encrypted_string = ''
    for char in string:
        ascii_code = ord(char)
        ascii_code += shift
        if ascii_code > ord('z'):
            ascii_code -= 26
        encrypted_string += chr(ascii_code)
    return encrypted_string",62
23792150170,largest_contiguous_sum,"def largest_contiguous_sum(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",62
43310335251,max_subarray_sum,"def max_subarray_sum(nums):
    max_current = max_global = nums[0]
    for i in range(1, len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",62
45363749321,max_non_adjacent_sum,"def max_non_adjacent_sum(arr):
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl>incl else incl
        incl = excl + i
        excl = new_excl
    return excl if excl>incl else incl",62
8710124603,largest_sum_subarray,"def largest_sum_subarray(nums):
    max_current = max_global = nums[0]
    for i in range(1, len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",62
6055854592,max_subarray,"def max_subarray(nums):
    if not nums:
        return 0
    cur_sum = max_sum = nums[0]
    for num in nums[1:]:
        cur_sum = max(num, cur_sum + num)
        max_sum = max(max_sum, cur_sum)
    return max_sum",62
27674298040,remove_duplicates,"def remove_duplicates(nums):
    if not nums:
        return []
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]
    return nums[:i + 1]",62
72311520025,count_BST,"def count_BST(n):
    if n <= 1:
        return 1
    total = 0
    for i in range(n):
        l = count_BST(i)
        r = count_BST(n - 1 - i)
        total += l * r
    return total",62
39752738594,longest_Common_Prefix,"def longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs,key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
27270085575,factorial_digit_sum,"def factorial_digit_sum(n):
    factorial = 1
    for i in range(1, n + 1):
        factorial *= i
    sum = 0
    while factorial > 0:
        sum += factorial % 10
        factorial //= 10
    return sum",62
29828684818,string_permutation,"def string_permutation(s):
    if len(s) == 1:
        return [s]
    permutations = []
    for i in range(len(s)):
        for perm in string_permutation(s[:i] + s[i+1:]):
            permutations.append(s[i] + perm)
    return permutations",62
29546053361,is_valid_parentheses_sequence,"def is_valid_parentheses_sequence(s: str) -> bool:
    stack = []
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack:
                return False
            stack.pop()
    return len(stack) == 0",62
5783987454,long_com_pre,"def long_com_pre(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
15907221968,minimize_max,"from itertools import accumulate
import math

def minimize_max(nums):
    n = len(nums)
    pre_sum = [0] + list(accumulate(nums))
    max_val = max(math.ceil(pre_sum[i] / i) for i in range(1, n + 1))
    return max_val",62
14902186958,max_possible_sum,"def max_possible_sum(arr):
    max_sum = arr[0]
    current_sum = arr[0]
    for i in range(1, len(arr)):
        current_sum = max(arr[i], current_sum + arr[i])
        max_sum = max(max_sum, current_sum)
    return max_sum",62
42061208602,ways_to_climb,"def ways_to_climb(n):
    if n <= 1:
        return 1
    first, second = 1, 1
    for _ in range(2, n + 1):
        third = first + second
        first, second = second, third
    return second",62
33624637779,count_anagram_pairs,"from collections import defaultdict

def count_anagram_pairs(strings: list[str]) -> int:
    counter = defaultdict(int)
    res = 0
    for s in strings:
        s = frozenset(sorted(s))
        res += counter[s]
        counter[s] += 1
    return res",62
21457411658,count_substring_occurrences,"def count_substring_occurrences(string, substring):
    count = 0
    start = 0
    while True:
        start = string.find(substring, start) + 1
        if start > 0:
            count += 1
        else:
            break
    return count",62
42806679001,longest_Common_Prefix,"def longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs,key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
19388554358,first_repeating_element,"def first_repeating_element(arr):
    seen = set()
    rep = set()
    for item in arr:
        if item in seen:
            rep.add(item)
        else:
            seen.add(item)
    for item in arr:
        if item in rep:
            return item
    return -1",62
36484279890,longestCommonPrefix,"def longestCommonPrefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
12371837132,days_until_deadline,"from datetime import datetime

def days_until_deadline(current_day, deadline_day):
    current_date = datetime.strptime(current_day, ""%Y-%m-%d"")
    deadline_date = datetime.strptime(deadline_day, ""%Y-%m-%d"")
    delta = deadline_date - current_date
    return delta.days",62
15520463479,mode,"from collections import Counter

def mode(lst):
    count = Counter(lst)
    max_count = max(list(count.values()))
    mode_val = [num for num, freq in count.items() if freq == max_count]
    return mode_val[0] if len(mode_val) == 1 else mode_val",62
72637934568,sum_of_multiples,"def sum_of_multiples(limit, multiples):
    unique_multiples = set()
    for multiple in multiples:
        if multiple > 0:
            for i in range(1, limit):
                if i % multiple == 0:
                    unique_multiples.add(i)
    return sum(unique_multiples)",62
13852291545,longestCommonPrefix,"def longestCommonPrefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
41690383378,largest_continuous_sum,"def largest_continuous_sum(arr):
    if not arr:
        return 0
    max_sum = current_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(max_sum, current_sum)
    return max_sum",62
10993283312,maxSubArray,"def maxSubArray(nums):
    if not nums:
        return 0
    cur_sum = max_sum = nums[0]
    for num in nums[1:]:
        cur_sum = max(num, cur_sum + num)
        max_sum = max(max_sum, cur_sum)
    return max_sum",62
9321055702,to_upper_case,"def to_upper_case(s):
    upper_s = """"
    for char in s:
        if 'a' <= char <= 'z':
            # Convert lowercase letter to uppercase
            upper_s += chr(ord(char) - 32)
        else:
            upper_s += char
    return upper_s",62
43826243793,climb_staircase,"def climb_staircase(n):
    if n <= 1:
        return 1
    first, second = 1, 1
    for i in range(2, n + 1):
        third = first + second
        first, second = second, third
    return second",62
32490099380,is_monotonic,"def is_monotonic(list):
    increasing = decreasing = True
    for i in range(1, len(list)):
        if list[i] > list[i-1]:
            decreasing = False
        if list[i] < list[i-1]:
            increasing = False
    return increasing or decreasing",62
71916903613,isPerfectSquare,"def isPerfectSquare(num):
    if num < 2:
        return True

    x = num // 2
    while x * x > num:
        x = (x + num // x) // 2
        if x * x == num:
            return True
    return False",62
16312208971,josephus,"def josephus(n,k):
    people = list(range(1, n+1))
    index = 0
    while len(people) > 1:
        index = (index + k - 1) % len(people)
        people.pop(index)
    return people[0]",62
27381669824,longestCommonPrefix,"def longestCommonPrefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
12817459788,maxNonAdjacentSum,"def maxNonAdjacentSum(nums) :
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl>incl else incl
        incl = excl + i
        excl = new_excl
    return excl if excl>incl else incl",62
12236033720,days_between_dates,"from datetime import datetime

def days_between_dates(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = abs((b - a).days)
    return delta",62
10898218196,delete_duplicates,"def delete_duplicates(lst):
    if not lst:
        return []
    cur = 0
    while cur < len(lst) - 1:
        if lst[cur] == lst[cur + 1]:
            lst.pop(cur + 1)
        else:
            cur += 1
    return lst",62
39169381655,count_pattern_occurrences,"def count_pattern_occurrences(text, pattern):
    count = 0
    index = 0
    while index < len(text):
        index = text.find(pattern, index)
        if index == -1:
            break
        count += 1
        index += 1
    return count",62
70944387000,max_subarray_sum,"def max_subarray_sum(nums):
    current_max = global_max = nums[0]
    for i in range(1, len(nums)):
        current_max = max(nums[i], current_max + nums[i])
        if current_max > global_max:
            global_max = current_max
    return global_max",62
39813873441,find_longest_subsequence,"def find_longest_subsequence(s, dictionary):
    longest_subsequence = """"
    for word in dictionary:
        it = iter(s)
        if all(c in it for c in word) and len(word) > len(longest_subsequence):
            longest_subsequence = word
    return longest_subsequence",62
15952121391,count_even_odd,"def count_even_odd(numbers):
    even_count = 0
    odd_count = 0
    for num in numbers:
        if num % 2 == 0:
            even_count += 1
        else:
            odd_count += 1
    return (even_count, odd_count)",62
35129291973,find_top_students,"import heapq

def find_top_students(scores, k):
    maxHeap = []
    for score in scores:
        heapq.heappush(maxHeap, -score)
    top_scores = []
    for _ in range(k):
        top_scores.append(-heapq.heappop(maxHeap))
    return top_scores",62
17053872387,find_unique_pairs,"def find_unique_pairs(numbers, target):
    seen = {}
    output = set()
    for number in numbers:
        complement = target - number
        if complement in seen:
            output.add((min(number, complement), max(number, complement)))
        seen[number] = True
    return len(output)",62
2469932078,group_anagrams,"from collections import defaultdict

def group_anagrams(strs):
    anagrams = defaultdict(list)
    for word in strs:
        # Sort the characters in the word to get the anagram key
        key = tuple(sorted(word))
        anagrams[key].append(word)
    return list(anagrams.values())",62
19605412385,largest_continuous_sum,"def largest_continuous_sum(nums):
    if not nums:
        return 0

    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)

    return max_sum",62
70082320265,ways_to_climb,"def ways_to_climb(n):
    if n <= 1:
        return 1
    first, second = 1, 1
    for _ in range(2, n + 1):
        third = first + second
        first, second = second, third
    return second",62
39640363613,reverse_digit_sum,"def reverse_digit_sum(n):
    if n < 0:
        return ""Input is not a positive integer!""
    sum = 0
    while n > 0:
        digit = n % 10
        sum += digit
        n = n // 10
    return sum",62
11357223972,plus_one,"def plus_one(digits):
    for i in range(len(digits)-1, -1, -1):
        if digits[i] < 9:
            digits[i] += 1
            return digits
        digits[i] = 0

    digits.insert(0, 1)
    return digits",62
6142152493,search_insert,"def search_insert(nums, target):
    try:
        return nums.index(target)
    except:
        index_i = min(range(len(nums)), key = lambda i: abs(nums[i]-target))
        if target > nums[index_i]:
            return index_i + 1
        else:
            return index_i",62
36779817541,first_repeating,"def first_repeating(arr):
    seen = set()
    repeats = set()
    
    for n in arr:
        if n in seen:
            repeats.add(n)
        else:
            seen.add(n)
    
    for n in arr:
        if n in repeats:
            return n

    return None",62
10789765705,max_subarray_sum,"def max_subarray_sum(nums):
    max_current = max_global = nums[0]
    for i in range(1, len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",62
71293511106,longest_common_prefix,"def longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",62
15432340740,max_sub_array,"def max_sub_array(nums):
    if not nums:
        return 0

    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",62
18788191547,max_Profit,"def max_Profit(prices) :
    if not prices:
        return 0
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            profit += prices[i] - prices[i-1]
    return profit",62
70409617359,is_self_number,"def is_self_number(n):
    if n < 10:
        return True
    for i in range(1, n):
        sum_of_digits = sum([int(digit) for digit in str(i)])
        if i + sum_of_digits == n:
            return False
    return True",62
32026948072,days_between_dates,"from datetime import datetime

def days_between_dates(date1, date2):
    d1 = datetime.strptime(date1, ""%Y-%m-%d"")
    d2 = datetime.strptime(date2, ""%Y-%m-%d"")
    delta = d2 - d1
    return abs(delta.days)",62
71742633380,average_of_lists,"def average_of_lists(list_of_lists):
    total_sum = 0
    total_count = 0
    for sublist in list_of_lists:
        total_sum += sum(sublist)
        total_count += len(sublist)
    return total_sum / total_count if total_count != 0 else 0",62
70441254428,find_max_subarray,"def find_max_subarray(nums):
    max_current = max_global = nums[0]
    for i in range(1, len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",62
20715074060,max_sum_sublist,"def max_sum_sublist(lst):
    max_sum = float('-inf')
    max_sublist = []
    for sublist in lst:
        current_sum = sum(sublist)
        if current_sum > max_sum:
            max_sum = current_sum
            max_sublist = sublist
    return max_sublist",62
39707482813,find_odd,"def find_odd(seq):
    counts = {}
    for num in seq:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1
    for num, count in counts.items():
        if count % 2 != 0:
            return num",62
39788578333,max_Profit,"def max_Profit(prices):
    if not prices:
        return 0
    profit = 0
    min_price = prices[0]
    for price in prices:
        profit = max(profit, price - min_price)
        min_price = min(min_price, price)
    return profit",62
30424032333,max_product,"def max_product(nums):
    max1 = max2 = float('-inf')
    for num in nums:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2:
            max2 = num
    return max1 * max2",62
7042304491,maxSubarraySum,"def maxSubarraySum(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",62
21785709054,has_vowel,"def has_vowel(str_list):
    vowels = ['a', 'e', 'i', 'o', 'u', 'y']
    result = []
    for word in str_list:
        for letter in word:
            if letter in vowels:
                result.append(word)
                break
    return result",62
22961782802,largest_non_adjacent_sum,"def largest_non_adjacent_sum(nums):
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return max(excl, incl)",61
12005906721,staircase_climbing,"def staircase_climbing(n: int) -> int:
    if n <= 2:
        return n
    first, second = 1, 2
    for _ in range(3, n + 1):
        first, second = second, first + second
    return second",61
73971138066,fibonacci_memo,"def fibonacci_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 2:
        return 1
    memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo)
    return memo[n]",61
2131037676,largest_sum_non_adjacent,"def largest_sum_non_adjacent(nums):
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return max(incl, excl)",61
786528858,count_digits,"def count_digits(n):
    if n == 0:
        return 1
    if n < 0:
        n = -n
    count = 0
    while n > 0:
        n = n // 10
        count += 1
    return count",61
12548041984,find_most_frequent_string,"def find_most_frequent_string(string_list):
    string_count = {}
    for string in string_list:
        if string in string_count:
            string_count[string] += 1
        else:
            string_count[string] = 1
    return max(string_count, key=string_count.get)",61
19750411394,find_third_smallest,"def find_third_smallest(numbers):
    unique_numbers = list(set(numbers)) # Remove duplicates
    unique_numbers.sort() # Sort the list
    if len(unique_numbers) < 3:
        return ""The list does not have enough unique elements.""
    else:
        return unique_numbers[2]",61
43215271453,lowest_missing_positive,"def lowest_missing_positive(arr):
    arr = [x for x in arr if x > 0]
    arr.sort()
    missing = 1
    for num in arr:
        if num == missing:
            missing += 1
        elif num > missing:
            break
    return missing",61
71319060093,sum_multiples,"def sum_multiples(n):
    def sum_of_multiples(factor):
        p = (n-1)//factor
        return factor*p*(p+1)//2
    return sum_of_multiples(3) + sum_of_multiples(5) - sum_of_multiples(15)",61
20401450471,max_non_adjacent_sum,"def max_non_adjacent_sum(arr):
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl>incl else incl
        incl = excl + i
        excl = new_excl
    return max(excl, incl)",61
6744810180,fibo,"def fibo(n):
    fib = [0, 1] + [0] * (n - 1)
    for i in range(2, n + 1):
        fib[i] = fib[i - 1] + fib[i - 2]
    return fib[n]",61
29172340567,staircaseClimbing,"def staircaseClimbing(n):
    if n == 1 or n == 2:
        return n
    a, b = 1, 2
    for _ in range(3, n + 1):
        a, b = b, a + b
    return b",61
33181241371,largest_non_adjacent_sum,"def largest_non_adjacent_sum(arr):
    incl = 0
    excl = 0
     
    for i in arr:
        new_excl = excl if excl > incl else incl
 
        incl = excl + i
        excl = new_excl
 
    return max(incl, excl)",61
34585223305,largest_sum,"def largest_sum(arr):
    if not arr:
        return 0

    max_sum = cur_sum = arr[0]

    for num in arr[1:]:
        cur_sum = max(num, cur_sum + num)
        max_sum = max(max_sum, cur_sum)

    return max_sum",61
7246940408,convertToBase5,"def convertToBase5(num):
    if num == 0: return '0'
    n, res = abs(num), ''
    while n:
      res = str(n % 5) + res
      n //= 5
    return res if num >= 0 else '-' + res",61
26334618247,largest_sum_non_adjacent,"def largest_sum_non_adjacent(nums):
    incl = 0
    excl = 0

    for i in nums:
        new_excl = excl if excl > incl else incl

        incl = excl + i
        excl = new_excl

    return max(incl, excl)",61
4295651971,count_odd_xor_pairs,"def count_odd_xor_pairs(arr):
    odd_count = 0
    even_count = 0
    for num in arr:
        if num % 2 == 0:
            even_count += 1
        else:
            odd_count += 1
    return odd_count * even_count",61
22852919165,is_isogram,"def is_isogram(string):
    string = string.lower() #convert all letters to lower case
    for char in string:
        if string.count(char) > 1 and char.isalpha(): #check if the character is a letter and occurs more than once
            return False
    return True",61
18698617612,kadanes_algorithm,"def kadanes_algorithm(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",61
5381838747,unique_sum_ways,"def unique_sum_ways(n):
    if n <= 2:
        return 1
    a, b = 1, 1
    for i in range(3, n+1):
        c = b + a
        a, b = b, c
    return b",61
36886407016,largest_non_adjacent_sum,"def largest_non_adjacent_sum(nums):
    incl = 0
    excl = 0

    for i in nums:
        new_excl = excl if excl > incl else incl

        incl = excl + i
        excl = new_excl

    return max(incl, excl)",61
28850021108,largest_sum,"def largest_sum(nums):
    if not nums:
        return 0

    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",61
30893247421,kadane_algorithm,"def kadane_algorithm(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",61
3271011271,count_pattern,"def count_pattern(string, pattern):
  count = start = 0
  while start < len(string):
    pos = string.find(pattern, start)
    if pos != -1:
      start = pos + 1
      count += 1
    else:
      break
  return count",61
32255515456,longest_common_prefix,"def longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs,key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",61
12454658348,power_num,"def power_num(base, exponent):
    if exponent == 0:
        return 1
    elif exponent > 0:
        return base * power_num(base, exponent - 1)
    else:
        return 1 / (base * power_num(base, -exponent - 1))",61
38666932151,days_between_dates,"from datetime import datetime

def days_between_dates(date1, date2):
  date_format = ""%Y-%m-%d""
  a = datetime.strptime(date1, date_format)
  b = datetime.strptime(date2, date_format)
  delta = b - a
  return abs(delta.days)",61
71003362661,number_of_ways,"def number_of_ways(n):
    if n <= 1:
        return n
    first, second = 1, 2
    for _ in range(3, n + 1):
        third = first + second
        first, second = second, third
    return second",61
28773099680,maxSubArray,"def maxSubArray(nums):
    max_current = max_global = nums[0]
    for i in range(1, len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",61
13966591386,find_max_min,"def find_max_min(arr):
    max_val = arr[0]
    min_val = arr[0]
    for num in arr:
        if num > max_val:
            max_val = num
        if num < min_val:
            min_val = num
    return max_val, min_val",61
23672830195,common_prefix,"def common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",61
33216267835,count_ways,"def count_ways(n):
    if n <= 1:
        return 1
    first, second = 1, 1
    for i in range(2, n+1):
        third = first + second
        first = second
        second = third
    return second",61
73979886265,valid_identifier,"import keyword

def valid_identifier(s: str) -> bool:
    if s[0].isdigit() or keyword.iskeyword(s):
        return False
    for char in s:
        if not (char.isalpha() or char.isdigit() or char == '_'):
            return False
    return True",61
74772107486,factorial_sum,"def factorial_sum(n):
    def factorial(x):
        if x == 0:
            return 1
        else:
            return x * factorial(x-1)
    total = 0
    for i in range(1, n+1):
        total += factorial(i)
    return total",61
40284779504,max_subarray,"def max_subarray(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",61
25587054304,count_Pairs,"from collections import Counter
def count_Pairs(arr,k):
    count = 0
    arr_frequency = Counter(arr)
    for i in arr_frequency:
        if i + k in arr_frequency:
            count = count + (arr_frequency[i] * arr_frequency[i + k])
    return count",61
73839323515,fib_memo,"def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 2:
        return 1
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]",61
15433424685,kadane_algorithm,"def kadane_algorithm(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",61
10190872250,find_good_pairs,"def find_good_pairs(nums):
    count = 0
    myDict = {}
    for i in nums:
        if i in myDict:
            count += myDict[i]
            myDict[i] += 1
        else:
            myDict[i] = 1
    return count",61
3748586180,max_adjacent_product,"def max_adjacent_product(input_list):
    max_product = float('-inf')
    for i in range(len(input_list) - 1):
        product = input_list[i] * input_list[i + 1]
        if product > max_product:
            max_product = product
    return max_product",61
22906851783,max_non_adjacent_sum,"def max_non_adjacent_sum(arr):
    incl = 0
    excl = 0

    for i in arr:
        new_excl = excl if excl>incl else incl

        incl = excl + i
        excl = new_excl

    return max(incl, excl)",61
74846376035,largest_sum_non_adjacent,"def largest_sum_non_adjacent(nums):
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return max(incl, excl)",61
22357532507,max_subarray_sum,"def max_subarray_sum(nums):
    max_current = max_global = nums[0]
    for i in range(1,len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",61
22049548735,max_non_adjacent_sum,"def max_non_adjacent_sum(nums):
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl>incl else incl
        incl = excl + i
        excl = new_excl
    return max(excl, incl)",61
37327569511,find_next_greater_elements,"def find_next_greater_elements(arr):
    stack = []
    result = [-1] * len(arr)
    for i in range(len(arr)):
        while stack and arr[stack[-1]] < arr[i]:
            result[stack.pop()] = arr[i]
        stack.append(i)
    return result",61
4878829461,check_vowels_order,"def check_vowels_order(s):
    vowels = 'aeiou'
    index = 0
    for char in s:
        if char == vowels[index]:
            index += 1
            if index == 5:
                return True
    return False if index < 5 else False",61
18159107405,smallest_common_multiple,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def smallest_common_multiple(nums):
    scm = nums[0]
    for i in nums[1:]:
        scm = scm*i//gcd(scm, i)
    return scm",61
33183522491,num_good_pairs,"def num_good_pairs(nums):
    count = 0
    num_dict = {}
    for num in nums:
        if num in num_dict:
            count += num_dict[num]
            num_dict[num] += 1
        else:
            num_dict[num] = 1
    return count",61
6873440461,longest_common_prefix,"def longest_common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs,key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",61
6243382691,calc_days_between,"from datetime import datetime

def calc_days_between(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return abs(delta.days)",61
25511709524,count_odd_xor_pairs,"def count_odd_xor_pairs(arr):
    odd_count = 0
    even_count = 0
    for num in arr:
        if num % 2 == 0:
            even_count += 1
        else:
            odd_count += 1
    return odd_count * even_count",61
6301350432,max_non_adjacent_sum,"def max_non_adjacent_sum(arr):
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return max(excl, incl)",61
29236916052,sum_of_three,"def sum_of_three(n):
    count = 0
    for i in range(1, n):
        for j in range(1, n):
            for k in range(1, n):
                if i + j + k == n:
                    count += 1
    return count",61
71691544501,maxNonAdjacentSum,"def maxNonAdjacentSum(arr):
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return excl if excl > incl else incl",61
72611977304,date_difference,"from datetime import datetime

def date_difference(date1, date2):
    d1 = datetime.strptime(date1, ""%Y-%m-%d"")
    d2 = datetime.strptime(date2, ""%Y-%m-%d"")
    delta = d2 - d1
    return abs(delta.days)",61
7054783306,num_Ways,"def num_Ways(n): 
    if n <= 1: 
        return n 
    first, second = 1, 2
    for i in range(2, n): 
        third = first + second 
        first = second 
        second = third 
    return second",61
1184779904,largest_non_adjacent_sum,"def largest_non_adjacent_sum(nums):
    incl = 0
    excl = 0
    for num in nums:
        new_excl = excl if excl > incl else incl
        incl = excl + num
        excl = new_excl
    return max(incl, excl)",61
14442038532,days_between_dates,"from datetime import datetime

def days_between_dates(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return abs(delta.days)",61
28129070504,is_valid_ip,"def is_valid_ip(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit() or int(part) < 0 or int(part) > 255:
            return False
    return True",61
29644319055,fib_memo,"def fib_memo(n, memo = {}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]",61
19669268300,staircase_ways,"def staircase_ways(n):
    if n <= 1:
        return 1
    first, second = 1, 2
    for _ in range(3, n + 1):
        third = first + second
        first, second = second, third
    return second",61
32247937373,lcp,"def lcp(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",61
39006462629,count_good_pairs,"def count_good_pairs(nums):
    ans = 0
    count = [0] * 101  # Create a list of size 101 initialized with zeros

    for num in nums:
        ans += count[num]
        count[num] += 1

    return ans",61
25200352007,max_non_adjacent_sum,"def max_non_adjacent_sum(nums):
    incl = 0
    excl = 0

    for num in nums:
        new_excl = excl if excl > incl else incl
        incl = excl + num
        excl = new_excl

    return max(excl, incl)",61
30554907371,sum_of_digits_in_range,"def sum_of_digits_in_range(n):
    def sum_of_digits(num):
        return sum([int(digit) for digit in str(num)])
    total_sum = 0
    for i in range(1, n+1):
        total_sum += sum_of_digits(i)
    return total_sum",61
19999349499,max_consecutive_diff,"def max_consecutive_diff(nums):
    if len(nums) < 2:
        return 0
    max_diff = 0
    for i in range(1, len(nums)):
        max_diff = max(max_diff, abs(nums[i] - nums[i-1]))
    return max_diff",61
26972500946,largest_non_adjacent_sum,"def largest_non_adjacent_sum(nums):
    incl = 0
    excl = 0
    
    for i in nums:
        new_excl = excl if excl > incl else incl
        
        incl = excl + i
        excl = new_excl
        
    return max(incl, excl)",61
11292740943,stairClimber,"def stairClimber(n):
    if n == 1:
        return 1
    first, second = 1, 2
    for i in range(3, n+1):
        third = first + second
        first, second = second, third
    return second",61
6391130536,max_min_elements,"def max_min_elements(arr):
    max_element = arr[0]
    min_element = arr[0]
    for element in arr:
        if element > max_element:
            max_element = element
        if element < min_element:
            min_element = element
    return max_element, min_element",61
34815249623,remove_duplicate_letters,"def remove_duplicate_letters(s):
    stack = []

    for i, char in enumerate(s):
        if char not in stack:
            while stack and stack[-1] in s[i:] and char < stack[-1]:
                stack.pop()
            
            stack.append(char)

    return ''.join(stack)",61
72180496502,date_difference,"from datetime import datetime

def date_difference(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = abs((b - a).days)
    return delta",61
7313756606,date_difference,"from datetime import datetime

def date_difference(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = abs((b - a).days)
    return delta",61
37286849778,find_max_min,"def find_max_min(lst):
    max_val = lst[0]
    min_val = lst[0]
    for num in lst:
        if num > max_val:
            max_val = num
        if num < min_val:
            min_val = num
    return max_val, min_val",61
10891375730,max_candy_sweetness,"def max_candy_sweetness(candies, num_children):
    candies.sort(reverse=True)
    total_sweetness = 0
    for i in range(num_children):
        if i < len(candies):
            total_sweetness += candies[i]
    return total_sweetness",61
6465413614,maxDifference,"def maxDifference(arr):
    tmin=arr[0]
    tmax=0
    for i in arr:
        if i < tmin:
            tmin=i
        elif i>tmin:
            d=i-tmin
            tmax=max(tmax,d)
    return tmax",61
7240028703,count_substring_occurrences,"def count_substring_occurrences(string, substring):
    count = 0
    start = 0
    while True:
        start = string.find(substring, start)
        if start == -1:
            break
        count += 1
        start += 1
    return count",61
21584836059,contains_nearby_duplicate,"from collections import defaultdict

def contains_nearby_duplicate(nums, k):
    indexes = defaultdict(int)

    for i, num in enumerate(nums):
        if num in indexes and abs(i - indexes[num]) <= k:
            return True
        else:
            indexes[num] = i

    return False",61
9364601689,threeConsecutiveEvens,"def threeConsecutiveEvens(arr):
    even_count = 0
    for e in arr:
        if e%2==0:
            even_count += 1
            if even_count == 3:
                return True
        else:
            even_count = 0
    return False",61
36777686683,days_between_dates,"from datetime import datetime

def days_between_dates(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return abs(delta.days)",61
42334147823,common_prefix,"def common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs, key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",61
9309018764,max_element,"def max_element(arr):
    if len(arr) == 1:
        return arr[0]
    else:
        mid = len(arr) // 2
        left_max = max_element(arr[:mid])
        right_max = max_element(arr[mid:])
        return max(left_max, right_max)",61
4100960850,max_sum_non_adjacent,"def max_sum_non_adjacent(arr):
    incl = 0
    excl = 0

    for i in arr:
        new_excl = excl if excl > incl else incl

        incl = excl + i
        excl = new_excl

    return max(incl, excl)",61
25458516383,is_narcissistic,"def is_narcissistic(num):
    num_str = str(num)
    num_len = len(num_str)
    sum = 0
    for i in num_str:
        sum += int(i)**num_len
    if sum == num:
        return True
    else:
        return False",61
14277067154,fib_memo,"def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 2:
        return 1
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]",61
15906955658,valid_word,"import re

def valid_word(word):
    patterns = '^[A-Z][a-z]*[A-Z]$'
    if re.match(patterns, word) and not re.search('[a-z][A-Z]', word):
        return 'Valid word!'
    else:
        return 'Invalid word!'",61
41528543657,max_profit,"def max_profit(prices):
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        compare_profit = price - min_price
        max_profit = max(max_profit, compare_profit)
    return max_profit",61
1676991017,largest_sum_non_adjacent,"def largest_sum_non_adjacent(nums):
    incl = 0
    excl = 0
    
    for i in nums:
        new_excl = excl if excl > incl else incl
        
        incl = excl + i
        excl = new_excl
        
    return max(incl, excl)",61
10363315797,min_abs_difference,"def min_abs_difference(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(len(arr) - 1):
        diff = abs(arr[i] - arr[i + 1])
        if diff < min_diff:
            min_diff = diff
    return min_diff",61
28617732633,kadane_algorithm,"def kadane_algorithm(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",61
41440405122,is_narcissistic,"def is_narcissistic(n):
    # convert number to string to get length
    num_str = str(n)
    num_len = len(num_str)
    total = 0
    for char in num_str:
        total += int(char) ** num_len
    return total == n",61
38900468651,list_intersection,"from collections import Counter

def list_intersection(list1, list2):
    """"""
    Finds the intersection of two lists, including duplicates.
    """"""
    counter1 = Counter(list1)
    counter2 = Counter(list2)
    intersection = counter1 & counter2
    return list(intersection.elements())",61
27856625164,max_sum_non_adjacent,"def max_sum_non_adjacent(nums):
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl>incl else incl
        incl = excl + i
        excl = new_excl
    return max(excl, incl)",61
71012425417,largest_non_adjacent_sum,"def largest_non_adjacent_sum(nums):
    incl = 0
    excl = 0

    for i in nums:
        new_excl = excl if excl > incl else incl

        incl = excl + i
        excl = new_excl

    return max(excl, incl)",61
26224523477,longestCommonPrefix,"def longestCommonPrefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs,key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",61
37704615979,num_days,"from datetime import datetime

def num_days(date1, date2):
    d1 = datetime.strptime(date1, ""%Y-%m-%d"")
    d2 = datetime.strptime(date2, ""%Y-%m-%d"")
    delta = d2 - d1
    return abs(delta.days)",61
10298588514,maximum_difference,"def maximum_difference(nums):
    max_diff = 0
    min_element = nums[0]
    for i in range(1, len(nums)):
        max_diff = max(max_diff, nums[i] - min_element)
        min_element = min(min_element, nums[i])
    return max_diff",61
36173113722,max_sum_non_adjacent,"def max_sum_non_adjacent(nums):
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl>incl else incl
        incl = excl + i
        excl = new_excl
    return max(incl, excl)",61
13790795095,climb_stairs,"def climb_stairs(n):
    if n == 1:
        return 1
    first, second = 1, 2
    for i in range(3, n + 1):
        third = first + second
        first, second = second, third
    return second",61
72484881784,climb_stairs,"def climb_stairs(n: int) -> int:
    if n == 1:
        return 1
    first, second = 1, 2
    for _ in range(3, n + 1):
        first, second = second, first + second
    return second",61
26688904006,count_pattern,"def count_pattern(text, pattern):
    count = start = 0
    while start < len(text):
        pos = text.find(pattern, start)
        if pos != -1:
            count += 1
            start = pos + 1
        else:
            break
    return count",61
14970214241,largest_sum_non_adjacent,"def largest_sum_non_adjacent(arr):
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return max(incl, excl)",61
781260325,is_subsequence,"def is_subsequence(subseq, sequence):
    subseq_index = 0
    for char in sequence:
        if subseq_index < len(subseq) and subseq[subseq_index] == char:
            subseq_index += 1
    return subseq_index == len(subseq)",61
36088109980,max_non_adjacent_sum,"def max_non_adjacent_sum(arr):
    incl = 0
    excl = 0

    for i in arr:
        new_excl = excl if excl > incl else incl

        incl = excl + i
        excl = new_excl

    return max(incl, excl)",61
41957394341,remove_duplicates,"def remove_duplicates(nums):
    if not nums:
        return 0
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]
    return i + 1",61
40693116102,group_anagrams,"from collections import defaultdict

def group_anagrams(strs):
    anagrams = defaultdict(list)
    
    for word in strs:
        # Sorted word is a key for anagrams
        key = ''.join(sorted(word))
        anagrams[key].append(word)
    
    return list(anagrams.values())",61
10741735719,days_between_dates,"from datetime import datetime

def days_between_dates(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return abs(delta.days)",61
32045497711,snake_to_camel,"def snake_to_camel(snake_str):
    components = snake_str.split('_')
    # Capitalize the first letter of each component except the first one
    components = [components[0].lower()] + [word.capitalize() for word in components[1:]]
    return ''.join(components)",61
20391314198,count_good_pairs,"def count_good_pairs(nums):
    hash_map = {}
    count = 0
    for num in nums:
        if num in hash_map:
            count += hash_map[num]
            hash_map[num] += 1
        else:
            hash_map[num] = 1
    return count",61
69969868160,can_form_string,"def can_form_string(target: str, strings: list) -> bool:
    if target == """":
        return True
    for s in strings:
        if target.startswith(s):
            remaining = target[len(s):]
            if can_form_string(remaining, strings):
                return True
    return False",61
7553658040,find_Longest_Common_Prefix,"def find_Longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, ch in enumerate(shortest):
        for other in strs:
            if other[i] != ch:
                return shortest[:i] 
    return shortest",61
42446280909,find_pattern,"def find_pattern(text, pattern):
    count = start = 0
    while start < len(text):
        pos = text.find(pattern, start)
        if pos != -1:
            start = pos + 1
            count += 1
        else:
            break
    return count",61
20855806560,is_valid_stack_sequence,"def is_valid_stack_sequence(pushed, popped):
    stack = []
    pop_index = 0

    for num in pushed:
        stack.append(num)
        while stack and stack[-1] == popped[pop_index]:
            stack.pop()
            pop_index += 1

    return not stack",61
39005493248,smallest_missing_positive,"def smallest_missing_positive(arr):
    arr = [x for x in arr if x > 0]
    arr.sort()
    missing = 1
    for num in arr:
        if num == missing:
            missing += 1
        elif num > missing:
            break
    return missing",61
12638471019,is_valid_parentheses,"def is_valid_parentheses(s: str) -> bool:
    stack = []
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack:
                return False
            stack.pop()
    return len(stack) == 0",61
73804403684,minAbsDifference,"def minAbsDifference(arr):
    arr.sort()
    min_diff = float('inf')
    n = len(arr)
    for i in range(1, n):
        diff = abs(arr[i] - arr[i-1])
        min_diff = min(min_diff, diff)
    return min_diff",61
31632264456,permutations,"def permutations(string):
    if len(string) == 1:
        return [string]

    perm_list = [] 
    for a in string: 
        rem_string = string.replace(a,'')
        for p in permutations(rem_string):
            perm_list.append(a + p)
    return perm_list",61
2365611031,longestCommonPrefix,"def longestCommonPrefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs,key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",61
6418651948,find_smallest,"def find_smallest(nums):
    min_val = nums[0]
    min_index = 0
    for i in range(1, len(nums)):
        if nums[i] < min_val:
            min_val = nums[i]
            min_index = i
    return min_val, min_index",61
1650525212,maxNonConsecutiveSum,"def maxNonConsecutiveSum(nums):
    incl = 0
    excl = 0

    for i in nums:
        new_excl = excl if excl>incl else incl

        incl = excl + i
        excl = new_excl

    return max(incl, excl)",61
3002446496,sort_by_frequency,"from collections import Counter

def sort_by_frequency(s: str) -> str:
    counts = sorted(Counter(s).items(), key=lambda item: (-item[1], item[0]))
    result = ''
    for char, count in counts:
        result += char * count
    return result",61
40186515614,max_sub_array,"def max_sub_array(nums):
    max_current = max_global = nums[0]
    for i in range(1, len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",61
23563894525,fib_memo,"def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 2:
        return 1
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]",61
12584613623,count_pattern,"def count_pattern(pattern, text):
    count = start = 0
    while start < len(text):
        pos = text.find(pattern, start)
        if pos != -1:
            start = pos + 1
            count += 1
        else:
            break
    return count",61
35187276081,add_fractions,"from fractions import Fraction

def add_fractions(fraction1: str, fraction2: str) -> str:
    f1 = Fraction(*map(int, fraction1.split(""/"")))
    f2 = Fraction(*map(int, fraction2.split(""/"")))
    return str(f1 + f2)",61
39150631290,all_prime,"def all_prime(list):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, n):
            if n % i == 0:
                return False
        return True

    return all(is_prime(x) for x in list)",61
43177671675,days_between_dates,"from datetime import datetime

def days_between_dates(date1, date2):
  date_format = ""%Y-%m-%d""
  a = datetime.strptime(date1, date_format)
  b = datetime.strptime(date2, date_format)
  delta = b - a
  return abs(delta.days)",61
40547872524,is_string_palindrome,"def is_string_palindrome(s):
    # Remove non-alphanumeric characters and convert to lowercase
    filtered_chars = [char.lower() for char in s if char.isalnum()]
    # Check if the filtered list of characters is equal to its reverse
    return filtered_chars == filtered_chars[::-1]",61
38666260559,target_possible,"def target_possible(numbers, target):
    def func(n, s):
        if n == len(numbers):
            return s == target
        return func(n + 1, s + numbers[n]) or func(n + 1, s - numbers[n])
    return func(0, 0)",61
31899749749,pair_elements,"def pair_elements(lst):
    result = []
    for i in range(0, len(lst), 2):
        if i + 1 < len(lst):
            result.append((lst[i], lst[i + 1]))
        else:
            result.append((lst[i], None))
    return result",61
16879790387,max_sum_nonadjacent,"def max_sum_nonadjacent(nums):
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return max(incl, excl)",61
7054845176,fib_memo,"def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 2:
        return 1
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]",61
31041167112,climb_stairs,"def climb_stairs(n):
    if n <= 2:
        return n
    first, second = 1, 2
    for _ in range(3, n + 1):
        third = first + second
        first, second = second, third
    return second",60
35516011839,smallest_repeating_pattern,"def smallest_repeating_pattern(s):
    for i in range(1, len(s)//2 + 1):
        if len(s) % i == 0:
            if s[:i] * (len(s) // i) == s:
                return s[:i]
    return s",60
13518069516,find_next_greater,"def find_next_greater(arr):
    stack = []
    result = [-1] * len(arr)
    for i in range(len(arr)):
        while stack and arr[stack[-1]] < arr[i]:
            result[stack.pop()] = arr[i]
        stack.append(i)
    return result",60
30865636547,next_Palindrome,"def next_Palindrome(n) : 
    if (n<0): 
        return ""Invalid Input"" 
    n = n + 1
    while(True): 
        if (str(n) == str(n)[::-1]): 
            return n 
        n += 1",60
70848188218,next_greater_elements,"def next_greater_elements(arr):
    result = [-1] * len(arr)
    stack = []
    for i in range(len(arr)):
        while stack and arr[stack[-1]] < arr[i]:
            result[stack.pop()] = arr[i]
        stack.append(i)
    return result",60
19357980730,next_greater,"def next_greater(arr):
    result = [-1] * len(arr)
    stack = []

    for i in range(len(arr)):
        while stack and arr[stack[-1]] < arr[i]:
            result[stack.pop()] = arr[i]
        stack.append(i)
    
    return result",60
30138267965,maxNonAdjacentSum,"def maxNonAdjacentSum(nums):
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl>incl else incl
        incl = excl + i
        excl = new_excl
    return max(excl, incl)",60
26223829457,longestCommonPrefix,"def longestCommonPrefix(strs):
    if not strs: return """"
    shortest_str = min(strs,key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",60
26232361710,uniqueOccurrences,"from typing import List
def uniqueOccurrences(arr: List[int]) -> bool:
    freq = {}
    for num in arr:
        freq[num] = freq.get(num, 0) + 1
    freqSet = set(freq.values())
    return len(freq) == len(freqSet)",60
16303201656,find_substring_count,"def find_substring_count(string, substring):
    count = 0
    start = 0
    while True:
        start = string.find(substring, start)
        if start == -1:
            break
        count += 1
        start += 1
    return count",60
19728387788,find_two_largest,"def find_two_largest(nums):
    first = second = float('-inf')
    for num in nums:
        if num > first:
            second = first
            first = num
        elif num > second and num != first:
            second = num
    return (first, second)",60
27742645028,sum_even_fibonacci,"def sum_even_fibonacci(n):
    a, b = 1, 2
    total = 0
    while b <= n:
        if b % 2 == 0:
            total += b
        a, b = b, a + b
    return total",60
3267115360,most_frequent_words,"from collections import Counter
import re

def most_frequent_words(text):
    words = re.findall(r'\b\w+\b', text)
    cnt = Counter(words)
    max_count = max(cnt.values())
    return [word for word in cnt if cnt[word] == max_count]",60
26632597435,maxNonAdjacentSum,"def maxNonAdjacentSum(nums):
    incl = 0
    excl = 0
    for i in nums:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return max(excl, incl)",60
69844818084,count_pattern,"def count_pattern(string, pattern):
    count = 0
    index = 0
    while index < len(string):
        index = string.find(pattern, index)
        if index == -1:
            break
        count += 1
        index += len(pattern)
    return count",60
17682694801,smallest_diff,"def smallest_diff(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(1, len(arr)):
        if arr[i] - arr[i-1] < min_diff:
            min_diff = arr[i] - arr[i-1]
    return min_diff",60
72101380907,is_valid_palindrome,"def is_valid_palindrome(s: str) -> bool:
    s = ''.join([i.lower() for i in s if i.isalnum()]) # Remove non-alphanumeric characters and convert to lowercase
    return s == s[::-1] # Check if original string is equal to reversed string",60
39717768784,weighted_average,"def weighted_average(values, weights):
    if len(values) != len(weights):
        raise ValueError(""The length of values and weights must be the same."")
    numerator = sum([value * weight for value, weight in zip(values, weights)])
    denominator = sum(weights)
    return numerator / denominator",60
11229579375,date_difference,"from datetime import datetime

def date_difference(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return abs(delta.days)",60
20839153905,maxNonAdjacentSum,"def maxNonAdjacentSum(arr):
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl>incl else incl
        incl = excl + i
        excl = new_excl
    return max(excl, incl)",60
14997387999,first_non_repeating,"def first_non_repeating(lst):
    count = {}
    for num in lst:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
    for num in lst:
        if count[num] == 1:
            return num",60
75069307864,base_to_int,"def base_to_int(num_str, base):
    num_str = str(num_str)
    total = 0
    for i in range(len(num_str)):
        total += int(num_str[i], base) * (base ** (len(num_str) - i - 1))
    return total",60
19849932786,bubble_sort,"def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr",60
40124186240,sum_of_unique,"from typing import List
from collections import Counter

def sum_of_unique(nums: List[int]) -> int:
    nums_counter = Counter(nums)
    a = 0
    for k, v in nums_counter.items():
        if v == 1:
            a += k
    return a",60
4902418315,fib_iterative,"def fib_iterative(n):
    a = 0
    b = 1
    if n == 0:
        return a
    for value in range(0,n-1):
        sum = a + b
        a = b
        b = sum

    return sum",60
9308817014,commonPrefix,"def commonPrefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs,key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",60
40075310267,calculate_difference,"def calculate_difference(nums):
    total_sum = sum(nums)
    left_sum = 0
    result = []

    for num in nums:
        right_sum = total_sum - left_sum - num
        result.append(abs(left_sum - right_sum))
        left_sum += num

    return result",60
11286528357,climbStairs,"def climbStairs(n):
    if n <= 2:
        return n
    first, second = 1, 2
    for _ in range(3, n + 1):
        third = first + second
        first, second = second, third
    return second",60
14115295886,smallest_largest,"def smallest_largest(nums):
    if not nums:
        return None
    
    smallest = largest = nums[0]
    
    for num in nums[1:]:
        if num < smallest:
            smallest = num
        elif num > largest:
            largest = num
    
    return smallest, largest",60
37742645456,solution,"import math


def solution(n):
    answer = 0
    tmp = int(math.sqrt(n))
    if tmp ** 2 == n:
        m = tmp
        answer = (m + 1) ** 2
    else:
        answer = -1

    return answer",60
74543065030,last_digit_of_power,"def last_digit_of_power(base, exponent):
    if exponent == 0:
        return 1
    last_digit = base % 10
    for _ in range(1, exponent):
        last_digit = (last_digit * base) % 10
    return last_digit",60
41343464226,valid_parentheses,"def valid_parentheses(string):
    balance = 0
    for character in string:
        if character == '(':
            balance += 1
        elif character == ')':
            balance -= 1
        if balance < 0:
            return False
    return balance == 0",60
333357115,smallest_missing,"def smallest_missing(arr):
    arr = [x for x in arr if x > 0]
    arr.sort()
    missing = 1
    for num in arr:
        if num == missing:
            missing += 1
        elif num > missing:
            break
    return missing",60
25264791517,search_insert,"def search_insert(nums, target):
    i = len(nums)-1
    while i >= 0 and nums[i] > target:
        i -= 1

    if i >= 0 and nums[i] == target:
        return i
    else:
        return i + 1",60
26366549639,maxNonAdjacentSum,"def maxNonAdjacentSum(nums):
    incl = 0
    excl = 0
    for num in nums:
        new_excl = excl if excl > incl else incl
        incl = excl + num
        excl = new_excl
    return max(incl, excl)",60
12934049225,sum_even_fibonacci,"def sum_even_fibonacci(limit):
    a, b = 1, 2
    result = 0
    while b <= limit:
        if b % 2 == 0:
            result += b
        a, b = b, a + b
    return result",60
38372176365,pattern_repetition,"def pattern_repetition(s):
    for i in range(1, len(s)//2 + 1):
        if len(s) % i == 0:
            if s[:i] * (len(s)//i) == s:
                return len(s)//i
    return 1",60
11121933391,maxNonAdjacentSum,"def maxNonAdjacentSum(arr):
    incl = 0
    excl = 0

    for i in arr:
        new_excl = excl if excl>incl else incl

        incl = excl + i
        excl = new_excl

    return max(excl, incl)",60
19622696079,sum_even_fibonacci,"def sum_even_fibonacci(limit):
    a, b = 1, 2
    total = 0
    while b <= limit:
        if b % 2 == 0:
            total += b
        a, b = b, a + b
    return total",60
11234850392,balanced_parentheses,"def balanced_parentheses(s):
    stack = []
    balanced = 0

    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')' and stack:
            stack.pop()
            if not stack:
                balanced += 1

    return balanced",60
15546086251,find_next_greater,"def find_next_greater(arr):
    result = [-1] * len(arr)
    stack = []
    for i in range(len(arr)):
        while stack and arr[stack[-1]] < arr[i]:
            result[stack.pop()] = arr[i]
        stack.append(i)
    return result",60
37878541165,factorial_Sum,"def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n-1)

def factorial_Sum(n) :
    sum = 0
    for i in range(1,n+1) : 
        sum += factorial(i)
    return sum",60
19676172044,maxSubArray,"def maxSubArray(nums):
    max_current = max_global = nums[0]
    for i in range(1,len(nums)):
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global",60
12820615586,check_bracket_sequence,"def check_bracket_sequence(s):
    balance = 0
    for c in s:
        if c == '(':
            balance += 1
        elif c == ')':
            balance -= 1
        if balance < 0:
            return False
    return balance == 0",60
14362497036,is_repeated_substring,"def is_repeated_substring(s: str) -> bool:
    for i in range(1, len(s)):
        sbstr = s[0:i]
        strr = sbstr * round(len(s)/len(sbstr))
        if strr == s:
            return True
    return False",60
38221109699,find_longest_common_prefix,"def find_longest_common_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs, key=len)
    for i, char in enumerate(shortest):
        for other in strs:
            if other[i] != char:
                return shortest[:i]
    return shortest",60
43416627833,is_valid_email,"import re

def is_valid_email(email):
    pattern = r'^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if re.match(pattern, email):
        return True
    else:
        return False",60
4314870199,find_min_diff,"def find_min_diff(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(len(arr) - 1):
        diff = arr[i + 1] - arr[i]
        if diff < min_diff:
            min_diff = diff
    return min_diff",60
31879900420,maximum_difference,"def maximum_difference(nums):
    ans, _min = -1, 10 ** 9 + 1
    for x in nums:
        if x <= _min:
            _min = x
        else:
            ans = max(ans, x - _min)
    return ans",60
13281769514,find_smallest_divisible,"from math import gcd

def lcm(a, b):
    return a * b // gcd(a, b)

def find_smallest_divisible(n):
    result = 1
    for i in range(1, n + 1):
        result = lcm(result, i)
    return result",60
4615470313,most_frequent,"def most_frequent(List): 
    counter = 0
    num = List[0] 
      
    for i in List: 
        curr_frequency = List.count(i) 
        if(curr_frequency> counter): 
            counter = curr_frequency 
            num = i 
  
    return num",60
9320571157,count_ways_to_climb,"def count_ways_to_climb(n):
    if n == 1 or n == 2:
        return n
    a, b = 1, 2
    for _ in range(2, n):
        a, b = b, a + b
    return b",60
74354425421,find_missing_numbers,"def find_missing_numbers(nums):
    n = len(nums)
    for i in range(n):
        x = abs(nums[i])
        nums[x-1] = -abs(nums[x-1])
    return [i+1 for i in range(n) if nums[i] > 0]",60
20715818877,find_ways,"def find_ways(n):
    ways = 0
    for i in range(1, n):
        temp = 0
        while temp < n:
            temp += i
            i += 1
        if temp == n:
            ways += 1
    return ways",60
34054265701,is_sorted_and_unique,"def is_sorted_and_unique(nums):
    n = len(nums)
    if n <= 1:
        return True
    for i in range(n - 1):
        if nums[i] >= nums[i + 1]:
            return False
    return len(nums) == len(set(nums))",60
14025911092,date_difference,"from datetime import datetime

def date_difference(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return abs(delta.days)",60
27641342232,transpose_matrix,"def transpose_matrix(mat):
    m = len(mat)
    n = len(mat[0])
    newmat = []
    for i in range(n):
        row = []
        for j in range(m):
            row.append(mat[j][i])
        newmat.append(row)
    return newmat",60
20356785882,is_valid_color_code,"import re

def is_valid_color_code(color_code):
    pattern = r'^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$'
    if re.match(pattern, color_code):
        return True
    else:
        return False",60
5655441043,date_difference,"from datetime import datetime

def date_difference(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return abs(delta.days)",60
18874367027,most_frequent_char,"def most_frequent_char(input_string):
    char_dict = {}
    for char in input_string:
        if char in char_dict:
            char_dict[char] += 1
        else:
            char_dict[char] = 1
    return max(char_dict, key=char_dict.get)",60
39157664907,find_next_greater,"def find_next_greater(arr):
    result = [-1] * len(arr)
    stack = []
    for i in range(len(arr)):
        while stack and arr[stack[-1]] < arr[i]:
            result[stack.pop()] = arr[i]
        stack.append(i)
    return result",60
72050616566,find_most_frequent_words,"from collections import Counter

def find_most_frequent_words(word_list):
    word_counts = Counter(word_list)
    max_count = max(word_counts.values())
    most_frequent_words = [word for word, count in word_counts.items() if count == max_count]
    return most_frequent_words",60
2881764627,product_even_odd,"def product_even_odd(numbers):
    even_product = 1
    odd_product = 1
    for number in numbers:
        if number % 2 == 0:
            even_product *= number
        else:
            odd_product *= number
    return (even_product, odd_product)",60
25758398259,find_longest_common_prefix,"def find_longest_common_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs, key=len)
    for i, char in enumerate(shortest):
        for other in strs:
            if other[i] != char:
                return shortest[:i]
    return shortest",60
70290536457,stars_and_bars,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def stars_and_bars(n, r):
    return factorial(n + r - 1) // (factorial(r - 1) * factorial(n))",60
33496728906,smallest_repeating_cycle,"def smallest_repeating_cycle(s):
    length = len(s)
    for i in range(1, length // 2 + 1):
        if length % i == 0:
            if s[:i] * (length // i) == s:
                return i
    return length",60
34085812426,smallest_difference,"def smallest_difference(lst):
    lst.sort()
    min_diff = float('inf')
    for i in range(len(lst) - 1):
        diff = abs(lst[i] - lst[i + 1])
        if diff < min_diff:
            min_diff = diff
    return min_diff",60
1456560101,date_difference,"from datetime import datetime

def date_difference(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return abs(delta.days)",60
7282374263,staircase,"def staircase(n):
    if n <= 1:
        return 1
    first, second = 1, 1
    for i in range(2, n + 1):
        third = first + second
        first = second
        second = third
    return second",60
13879980589,valid_parentheses,"def valid_parentheses(string):
    balance = 0
    for char in string:
        if char == '(':
            balance += 1
        elif char == ')':
            balance -= 1
            if balance < 0:
                return False
    return balance == 0",60
3088079425,fibonacci_memo,"def fibonacci_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo)
    return memo[n]",60
13538766505,is_valid_hexadecimal,"def is_valid_hexadecimal(hexa):
    valid_chars = set(""0123456789ABCDEFabcdef"")
    if hexa == """":
        return False
    for char in hexa:
        if char not in valid_chars:
            return False
    return True",60
74267633590,count_even_odd,"def count_even_odd(numbers):
    even_count = 0
    odd_count = 0
    for num in numbers:
        if num % 2 == 0:
            even_count += 1
        else:
            odd_count += 1
    return even_count, odd_count",60
16459058671,find_substring_count,"def find_substring_count(string, substring):
    count = 0
    start = 0
    while True:
        start = string.find(substring, start)
        if start == -1:
            break
        count += 1
        start += 1
    return count",60
26622699662,maxNonAdjacentSum,"def maxNonAdjacentSum(arr):
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl>incl else incl
        incl = excl + i
        excl = new_excl
    return max(excl, incl)",60
4900199452,common_prefix,"def common_prefix(strs):
    if not strs:
        return """"
    shortest_str = min(strs,key=len)
    for i, char in enumerate(shortest_str):
        for other in strs:
            if other[i] != char:
                return shortest_str[:i]
    return shortest_str",60
20734880097,has_three_consecutive_odds,"def has_three_consecutive_odds(nums):
    count = 0
    for num in nums:
        if num % 2 != 0:
            count += 1
            if count == 3:
                return True
        else:
            count = 0
    return False",60
26865248046,find_pair,"def find_pair(numbers, target):
    if len(numbers) <= 1:
        return None
    nums_dict = {}
    for num in numbers:
        if target - num in nums_dict:
            return [target - num, num]
        nums_dict[num] = True
    return None",60
70034287107,climb_Stairs,"def climb_Stairs(n):
    if n <= 2:
        return n
    first, second = 1, 2
    for i in range(3, n + 1):
        third = first + second
        first, second = second, third
    return second",60
42322796439,maxNonAdjacentSum,"def maxNonAdjacentSum(arr):
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl>incl else incl
        incl = excl + i
        excl = new_excl
    return max(incl, excl)",60
39212697493,ladder_climbing,"def ladder_climbing(n):
    if n <= 2:
        return n
    first, second = 1, 2
    for _ in range(3, n+1):
        third = first + second
        first, second = second, third
    return third",60
72915666769,climbStairs,"def climbStairs(n):
    if n <= 2:
        return n
    first, second = 1, 2
    for _ in range(3, n + 1):
        third = first + second
        first, second = second, third
    return second",60
18957348177,count_ways,"def count_ways(n):
    if n <= 1:
        return 1
    first, second = 1, 1
    for i in range(2, n+1):
        third = first + second
        first, second = second, third
    return second",60
15951647951,count_substring_occurrences,"def count_substring_occurrences(s, sub):
    count = 0
    pos = 0
    while True:
        pos = s.find(sub, pos)
        if pos == -1:
            break
        count += 1
        pos += 1
    return count",60
12501727491,date_difference,"from datetime import datetime

def date_difference(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return abs(delta.days)",60
8402831541,stock_max_profit,"def stock_max_profit(prices):
    max_profit = 0
    min_price = float('inf')
    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)
    return max_profit",60
20088623018,repeated_words,"import re
def repeated_words(sentence):
    words = sentence.split()
    repeated_words = []
    for i in range(len(words)-1):
        if words[i] == words[i+1] and words[i] not in repeated_words:
            repeated_words.append(words[i])
    return repeated_words",60
6423260175,max_product_adjacent,"def max_product_adjacent(numbers):
    max_product = float('-inf')
    for i in range(len(numbers) - 1):
        current_product = numbers[i] * numbers[i + 1]
        if current_product > max_product:
            max_product = current_product
    return max_product",60
26414784815,remove_element,"def remove_element(nums, val):
  i = -1
  j = 0
  while j < len(nums):
    if nums[j] != val:
      i += 1
      nums[i] = nums[j]
    j += 1
  return i + 1",60
38122465900,increasingTriplet,"def increasingTriplet(nums):
    first_min = second_min = float('inf')
    for num in nums:
        if num <= first_min:
            first_min = num
        elif num <= second_min:
            second_min = num
        else:
            return True
    return False",59
37888021916,median_of_three,"def median_of_three( x, y, z ):
    if (x - y) * (z - x) >= 0:
        return x
    elif (y - x) * (z - y) >= 0:
        return y
    else:
        return z",59
27983093688,largest_digit,"def largest_digit(n):
    n = abs(n)
    max_digit = 0
    while n > 0:
        current_digit = n % 10
        max_digit = max(max_digit, current_digit)
        n = n // 10
    return max_digit",59
23106838494,find_most_frequent_char,"def find_most_frequent_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    return max(char_count, key=char_count.get)",59
2706273097,is_leap_year,"def is_leap_year(year):
  if year % 4 != 0:
    return False
  elif year % 100 != 0:
    return True
  elif year % 400 != 0:
    return False
  else:
    return True",59
2426840718,permutations,"def permutations(nums):
    if len(nums) == 1:
        return [nums]
    result = []
    for i in range(len(nums)):
        for p in permutations(nums[:i] + nums[i+1:]):
            result.append([nums[i]] + p)
    return result",59
11443845105,smallest_greater,"def smallest_greater(arr, x):
    min_val = float('inf')
    index = -1
    for i in range(len(arr)):
        if arr[i] > x and arr[i] < min_val:
            min_val = arr[i]
            index = i
    return index",59
35745417430,isValidBinary,"def isValidBinary(s: str) -> bool:
    if s == '0':
        return True
    if s[0] == '0':
        return False
    for char in s:
        if char not in ('0', '1'):
            return False
    return True",59
7199272590,largest_palindrome,"def largest_palindrome(n):
    if n < 0:
        return None

    def is_palindrome(x):
        return str(x) == str(x)[::-1]

    for i in range(n, -1, -1):
        if is_palindrome(i):
            return i",59
32353887522,median_of_three,"def median_of_three(x, y, z):
    if x <= y <= z or z <= y <= x:
        median = y
    elif y <= x <= z or z <= x <= y:
        median = x
    else:
        median = z
    return median",59
37809494874,is_permutation,"def is_permutation(arr):
    n = len(arr)
    seen = [False] * n
    for num in arr:
        if num > n or seen[num - 1]:
            return False
        seen[num - 1] = True
    return all(seen)",59
19099430818,unique_permutations,"from itertools import permutations

def unique_permutations(arr):
    perm_list = list(permutations(arr))
    unique_perm_list = []
    for perm in perm_list:
        if list(perm) not in unique_perm_list:
            unique_perm_list.append(list(perm))
    return unique_perm_list",59
20551511182,max_unique_chars,"def max_unique_chars(lst):
    max_str = """"
    max_unique = 0
    for string in lst:
        unique_chars = set(string)
        if len(unique_chars) > max_unique:
            max_unique = len(unique_chars)
            max_str = string
    return max_str",59
27426426306,check,"def check(string):
    temp = {')':'('}
    stack = []
    for i in string:
        if(i not in temp):
            stack.append(i)
        else:
            if(not stack or temp[i] != stack.pop()):
                return False
    return len(stack)==0",59
24814694053,count_valid_parentheses,"def count_valid_parentheses(n):
    if n == 0:
        return 1
    result = 0
    for i in range(n):
        result += count_valid_parentheses(i) * count_valid_parentheses(n - 1 - i)
    return result",59
72985079637,min_abs_difference,"def min_abs_difference(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(1, len(arr)):
        diff = abs(arr[i] - arr[i-1])
        if diff < min_diff:
            min_diff = diff
    return min_diff",59
39658499520,valid_hex_color,"import re
def valid_hex_color(color):
    if re.match(r'^#([A-Fa-f0-9]{6})$', color):
        return f""{color} is a valid hexadecimal color code.""
    else:
        return f""{color} is an invalid hexadecimal color code.""",59
40510108278,find_range,"def find_range(numbers):
    result = []
    for index, number in enumerate(numbers):
        if 10 < number[0] < 100 and 10 < number[1] < 100:
            result.append((index, number))
    return result",59
21090896522,is_valid_bracket_sequence,"def is_valid_bracket_sequence(s: str) -> bool:
    stack = []
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack or stack.pop() != '(':
                return False
    return not stack",59
10242551487,nextGreaterElement,"def nextGreaterElement(nums):
    stack = []
    result = [-1] * len(nums)
    for i, num in enumerate(nums):
        while stack and nums[stack[-1]] < num:
            result[stack.pop()] = num
        stack.append(i)
    return result",59
12215289621,fahrenheit_to_celsius,"def fahrenheit_to_celsius(fahrenheit):
    """"""
    Convert temperature from Fahrenheit to Celsius.

    Args:
    fahrenheit (float): Temperature in Fahrenheit.

    Returns:
    float: Temperature in Celsius.
    """"""
    return (fahrenheit - 32) * 5/9",59
6257698947,tup_to_dict,"def tup_to_dict(tuples):
    dictionary = {}
    for tup in tuples:
        if tup[0] in dictionary:
            dictionary[tup[0]].append(tup[1])
        else:
            dictionary[tup[0]] = [tup[1]]
    return dictionary",59
26475217841,find_sym_diff,"def find_sym_diff(list1, list2):
    set1 = set(list1)
    set2 = set(list2)
    diff1 = list(set1.difference(set2))
    diff2 = list(set2.difference(set1))
    return (diff1, diff2)",59
34745168717,findMaxProduct,"def findMaxProduct(nums):
    max_product = 0
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[i]*nums[j] > max_product:
                max_product = nums[i]*nums[j]
    return max_product",59
8414846993,is_leap_year,"def is_leap_year(year):
    if year % 400 == 0:
        return True
    elif year % 100 == 0:
        return False
    elif year % 4 == 0:
        return True
    else:
        return False",59
39105569461,two_sum,"def two_sum(nums, target):
    freq_count = {}
    for i in range(len(nums)):
        complement = target - nums[i]
        if complement in freq_count:
            return [freq_count[complement], i]
        freq_count[nums[i]] = i
    return []",59
17272478666,pascal_row,"def pascal_row(n):
    row = [1] * (n + 1)
    for i in range(n + 1):
        for j in range(i - 1, 0, -1):
            row[j] += row[j - 1]
    return row",59
19764697451,max_profit,"def max_profit(prices):
    max_profit = 0
    min_price = float('inf')
    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)
    return max_profit",59
34341724905,is_leap_year,"def is_leap_year(year):
  if year % 4 != 0:
    return False
  elif year % 100 != 0:
    return True
  elif year % 400 != 0:
    return False
  else:
    return True",59
14102733167,is_perfect_number,"def is_perfect_number(n):
    if n < 1:
        return False
    sum_divisors = 0
    for i in range(1, n):
        if n % i == 0:
            sum_divisors += i
    return sum_divisors == n",59
70658091829,min_abs_diff,"def min_abs_diff(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(1, len(arr)):
        diff = abs(arr[i] - arr[i-1])
        if diff < min_diff:
            min_diff = diff
    return min_diff",59
39871356353,check_zero_sum_subarray,"def check_zero_sum_subarray(arr):
    hash_set = set()
    sum = 0
    for i in range(len(arr)):
        sum += arr[i]
        if sum == 0 or sum in hash_set:
            return True
        hash_set.add(sum)
    return False",59
28930489844,remove_consecutive_duplicates,"def remove_consecutive_duplicates(arr):
    if not arr:
        return []
        
    new_arr = [arr[0]]
    for i in range(1, len(arr)):
        if arr[i] != arr[i-1]:
            new_arr.append(arr[i])
            
    return new_arr",59
37104862255,find_pattern,"def find_pattern(text, pattern):
    indexes = []
    pattern_len = len(pattern)
    text_len = len(text)

    for i in range(text_len - pattern_len + 1):
        if text[i:i+pattern_len] == pattern:
            indexes.append(i)
    return indexes",59
40124595120,is_valid_parentheses,"def is_valid_parentheses(s: str) -> bool:
    stack = []
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack or stack.pop() != '(':
                return False
    return not stack",59
72101377067,min_substring_length,"def min_substring_length(s):
    length = len(s)
    for i in range(1, length//2 + 1):
        if length % i == 0:
            if s[:i] * (length // i) == s:
                return i
    return length",59
31215033124,find_max_sum,"def find_max_sum(arr):
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return max(incl, excl)",59
74794586518,fib_count,"def fib_count(arr):
    def is_fib(n):
        a, b = 0, 1
        while a < n:
            a, b = b, a + b
        return a == n
    return sum(is_fib(x) for x in arr)",59
20636943757,find_max_product,"def find_max_product(nums):
    max_product = nums[0] * nums[1]
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            max_product = max(max_product, nums[i] * nums[j])
    return max_product",59
827732716,partition,"def partition(n):
    p = [1] + [0]*n
    for i in range(1, n+1):
        k = i
        while k <= n:
            p[k] += p[k-i]
            k += 1
    return p[n]",59
11384438791,ways_to_express,"def ways_to_express(n):
    if n < 0:
        return 0
    if n == 0:
        return 1
    return ways_to_express(n-1) + ways_to_express(n-3) + ways_to_express(n-4)",59
42091447702,count_valid_parentheses,"def count_valid_parentheses(n):
    if n == 0:
        return 1
    count = 0
    for i in range(n):
        count += count_valid_parentheses(i) * count_valid_parentheses(n - 1 - i)
    return count",59
45317083315,unique_char_count,"def unique_char_count(s):
    return len(set(s))

assert unique_char_count(""abc"") == 3
assert unique_char_count(""aabbcc"") == 3
assert unique_char_count(""abcdefg"") == 7
assert unique_char_count(""aA"") == 2",59
39005323778,decimal_to_binary,"def decimal_to_binary(decimal_num):
    if decimal_num == 0:
        return ""0""
    binary_num = """"
    while decimal_num > 0:
        binary_num = str(decimal_num % 2) + binary_num
        decimal_num //= 2
    return binary_num",59
10371552644,count_subarrays,"def count_subarrays(nums, target):
    count = 0
    for i in range(len(nums)):
        sum = 0
        for j in range(i, len(nums)):
            sum += nums[j]
            if sum == target:
                count += 1
    return count",59
17544759237,find_longest_prefix,"def find_longest_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, char in enumerate(shortest):
        for others in strs:
            if others[i] != char:
                return shortest[:i] 
    return shortest",59
72807772105,remove_consecutive,"def remove_consecutive(str1):
    if len(str1) <= 1:
        return str1

    result = [str1[0]]
    for char in str1[1:]:
        if char != result[-1]:
            result.append(char)
    return ''.join(result)",59
41694476269,remove_second_smallest,"def remove_second_smallest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return numbers
    unique_numbers.sort()
    second_smallest = unique_numbers[1]
    return [num for num in numbers if num != second_smallest]",59
73148510666,smallest_repeating_cycle,"def smallest_repeating_cycle(s):
    n = len(s)
    for i in range(1, n//2 + 1):
        if n % i == 0:
            if s[:i] * (n//i) == s:
                return i
    return n",59
17905127145,odd_length_subarrays_sum,"def odd_length_subarrays_sum(arr):
  total_sum = 0
  n = len(arr)
  for i in range(n):
    total_sum += ((i + 1) * (n - i) + 1) // 2 * arr[i]
  return total_sum",59
27046339992,count_pattern_occurrences,"def count_pattern_occurrences(string, pattern):
    count = 0
    start = 0
    while True:
        start = string.find(pattern, start)
        if start == -1:
            break
        count += 1
        start += len(pattern)
    return count",59
4582163070,multiply_nested_tuples,"def multiply_nested_tuples(test_tup1, test_tup2):
  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))
              for tup1, tup2 in zip(test_tup1, test_tup2))
  return (res)",59
14953904574,findLongestCommonPrefix,"def findLongestCommonPrefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, ch in enumerate(shortest):
        for other in strs:
            if other[i] != ch:
                return shortest[:i]
    return shortest",59
14558203629,count_number_in_list_of_lists,"def count_number_in_list_of_lists(lst, num):
    count = 0
    for i in lst:
        if type(i) == list:
            count += count_number_in_list_of_lists(i, num)
        elif i == num:
            count += 1
    return count",59
9771140845,is_ugly_number,"def is_ugly_number(num: int) -> bool:
    if num <= 0:
        return False
    for i in [2, 3, 5]:
        while num % i == 0:
            num = num // i
    return num == 1",59
30202471774,majority_element,"def majority_element(nums):
    count = 0
    result = 0
    for num in nums:
        if count == 0:
            result = num
        if num == result:
            count += 1
        else:
            count -= 1
    return result",59
8070246788,find_smallest_difference,"def find_smallest_difference(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(len(arr)-1):
        diff = abs(arr[i] - arr[i+1])
        if diff < min_diff:
            min_diff = diff
    return min_diff",59
1059675864,is_symmetric,"def is_symmetric(matrix):
    if len(matrix) != len(matrix[0]):
        return False
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            if matrix[i][j] != matrix[j][i]:
                return False
    return True",59
30423768713,sum_and_product,"def sum_and_product(n):
    s, p = 0, 1
    while n > 0:
        i = n % 10
        s += i
        p *= i
        n = n // 10
    return (s, p)",59
3789059595,find_repeating_pattern,"def find_repeating_pattern(s):
    for i in range(1, len(s)//2 + 1):
        if len(s) % i == 0:
            if s[:i]*(len(s)//i) == s:
                return len(s)//i
    return 1",59
39383994052,is_leap_year,"def is_leap_year(year):
    if year % 4 != 0:
        return False
    elif year % 100 != 0:
        return True
    elif year % 400 != 0:
        return False
    else:
        return True",59
11234995349,find_longest_common_prefix,"def find_longest_common_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, ch in enumerate(shortest):
        for other in strs:
            if other[i] != ch:
                return shortest[:i]
    return shortest",59
37984963609,index_addition,"def index_addition(test_tup1, test_tup2):
  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))
   for tup1, tup2 in zip(test_tup1, test_tup2))
  return (res)",59
42783227953,count_substrings_with_ones,"def count_substrings_with_ones(binary_string):
    count = 0
    total = 0
    for bit in binary_string:
        if bit == '1':
            count += 1
            total += count
        else:
            count = 0
    return total",59
22631432388,smallest_number_and_index,"def smallest_number_and_index(lst):
    min_val = lst[0]
    min_idx = 0
    for idx, val in enumerate(lst):
        if val < min_val:
            min_val = val
            min_idx = idx
    return (min_val, min_idx)",59
9352967957,can_form_sequence,"def can_form_sequence(lst): 
    if not lst: 
        return False
    lst = sorted(lst) 
    for i in range(1, len(lst)): 
        if lst[i] != lst[i-1] + 1: 
            return False
    return True",59
20527946590,is_power_of_three,"def is_power_of_three(num: int) -> bool:
    if (num == 0):
        return False
    power = []
    for i in range(19):
        power.append(3 ** i)
        if (num in power):
            return True
    return False",59
39437049994,find_most_frequent_char,"def find_most_frequent_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    return max(char_count, key=char_count.get)",59
3158969075,letter_case_count,"def letter_case_count(input_string):
    uppercase_count = sum(1 for c in input_string if c.isupper())
    lowercase_count = sum(1 for c in input_string if c.islower())
    return {'Uppercase': uppercase_count, 'Lowercase': lowercase_count}",59
36876159818,max_sum_non_adjacent,"def max_sum_non_adjacent(arr):
    incl = 0
    excl = 0

    for i in arr:
        new_excl = max(incl, excl)
        incl = excl + i
        excl = new_excl

    return max(incl, excl)",59
70191512730,pascals_triangle_row,"def pascals_triangle_row(n):
    row = [1] * (n + 1)
    for i in range(1, n + 1):
        row[i] = row[i-1] * (n - i + 1) // i
    return row",59
25906156972,count_consonants,"def count_consonants(s):
    consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ""
    ans = 0
    for i in s:
        if i in consonants:
            ans += 1
    return ans",59
19956085424,check_isogram,"def check_isogram(string):
    string = string.lower() #Convert the string to lowercase to handle case sensitivity
    return len(string) == len(set(string)) #If the length of the string is equal to the length of the set of characters in the string, it is an isogram",59
34280643209,find_repeating_pattern,"def find_repeating_pattern(s):
    for i in range(1, len(s)//2 + 1):
        if len(s) % i == 0:
            if s[:i]*(len(s)//i) == s:
                return len(s)//i
    return 1",59
34854154348,staircase_ways,"def staircase_ways(n):
    if n <= 1:
        return n
    first = 1
    second = 2
    for _ in range(2, n):
        temp = second
        second = first + second
        first = temp
    return second",59
14669055229,list_of_primes,"def list_of_primes(n):
    primes = []
    for num in range(2, n + 1):
        for i in range(2, num):
            if (num % i) == 0:
                break
        else:
            primes.append(num)
    return primes",59
41145207798,word_count,"def word_count(text):
    words = text.split()
    word_count_dict = {}
    for word in words:
        if word in word_count_dict:
            word_count_dict[word] += 1
        else:
            word_count_dict[word] = 1
    return word_count_dict",59
23341577214,rotateMatrix,"def rotateMatrix(matrix):
    n = len(matrix)
    result = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            result[j][n - i - 1] = matrix[i][j]
    return result",59
26295342796,shift_right,"def shift_right(A, K):
    if not len(A):
        return A

    N = len(A)
    B = [None] * N

    for i in range(0, N):
        B[(i + K) % N] = A[i]
    return B",59
73864278488,find_smallest_pattern,"def find_smallest_pattern(s):
    length = len(s)
    for i in range(1, length//2 + 1):
        if length % i == 0:
            if s[:i]*(length//i) == s:
                return s[:i]
    return None",59
17542356853,next_greater,"def next_greater(arr):
    result = [-1] * len(arr)
    stack = []
    for i in range(len(arr)):
        while stack and arr[i] > arr[stack[-1]]:
            result[stack.pop()] = arr[i]
        stack.append(i)
    return result",59
26262088611,majority_element,"def majority_element(nums):
    count = 0
    result = 0
    for i in nums:
        if count == 0:
            result = i
        if i == result:
            count += 1
        else:
            count -= 1
    return result",59
365071335,collatz_sequence,"def collatz_sequence(n):
    sequence = [n]
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence",59
33971933061,next_greater_element,"def next_greater_element(array):
    result = [-1] * len(array)
    stack = []
    for i, num in enumerate(array):
        while stack and array[stack[-1]] < num:
            result[stack.pop()] = num
        stack.append(i)
    return result",59
15217871548,collatz_sequence,"def collatz_sequence(n):
    sequence = [n]
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence",59
33831009878,find_most_frequent_char,"def find_most_frequent_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    return max(char_count, key=char_count.get)",59
40622185868,find_Largest_Smallest,"def find_Largest_Smallest(arr):
    largest = arr[0]
    smallest = arr[0]
    for i in arr:
        if i > largest:
            largest = i
        if i < smallest:
            smallest = i
    return (largest, smallest)",59
36750045583,next_greater_element,"def next_greater_element(arr):
    result = [-1]*len(arr)
    stack = []
    for i in range(len(arr)):
        while stack and arr[i] > arr[stack[-1]]:
            result[stack.pop()] = arr[i]
        stack.append(i)
    return result",59
41567916551,find_most_frequent_char,"def find_most_frequent_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    return max(char_count, key=char_count.get)",59
17210094724,longest_Common_Prefix,"def longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest = min(strs, key=len)
    for i, char in enumerate(shortest):
        for other in strs:
            if other[i] != char:
                return shortest[:i]
    return shortest",59
23384373115,ways_to_traverse,"def ways_to_traverse(distance):
    if distance == 0:
        return 1
    if distance < 0:
        return 0
    return ways_to_traverse(distance-1) + ways_to_traverse(distance-2) + ways_to_traverse(distance-3)",59
8648512068,days_between_dates,"from datetime import datetime

def days_between_dates(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return delta.days",59
29744332050,smallest_common_multiple,"def smallest_common_multiple(a,b):
    #finding the greatest common divisor
    def gcd(x,y):
        while(y):
            x,y=y,x%y
        return x
    #finding the least common multiple
    lcm = (a*b)//gcd(a,b)
    return lcm",59
33402286993,smallest_difference,"def smallest_difference(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(len(arr)-1):
        if arr[i+1] - arr[i] < min_diff:
            min_diff = arr[i+1] - arr[i]
    return min_diff",59
74866393623,next_greater_element,"def next_greater_element(nums):
    result = [-1] * len(nums)
    stack = []
    for i, num in enumerate(nums):
        while stack and nums[stack[-1]] < num:
            result[stack.pop()] = num
        stack.append(i)
    return result",59
69921592850,count_pattern_occurrence,"def count_pattern_occurrence(text, pattern):
    count = 0
    start = 0
    while True:
        start = text.find(pattern, start)
        if start == -1:
            break
        count += 1
        start += len(pattern)
    return count",59
32934219346,fibonacci_recursive,"def fibonacci_recursive(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0, 1]
    else:
        fib = fibonacci_recursive(n - 1)
        fib.append(fib[-1] + fib[-2])
        return fib",59
39779802272,document_review_days,"from datetime import datetime

def document_review_days(start_date, end_date):
    start = datetime.strptime(start_date, ""%Y-%m-%d"")
    end = datetime.strptime(end_date, ""%Y-%m-%d"")
    delta = end - start
    return delta.days + 1",59
74337296530,fibonacci_sum,"def fibonacci_sum(n):
    if n <= 0:
        return 0
    a, b = 0, 1
    total = 0
    while b <= n:
        total += b
        a, b = b, a + b
    return total",59
72958175873,smallest_difference,"def smallest_difference(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(len(arr)-1):
        if arr[i+1] - arr[i] < min_diff:
            min_diff = arr[i+1] - arr[i]
    return min_diff",59
40289124181,recursive_factorial,"def recursive_factorial(n):
    # base case: 1! = 1
    if n == 1:
        return 1
    # recursive case: n! = n * (n-1)!
    else:
        return n * recursive_factorial(n-1)",59
748815245,max_days,"def max_days(food_amount, daily_consumption):
    if daily_consumption <= 0:
        raise ValueError('Daily consumption must be more than zero')
    return food_amount // daily_consumption if food_amount % daily_consumption == 0 else food_amount // daily_consumption + 1",59
19408773463,is_leap_year,"def is_leap_year(year):
    if year % 4 != 0:
        return False
    elif year % 100 != 0:
        return True
    elif year % 400 != 0:
        return False
    else:
        return True",59
74903994677,convert_3x,"def convert_3x(n):
    lst = []
    num = 0
    while len(lst) != n:
        num += 1
        if num%3 != 0 and '3' not in str(num):
            lst.append(num)
    return lst[-1]",59
39797451520,min_adjacent_difference,"def min_adjacent_difference(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(len(arr)-1):
        diff = abs(arr[i] - arr[i+1])
        if diff < min_diff:
            min_diff = diff
    return min_diff",59
9499058194,lis,"def lis(nums):
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)",59
9215834001,permutations,"def permutations(nums):
    if len(nums) == 1:
        return [nums]
    result = []
    for i in range(len(nums)):
        for perm in permutations(nums[:i] + nums[i+1:]):
            result.append([nums[i]] + perm)
    return result",59
15242076365,longest_Common_Prefix,"def longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, char in enumerate(shortest):
        for other in strs:
            if other[i] != char:
                return shortest[:i]
    return shortest",58
32362525917,max_element,"def max_element(arr):
    if len(arr) == 1:
        return arr[0]
    mid = len(arr) // 2
    left_max = max_element(arr[:mid])
    right_max = max_element(arr[mid:])
    return max(left_max, right_max)",58
26622393304,kthLargestElement,"import heapq

def kthLargestElement(nums, k):
    min_heap = []
    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    return min_heap[0]",58
2446877837,find_largest_digit,"def find_largest_digit(n):
    n = abs(n)
    largest = 0
    while n > 0:
        digit = n % 10
        if digit > largest:
            largest = digit
        n = n // 10
    return largest",58
31483649163,most_frequent_word,"def most_frequent_word(words):
    word_count = {}
    for word in words:
        if word in word_count:
            word_count[word] += 1
        else:
            word_count[word] = 1
    return max(word_count, key=word_count.get)",58
20352370597,divisible_by_all,"from math import gcd

def lcm(a, b):
    return a * b // gcd(a, b)

def divisible_by_all(n):
    result = 1
    for i in range(1, n + 1):
        result = lcm(result, i)
    return result",58
32825730952,diff_date,"from datetime import datetime

def diff_date(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return delta.days",58
9697326036,climb_Stairs,"def climb_Stairs(n: int) -> int:
    if n == 1:
        return 1
    first, second = 1, 2
    for i in range(2, n):
        first, second = second, first + second
    return second",58
38921072985,is_pangram,"import string

def is_pangram(sentence):
    alphabet = set(string.ascii_lowercase)
    sentence = sentence.lower()
    for char in sentence:
        if char in alphabet:
            alphabet.remove(char)
        if len(alphabet) == 0:
            return True
    return False",58
33721124098,decimal_to_binary_string,"def decimal_to_binary_string(decimal_number):
    binary_string = """"
    while decimal_number > 0:
        binary_string = str(decimal_number % 2) + binary_string
        decimal_number = decimal_number // 2
    return ""db"" + binary_string + ""db""",58
12069725785,count_unique_substrings,"def count_unique_substrings(s):
    n = len(s)
    unique_substrings = set()
    
    for i in range(n):
        for j in range(i+1, n+1):
            unique_substrings.add(s[i:j])
            
    return len(unique_substrings)",58
39031633912,find_smallest_difference,"def find_smallest_difference(lst):
    lst.sort()
    min_diff = float('inf')
    for i in range(len(lst)-1):
        diff = lst[i+1] - lst[i]
        if diff < min_diff:
            min_diff = diff
    return min_diff",58
31804108097,median_of_three,"def median_of_three(x, y, z):
    if (x - y) * (z - x) >= 0:
        return x
    elif (y - x) * (z - y) >= 0:
        return y
    else:
        return z",58
31953390381,longest_Common_Prefix,"def longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, ch in enumerate(shortest):
        for other in strs:
            if other[i] != ch:
                return shortest[:i]
    return shortest",58
25682075822,to_lower_case,"def to_lower_case(s):
    lower_string = """"
    for char in s:
        if ord('A') <= ord(char) <= ord('Z'):
            lower_string += chr(ord(char) + 32)
        else:
            lower_string += char
    return lower_string",58
73096122618,check_double_exists,"def check_double_exists(arr):
    s = {arr[0]}
    for a in arr:
        if (a % 2 == 0 and a // 2 in s) or a * 2 in s:
            return True
        s.add(a)
    return False",58
75246705945,pascal_row,"def pascal_row(n):
    row = [1] * (n + 1)
    for i in range(1, n + 1):
        row[i] = int(row[i-1] * (n - i + 1) / i)
    return row",58
17540343588,shortest_pattern,"def shortest_pattern(str):
    length = len(str)
    for x in range(1, length//2 + 1):
        if length % x == 0:
            if str[:x] * (length//x) == str:
                return x
    return -1",58
19669698700,find_equilibrium_index,"def find_equilibrium_index(arr):
    total_sum = sum(arr)
    left_sum = 0
    for i, num in enumerate(arr):
        total_sum -= num
        if left_sum == total_sum:
            return i
        left_sum += num
    return -1",58
2512540858,round_list,"from math import floor, ceil

def round_list(numbers):
    rounded_list = []
    for number in numbers:
        if number - floor(number) >= 0.5:
            rounded_list.append(ceil(number))
        else:
            rounded_list.append(floor(number))
    return rounded_list",58
5959714962,date_diff,"from datetime import datetime

def date_diff(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return delta.days",58
21091380722,find_largest_digit,"def find_largest_digit(number):
    number = abs(number)
    largest_digit = 0
    while number > 0:
        digit = number % 10
        largest_digit = max(largest_digit, digit)
        number //= 10
    return largest_digit",58
74896195666,permute,"def permute(s):
    if len(s) == 1:
        return [s]
    result = []
    for i in range(len(s)):
        for perm in permute(s[:i]+s[i+1:]):
            result.append(s[i]+perm)
    return result",58
3473878804,find_pattern_count,"def find_pattern_count(text, pattern):
    count = 0
    pos = 0
    while True:
        pos = text.find(pattern, pos)
        if pos == -1:
            break
        count += 1
        pos += 1
    return count",58
21464062888,max_pairwise_product,"def max_pairwise_product(numbers):
    n = len(numbers)
    max_product = 0
    for i in range(n):
        for j in range(i + 1, n):
            max_product = max(max_product, numbers[i] * numbers[j])
    return max_product",58
6086226418,count_pattern_occurrences,"def count_pattern_occurrences(s, pattern):
    n = len(s)
    m = len(pattern)
    count = 0
    for i in range(n - m + 1):
        if s[i:i+m] == pattern:
            count += 1
    return count",58
20671454951,isSubsequence,"def isSubsequence(sub: str, big: str) -> bool:
    idx = 0
    for c in big:
        if idx == len(sub):
            return True
        if c == sub[idx]:
            idx += 1
    return idx == len(sub)",58
7583822690,find_Repeating_Pattern,"def find_Repeating_Pattern(s):
    for i in range(1, len(s)//2 + 1):
        if len(s) % i == 0:
            if s[:i]*(len(s)//i) == s:
                return s[:i]
    return s",58
73751524953,find_longest_prefix,"def find_longest_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, ch in enumerate(shortest):
        for other in strs:
            if other[i] != ch:
                return shortest[:i]
    return shortest",58
20301270349,find_max_difference,"def find_max_difference(arr):
    diff = 0
    min_element = arr[0]
    for i in range(1, len(arr)):
        diff = max(diff, arr[i] - min_element)
        min_element = min(min_element, arr[i])
    return diff",58
40853122671,find_distance,"import math
def find_distance(point1, point2):
    x1, y1 = point1
    x2, y2 = point2
    distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return distance",58
5213798513,findKthLargest,"import heapq
def findKthLargest(nums, k):
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
    for _ in range(len(nums) - k):
        heapq.heappop(heap)
    return heapq.heappop(heap)",58
19512967410,dec_to_bin,"def dec_to_bin(dec):
    if dec == 0:
        return '0'
    binary = ''
    while dec > 0:
        remainder = dec % 2
        dec = dec // 2
        binary = str(remainder) + binary
    return binary",58
71359044826,next_greater_element,"def next_greater_element(array):
  stack = []
  result = [-1] * len(array)
  for idx, num in enumerate(array):
    while stack and num > array[stack[-1]]:
      result[stack.pop()] = num
    stack.append(idx)
  return result",58
28374614732,to_lower_case,"def to_lower_case(s):
    lower_case_string = """"
    for char in s:
        if 'A' <= char <= 'Z':
            lower_case_string += chr(ord(char) + 32)
        else:
            lower_case_string += char
    return lower_case_string",58
27264257113,days_between,"from datetime import datetime

def days_between(date1, date2):
    d1 = datetime.strptime(date1, ""%Y-%m-%d"")
    d2 = datetime.strptime(date2, ""%Y-%m-%d"")
    return abs((d2 - d1).days)",58
32193680477,permutations,"def permutations(string):
    if len(string) == 1:
        return [string]
    result = []
    for i in range(len(string)):
        for perm in permutations(string[:i] + string[i+1:]):
            result.append(string[i] + perm)
    return result",58
70959716991,find_most_frequent_characters,"from collections import Counter

def find_most_frequent_characters(s):
    counter = Counter(s)
    max_count = max(counter.values())
    most_frequent_chars = [char for char, count in counter.items() if count == max_count]
    return sorted(most_frequent_chars)",58
30813675392,avg_of_lists,"def avg_of_lists(list_of_lists):
  total_sum = 0
  total_elements = 0
  for sublist in list_of_lists:
    total_sum += sum(sublist)
    total_elements += len(sublist)
  avg = total_sum / total_elements
  return avg",58
8499338548,dec_to_bin,"def dec_to_bin(decimal_num):
    if decimal_num == 0:
        return '0'
    binary = ''
    while decimal_num > 0:
        binary = str(decimal_num % 2) + binary
        decimal_num = decimal_num // 2
    return binary",58
18616734019,find_first_non_repeating,"from collections import defaultdict

def find_first_non_repeating(s):
    charcount = defaultdict(int)
    for c in s:
        charcount[c] += 1
    for c in s:
        if charcount[c] == 1:
            return c
    return None",58
70523756279,fibonacci_sequence,"def fibonacci_sequence(n):
    fib_sequence = [0, 1]
    while True:
        next_fib = fib_sequence[-1] + fib_sequence[-2]
        if next_fib > n:
            break
        fib_sequence.append(next_fib)
    return fib_sequence",58
11031666383,snake_to_camel,"def snake_to_camel(snake_str):
    components = snake_str.split('_')
    # Capitalize the first letter of each component except the first one
    # and join them together.
    return components[0] + ''.join(x.title() for x in components[1:])",58
29552941850,find_longest_prefix,"def find_longest_prefix(strs):
    if not strs: return """"
    shortest = min(strs, key=len)
    for i, char in enumerate(shortest):
        for other in strs:
            if other[i] != char:
                return shortest[:i]
    return shortest",58
14123769386,smallestMultiple,"from math import gcd

def lcm(a, b):
    return a * b // gcd(a, b)

def smallestMultiple(n):
    multiple = 1
    for i in range(1, n + 1):
        multiple = lcm(multiple, i)
    return multiple",58
27750544040,smallest_missing_positive,"def smallest_missing_positive(nums):
    nums = list(set(nums))
    nums.sort()
    smallest_missing = 1
    for num in nums:
        if num == smallest_missing:
            smallest_missing += 1
        elif num > smallest_missing:
            break
    return smallest_missing",58
33419450131,max_sum,"def max_sum(array):
    incl = 0
    excl = 0

    for i in array:
        new_excl = excl if excl>incl else incl

        incl = excl + i
        excl = new_excl

    return max(excl,incl)",58
18735465919,smallest_subarray_sum,"def smallest_subarray_sum(arr):
    min_sum = arr[0]
    current_sum = arr[0]
    for num in arr[1:]:
        current_sum = min(num, current_sum + num)
        min_sum = min(min_sum, current_sum)
    return min_sum",58
43271526077,date_difference,"from datetime import datetime

def date_difference(date1, date2):
    date_format = ""%Y-%m-%d""
    a = datetime.strptime(date1, date_format)
    b = datetime.strptime(date2, date_format)
    delta = b - a
    return delta.days",58
37872325707,digitsInFactorial,"import math

def digitsInFactorial(N):
    if N == 0:
        return 1
    ans = 0
    for i in range(2, N + 1):
        ans += math.log10(i)
    return int(ans) + 1",58
37219542571,count_pairs_with_diff,"from collections import Counter

def count_pairs_with_diff(nums, k):
    hmp = Counter(nums)
    cnt = 0
    for n, v in hmp.items():
        if n+k in hmp:
            cnt += v * hmp[n+k]
    return cnt",58
70095545909,is_prime,"def is_prime(n):
    if n <= 1 or (n % 2 == 0 and n > 2): 
        return False
    return all(n % i for i in range(3, int(n**0.5) + 1, 2))",58
16171780638,char_frequency,"def char_frequency(s):
    frequency = {}
    for char in s:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return sorted(frequency.items(), key=lambda x: x[1], reverse=True)",58
32711593746,reverseString,"def reverseString(s):
    left, right = 0, len(s) - 1
    while left < right:
        s[left], s[right] = s[right], s[left]
        left, right = left + 1, right - 1
    return s",58
39842814372,find_prime_numbers,"def find_prime_numbers(numbers):
    primes = []
    for num in numbers:
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                primes.append(num)
    return primes",58
41391638780,combinations,"def combinations(n, k):
    numerator = 1
    for i in range(n, n-k, -1):
        numerator *= i
    denominator = 1
    for i in range(1, k+1):
        denominator *= i
    return numerator // denominator",58
72611241353,find_mode,"from collections import Counter

def find_mode(nums):
    if not nums:
        return []
    
    counter = Counter(nums)
    max_count = max(counter.values())
    mode = [num for num, count in counter.items() if count == max_count]
    
    return sorted(mode)",58
9737884401,largest_digit,"def largest_digit(n):
    n = abs(n)
    max_digit = 0
    while n > 0:
        digit = n % 10
        if digit > max_digit:
            max_digit = digit
        n //= 10
    return max_digit",58
37486530974,count_ways_to_reach_n_stairs,"def count_ways_to_reach_n_stairs(n):
    if n <= 1:
        return n
    first, second = 1, 2
    for i in range(2, n):
        first, second = second, first + second
    return second",58
15550507003,frequent_elements,"from typing import List
from collections import Counter

def frequent_elements(nums: List[int]) -> List[int]:
    counter = Counter(nums)
    max_freq = max(counter.values())
    result = [k for k, v in counter.items() if v == max_freq]
    return result",58
74472378639,reverse_list_in_place,"def reverse_list_in_place(lst):
    left = 0
    right = len(lst) - 1
    while left < right:
        lst[left], lst[right] = lst[right], lst[left]
        left += 1
        right -= 1
    return lst",58
14782927764,kth_largest_element,"import heapq

def kth_largest_element(nums, k):
    min_heap = []
    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    return min_heap[0]",58
71936517595,two_sum_indices,"def two_sum_indices(nums, target):
    index_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in index_map:
            return [index_map[complement], i]
        index_map[num] = i
    return []",58
22827894777,single_elements,"def single_elements(nums):
    counts = {}
    for num in nums:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1
    return [num for num, count in counts.items() if count == 1]",58
16544313447,min_moves,"def min_moves(boxes):
    size = len(boxes)
    answer = [0]*size
    for i in range(size):
        for j in range(size):
            if boxes[j] == ""1"":
                answer[i] += abs(j-i)
    return min(answer)",58
15854398998,calculate_distance,"import math

def calculate_distance(point1, point2):
    x1, y1 = point1
    x2, y2 = point2
    distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return distance",58
26394973085,longest_Common_Prefix,"def longest_Common_Prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, ch in enumerate(shortest):
        for other in strs:
            if other[i] != ch:
                return shortest[:i]
    return shortest",58
40707641514,isValidIPv4,"def isValidIPv4(ip):
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit() or not 0 <= int(part) <= 255:
            return False
    return True",58
11795379997,count_substring,"def count_substring(str):
    n = len(str)
    result = 0
    for i in range(n):
        for j in range(i+1, n+1):
            if str[i] == str[j-1]:
                result += 1
    return result",58
18836380632,count_elements,"def count_elements(list_of_lists):
    element_count = {}
    for sublist in list_of_lists:
        for element in sublist:
            if element in element_count:
                element_count[element] += 1
            else:
                element_count[element] = 1
    return element_count",58
8841363307,first_max_index,"def first_max_index(arr):
    max_index = 0
    max_value = arr[0]
    for i in range(1, len(arr)):
        if arr[i] > max_value:
            max_value = arr[i]
            max_index = i
    return max_index",58
22214462481,isPerfectNumber,"def isPerfectNumber(n):
     arr=[]
     for i in range(1,(n+2)//2):
          if n%i==0:
               arr.append(i)

     s=sum(arr)

     if n==s:
          return 1
     else:
          return 0",58
19249533121,most_repeated_char,"def most_repeated_char(s):
    freq = {}
    for char in s:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1
    max_char = max(freq, key=freq.get)
    return max_char",58
40731457849,convert_fahrenheit_to_celsius,"def convert_fahrenheit_to_celsius(fahrenheit_list):
    celsius_list = []
    for fahrenheit in fahrenheit_list:
        celsius = (fahrenheit - 32) * 5 / 9
        celsius_list.append(celsius)
    return celsius_list",58
14334637527,move_zeros,"def move_zeros(nums):
    index = 0
    for i in nums:
        if i != 0:
            nums[index] = i
            index += 1
    for i in range(index, len(nums)):
        nums[i] = 0
    return nums",58
21865398857,smallest_common_multiple,"from math import gcd

def smallest_common_multiple(nums):
    def lcm(a, b):
        return a * b // gcd(a, b)
    
    multiple = nums[0]
    for num in nums[1:]:
        multiple = lcm(multiple, num)
    
    return multiple",58
24617270191,pascal_row,"def pascal_row(n):
    row = [1] * (n + 1)
    for i in range(1, n + 1):
        row[i] = row[i - 1] * (n - i + 1) // i
    return row",58
12246220469,divisor_pair,"def divisor_pair(n):
    l = int(n**0.5)
    while n % l != 0:
        l -= 1
    l1 = n // l
    return [l1, l] if l1 > l else [l, l1]",58
43146272730,count_consecutive,"def count_consecutive(lst, elem):
    count = 0
    result = 0
    for i in lst:
        if i == elem:
            count += 1
            result = max(result, count)
        else:
            count = 0
    return result",58
12827325188,circle_area,"import math

def circle_area(radius):
    """"""
    Calculate the area of a circle given its radius.

    Args:
    radius (float): The radius of the circle.

    Returns:
    float: The area of the circle.
    """"""
    return math.pi * radius ** 2",58
37248144345,third_max,"def third_max(nums):
    unique_nums = list(set(nums))
    if len(unique_nums) < 3:
        return max(unique_nums)

    for _ in range(2):  # Remove two max values
        unique_nums.remove(max(unique_nums))

    return max(unique_nums)",58
32279753445,smallest_divisible,"from math import gcd

def lcm(a, b):
    return a * b // gcd(a, b)

def smallest_divisible(n):
    result = 1
    for i in range(1, n + 1):
        result = lcm(result, i)
    return result",58
31045353128,find_most_frequent,"def find_most_frequent(arr):
    from collections import Counter
    counter = Counter(arr)
    max_freq = max(counter.values())
    most_frequent_elements = [k for k, v in counter.items() if v == max_freq]
    return min(most_frequent_elements)",58
72625204632,count_pairs_with_diff_k,"def count_pairs_with_diff_k(arr, k):
    count = 0
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            if abs(arr[i] - arr[j]) == k:
                count += 1
    return count",58
73283665800,isPerfectSquare,"def isPerfectSquare(num):
    if num < 0:
        return False
    if num == 0:
        return True
    i = 1
    while num > 0:
        num -= i
        i += 2
    return num == 0",58
70171227778,prod_second_min_max,"def prod_second_min_max(nums):
    unique_nums = list(set(nums))
    unique_nums.sort()
    if len(unique_nums) < 2:
        raise ValueError(""Input array must contain at least 2 distinct numbers."")
    return unique_nums[1] * unique_nums[-2]",58
12338890285,convert_days,"def convert_days(days):
    years = days // 365
    months = (days % 365) // 30
    remaining_days = (days % 365) % 30
    return (years, months, remaining_days)",58
14921508942,staircase,"def staircase(n):
    if n <= 2:
        return n
    first, second = 1, 2
    for _ in range(3, n + 1):
        third = first + second
        first, second = second, third
    return second",58
33186371539,max_tasks,"def max_tasks(tasks):
    tasks.sort(key=lambda x: x[1])
    count, end = 0, -1
    for task in tasks:
        if task[0] >= end:
            count += 1
            end = task[1]
    return count",58
22811177159,find_pattern,"def find_pattern(text, pattern):
    count = 0
    index = 0
    while True:
        index = text.find(pattern, index)
        if index == -1:
            break
        count += 1
        index += 1
    return count",57
9480971231,count_upper_lower,"def count_upper_lower(str1):
    upper = 0
    lower = 0
    for i in str1:
        if i.isupper():
            upper += 1
        elif i.islower():
            lower += 1
    return (upper, lower)",57
29781623033,two_sum,"def two_sum(nums, target):
    num_dict = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_dict:
            return [num_dict[complement], i]
        num_dict[num] = i
    return []",57
15229454715,count_target_pairs,"from collections import defaultdict

def count_target_pairs(nums, target):
    counts = defaultdict(int)
    result = 0
    for num in nums:
        complement = target - num
        result += counts[complement]
        counts[num] += 1
    return result",57
27674238860,find_following_words,"def find_following_words(text, first, second):
    words = text.split()
    s=[]
    for i in range(len(words)-2):
        if words[i] == first and words[i+1] == second:
            s.append(words[i+2])
    return s",57
985706820,find_pattern,"def find_pattern(text, pattern):
    count = 0
    index = 0
    while True:
        index = text.find(pattern, index)
        if index == -1:
            break
        count += 1
        index += len(pattern)
    return count",57
39519686301,count_distinct_chars,"def count_distinct_chars(string):
    distinct_chars = set(string)
    return len(distinct_chars)

if __name__ == ""__main__"":
    print(count_distinct_chars(""hello""))
    print(count_distinct_chars(""mississippi""))
    print(count_distinct_chars(""programming""))",57
26975313603,reverse_string_inplace,"def reverse_string_inplace(s):
    i, j = 0, len(s) - 1
    while i < j:
        s[i], s[j] = s[j], s[i]
        i += 1
        j -= 1
    return s",57
16093740989,count_substring_occurrences,"def count_substring_occurrences(s, sub):
    count = 0
    start = 0
    while True:
        start = s.find(sub, start)
        if start == -1:
            return count
        count += 1
        start += 1",57
13183507632,check_palindrome_partition,"def check_palindrome_partition(s):
    def is_palindrome(s):
        return s == s[::-1]

    for i in range(1, len(s)):
        if is_palindrome(s[:i]) and is_palindrome(s[i:]):
            return True
    return False",57
9983485298,count_pos_neg,"def count_pos_neg(lst):
    positive = 0
    negative = 0
    for num in lst:
        if num > 0:
            positive += 1
        elif num < 0:
            negative += 1
    return (positive, negative)",57
29741053074,find_smallest_pattern,"def find_smallest_pattern(s):
    for i in range(1, len(s)//2 + 1):
        if len(s) % i == 0:
            if s[:i]*(len(s)//i) == s:
                return s[:i]
    return s",57
38399751302,reverse_string_inplace,"def reverse_string_inplace(s):
    left, right = 0, len(s) - 1
    while left < right:
        s[left], s[right] = s[right], s[left]
        left += 1
        right -= 1
    return s",57
7420281365,find_longest_prefix,"def find_longest_prefix(lst):
    if not lst:
        return """"
    shortest = min(lst, key=len)
    for i, char in enumerate(shortest):
        for others in lst:
            if others[i] != char:
                return shortest[:i]
    return shortest",57
13602267427,is_balanced_parentheses,"def is_balanced_parentheses(s):
    stack = []
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack:
                return False
            stack.pop()
    return len(stack) == 0",57
23501862328,is_ugly_number,"def is_ugly_number(n: int) -> bool:
    if n <= 0:
        return False
    for i in [2, 3, 5]:
        while n % i == 0:
            n //= i
    return n == 1",57
37319743863,get_fibonacci,"def get_fibonacci(n):
  if (n == 0):
    return 0
  elif (n == 1):
    return 1
  else:
    return get_fibonacci(n - 1) + get_fibonacci(n - 2)",57
25042312736,max_product_adjacent,"def max_product_adjacent(nums):
    max_product = nums[0] * nums[1]
    for i in range(1, len(nums) - 1):
        max_product = max(max_product, nums[i] * nums[i + 1])
    return max_product",57
32575241481,max_adjacent_product,"def max_adjacent_product(nums):
    max_product = nums[0] * nums[1]
    for i in range(1, len(nums) - 1):
        max_product = max(max_product, nums[i] * nums[i + 1])
    return max_product",57
10741256899,increasing_triplet,"def increasing_triplet(nums):
    small, mid = float('inf'), float('inf')
    for num in nums:
        if num <= small:
            small = num
        elif num <= mid:
            mid = num
        else:
            return True
    return False",57
26007010012,no_00,"def no_00(n):
    if n == 1:
        return 2
    a, b = 1, 2
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b",57
73096172184,longest_prefix,"def longest_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs, key=len)
    for i, char in enumerate(shortest):
        for other in strs:
            if other[i] != char:
                return shortest[:i]
    return shortest",57
12397829322,max_subarray,"def max_subarray(arr):
    max_sum = arr[0]
    current_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",57
2130892416,kthLargest,"import heapq

def kthLargest(nums, k):
    min_heap = []
    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    return min_heap[0]",57
42800887062,is_balanced_parentheses,"def is_balanced_parentheses(s):
    stack = []

    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack:
                return False
            stack.pop()

    return len(stack) == 0",57
42318981290,find_second_largest,"def find_second_largest(num_list):
    if len(num_list) < 2:
        return None
    num_list = list(set(num_list))
    if len(num_list) < 2:
        return None
    num_list.sort()
    return num_list[-2]",57
22816201956,numIdenticalPairs,"def numIdenticalPairs(nums):
    count = 0
    dic = {}
    for i in nums:
        if i in dic:
            count += dic[i]
            dic[i] += 1
        else:
            dic[i] = 1
    return count",57
23918305564,rotate_matrix,"def rotate_matrix(matrix):
    n = len(matrix)
    result = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            result[j][n-i-1] = matrix[i][j]
    return result",57
26972377206,rec_product,"def rec_product(a, b):
    if b == 0:
        return 0
    if b > 0:
        return (a + rec_product(a, b - 1))
    if b < 0:
        return -rec_product(a, -b)",57
20300710829,smallest_difference,"def smallest_difference(nums):
    nums.sort()
    min_diff = float('inf')
    for i in range(1, len(nums)):
        diff = nums[i] - nums[i-1]
        if diff < min_diff:
            min_diff = diff
    return min_diff",57
29416040924,min_operations,"def min_operations(X, Y):
    operations = 0
    while Y > X:
        if Y % 2 == 0:
            Y //= 2
        else:
            Y += 1
        operations += 1
    return operations + X - Y",57
18875677798,smallestRepeatingPattern,"def smallestRepeatingPattern(s):
    for i in range(1, len(s)//2 + 1):
        if len(s) % i == 0:
            if s[:i]*(len(s)//i) == s:
                return s[:i]
    return s",57
73965212600,find_max_recursively,"def find_max_recursively(lst, index=0, max_val=float(""-inf"")):
    if index == len(lst):
        return max_val
    max_val = max(max_val, lst[index])
    return find_max_recursively(lst, index + 1, max_val)",57
70612990417,count_unique_chars,"def count_unique_chars(s):
    return len(set(s))

# Test cases
print(count_unique_chars(""abcabc"") == 3) 
print(count_unique_chars(""hello world"") == 8)
print(count_unique_chars(""aAaAaA"") == 2)",57
35754649706,binary_strings,"def binary_strings(n):
    if n == 0:
        return [""""]
    smaller_strings = binary_strings(n-1)
    result = []
    for string in smaller_strings:
        result.append(string + '0')
        result.append(string + '1')
    return result",57
35384376042,two_sum,"def two_sum(nums, target):
    num_dict = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_dict:
            return [num_dict[complement], i]
        num_dict[num] = i
    return []",57
5402426780,kth_largest,"import heapq

def kth_largest(nums, k):
    min_heap = []
    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    return min_heap[0]",57
23069305337,find_smallest,"def find_smallest(numbers):
    smallest = numbers[0]
    index = 0
    for i in range(1, len(numbers)):
        if numbers[i] < smallest:
            smallest = numbers[i]
            index = i
    return (smallest, index)",57
23840091921,perfect_number,"def perfect_number(n):
    if n < 1:
        return False
    sum_divisors = 0
    for i in range(1, n):
        if n % i == 0:
            sum_divisors += i
    return sum_divisors == n",57
43768295732,longest_prefix,"def longest_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, char in enumerate(shortest):
        for others in strs:
            if others[i] != char:
                return shortest[:i] 
    return shortest",57
37033680322,count_valid_parentheses,"def count_valid_parentheses(n):
    if n == 0:
        return 1
    count = 0
    for i in range(n):
        count += count_valid_parentheses(i) * count_valid_parentheses(n-1-i)
    return count",57
72925828476,longest_prefix,"def longest_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, char in enumerate(shortest):
        for others in strs:
            if others[i] != char:
                return shortest[:i] 
    return shortest",57
42302731732,snake_to_camel,"def snake_to_camel(snake_str):
    components = snake_str.split('_')
    # We capitalize the first letter of each component except the first one with the 'title' method
    # and join them together.
    return ''.join(x.title() for x in components)",57
23706420994,max_subarray_sum,"def max_subarray_sum(nums):
    max_current = max_global = nums[0]
    for num in nums[1:]:
        max_current = max(num, max_current + num)
        if max_current > max_global:
            max_global = max_current
    return max_global",57
70474711069,longest_prefix,"def longest_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, char in enumerate(shortest):
        for other in strs:
            if other[i] != char:
                return shortest[:i] 
    return shortest",57
15465913066,num_unique_substrings,"def num_unique_substrings(s: str) -> int:
    unique_substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            unique_substrings.add(s[i:j])
    return len(unique_substrings)",57
21457742528,is_balanced_parentheses,"def is_balanced_parentheses(string):
    stack = []
    for char in string:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack:
                return False
            stack.pop()
    return len(stack) == 0",57
24847687695,find_pair,"def find_pair(numbers, target):
    num_dict = {}
    for i, num in enumerate(numbers):
        complement = target - num
        if complement in num_dict:
            return (num_dict[complement], i)
        num_dict[num] = i
    return None",57
16470639548,smallest_difference,"def smallest_difference(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(1, len(arr)):
        diff = arr[i] - arr[i-1]
        if diff < min_diff:
            min_diff = diff
    return min_diff",57
10741356429,find_longest_word,"def find_longest_word(sentence):
    words = sentence.split()
    longest_word = """"
    max_length = 0
    for word in words:
        if len(word) > max_length:
            longest_word = word
            max_length = len(word)
    return longest_word",57
70460810041,count_ways,"def count_ways(n):
    if n <= 1:
        return n
    first, second = 1, 2
    for i in range(2, n):
        third = first + second
        first, second = second, third
    return second",57
31568226840,convert_number,"def convert_number(x, y):
    steps = 0
    while x < y:
        if y % 2 == 1:
            y += 1
        else:
            y //= 2
        steps += 1
    return steps + x - y",57
36213729407,partition,"def partition(n):
    partitions = [1] + [0] * n
    for i in range(1, n + 1):
        for j in range(i, n + 1):
            partitions[j] += partitions[j - i]
    return partitions[n]",57
38236064568,find_largest_number,"def find_largest_number(numbers):
    numbers = list(map(str, numbers)) # convert each number to string
    numbers.sort(key=lambda x:x*3, reverse=True) # sort the numbers
    return int(''.join(numbers)) # join the numbers and convert to integer",57
72578709565,minSteps,"def minSteps(nums):
    steps = 0
    avg = sum(nums)/len(nums)
    for num in nums:
        if num != avg:
            steps += 1
            nums = [avg if x == num else x for x in nums]
    return steps",57
12558158332,is_strict_palindrome,"import re

def is_strict_palindrome(s: str) -> bool:
    # Remove all non-alphanumeric characters and convert to lowercase
    s = re.sub(r'[^A-Za-z0-9]', '', s).lower()
    return s == s[::-1]",57
13300899956,valid_identifier,"import keyword

def valid_identifier(s: str) -> bool:
    if s[0].isdigit() or keyword.iskeyword(s):
        return False
    for c in s:
        if not (c.isalnum() or c == '_'):
            return False
    return True",57
15175670647,smallest_difference,"def smallest_difference(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(1, len(arr)):
        diff = arr[i] - arr[i-1]
        if diff < min_diff:
            min_diff = diff
    return min_diff",57
37283815458,find_smallest_difference,"def find_smallest_difference(nums):
  nums.sort()
  smallest_diff = float('inf')
  for i in range(1, len(nums)):
    diff = nums[i] - nums[i-1]
    smallest_diff = min(smallest_diff, diff)
  return smallest_diff",57
14301436065,remove_leading_zeros,"def remove_leading_zeros(binary_str: str) -> str:
    i = 0
    while i < len(binary_str) and binary_str[i] == '0':
        i += 1
    return binary_str[i:] if i < len(binary_str) else ''",57
15544484093,find_largest_with_heap,"import heapq

def find_largest_with_heap(nums):
    # Convert the list into a max-heap
    heap = [-num for num in nums]
    heapq.heapify(heap)
    # Pop and return the largest element
    return -heapq.heappop(heap)",57
44564883055,find_median,"def find_median(a, b, c):
    if (a - b) * (c - a) >= 0:
        return a
    elif (b - a) * (c - b) >= 0:
        return b
    else:
        return c",57
23884370678,num_good_pairs,"from collections import Counter

def num_good_pairs(nums):
    frequency = Counter(nums)
    filtered = [*set(nums)]
    count = 0
    for num in filtered:
        n = frequency[num]
        count += (n*(n-1)//2)
    return count",57
75032273465,min_abs_difference,"def min_abs_difference(arr):
    arr.sort()
    min_diff = abs(arr[1] - arr[0])
    for i in range(2, len(arr)):
        min_diff = min(min_diff, abs(arr[i] - arr[i-1]))
    return min_diff",57
3999697164,power_of_number,"def power_of_number(base, exponent):
    if exponent == 0:
        return 1
    result = 1
    for _ in range(abs(exponent)):
        result *= base
    if exponent < 0:
        return 1 / result
    return result",57
37648775514,fibonacci_memo,"def fibonacci_memo(n, memo={}):
    if n <= 2:
        return 1
    if n not in memo:
        memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo)
    return memo[n]",57
31008284127,multiplicationWithoutAsterisk,"def multiplicationWithoutAsterisk(a, b):
    result = 0
    while b > 0:
        if b % 2 == 1:
            result += a
        a = a << 1
        b = b >> 1
    return result",57
26925247401,find_smallest_k,"def find_smallest_k(n):
    k = 1
    sum_of_odds = 0
    while sum_of_odds < n:
        sum_of_odds += 2 * k - 1
        k += 1
    return k - 1",57
71069383749,get_fibonacci,"def get_fibonacci(n): 
    if n <= 0: 
        return 0
    elif n == 1: 
        return 1
    else: 
        return get_fibonacci(n-1) + get_fibonacci(n-2)",57
786649908,common_prefix,"def common_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, ch in enumerate(shortest):
        for other in strs:
            if other[i] != ch:
                return shortest[:i] 
    return shortest",57
33558063764,find_smallest_pattern,"def find_smallest_pattern(s):
    for i in range(1, len(s)//2 + 1):
        if len(s) % i == 0:
            if s[:i]*(len(s)//i) == s:
                return s[:i]
    return s",57
32225138981,numIdenticalPairs,"from collections import Counter

def numIdenticalPairs(nums):
    count = Counter(nums)
    good_pairs = 0
    for num in count:
        n = count[num]
        good_pairs += n * (n - 1) // 2
    return good_pairs",57
30974468494,rotations_same_string,"def rotations_same_string(s):
    rotations = 1
    temp = s
    while rotations <= len(s):
        temp = temp[-1:] + temp[:-1]
        if temp == s:
            return rotations
        rotations += 1
    return len(s)",57
9793746473,two_sum,"def two_sum(nums, target):
    num_dict = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_dict:
            return [num_dict[complement], i]
        num_dict[num] = i
    return []",57
14866279377,minMoves,"def minMoves(nums):
    n = len(nums)
    idx = n // 2
    nums.sort()
    median = nums[idx]
    m1 = 0
    for num in nums:
        m1 += abs(median - num)
    
    return m1",57
41672302914,missing_numbers,"from collections import Counter
def missing_numbers(numbers):
    chk = {i : 1 for i in range(max(numbers)+1)}
    chk = Counter(chk)
    numbers = Counter(numbers)
    res = chk - numbers
    answer = list(res.keys())
    return answer",57
30585229396,isPowerOfTwo,"def isPowerOfTwo(n): 
    if (n == 0): 
        return False
    while (n != 1): 
        if (n % 2 != 0): 
            return False
        n = n // 2
    return True",57
32015311066,rotate_matrix,"def rotate_matrix(mat):
    n = len(mat)
    rotated = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            rotated[j][n-i-1] = mat[i][j]
    return rotated",57
29287937046,longest_common_prefix,"def longest_common_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, char in enumerate(shortest):
        for other in strs:
            if other[i] != char:
                return shortest[:i]
    return shortest",57
13336071938,valid_parentheses_string,"def valid_parentheses_string(n):
    if n == 0:
        return 1
    count = 0
    for i in range(n):
        count += valid_parentheses_string(i) * valid_parentheses_string(n-1-i)
    return count",57
20538697136,longest_string_chain,"def longest_string_chain(words):
    dp = {}
    for word in sorted(words, key=len):
        dp[word] = max(dp.get(word[:i] + word[i+1:], 0) + 1 for i in range(len(word)))
    return max(dp.values())",57
21200248526,climb_stairs,"def climb_stairs(n: int) -> int:
    if n <= 2:
        return n
    p, q = 1, 2
    for _ in range(2, n):
        p, q = q, p + q
    return q",57
26436642964,count_strings,"def count_strings(lst):
    string_dict = {}
    for string in lst:
        string = string.strip().lower()
        if string not in string_dict:
            string_dict[string] = 1
        else:
            string_dict[string] += 1
    return string_dict",57
13377262039,longest_prefix,"def longest_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, char in enumerate(shortest):
        for others in strs:
            if others[i] != char:
                return shortest[:i] 
    return shortest",57
9011473468,longestCommonPrefix,"def longestCommonPrefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, ch in enumerate(shortest):
        for other in strs:
            if other[i] != ch:
                return shortest[:i]
    return shortest",57
11575633869,hasSubArrayWithZeroSum,"def hasSubArrayWithZeroSum(arr):
    sumSet = set()
    sum = 0
    for num in arr:
        sum += num
        if sum == 0 or sum in sumSet:
            return True
        sumSet.add(sum)
    return False",57
12817524348,next_power_of_2,"def next_power_of_2(num):
    if num == 0:
        return 1
    if num and not(num & (num-1)):
        return num 
    res = 1
    while res < num:
        res <<= 1
    return res",57
26740811020,uppercase_conversion,"def uppercase_conversion(s):
    result = """"
    for char in s:
        if ord(char) >= 97 and ord(char) <= 122:
            result += chr(ord(char) - 32)
        else:
            result += char
    return result",57
41486239839,sort_mixed_numbers,"def sort_mixed_numbers(mixed_list):
    int_list = sorted([i for i in mixed_list if isinstance(i, int)])
    float_list = sorted([i for i in mixed_list if isinstance(i, float)], reverse=True)
    return (int_list, float_list)",57
38358304592,max_sum_non_adjacent,"def max_sum_non_adjacent(nums):
    prev2 = 0
    prev1 = 0
    for num in nums:
        curr = max(prev2 + num, prev1)
        prev2 = prev1
        prev1 = curr
    return prev1",57
72257241386,equilibrium_index,"def equilibrium_index(arr):
    total_sum = sum(arr)
    left_sum = 0
    for index, num in enumerate(arr):
        total_sum -= num
        if left_sum == total_sum:
            return index
        left_sum += num
    return -1",56
42867911372,smallest_diff,"def smallest_diff(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(1, len(arr)):
        diff = abs(arr[i] - arr[i - 1])
        min_diff = min(min_diff, diff)
    return min_diff",56
17670147008,find_middle,"def find_middle(nums):
    nums.sort()
    length = len(nums)
    if length % 2 == 0:
        return (nums[length//2 - 1] + nums[length//2]) / 2
    else:
        return nums[length//2]",56
24803153826,count_ways_to_climb,"def count_ways_to_climb(n):
    if n <= 1:
        return 1
    first, second = 1, 2
    for i in range(2, n):
        first, second = second, first + second
    return second",56
27209216683,min_abs_difference,"def min_abs_difference(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(1, len(arr)):
        diff = abs(arr[i] - arr[i-1])
        min_diff = min(min_diff, diff)
    return min_diff",56
29935862140,longest_prefix,"def longest_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, char in enumerate(shortest):
        for other in strs:
            if other[i] != char:
                return shortest[:i]
    return shortest",56
31654043434,equilibrium_index,"def equilibrium_index(A):
    total_sum = sum(A)
    left_sum = 0
    for i, num in enumerate(A):
        total_sum -= num
        if left_sum == total_sum:
            return i
        left_sum += num
    return -1",56
71551180887,fibonacci_memo,"def fibonacci_memo(n, memo={}):
    if n <= 1:
        return n
    if n not in memo:
        memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo)
    return memo[n]",56
12973883963,is_leap_year,"def is_leap_year(year):
    if year % 400 == 0:
        return True
    if year % 100 == 0:
        return False
    if year % 4 == 0:
        return True
    return False",56
31079182405,find_most_frequent,"from collections import Counter

def find_most_frequent(lst):
    counter = Counter(lst)
    max_count = max(list(counter.values()))
    most_frequent = [k for k, v in counter.items() if v == max_count]
    return most_frequent[0]",56
33157046153,count_even_digits,"def count_even_digits(n):
    count = 0
    while n > 0:
        digit = n % 10
        if digit % 2 == 0:
            count += 1
        n = n // 10
    return count",56
73250986265,calculate_triangle_area,"def calculate_triangle_area(a, b, c):
    s = (a + b + c) / 2
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    return area",56
40622312298,calculate_median,"def calculate_median(arr):
    arr.sort()
    n = len(arr)
    if n % 2 == 0:
        return (arr[n//2 - 1] + arr[n//2]) / 2
    else:
        return arr[n//2]",56
3139045551,min_abs_diff,"def min_abs_diff(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(1, len(arr)):
        diff = abs(arr[i] - arr[i-1])
        min_diff = min(min_diff, diff)
    return min_diff",56
41101242348,pattern_count,"def pattern_count(text, pattern):
    count = 0
    pattern_len = len(pattern)
    for i in range(len(text) - pattern_len + 1):
        if text[i:i+pattern_len] == pattern:
            count += 1
    return count",56
73096801338,sum_of_squares_of_digits,"def sum_of_squares_of_digits(n: int) -> int:
    sum_of_squares = 0
    while n:
        n, r = divmod(n, 10)
        sum_of_squares += r**2
    return sum_of_squares",56
16248135901,kth_smallest_num,"import heapq
def kth_smallest_num(nums, k):
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
    for _ in range(k-1):
        heapq.heappop(heap)
    return heapq.heappop(heap)",56
3401281991,remove_character,"def remove_character(s: str, char: str):
    """"""
    Remove all occurrences of a specific character from a string.

    Time Complexity: O(N)
    Space Complexity: O(N)
    """"""
    return """".join([c for c in s if c != char])",56
33182400761,pivot_index,"def pivot_index(nums):
    total_sum = sum(nums)
    left_sum = 0
    for i, num in enumerate(nums):
        total_sum -= num
        if left_sum == total_sum:
            return i
        left_sum += num
    return -1",56
34765472825,can_permute_palindrome,"from collections import Counter

def can_permute_palindrome(s):
    c = Counter(s)
    odds = 0
    for ch, cnt in c.items():
        odds += cnt & 1
        if odds > 1:
            return False
    return True",56
18401637572,find_median,"def find_median(lst):
    lst.sort()
    n = len(lst)
    if n % 2 == 0:
        return (lst[n//2 - 1] + lst[n//2]) / 2
    else:
        return lst[n//2]",56
32196974364,nth_fibonacci,"def nth_fibonacci(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b",56
38484648357,unique_substrings,"def unique_substrings(s: str) -> int:
    unique_substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            unique_substrings.add(s[i:j])
    return len(unique_substrings)",56
34534916129,balance_index,"def balance_index(arr):
    total_sum = sum(arr)
    left_sum = 0
    for i, num in enumerate(arr):
        total_sum -= num
        if left_sum == total_sum:
            return i
        left_sum += num
    return -1",56
42321147606,find_k_smallest,"import heapq

def find_k_smallest(nums, k):
    # O(n + klogn)
    h = nums[:]
    heapq.heapify(h)
    smallest = []
    for _ in range(k):
        smallest.append(heapq.heappop(h))
    return smallest",56
40498943767,reverse_letters,"def reverse_letters(s):
    letters = [c for c in s if c.isalpha()]
    result = []
    for c in s:
        if c.isalpha():
            result.append(letters.pop())
        else:
            result.append(c)
    return ''.join(result)",56
5362517544,fib_seq,"def fib_seq(n):
    fib = [0, 1]
    if n <= 2:
        return fib[:n]
    else:
        for i in range(2, n):
            fib.append(fib[-1] + fib[-2])
        return fib",56
42614686956,move_negatives_to_start,"def move_negatives_to_start(nums):
    negative_list = []
    non_negative_list = []
    for num in nums:
        if num < 0:
            negative_list.append(num)
        else:
            non_negative_list.append(num)
    return negative_list + non_negative_list",56
71439457270,max_sum_consecutive_elements,"def max_sum_consecutive_elements(arr):
    max_sum = 0
    current_sum = 0
    for num in arr:
        current_sum = max(0, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",56
36160461057,count_pattern,"def count_pattern(nums, pattern):
    pattern_len = len(pattern)
    count = 0
    for i in range(len(nums) - pattern_len + 1):
        if nums[i:i+pattern_len] == pattern:
            count += 1
    return count",56
32421994871,has_Interval_Overlap,"def has_Interval_Overlap(intervals):
    intervals.sort(key=lambda x: x[0])
    for i in range(len(intervals) - 1):
        if intervals[i][1] >= intervals[i + 1][0]:
            return True
    return False",56
32888902656,equilibrium_index,"def equilibrium_index(A):
    total_sum = sum(A)
    left_sum = 0
    for i, num in enumerate(A):
        total_sum -= num
        if left_sum == total_sum:
            return i
        left_sum += num
    return -1",56
40211275988,consecutive_missing,"def consecutive_missing(numbers):
    num_max = max(set(numbers))
    num_min = min(set(numbers))
    counter = 0
    for i in range(num_min, num_max+1):
        if i not in numbers:
            counter += 1
    return counter",56
387127720,sum_of_factorial_digits,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def sum_of_factorial_digits(n):
    fact = factorial(n)
    return sum(int(digit) for digit in str(fact))",56
11841503652,equilibrium_index,"def equilibrium_index(arr):
    total_sum = sum(arr)
    left_sum = 0
    for i, num in enumerate(arr):
        total_sum -= num
        if left_sum == total_sum:
            return i
        left_sum += num
    return -1",56
18345667231,word_frequency,"def word_frequency(sentence):
    word_list = sentence.split()
    word_count = {}
    for word in word_list:
        if word in word_count:
            word_count[word] += 1
        else:
            word_count[word] = 1
    return word_count",56
37004526208,pivot_index,"def pivot_index(nums):
    total_sum = sum(nums)
    left_sum = 0
    for i, num in enumerate(nums):
        total_sum -= num
        if left_sum == total_sum:
            return i
        left_sum += num
    return -1",56
70328984310,longestPrefix,"def longestPrefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, ch in enumerate(shortest):
        for other in strs:
            if other[i] != ch:
                return shortest[:i]
    return shortest",56
17739253486,zero_sum_subarray,"def zero_sum_subarray(arr):
    s = set()
    s.add(0)
    sum = 0
    for i in range(len(arr)):
        sum += arr[i]
        if sum in s:
            return True
        s.add(sum)
    return False",56
72974406429,num_jewels_in_stones,"import collections

def num_jewels_in_stones(J: str, S: str) -> int:
    jewels = collections.Counter(J)
    count = 0
    for s in S:
        if s in jewels:
            count += 1
    return count",56
25903477492,arrangeCoins,"def arrangeCoins(n):
    count = 0
    step = 0

    for i in range(1, n+1):
        count += i
        if count <= n:
            step += 1
        else:
            return step
    return step",56
16176146765,check_perfect_number,"def check_perfect_number(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    if sum == n:
        return ""Yes""
    else:
        return ""No""",56
72595104747,rotate_matrix,"def rotate_matrix(matrix):
    n = len(matrix)
    result = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            result[j][n-i-1] = matrix[i][j]
    return result",56
671498747,find_median,"def find_median(lst):
    lst.sort()
    n = len(lst)
    if n % 2 == 0:
        return (lst[n//2 - 1] + lst[n//2]) / 2
    else:
        return lst[n//2]",56
7233158206,substring_count,"def substring_count(string, substring):
    count = 0
    start = 0
    while True:
        start = string.find(substring, start) + 1
        if start > 0:
            count += 1
        else:
            return count",56
36254637600,largest_digit,"def largest_digit(n):
    n = abs(n)
    largest = 0
    while n > 0:
        digit = n % 10
        if digit > largest:
            largest = digit
        n = n // 10
    return largest",56
42446849654,count_good_pairs,"def count_good_pairs(nums):
    count = {}
    result = 0
    for num in nums:
        if num in count:
            result += count[num]
            count[num] += 1
        else:
            count[num] = 1
    return result",56
70539124713,top_frequent_elements,"from collections import Counter

def top_frequent_elements(N, nums):
    freq = Counter(nums)
    sorted_freq = sorted(freq.items(), key=lambda x: (-x[1], x[0]))
    return [item[0] for item in sorted_freq[:N]]",56
410408743,smallest_missing_positive,"def smallest_missing_positive(arr):
    arr = [i for i in arr if i > 0]
    arr.sort()
    smallest_missing = 1
    for num in arr:
        if num == smallest_missing:
            smallest_missing += 1
    return smallest_missing",56
32228391799,count_substring_occurrences,"def count_substring_occurrences(string, sub_string):
    count = 0
    for i in range(len(string) - len(sub_string) + 1):
        if string[i:i+len(sub_string)] == sub_string:
            count += 1
    return count",56
69904233782,to_uppercase,"def to_uppercase(str1):
    uppercase = """"
    for char in str1:
        if 97 <= ord(char) <= 122:
            uppercase += chr(ord(char) - 32)
        else:
            uppercase += char
    return uppercase",56
5113583471,reverse_sentence,"def reverse_sentence(sentence):
    words = sentence.split()
    reversed_sentence = """"
    for i in range(len(words)-1, -1, -1):
        reversed_sentence += words[i]
        if i != 0:
            reversed_sentence += "" ""
    return reversed_sentence",56
16103995269,list_difference,"def list_difference(list1, list2):
    """"""
    Returns a new list with elements from list1 that are not present in list2, preserving the order of elements in list1.
    """"""
    return [x for x in list1 if x not in list2]",56
72101345387,fibonacci,"def fibonacci(n):
    fib = [0, 1] + [0] * (n-1)
    for i in range(2, n+1):
        fib[i] = fib[i-1] + fib[i-2]
    return fib[n]",56
13955324809,list_factorial,"def list_factorial(numbers):
    def factorial(n):
        if n == 0:
            return 1
        else:
            return n * factorial(n-1)
    
    result = []
    for num in numbers:
        result.append(factorial(num))
    return result",56
9946199591,reverse_characters,"def reverse_characters(str1):
    words = str1.split("" "")
    reversed_words = []
    for word in words:
        reversed_word = word[::-1]
        reversed_words.append(reversed_word)
    result_string = "" "".join(reversed_words)
    return result_string",56
12284973318,count_digit,"def count_digit(n, d):
    count = 0
    while(n > 0):
        rem = n % 10
        if(rem == d):
            count = count + 1
        n = n // 10
    return count",56
5820864774,count_unique_substrings,"def count_unique_substrings(s):
    n = len(s)
    unique_substrings = set()
    for i in range(n):
        for j in range(i+1, n+1):
            unique_substrings.add(s[i:j])
    return len(unique_substrings)",56
364145975,separate_even_odd,"def separate_even_odd(numbers):
    even_numbers = []
    odd_numbers = []
    for num in numbers:
        if num % 2 == 0:
            even_numbers.append(num)
        else:
            odd_numbers.append(num)
    return (even_numbers, odd_numbers)",56
12491857609,min_diff,"def min_diff(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(len(arr)-1):
        diff = arr[i+1] - arr[i]
        if diff < min_diff:
            min_diff = diff
    return min_diff",56
26650952643,findKthSmallest,"import heapq

def findKthSmallest(nums, k):
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
    for _ in range(k-1):
        heapq.heappop(heap)
    return heapq.heappop(heap)",56
32321849089,stairClimb,"def stairClimb(n):
    if n <= 1:
        return n
    first, second = 1, 2
    for _ in range(3, n + 1):
        first, second = second, first + second
    return second",56
11900657661,max_xor,"from itertools import combinations

def max_xor(arr):
    max_xor = 0
    for pair in combinations(arr, 2):
        xor = pair[0] ^ pair[1]
        if xor > max_xor:
            max_xor = xor
    return max_xor",56
10367493940,camel_to_snake,"def camel_to_snake(s):
    snake_case = """"
    for i, char in enumerate(s):
        if char.isupper() and i > 0:
            snake_case += ""_"" + char.lower()
        else:
            snake_case += char.lower()
    return snake_case",56
15526957597,is_anagram_of_palindrome,"from collections import Counter

def is_anagram_of_palindrome(s: str) -> bool:
    char_counts = Counter(s)
    odd_counts = sum(1 for count in char_counts.values() if count % 2 != 0)
    return odd_counts <= 1",56
36208522109,count_substring_with_overlap,"def count_substring_with_overlap(string, sub_string):
    count = 0
    for i in range(len(string) - len(sub_string) + 1):
        if string[i:i+len(sub_string)] == sub_string:
            count += 1
    return count",56
6268341692,is_hexadecimal,"def is_hexadecimal(s):
    hex_digits = set(""0123456789abcdefABCDEF"")
    if s == """":
        return False
    for char in s:
        if char not in hex_digits:
            return False
    return True",56
38260369635,smallest_repeating_subseq,"def smallest_repeating_subseq(str):
    for i in range(1, len(str)//2 + 1):
        subseq = str[:i]
        if subseq * (len(str)//len(subseq)) == str:
            return subseq
    return str",56
36221848997,count_good_pairs,"def count_good_pairs(nums):
    key = {}
    res = 0
    for i in nums:
      if i in key:
        res += key[i]
        key[i] += 1
      else:
        key[i] = 1
    return res",56
2615872827,is_palindrome_permutation,"def is_palindrome_permutation(s):
    s = s.replace("" "", """").lower()
    chars = set()

    for char in s:
        if char in chars:
            chars.remove(char)
        else:
            chars.add(char)

    return len(chars) <= 1",56
23542159023,smallest_diff,"def smallest_diff(arr):
    arr.sort()
    diff = float('inf')
    for i in range(1, len(arr)):
        if arr[i] - arr[i-1] < diff:
            diff = arr[i] - arr[i-1]
    return diff",56
18244676068,next_Prime,"def next_Prime(n): 
    prime = n 
    found = False
    while not found: 
        prime = prime + 1
        if all(prime % i for i in range(2, prime)): 
            found = True
    return prime",56
30783133822,odd_index_sort,"def odd_index_sort(lst):
    odd_list = sorted([lst[i] for i in range(1, len(lst), 2)])
    for i in range(1, len(lst), 2):
        lst[i] = odd_list.pop(0)
    return lst",56
39227943868,count_unique_substrings,"def count_unique_substrings(s):
    n = len(s)
    unique_substrings = set()
    for i in range(n):
        for j in range(i+1, n+1):
            unique_substrings.add(s[i:j])
    return len(unique_substrings)",56
74658609436,longest_prefix,"def longest_prefix(strs):
    if not strs:
        return """"
    shortest = min(strs,key=len)
    for i, char in enumerate(shortest):
        for others in strs:
            if others[i] != char:
                return shortest[:i]
    return shortest",56
38025153411,find_pattern,"def find_pattern(s, pattern):
    pattern_len = len(pattern)
    count = 0
    for i in range(len(s) - pattern_len + 1):
        if s[i:i+pattern_len] == pattern:
            count += 1
    return count",56
12817306458,fibonacci,"def fibonacci(n):
    fib = [0, 1] + [0] * (n-1)
    for i in range(2, n+1):
        fib[i] = fib[i-1] + fib[i-2]
    return fib[n]",56
20352295277,find_largest_within_threshold,"def find_largest_within_threshold(nums, threshold):
    max_within_threshold = None
    for num in nums:
        if num <= threshold:
            if max_within_threshold is None or num > max_within_threshold:
                max_within_threshold = num
    return max_within_threshold",55
11102605948,even_upper_odd_lower,"def even_upper_odd_lower(s):
    new_str = """"
    for i in range(len(s)):
        if i % 2 == 0:
            new_str += s[i].upper()
        else:
            new_str += s[i].lower()
    return new_str",55
10989537951,next_pascal_line,"def next_pascal_line(current_line):
    next_line = [1]
    for i in range(len(current_line) - 1):
        next_line.append(current_line[i] + current_line[i + 1])
    next_line.append(1)
    return next_line",55
29606403506,word_length,"def word_length(words):
    result = []
    for word in words:
        length = len(word)
        if word == word[::-1]:
            result.append(f""{word}{length}Palindrome"")
        else:
            result.append(f""{word}{length}"")
    return result",55
72907423438,sort_array,"def sort_array(array):
    for i in range(len(array)):
        for j in range(len(array)-1):
            if array[j] > array[j+1]:
                array[j], array[j+1] = array[j+1], array[j]
    return array",55
4113863650,climb_stairs,"def climb_stairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(3, n + 1):
        a, b = b, a + b
    return b",55
27418663160,find_second_smallest,"def find_second_smallest(numbers):
    if len(numbers) < 2:
        return None
    unique_numbers = set(numbers)
    if len(unique_numbers) < 2:
        return None
    unique_numbers.remove(min(unique_numbers))
    return min(unique_numbers)",55
15037765873,rotate_list,"def rotate_list(nums, rotation_count):
    if len(nums) == 0:
        return []
    rotation_count %= len(nums)
    if rotation_count < 0:
        rotation_count += len(nums)
    return nums[-rotation_count:] + nums[:-rotation_count]",55
29313221907,square_root,"def square_root(n):
    guess = n
    i = 0
    while guess * guess != n and i < 20:
        guess = (guess + n / guess) / 2.0
        i += 1
    return guess",55
13069225792,intersection_all_sublists,"from typing import List

def intersection_all_sublists(lists: List[List]) -> List:
    if not lists:
        return []
    result = set(lists[0])
    for lst in lists[1:]:
        result.intersection_update(lst)
    return list(result)",55
2512914768,to_upper,"def to_upper(s):
    result = ''
    for char in s:
        if 'a' <= char <= 'z':
            result += chr(ord(char) - (ord('a') - ord('A')))
        else:
            result += char
    return result",55
20932739143,num_unique_substrings,"def num_unique_substrings(s):
    unique_substrings = set()
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            unique_substrings.add(s[i:j])
    return len(unique_substrings)",55
73468277559,similar_pairs,"def similar_pairs(words):
    res = 0
        
    for indx, word in enumerate(words):
        word = set(word)
            
        for next_word in words[indx+1:]:
            if word == set(next_word):
                res += 1
                    
    return res",55
5662100374,first_unique_char,"def first_unique_char(s: str) -> int:
    d={}
    for i in s:
        d[i]=d.get(i,0)+1
    for i,val in enumerate(s):
        if d[val]==1:
            return i
    return -1",55
35756471298,find_largest_by_key,"def find_largest_by_key(dict_list, key):
    max_value = None
    for item in dict_list:
        if key in item:
            if max_value is None or item[key] > max_value:
                max_value = item[key]
    return max_value",55
11598626283,binary_to_decimal,"def binary_to_decimal(binary_string):
    decimal = 0
    power = len(binary_string) - 1
    for digit in binary_string:
        if digit == '1':
            decimal += 2 ** power
        power -= 1
    return decimal",55
18698593402,vowel_counter,"def vowel_counter(str):
  vowel_list = ['a', 'e', 'i', 'o', 'u']
  vowel_ctr = 0
  for i in str:
    if i in vowel_list:
      vowel_ctr += 1
  return vowel_ctr",55
74794760585,next_pascal_row,"def next_pascal_row(prev_row):
    next_row = [1]
    for i in range(len(prev_row) - 1):
        next_row.append(prev_row[i] + prev_row[i + 1])
    next_row.append(1)
    return next_row",55
15385235447,max_points,"def max_points(nums):
    prev = curr = 0
    for i in range(len(nums) - 1, -1, -1):
        temp = curr
        curr = max(curr, prev + nums[i])
        prev = temp
    return curr",55
9476368259,convert_to_uppercase,"def convert_to_uppercase(s):
    uppercase_str = """"
    for char in s:
        if 'a' <= char <= 'z':
            uppercase_str += chr(ord(char) - 32)
        else:
            uppercase_str += char
    return uppercase_str",55
5193500541,has_consecutive_three,"def has_consecutive_three(nums):
    for i in range(len(nums) - 2):
        if nums[i] + 1 == nums[i + 1] and nums[i] + 2 == nums[i + 2]:
            return True
    return False",55
73979900985,even_positions,"def even_positions(lst):
  d = {}
  for i, val in enumerate(lst):
    if val % 2 == 0:
      if val in d:
        d[val].append(i)
      else:
        d[val] = [i]
  return d",55
40597399247,tuple_to_dict,"def tuple_to_dict(tuples):
  d = {}
  for t in tuples:
    if t[0] in d:
      d[t[0]].append(t[1])
    else:
      d[t[0]] = [t[1]]
  return d",55
33210873560,count_strings,"def count_strings(strings_list: list) -> dict:
    string_dict = {}
    for string in strings_list:
        if string in string_dict:
            string_dict[string] += 1
        else:
            string_dict[string] = 1
    return string_dict",55
27654817620,next_power_of_2,"def next_power_of_2(n):
  if n == 0:
    return 1
  elif n & (n - 1) == 0:
    return n
  else:
    return 1 << (n - 1).bit_length()",55
8326000843,find_most_common_element,"from collections import Counter

def find_most_common_element(lst):
    if not lst:
        return None
    counted = Counter(lst)
    max_count = max(list(counted.values()))
    for e in lst:
        if counted[e] == max_count:
            return e",55
30823307040,count_substring_occurrences,"def count_substring_occurrences(string, substring):
    count = start = 0
    while True:
        start = string.find(substring, start) + 1
        if start > 0:
            count += 1
        else:
            return count",55
11332409465,str_to_upper,"def str_to_upper(s):
    result = """"
    for char in s:
        if 'a' <= char <= 'z':
            result += chr(ord(char) - ord('a') + ord('A'))
        else:
            result += char
    return result",55
22531392665,convert_to_uppercase,"def convert_to_uppercase(s):
    uppercase_string = """"
    for char in s:
        if 'a' <= char <= 'z':
            uppercase_string += chr(ord(char) - 32)
        else:
            uppercase_string += char
    return uppercase_string",55
13551309142,fib_iterative,"def fib_iterative(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b",55
73858498838,linearSearch,"def linearSearch(s, target):
    """"""
    :type s: list
    :type target: str
    :rtype: int
    """"""
    for i in range(len(s)):
        if s[i] == target:
            return i
    return -1",55
8841228807,is_valid_identifier,"import keyword
import re

def is_valid_identifier(identifier):
    if keyword.iskeyword(identifier):
        return False
    identifier_re = re.compile(r'^[a-zA-Z_][a-zA-Z0-9_]*$')
    return bool(identifier_re.match(identifier))",55
31160212770,climb_stairs,"def climb_stairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(3, n + 1):
        a, b = b, a + b
    return b",55
14947479577,find_index,"def find_index(nums, target):
    """"""
    :type nums: List[int]
    :type target: int
    :rtype: int
    """"""
    for i, num in enumerate(nums):
        if num == target:
            return i
    return -1",55
28092625933,topKFrequent,"from collections import Counter

def topKFrequent(words, k):
    tempdict = dict()
    outputdict = dict(Counter(words))
    result = sorted(outputdict.keys(), key = lambda x: (-outputdict[x],x))
    return result[0:k]",55
69954201877,meeting_overlap,"def meeting_overlap(intervals, query):
    start, end = query
    overlap_count = 0

    for interval in intervals:
        if interval[0] < end and interval[1] > start:
            overlap_count += 1

    return overlap_count",55
32230784914,remove_value,"def remove_value(nums, val):
    i = 0
    temp = []
    while(i<len(nums)):
        if nums[i]!=val:
            temp.append(nums[i])
        i+=1
    nums[:len(temp)] = temp
    return len(temp)",55
5493804646,smallest_Divisor,"def smallest_Divisor(n):
    if n == 1:
        return 1
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return i
    return n",55
71651246554,cube_square,"def cube_square(numbers):
    result = []
    for num in numbers:
        if num > 0:
            result.append(num**3)
        elif num < 0:
            result.append(num**2)
        else:
            result.append(0)
    return result",55
44368941838,convertToBase7,"def convertToBase7(num):
    if num < 0:
        return '-' + convertToBase7(-num)
    if num < 7:
        return str(num)
    return convertToBase7(num // 7) + str(num % 7)",55
4431955065,unique_strings,"def unique_strings(strs):
    unique_sets = set()
    result = []
    for s in strs:
        sorted_s = ''.join(sorted(s))
        if sorted_s not in unique_sets:
            unique_sets.add(sorted_s)
            result.append(s)
    return result",55
44151735606,most_frequent_elements,"from collections import Counter

def most_frequent_elements(nums):
    counter = Counter(nums)
    max_freq = max(counter.values())
    most_frequent = [num for num, freq in counter.items() if freq == max_freq]
    return sorted(most_frequent)",55
15950507391,valid_parentheses,"def valid_parentheses(sequence):
    stack = []
    for char in sequence:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack:
                return False
            stack.pop()
    return len(stack) == 0",55
25459417027,median,"def median(arr):
    arr.sort()
    n = len(arr)
    if n % 2 == 0:
        return (arr[n//2 - 1] + arr[n//2]) / 2
    else:
        return arr[n//2]",55
14621552747,check_string,"def check_string(s):
    z = []
    for i,j in enumerate(s):
        if j == 'b':
            z = s[i:]
            break
    if z == []:
        return True
    else:
        return z.count('a') == 0",55
12473453291,count_ways_to_climb,"def count_ways_to_climb(n):
    if n <= 1:
        return n
    a, b = 1, 2
    for _ in range(2, n):
        a, b = b, a + b
    return b",55
20301251519,countTargetPairs,"def countTargetPairs(arr, target):
    count = 0
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            if arr[i] + arr[j] == target:
                count += 1
    return count",55
2803054069,find_second_most_frequent,"from collections import Counter

def find_second_most_frequent(strings):
  count = Counter(strings)
  most_common = count.most_common()
  if len(most_common) < 2:
    return None
  else:
    return most_common[1][0]",55
26654903928,check_suffix_prefix,"def check_suffix_prefix(s):
    for i in range(1, len(s)//2 + 1):
        if s[:i] == s[-i:]:
            if len(s) % (2 * i) == 0:
                return True
    return False",55
71842560385,climbStairs,"def climbStairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(3, n + 1):
        a, b = b, a + b
    return b",55
39734849545,check_perfect_number,"def check_perfect_number(number):
    sum=0
    if number > 0:
        for i in range(1, number):
            if number % i == 0:
                sum += i
        return sum == number
    else:
        return False",55
74281066904,solution,"def solution(nums, k):
    count = 0
    nums.sort()
    for i in range(len(nums)):
        if nums[i] + k in nums[i+1:]:
            count += nums[i+1:].count(nums[i] + k)
    return count",55
40264203299,count_pairs,"def count_pairs(nums, k):
    count = 0
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if abs(nums[i] - nums[j]) == k:
                count += 1
    return count",55
19665436908,climb_stairs,"def climb_stairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(3, n + 1):
        a, b = b, a + b
    return b",55
34057555898,smallest_power_of_2,"def smallest_power_of_2(n):
    if n == 0:
        return 1
    elif n & (n - 1) == 0:
        return n
    else:
        return 1 << (n - 1).bit_length()",55
20470905993,findKthLargest,"import heapq
def findKthLargest(nums, k):
    nums=[-i for i in nums]
    heapq.heapify(nums)
    for _ in range(k-1):
        heapq.heappop(nums)
    return -heapq.heappop(nums)",55
30051128184,find_max_subarray,"def find_max_subarray(nums):
    max_sum = float('-inf')
    current_sum = 0
    for num in nums:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",55
38901477401,second_largest_number,"def second_largest_number(numbers):
    if len(numbers) < 2:
        return None
    unique_numbers = set(numbers)
    if len(unique_numbers) < 2:
        return None
    unique_numbers.remove(max(unique_numbers))
    return max(unique_numbers)",55
43063514549,num_ways_to_climb_stairs,"def num_ways_to_climb_stairs(n):
    if n<=2:
        return n
    a, b = 1, 2
    for i in range(2, n):
        a, b = b, a+b
    return b",55
30500247992,h_index,"def h_index(citations):
    citations.sort(reverse=True)
    h = 0
    for i in range(len(citations)):
        if citations[i] >= i + 1:
            h = i + 1
        else:
            break
    return h",55
20063775492,find_largest_product,"def find_largest_product(nums):
    if len(nums) < 3:
        return None
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",55
4197009547,most_frequent_words,"from collections import Counter

def most_frequent_words(words):
    word_counts = Counter(words)
    max_count = max(word_counts.values())
    most_frequent = [word for word, count in word_counts.items() if count == max_count]
    return most_frequent",55
70689297025,max_subarray_sum,"def max_subarray_sum(nums):
    max_sum = float('-inf')
    current_sum = 0
    for num in nums:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",55
10408078474,reverse_integer,"def reverse_integer(x):
    sign = [1,-1][x < 0]
    rst = sign * int(str(abs(x))[::-1])
    return rst if -(2**31) - 1 < rst < 2**31 else 0",55
34279666320,find_largest_subarray_sum,"def find_largest_subarray_sum(nums):
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",55
30342753527,find_most_frequent,"from collections import Counter

def find_most_frequent(lst):
    count = Counter(lst)
    max_freq = max(count.values())
    most_frequent = [item for item, freq in count.items() if freq == max_freq]
    return sorted(most_frequent)",55
40650404612,check_anagrams,"def check_anagrams(str1, str2):
    str1 = str1.replace(' ', '').lower()
    str2 = str2.replace(' ', '').lower()
    if sorted(str1) == sorted(str2):
        return True
    else:
        return False",55
42657843281,find_pattern,"def find_pattern(s):
    for i in range(1, len(s)//2 + 1):
        if len(s) % i == 0:
            if s[:i]*(len(s)//i) == s:
                return s[:i]
    return s",55
8240589975,book_pages,"def book_pages(books):
    author_pages = {}
    for book in books:
        if book[1] not in author_pages:
            author_pages[book[1]] = []
        author_pages[book[1]].append(book[2])
    return author_pages",55
31969577575,fib,"def fib(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 2:
        return 1
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]",55
963505743,substring_count,"def substring_count(string, sub):
    count = 0
    start = 0
    while True:
        start = string.find(sub, start) + 1
        if start > 0:
            count += 1
        else:
            return count",55
70928272826,find_largest_smallest,"def find_largest_smallest(lst):
    largest = lst[0]
    smallest = lst[0]
    for num in lst:
        if num > largest:
            largest = num
        if num < smallest:
            smallest = num
    return largest, smallest",55
9072764138,count_unique_common_chars,"def count_unique_common_chars(str1, str2):
    # Convert both strings to sets to remove duplicates and find common elements
    common_chars = set(str1) & set(str2)
    # Return the number of unique common characters
    return len(common_chars)",55
22853019796,find_MaximumSubarraySum,"def find_MaximumSubarraySum(nums):
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",55
25380202130,find_max_recursive,"def find_max_recursive(lst):
    if len(lst) == 1:
        return lst[0]
    else:
        max_in_rest = find_max_recursive(lst[1:])
        return max_in_rest if max_in_rest > lst[0] else lst[0]",55
30855581555,string_to_uppercase,"def string_to_uppercase(s):
    uppercase_string = """"
    for char in s:
        if 'a' <= char <= 'z':
            uppercase_string += chr(ord(char) - 32)
        else:
            uppercase_string += char
    return uppercase_string",55
8834336091,most_frequent_chars,"from collections import Counter

def most_frequent_chars(s):
    counter = Counter(s)
    max_freq = max(counter.values())
    most_freq_chars = [char for char, freq in counter.items() if freq == max_freq]
    return sorted(most_freq_chars)",55
1433801066,find_largest_subarray_sum,"def find_largest_subarray_sum(nums):
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",55
2308461064,find_substring_occurrences,"def find_substring_occurrences(text, substring):
    count = start = 0
    while True:
        start = text.find(substring, start) + 1
        if start > 0:
            count += 1
        else:
            return count",55
4582698380,second_highest,"def second_highest(numbers):
    unique_numbers = set(numbers)
    if len(unique_numbers) < 2:
        return None
    highest = max(unique_numbers)
    unique_numbers.remove(highest)
    second_highest = max(unique_numbers)
    return second_highest",55
13285481597,prime_digit_sum,"def prime_digit_sum(num):
    prime_digits = [2, 3, 5, 7]
    result = 0
    for digit in str(num):
        if int(digit) in prime_digits:
            result += int(digit)
    return result",55
9153318238,is_power_of_two,"def is_power_of_two(n): 
    if n == 0: 
        return False
    while n != 1: 
        if n % 2 != 0: 
            return False
        n = n // 2
    return True",54
44919137111,sort_by_char_freq,"from collections import Counter

def sort_by_char_freq(strings):
    def sort_key(s):
        char_freq = Counter(s)
        return sorted(s, key=lambda x: (-char_freq[x], x))
    return sorted(strings, key=lambda s: sort_key(s))",54
33273189906,smallest_difference,"def smallest_difference(nums):
    nums.sort()
    min_diff = float('inf')
    for i in range(1, len(nums)):
        diff = nums[i] - nums[i-1]
        min_diff = min(min_diff, diff)
    return min_diff",54
21291965867,kth_largest,"import heapq

def kth_largest(nums, k):
    H = []
    for num in nums:
        heapq.heappush(H, num)
        if len(H) > k:
            heapq.heappop(H)
    return heapq.heappop(H)",54
4914901935,reverse_number,"def reverse_number(n):
    reversed_num = 0
    while n > 0:
        digit = n % 10
        reversed_num = reversed_num * 10 + digit
        n = n // 10
    return reversed_num",54
4133847741,find_smallest_divisible,"from math import gcd
from functools import reduce

def find_smallest_divisible(nums, start):
    lcm = reduce(lambda x, y: x*y // gcd(x, y), nums)
    return ((start + lcm - 1) // lcm) * lcm",54
14793576302,next_greatest_letter,"def next_greatest_letter(letters, target):
    set_let = set(letters)
    tmp = [x for x in set_let if x > target]
    if tmp:
        return min(tmp)
    else:
        return min(set_let)",54
11468787158,is_balanced,"def is_balanced(s):
    stack = []
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack:
                return False
            stack.pop()
    return len(stack) == 0",54
9296162622,is_hex_color_code,"import re

def is_hex_color_code(color_code: str) -> bool:
    pattern = r'^#([A-Fa-f0-9]{6})$'
    if re.match(pattern, color_code):
        return True
    else:
        return False",54
25173696118,reverse_digits,"def reverse_digits(x):
    sign = [1, -1][x < 0]
    rst = sign * int(str(abs(x))[::-1])
    return rst if -(2**31)-1 < rst < 2**31 else 0",54
17550368605,reverse_int,"def reverse_int(num):
    reversed_num = 0
    while num > 0:
        digit = num % 10
        reversed_num = reversed_num * 10 + digit
        num = num // 10
    return reversed_num",54
37844060412,maxProfit,"def maxProfit(prices):
    max_profit = 0
    min_price = float('inf')
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit",54
42591696293,find_permutations,"from itertools import permutations

def find_permutations(s: str) -> list:
    return sorted(list(set([''.join(p) for p in permutations(s)])))

print(find_permutations(""abc""))
print(find_permutations(""aab""))
print(find_permutations(""a""))",54
11358690142,max_diff_between_consecutive,"def max_diff_between_consecutive(points):
    points.sort()
    diff = 0
    for i in range(len(points)-1):
        b = points[i+1] - points[i]
        if b > diff:
            diff = b
    return diff",54
12817518968,is_valid_bracket_sequence,"def is_valid_bracket_sequence(s):
    stack = []
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack or stack.pop() != '(':
                return False
    return not stack",54
74002492926,third_smallest,"def third_smallest(nums):
    unique_nums = list(set(nums))  # Remove duplicates
    if len(unique_nums) < 3:
        return ""List must have at least 3 distinct elements""
    unique_nums.sort()
    return unique_nums[2]",54
16061095160,separate_even_odd,"def separate_even_odd(numbers):
    even_numbers = []
    odd_numbers = []
    for number in numbers:
        if number % 2 == 0:
            even_numbers.append(number)
        else:
            odd_numbers.append(number)
    return even_numbers, odd_numbers",54
18224428949,stock_profit,"def stock_profit(prices):
    max_profit = 0
    min_price = float('inf')
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit",54
10514289291,count_divisible_digits,"def count_divisible_digits(num):
    str_num = str(num)
    count = 0
    for i in str_num:
        if int(i) != 0 and num % int(i) == 0:
            count += 1
    return count",54
28279411381,get_fibonacci,"def get_fibonacci(n):
  if (n == 0):
    return 0
  elif (n == 1):
    return 1
  return get_fibonacci(n - 1) + get_fibonacci(n - 2)",54
13422059786,missing_element,"def missing_element(arr1, arr2):
    arr1.sort()
    arr2.sort()
    for num1, num2 in zip(arr1, arr2):
        if num1 != num2:
            return num1
    return arr1[-1]",54
19130358245,valid_triangle,"def valid_triangle(nums):
    nums.sort()
    for i in range(len(nums) - 2):
        if nums[i] > 0 and nums[i] + nums[i + 1] > nums[i + 2]:
            return True
    return False",54
31517335026,longestOnes,"def longestOnes(nums):
    c=0
    max=0
    for i in nums:
        if i==1:
            c=c+1
            if max<c:
                max=c
        else:
            c=0
    return max",54
72915681169,to_uppercase,"def to_uppercase(s):
    uppercase_str = """"
    for char in s:
        if 'a' <= char <= 'z':
            uppercase_str += chr(ord(char) - 32)
        else:
            uppercase_str += char
    return uppercase_str",54
12257198743,distinct_substrings,"def distinct_substrings(s):
    substrings = set()
    n = len(s)
    for i in range(n):
        for j in range(i + 1, n + 1):
            substrings.add(s[i:j])
    return len(substrings)",54
27961201734,herons_formula,"import math

def herons_formula(a, b, c):
    s = (a + b + c) / 2
    area = math.sqrt(s * (s - a) * (s - b) * (s - c))
    return area",54
73267672898,largest_digit,"def largest_digit(n):
    n = abs(n)
    largest = 0
    while n > 0:
        digit = n % 10
        largest = max(largest, digit)
        n = n // 10
    return largest",54
675155954,character_count,"def character_count(str):
  str = str.lower()
  char_dict = {}
  for char in str:
    if char in char_dict:
      char_dict[char] += 1
    else:
      char_dict[char] = 1
  return char_dict",54
13979875191,max_gap,"def max_gap(nums):
    nums.sort()
    max_gap = 0
    for i in range(1, len(nums)):
        gap = nums[i] - nums[i - 1]
        max_gap = max(max_gap, gap)
    return max_gap",54
24969904236,valid_substrings,"def valid_substrings(s):
    stack = []
    count = 0
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')' and stack:
            stack.pop()
            count += 1
    return count",54
44153876846,multiply,"def multiply(a, b):
    if b == 0:
        return 0
    if b > 0:
        return (a + multiply(a, b - 1))
    if b < 0:
        return -multiply(a, -b)",54
38217867259,max_subsequence_sum,"def max_subsequence_sum(arr):
    maxsum = currsum = 0
    for i in range(len(arr)):
        currsum = max(0, currsum + arr[i])
        maxsum = max(currsum, maxsum)
    return maxsum",54
2723033523,increasing_Triplet,"def increasing_Triplet(nums):
    first = second = float('inf')
    for n in nums:
        if n <= first:
            first = n
        elif n <= second:
            second = n
        else:
            return True
    return False",54
4672000625,find_divisible,"def find_divisible(arr, divisor):
    answer = []
    for i in arr:
        if i % divisor == 0:
            answer.append(i)
    answer.sort()
    if len(answer) == 0:
        answer.append(-1)
    return answer",54
22836542713,calculate_triangle_area,"import math

def calculate_triangle_area(a, b, c):
    s = (a + b + c) / 2
    area = math.sqrt(s * (s - a) * (s - b) * (s - c))
    return area",54
34074817004,prime_numbers,"def prime_numbers(n):
    primes = []
    for num in range(2, n):
        for i in range(2, num):
            if (num % i) == 0:
                break
        else:
            primes.append(num)
    return primes",54
36292080327,nearest_divisible,"def nearest_divisible(n, divisor):
    quotient = n // divisor
    lower = divisor * quotient
    upper = divisor * (quotient + 1)
    if n - lower >= upper - n:
        return upper
    else:
        return lower",54
31773048955,word_count,"def word_count(sentence):
    words = sentence.split()
    word_dict = {}
    for word in words:
        if word in word_dict:
            word_dict[word] += 1
        else:
            word_dict[word] = 1
    return word_dict",54
16946424750,find_pairs,"def find_pairs(arr, target):
    count = 0
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            if arr[i] + arr[j] == target:
                count += 1
    return count",54
38474658962,largest_fibonacci,"def largest_fibonacci(n):
    fib1 = 0
    fib2 = 1
    while fib2 <= n:
        temp = fib2
        fib2 = fib1 + fib2
        fib1 = temp
    return fib1",54
5396921852,find_max_subarray_sum,"def find_max_subarray_sum(nums):
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",54
30782167491,is_palindrome_permutation,"from collections import Counter

def is_palindrome_permutation(s):
    count = Counter(s)
    odd_count = 0
    for v in count.values():
        if v % 2:
            odd_count += 1
    return odd_count <= 1",54
71153769396,reverse_number,"def reverse_number(n):
    reversed_num = 0
    while n > 0:
        digit = n % 10
        reversed_num = reversed_num * 10 + digit
        n = n // 10
    return reversed_num",54
74928817417,find_middle,"def find_middle(num_list):
    n = len(num_list)
    mid = n // 2
    if n % 2 == 0:
        return [num_list[mid - 1], num_list[mid]]
    else:
        return num_list[mid]",54
74060836154,expanding,"def expanding(l):
    a=0
    for i in range(1,len(l)):
        if a >= abs(l[i]-l[i-1]):
            return False
        a=abs(l[i]-l[i-1])
    else:
        return True",54
34564829366,to_upper,"def to_upper(s):
    result = """"
    for char in s:
        if 'a' <= char <= 'z':
            result += chr(ord(char) - ord('a') + ord('A'))
        else:
            result += char
    return result",54
43513362248,generate_pairs,"def generate_pairs(lst):
    if len(lst) < 2:
        return []
    pairs = []
    for i in range(len(lst)):
        for j in range(i+1, len(lst)):
            pairs.append((lst[i], lst[j]))
    return pairs",54
2536292186,substring_count,"def substring_count(s, sub):
    count = 0
    start = 0
    while True:
        start = s.find(sub, start) + 1
        if start > 0:
            count+=1
        else:
            return count",54
22877426098,square_or_cube,"def square_or_cube(arr, flag):
    new_arr = []
    for i in range(len(flag)):
        if flag[i] == True:
            new_arr.append(arr[i]**2)
        else:
            new_arr.append(arr[i]**3)
    return new_arr",54
8792468195,largest_Continuous_Sum,"def largest_Continuous_Sum(arr):
    max_sum = current_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(current_sum + num, num)
        max_sum = max(max_sum, current_sum)
    return max_sum",54
28851403768,check_double_exists,"def check_double_exists(arr):
    seen = set()
    for num in arr:
        if num * 2 in seen or (num % 2 == 0 and num // 2 in seen):
            return True
        seen.add(num)
    return False",54
37163649030,find_pattern_matches,"def find_pattern_matches(text, pattern):
    n = len(text)
    m = len(pattern)
    matches = []
    for i in range(n - m + 1):
        if text[i:i+m] == pattern:
            matches.append(i)
    return matches",54
4497669001,count_unique_substrings,"def count_unique_substrings(s):
    unique_substrings = set()
    n = len(s)
    for i in range(n):
        for j in range(i, n):
            unique_substrings.add(s[i:j+1])
    return len(unique_substrings)",54
38484550998,sum_consecutives,"def sum_consecutives(n):
    ways = 0
    for i in range(1, n):
        if (n - i) % (i + 1) == 0:
            ways += 1
    return ways + 1",54
31953430731,is_triangle_number,"def is_triangle_number(number):
    import math
    # calculate n using the formula
    n = (-1 + math.sqrt(1 + 8 * number)) / 2
    # check if n is an integer
    return n == int(n)",54
70124512666,nth_fibonacci,"def nth_fibonacci(n):
    fib = [0, 1, 1]
    for i in range(3, n + 1):
        fib.append(fib[i - 1] + fib[i - 2])
    return fib[n]",54
73477952841,reverse_number,"def reverse_number(n):
    reversed_num = 0
    while n > 0:
        digit = n % 10
        reversed_num = reversed_num * 10 + digit
        n = n // 10
    return reversed_num",54
10575689431,count_substring,"def count_substring(string, sub_string):
    count = 0
    for i in range(len(string) - len(sub_string) + 1):
        if string[i:i+len(sub_string)] == sub_string:
            count += 1
    return count",54
70452842695,isRotationOfPalindrome,"def isRotationOfPalindrome(s):
    def isPalindrome(s):
        return s == s[::-1]
    for i in range(len(s)):
        if isPalindrome(s):
            return True
        s = s[1:] + s[0]
    return False",54
38444041916,is_self_dividing,"def is_self_dividing(num):
    digits = [int(digit) for digit in str(num)]
    if 0 in digits:
        return False
    for digit in digits:
        if num % digit != 0:
            return False
    return True",54
32787138009,find_median,"def find_median(nums):
    n = len(nums)
    if n % 2 == 1:
        return nums[n // 2]
    else:
        return (nums[n // 2 - 1] + nums[n // 2]) / 2",54
6505518016,convert_to_binary,"def convert_to_binary(n):
    if n == 0:
        return '0'
    bits = []
    while n > 0:
        bits.append(str(n % 2))
        n = n >> 1
    return ''.join(reversed(bits))",54
6391474856,count_word_occurrences,"import re

def count_word_occurrences(sentences, word):
    count = 0
    for sentence in sentences:
        count += len(re.findall(r'\b' + re.escape(word) + r'\b', sentence, re.IGNORECASE))
    return count",54
71496989779,count_substrings,"def count_substrings(s):
    count = 0
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            if s[i] == s[j-1]:
                count += 1
    return count",54
38631057586,odd_Square_Sum,"def odd_Square_Sum(n): 
    sum = 0; 
    for i in range(1,n + 1): 
        j = 2*i - 1; 
        sum = sum + (j*j); 
    return sum;",54
15529981760,string_permutations,"from math import factorial

def string_permutations(s):
    unique_chars = set(s)
    counts = [s.count(char) for char in unique_chars]
    permutations = factorial(len(s))
    for count in counts:
        permutations //= factorial(count)
    return permutations",54
70871187289,climb_Stairs,"def climb_Stairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(3, n+1):
        a, b = b, a + b
    return b",54
70676290697,fibonacci_sequence,"def fibonacci_sequence(n):
    fib_sequence = [0, 1]
    while len(fib_sequence) < n:
        next_value = fib_sequence[-1] + fib_sequence[-2]
        fib_sequence.append(next_value)
    return fib_sequence[:n]",54
6853650622,is_balanced,"def is_balanced(s):
  stack = []
  for char in s:
    if char == '(':
      stack.append(char)
    elif char == ')':
      if not stack:
        return False
      stack.pop()
  return len(stack) == 0",54
32100225117,is_consecutive,"def is_consecutive(sequence):
    sequence.sort()
    flag = True
    for i in range(len(sequence) - 1):
        if sequence[i + 1] - sequence[i] > 1:
            flag = False
            break
    return flag",54
6616815561,canJump,"def canJump(nums):
    goal = len(nums) - 1
    for i in range(len(nums) - 2, -1, -1):
        if i + nums[i] >= goal:
            goal = i
    return goal == 0",54
3632287591,count_good_substrings,"def count_good_substrings(s: str) -> int:
    count = 0
    for i in range(len(s) - 2):
        if len(set(s[i:i + 3])) == 3:
            count += 1
    return count",54
6643682158,second_largest,"def second_largest(numbers):
    max_num = max(numbers)
    second_max = None
    for num in numbers:
        if num < max_num:
            if second_max is None or num > second_max:
                second_max = num
    return second_max",54
8718670586,remove_adjacent_duplicates,"def remove_adjacent_duplicates(numbers):
    if not numbers:
        return []
    result = [numbers[0]]
    for i in range(1, len(numbers)):
        if numbers[i] != numbers[i-1]:
            result.append(numbers[i])
    return result",54
10952976661,find_anagrams,"from collections import defaultdict

def find_anagrams(words):
    anagrams = defaultdict(list)
    for word in words:
        anagrams[''.join(sorted(word))].append(word)
    return sorted([sorted(anagram) for anagram in anagrams.values()])",54
41649618537,square_root,"def square_root(number):
    guess = number / 2.0
    i = 0
    while i < 10:
        guess = (guess + number / guess) / 2.0
        i += 1
    return guess",54
16593479264,find_max_recursion,"def find_max_recursion(lst):
    if len(lst) == 1:
        return lst[0]
    else:
        max_rest = find_max_recursion(lst[1:])
        return lst[0] if lst[0] > max_rest else max_rest",54
28485903098,get_fibonacci,"def get_fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return get_fibonacci(n-1) + get_fibonacci(n-2)",53
35862912061,is_valid_email,"import re

def is_valid_email(email):
    pattern = r""^[^\s@]+@[^\s@]+\.[^\s@]+$""
    if re.match(pattern, email):
        if '..' not in email:
            return True
    return False",53
29750753353,max_squares,"def max_squares(N,K):
    if (N < K):
        return -1;
    else:
        count = 0
        for i in range(K, N+1):
            count += (N-i+1)**2
        return count",53
10813843864,is_valid_pin,"def is_valid_pin(pin):
    if not pin.isdigit():
        return False
    if len(pin) < 4 or len(pin) > 6:
        return False
    if pin[0] == '0':
        return False
    return True",53
23019687395,count_Ways,"def count_Ways(n): 
    if n <= 1:
        return n
    first, second = 1, 2
    for i in range(2, n):
        first, second = second, first + second
    return second",53
23232363543,largestSubarraySum,"def largestSubarraySum(nums):
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",53
15890634561,max_pair_product,"def max_pair_product(lst):
    lst.sort()
    # The maximum product can be either from the two largest positive numbers or from the two smallest negative numbers.
    return max(lst[0] * lst[1], lst[-1] * lst[-2])",53
17866418779,consecutive_three,"def consecutive_three(lst):
    for i in range(len(lst) - 2):
        if lst[i] + 1 == lst[i + 1] and lst[i] + 2 == lst[i + 2]:
            return True
    return False",53
39053223521,count_distinct_substrings,"def count_distinct_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            substrings.add(s[i:j])
    return len(substrings)",53
41524141297,can_construct,"def can_construct(ransomNote: str, magazine: str) -> bool:
    for i in ransomNote:
        if i in magazine:
            magazine = magazine.replace(i, """", 1)
            continue
        else:
            return False
    return True",53
21905709813,merge_dictionaries,"def merge_dictionaries(dict1, dict2):
    result = dict1.copy()
    for key, value in dict2.items():
        if key in result:
            result[key] += value
        else:
            result[key] = value
    return result",53
3204467155,largest_subarray_sum,"def largest_subarray_sum(nums):
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",53
30849737069,largest_subarray_sum,"def largest_subarray_sum(nums):
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",53
13709496391,least_common_multiple,"def greatest_common_divisor(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def least_common_multiple(a, b):
    return a * b // greatest_common_divisor(a, b)",53
13383748139,vowel_count,"def vowel_count(string):
    vowels = 'aeiou'
    vowel_count = {vowel: 0 for vowel in vowels}
    for char in string.lower():
        if char in vowels:
            vowel_count[char] += 1
    return vowel_count",53
73096169944,reverse_integer,"def reverse_integer(x):
    sign = [1,-1][x < 0]
    rst = sign * int(str(abs(x))[::-1])
    return rst if -(2**31)-1 < rst < 2**31 else 0",53
17463540936,is_happy_number,"def is_happy_number(n):
    seen = set()
    while n not in seen:
        seen.add(n)
        n = sum(int(digit)**2 for digit in str(n))
        if n == 1:
            return True
    return False",53
3631609711,is_even_sum_and_unique_digits,"def is_even_sum_and_unique_digits(n):
    digits = [int(d) for d in str(n)]
    if len(digits) != len(set(digits)):
        return False
    digit_sum = sum(digits)
    return digit_sum % 2 == 0",53
21598839348,sum_except_nine,"def sum_except_nine(n):
    total = 0
    while n > 0:
        digit = n % 10
        if digit != 9:
            total += digit
        n = n // 10
    return total",53
26222585129,find_pairs,"def find_pairs(nums, target):
    seen = {}
    pairs = []
    for num in nums:
        complement = target - num
        if complement in seen:
            pairs.append((complement, num))
        seen[num] = True
    return pairs",53
28918954029,check_duplicates,"def check_duplicates(numbers):
    number_count = {}
    for number in numbers:
        if number in number_count:
            return len([n for n in numbers if n == number])
        else:
            number_count[number] = 1
    return -1",53
34361870986,is_pronic,"def is_pronic(num):
    for i in range(1, num):
        if i * (i + 1) == num:
            return True
        elif i * (i + 1) > num:
            return False
    return False",53
383652140,group_anagrams,"from collections import defaultdict

def group_anagrams(words):
    anagrams_dict = defaultdict(list)
    for word in words:
        sorted_word = ''.join(sorted(word))
        anagrams_dict[sorted_word].append(word)
    return list(anagrams_dict.values())",53
75151899145,largestSubarraySum,"def largestSubarraySum(nums):
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",53
33182446491,ways_to_climb,"def ways_to_climb(n):
    if n <= 1:
        return n
    a, b = 1, 2
    for _ in range(2, n):
        a, b = b, a + b
    return b",53
33760299818,find_kth_largest,"import heapq

def find_kth_largest(nums, k):
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)
    return heap[0]",53
27393421543,smallest_multiple,"from math import gcd

def lcm(a, b):
    return a * b // gcd(a, b)

def smallest_multiple(nums):
    result = nums[0]
    for num in nums[1:]:
        result = lcm(result, num)
    return result",53
5345897252,frequent_elements,"from collections import Counter

def frequent_elements(elements):
    freq = Counter(elements)
    highest_freq = max(freq.values())
    most_frequent = [key for key, val in freq.items() if val == highest_freq]
    return sorted(most_frequent)",53
30367999879,maxSubArraySum,"def maxSubArraySum(nums):
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",53
35671472210,smallest_diff,"def smallest_diff(numbers, target):
    numbers.sort()
    min_diff = abs(numbers[0] - target)
    for i in numbers:
        if abs(i - target) < min_diff:
            min_diff = abs(i - target)
    return min_diff",53
21463766988,isContinuousSubsequence,"def isContinuousSubsequence(lst, sublst):
    sub_len = len(sublst)
    for i in range(len(lst) - sub_len + 1):
        if lst[i:i+sub_len] == sublst:
            return True
    return False",53
35011423989,even_odd_partition,"def even_odd_partition(array):
    even_list, odd_list = [], []
    for number in array:
        if number % 2 == 0:
            even_list.append(number)
        else:
            odd_list.append(number)
    return even_list + odd_list",53
10896628036,largest_subarray_sum,"def largest_subarray_sum(nums):
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",53
20736707220,find_most_frequent_char,"from collections import Counter

def find_most_frequent_char(s):
    if not s:
        return []
    counter = Counter(s)
    max_freq = max(counter.values())
    return [char for char, freq in counter.items() if freq == max_freq]",53
19736473577,find_fibonacci,"def find_fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return find_fibonacci(n-1) + find_fibonacci(n-2)",53
38901730261,check_binary_substrings,"def check_binary_substrings(S: str, N: int) -> bool:
    for n in range(max(1, N >> 1), N+1):
        if S.find(bin(n)[2:]) < 0: return False
    return True",53
26650713233,unique_permutations,"from itertools import permutations

def unique_permutations(strings):
    unique_perms = set()
    for p in permutations(strings):
        sorted_p = tuple("""".join(sorted(s)) for s in p)
        unique_perms.add(sorted_p)
    return len(unique_perms)",53
25544239858,sum_even_odd,"def sum_even_odd(nums):
    even_sum = sum(num for num in nums if num % 2 == 0)
    odd_sum = sum(num for num in nums if num % 2 != 0)
    return [even_sum, odd_sum]",53
74270052503,find_max,"def find_max(nums):
    if len(nums) == 1:
        return nums[0]
    else:
        max_in_rest = find_max(nums[1:])
        return nums[0] if nums[0] > max_in_rest else max_in_rest",53
42554700707,first_missing_positive,"def first_missing_positive(nums):
    nums = list(set(nums))
    nums.sort()
    expected = 1
    for num in nums:
        if num == expected:
            expected += 1
        elif num > expected:
            break
    return expected",53
7211884040,triangle_area,"import math

def triangle_area(a, b, c):
    s = (a + b + c) / 2
    area = math.sqrt(s * (s - a) * (s - b) * (s - c))
    return area",53
73881310651,has_anagrams,"def has_anagrams(word_list):
    word_dict = {}
    for word in word_list:
        key = ''.join(sorted(word))
        if key in word_dict:
            return True
        else:
            word_dict[key] = 1
    return False",53
37339336775,max_consecutive_sum,"def max_consecutive_sum(nums):
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",53
36902910525,area_triangle,"import math

def area_triangle(a, b, c):
    s = (a + b + c) / 2
    area = math.sqrt(s * (s - a) * (s - b) * (s - c))
    return area",53
71439452790,pattern,"def pattern(N):
    temp = N
    res = []
    while(temp > 0):
        res.append(temp)
        temp = temp-5
    while(temp <= N):
        res.append(temp)
        temp = temp+5
    return res",53
6995824918,stock_profit,"def stock_profit(prices):
    max_profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            max_profit += prices[i] - prices[i-1]
    return max_profit",53
16086434617,find_longest_string,"def find_longest_string(string_list):
    longest_string = """"
    max_length = 0
    for string in string_list:
        if len(string) > max_length:
            longest_string = string
            max_length = len(string)
    return longest_string",53
22512883784,most_frequent_character,"def most_frequent_character(s):
    frequency = {}
    for char in s:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return max(frequency, key=frequency.get)",53
37808983774,max_stock_profit,"def max_stock_profit(prices):
    result = 0
    price_prev = prices[0]
    for price in prices[1:]:
        if price > price_prev:
            result += price - price_prev
        price_prev = price
    return result",53
7358801419,solution,"import collections

def solution(nums):
    dict = collections.Counter(nums)
    max_val = len(nums) // 2
    key_length = len(dict.keys())
    if key_length > max_val:
        return max_val
    else:
        return key_length",53
37167417734,top_frequent_elements,"from collections import Counter

def top_frequent_elements(nums, k):
    freq = Counter(nums)
    sorted_freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)
    return [key for key, _ in sorted_freq[:k]]",53
16709236431,find_substring_count,"def find_substring_count(s, sub):
    count = start = 0
    while True:
        start = s.find(sub, start) + 1
        if start > 0:
            count += 1
        else:
            return count",53
31541106,is_happy_number,"def is_happy_number(n):
    seen = set()
    while n not in seen:
        seen.add(n)
        n = sum(int(digit)**2 for digit in str(n))
        if n == 1:
            return True
    return False",53
18138428878,is_rotated_substring,"def is_rotated_substring(s, sub):
    if sub not in s+s:
        return False
    for i in range(len(sub)):
        if s.find(sub[i:]+sub[:i]) != -1:
            return True
    return False",53
5354160773,stock_profit,"def stock_profit(prices):
    max_profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            max_profit += prices[i] - prices[i-1]
    return max_profit",53
8464582360,triangle_area,"import math

def triangle_area(a, b, c):
    s = (a + b + c) / 2
    area = math.sqrt(s * (s - a) * (s - b) * (s - c))
    return area",53
1185352874,largest_sum,"def largest_sum(nums):
    max_sum = float('-inf')
    current_sum = 0
    for num in nums:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",53
4485681013,second_smallest,"def second_smallest(numbers):
    if len(numbers) < 2:
        return None
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return None
    unique_numbers.sort()
    return unique_numbers[1]",53
9499249184,check_perfect_number,"def check_perfect_number(num):
    if num < 1:
        return False
    sum = 0
    for i in range(1, num):
        if num % i == 0:
            sum += i
    return sum == num",53
41538982594,second_max,"def second_max(numbers):
    if len(numbers) < 2:
        return None
    unique_numbers = set(numbers)
    if len(unique_numbers) < 2:
        return None
    unique_numbers.remove(max(unique_numbers))
    return max(unique_numbers)",53
17925663484,reverse_Digits,"def reverse_Digits(n):
    reverse = 0
    while n > 0:
        remainder = n % 10
        reverse = (reverse * 10) + remainder
        n = n // 10
    return reverse",53
8724725511,count_BST,"def count_BST(n):
    if n <= 1:
        return 1
    total = 0
    for i in range(n):
        total += count_BST(i) * count_BST(n - i - 1)
    return total",53
12619000187,vowel_count,"def vowel_count(input_string):
    vowels = ['a', 'e', 'i', 'o', 'u']
    count = 0
    for char in input_string.lower():
        if char in vowels:
            count += 1
    return count",53
13272006554,transpose,"def transpose(matrix):
    rows = len(matrix)
    cols = len(matrix[0])
    result = []

    for j in range(cols):
        result.append([])
        for i in range(rows):
            result[j].append(matrix[i][j])

    return result",53
73725823512,max_Product,"def max_Product(nums):
    if len(nums) < 2:
        raise ValueError(""Input list must contain at least two elements"")
    
    nums.sort()
    return max(nums[0] * nums[1], nums[-1] * nums[-2])",53
7531428756,age_to_names,"def age_to_names(people):
    age_dict = {}
    for name, age in people:
        if age in age_dict:
            age_dict[age].append(name)
        else:
            age_dict[age] = [name]
    return age_dict",53
44022209326,most_Frequent_Character,"def most_Frequent_Character(s):
    frequency = {}
    for char in s:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return max(frequency, key=frequency.get)",53
12720113987,second_smallest,"def second_smallest(numbers):
    if len(numbers) < 2:
        return None
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return None
    unique_numbers.sort()
    return unique_numbers[1]",53
40514025280,create_nested_dict,"def create_nested_dict(top_keys, second_keys, values):
    result = []
    for i in range(len(top_keys)):
        nested_dict = {top_keys[i]: {second_keys[i]: values[i]}}
        result.append(nested_dict)
    return result",53
12488791757,convert_to_uppercase,"def convert_to_uppercase(input_str):
    uppercase_str = """"
    for char in input_str:
        if 'a' <= char <= 'z':
            char = chr(ord(char) - 32)
        uppercase_str += char
    return uppercase_str",53
30042329815,find_max_unique,"def find_max_unique(*args):
    max_unique = 0
    max_string = """"
    for string in args:
        if len(set(string)) > max_unique:
            max_unique = len(set(string))
            max_string = string
    return max_string",53
20004479071,is_perfect_number,"def is_perfect_number(n):
    if n < 1:
        return False
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n",53
40711253914,single_digit_sum,"def single_digit_sum(n):
    while n >= 10:
        sum = 0
        while n > 0:
            sum += n % 10
            n = n // 10
        n = sum
    return n",53
16165492185,merge_dictionaries,"def merge_dictionaries(dict1, dict2):
    result = dict1.copy()
    for key, value in dict2.items():
        if key in result:
            result[key] += value
        else:
            result[key] = value
    return result",53
37957644413,maxProfit,"def maxProfit(prices):
    max_profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            max_profit += prices[i] - prices[i-1]
    return max_profit",53
13346992544,two_sum,"def two_sum(nums, target):
    num_dict = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_dict:
            return (num_dict[complement], i)
        num_dict[num] = i",53
4742600874,count_distinct_substrings,"def count_distinct_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            substrings.add(s[i:j])
    return len(substrings)",53
29878164553,max_element,"def max_element(arr):
    if len(arr) == 1:
        return arr[0]
    else:
        max_of_rest = max_element(arr[1:])
        return arr[0] if arr[0] > max_of_rest else max_of_rest",53
70972950608,canFormString,"from collections import Counter

def canFormString(str1, str2):
    a = Counter(str1)
    b = Counter(str2)
    for i, _ in a.items():
        if(a[i]>b[i]):
            return False
    return True",53
12443802596,check_perfect_number,"def check_perfect_number(num):
    if num < 1:
        return False
    sum = 0
    for i in range(1, num):
        if num % i == 0:
            sum += i
    return sum == num",53
702093666,count_increasing_subsequences,"def count_increasing_subsequences(nums):
    count = 0
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[j] > nums[i]:
                count += 1
    return count",53
35130259970,reverseDigits,"def reverseDigits(x):
    sign = [1,-1][x < 0]
    rst = sign * int(str(abs(x))[::-1])
    return rst if -(2**31)-1 < rst < 2**31 else 0",53
25815234179,two_sum,"def two_sum(nums, target):
    num_dict = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_dict:
            return [num_dict[complement], i]
        num_dict[num] = i",53
31580228846,most_frequent_word,"import re
from collections import Counter

def most_frequent_word(text):
    words = re.findall(r'\b\w+\b', text.lower())
    most_common_word = Counter(words).most_common(1)[0][0]
    return most_common_word",53
35697586545,extract_words_with_prefix,"def extract_words_with_prefix(words, prefix):
    result = {}
    for word in words:
        if word.startswith(prefix):
            if word in result:
                result[word] += 1
            else:
                result[word] = 1
    return result",53
6572528702,find_lcm,"def gcd(x, y):
   while(y):
       x, y = y, x % y
   return x

def find_lcm(num1, num2):
   lcm = (num1*num2)//gcd(num1,num2)
   return lcm",53
40499975424,find_kth_largest,"import heapq

def find_kth_largest(nums, k):
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)
    return heap[0]",53
10741598529,max_stock_profit,"def max_stock_profit(prices):
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            profit += prices[i] - prices[i - 1]
    return profit",53
34589163231,message_decode,"import re

def message_decode(s: str):
    while '[' in s:
        s = re.sub(r'(\d+)\[([a-z]*)\]', lambda m: int(m.group(1)) * m.group(2), s)
    return s",53
30124078648,cumulative_product,"def cumulative_product(nums):
    index_product = 1
    result = []
    for i in range(len(nums)):
        index_product = index_product * nums[i]
        # print(nums[i], index_product)
        result.append(index_product)
            
    return result",53
12187968723,findLargestUsingHeap,"import heapq

def findLargestUsingHeap(arr):
    # Convert list into a max-heap in-place
    heapq._heapify_max(arr)
    # Return root element of max-heap, which is the largest element
    return arr[0]",53
953390269,merge_dictionaries,"def merge_dictionaries(dict1, dict2):
    result = dict1.copy()
    for key, value in dict2.items():
        if key in result:
            result[key] += value
        else:
            result[key] = value
    return result",53
37204366617,find_largest_three_digit_number,"def find_largest_three_digit_number(numbers):
    three_digit_numbers = [num for num in numbers if 100 <= num <= 999]
    if three_digit_numbers:
        return max(three_digit_numbers)
    else:
        return None",53
73589187225,valid_parentheses,"def valid_parentheses(s):
    stack = []
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack or stack.pop() != '(':
                return False
    return not stack",53
12965246383,max_abs_difference,"def max_abs_difference(arr):
    max_diff = 0
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            max_diff = max(max_diff, abs(arr[i] - arr[j]))
    return max_diff",53
26706759326,find_Fibonacci,"def find_Fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return find_Fibonacci(n-1) + find_Fibonacci(n-2)",53
31123260213,find_extremes,"def find_extremes(test_list):
  max_first = max(test_list, key=lambda x: x[0])[0]
  min_second = min(test_list, key=lambda x: x[1])[1]
  return ((max_first),(min_second))",53
17517387508,find_missing_element,"def find_missing_element(arr1, arr2):
    arr1.sort()
    arr2.sort()
    for i in range(len(arr2)):
        if arr1[i] != arr2[i]:
            return arr1[i]
    return arr1[-1]",53
14636869926,is_power,"def is_power(num, base):
    if num == 1:
        return True
    if num < 1 or base < 2:
        return False
    return is_power(num / base, base) if num % base == 0 else False",53
41618523676,camel_to_snake,"def camel_to_snake(camel_str):
    snake_str = ''
    for char in camel_str:
        if char.isupper():
            snake_str += '_' + char.lower()
        else:
            snake_str += char
    return snake_str.lstrip('_')",53
32592770173,convert_to_email,"def convert_to_email(email, domain):
    if '@' in email:
        email_parts = email.split('@')
        email = email_parts[0] + '@' + domain
    else:
        email = email + '@' + domain
    return email",53
17787669281,findKthLargest,"import heapq

def findKthLargest(nums, k):
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
            heapq.heappop(heap)
    return heap[0]",53
35128780873,maxProfit,"def maxProfit(prices):
    total_profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            total_profit += prices[i] - prices[i-1]
    return total_profit",53
74225261429,generate_prime_numbers,"def generate_prime_numbers(n):
    primes = []
    num = 2
    while len(primes) < n:
        if all(num % p != 0 for p in primes):
            primes.append(num)
        num += 1
    return primes",53
12777699011,age_grouping,"def age_grouping(people):
    age_dict = {}
    for name, age in people:
        if age in age_dict:
            age_dict[age].append(name)
        else:
            age_dict[age] = [name]
    return age_dict",53
6126275920,find_missing_element,"def find_missing_element(arr1, arr2):
    arr1.sort()
    arr2.sort()
    for i in range(len(arr2)):
        if arr1[i] != arr2[i]:
            return arr1[i]
    return arr1[-1]",53
14658946272,get_fibonacci,"def get_fibonacci(n):
  if n == 0:
    return 0
  elif n == 1:
    return 1
  else:
    return get_fibonacci(n-1) + get_fibonacci(n-2)",53
38466561284,find_missing,"def find_missing(arr1, arr2):
    arr1.sort()
    arr2.sort()

    for i in range(len(arr2)):
        if (arr1[i] != arr2[i]):
            return arr1[i]

    return arr1[-1]",53
43666165257,count_pattern_occurrences,"def count_pattern_occurrences(text, pattern):
    count = start = 0
    while True:
        start = text.find(pattern, start) + 1
        if start > 0:
            count += 1
        else:
            return count",53
33564898381,most_occurring_element,"def most_occurring_element(arr):
    frequency = {}
    for num in arr:
        if num in frequency:
            frequency[num] += 1
        else:
            frequency[num] = 1
    return max(frequency, key=frequency.get)",53
71942347628,check_string,"def check_string(s):
    valid_chars = {'a', 'b', 'c'}
    if 'a' not in s:
        return False
    for char in s:
        if char not in valid_chars:
            return False
    return True",52
6316906329,grade_score,"def grade_score(marks):
    if marks < 40:
        return 0
    elif marks < 60:
        return 1
    elif marks < 80:
        return 2
    else:
        return 3",52
28740180951,decimal_to_binary,"def decimal_to_binary(num):
    if num == 0:
        return ""0""
    binary = []
    while num > 0:
        binary.append(str(num % 2))
        num //= 2
    return """".join(binary[::-1])",52
41617542611,max_score,"def max_score(players):
    if not players:
        return None
    max_val = players[0][1]
    for player in players:
        if player[1] > max_val:
            max_val = player[1]
    return max_val",52
37628216263,most_frequent_elements,"from collections import Counter

def most_frequent_elements(lst):
    if not lst:
        return []
    counter = Counter(lst)
    max_freq = max(counter.values())
    return [num for num, freq in counter.items() if freq == max_freq]",52
12243690920,count_increasing_subsequences,"def count_increasing_subsequences(nums):
    count = 0
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[j] > nums[i]:
                count += 1
    return count",52
75090122676,reverse_number,"def reverse_number(number):
  reverse = 0
  while number > 0:
    last_digit = number % 10
    reverse = reverse * 10 + last_digit
    number = number // 10
  return reverse",52
5579377784,dec_to_bin,"def dec_to_bin(n):
    if n == 0:
        return '0'
    binary = ''
    while n > 0:
        binary = str(n % 2) + binary
        n = n // 2
    return binary",52
32269557279,thirdLargest,"def thirdLargest(nums):
    nums = list(set(nums))
    if len(nums) < 3:
        return ""List should have at least 3 unique elements""
    nums.remove(max(nums))
    nums.remove(max(nums))
    return max(nums)",52
38594940003,int_to_binary,"def int_to_binary(n):
    if n == 0:
        return '0'
    binary = ''
    while n > 0:
        binary = str(n % 2) + binary
        n = n // 2
    return binary",52
16298476687,most_common_char,"from collections import Counter

def most_common_char(s):
    if not s:
        return None
    counter = Counter(s)
    max_freq = max(counter.values())
    for char in s:
        if counter[char] == max_freq:
            return char",52
25621395791,binary_to_decimal,"def binary_to_decimal(binary_list):
    decimal_list = []
    for binary in binary_list:
        decimal = 0
        for digit in binary:
            decimal = decimal*2 + int(digit)
        decimal_list.append(decimal)
    return decimal_list",52
8691125265,smallest_rotation,"def smallest_rotation(s):
    s = s + s
    n = len(s) // 2
    for i in range(1, n):
        if s[i:i+n] == s[:n]:
            return i
    return 0",52
41693370446,is_harshad_number,"def is_harshad_number(num):
    if num<1:
        return False
    sum_of_digits = sum([int(i) for i in str(num)])
    if num%sum_of_digits==0:
        return True
    return False",52
73289996156,max_num_recursive,"def max_num_recursive(lst):
    if len(lst) == 1:
        return lst[0]
    else:
        max_rest = max_num_recursive(lst[1:])
        return lst[0] if lst[0] > max_rest else max_rest",52
19141374114,int_to_binary,"def int_to_binary(num):
    if num == 0:
        return ""0""
    binary = """"
    while num > 0:
        binary = str(num % 2) + binary
        num = num // 2
    return binary",52
44237153322,reverse_number,"def reverse_number(n):
    reverse = 0
    while n > 0:
        remainder = n % 10
        reverse = (reverse * 10) + remainder
        n = n // 10
    return reverse",52
69836795026,find_most_common,"from collections import Counter

def find_most_common(lst):
    if not lst:
        return None
    count = Counter(lst)
    max_count = max(count.values())
    for item in lst:
        if count[item] == max_count:
            return item",52
21944720402,max_length_string,"def max_length_string(string_list):
    max_length = 0
    max_string = """"
    for string in string_list:
        if len(string) > max_length:
            max_length = len(string)
            max_string = string
    return max_string",52
27805526697,find_majority_element,"def find_majority_element(arr):
    count = 0
    candidate = None

    for num in arr:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    return candidate",52
34104172029,invert_case,"def invert_case(input_string):
    result = """"
    for char in input_string:
        if char.islower():
            result += char.upper()
        elif char.isupper():
            result += char.lower()
        else:
            result += char
    return result",52
14983685802,median_of_three,"def median_of_three(a, b, c):
    if a <= b <= c or c <= b <= a:
        return b
    elif b <= a <= c or c <= a <= b:
        return a
    else:
        return c",52
13396641012,stair_climb,"def stair_climb(n):
    if n <= 1:
        return n
    a, b = 1, 2
    for _ in range(2, n):
        a, b = b, a + b
    return b",52
946571909,dec_to_bin,"def dec_to_bin(number):
    if number == 0:
        return '0'
    binary = ''
    while number > 0:
        binary = str(number % 2) + binary
        number = number // 2
    return binary",52
2389543507,count_substring,"def count_substring(s, sub):
    count = start = 0
    while True:
        start = s.find(sub, start) + 1
        if start > 0:
            count += 1
        else:
            return count",52
70085466106,count_unique_substrings,"def count_unique_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            substrings.add(s[i:j])
    return len(substrings)",52
32383096576,find_max_recursive,"def find_max_recursive(lst):
    if len(lst) == 1:
        return lst[0]
    else:
        max_rest = find_max_recursive(lst[1:])
        return lst[0] if lst[0] > max_rest else max_rest",52
11873141859,merge_dicts,"def merge_dicts(dict1, dict2):
    result = {}
    for key in set(dict1.keys()).union(dict2.keys()):
        result[key] = dict1.get(key, 0) + dict2.get(key, 0)
    return result",52
23484127467,find_pair,"def find_pair(arr, target_sum):
    hash_set = set()
    for num in arr:
        complement = target_sum - num
        if complement in hash_set:
            return [complement, num]
        hash_set.add(num)
    return []",52
21013073321,descending_sort,"def descending_sort(lst):
    for i in range(len(lst)):
        for j in range(i + 1, len(lst)):
            if lst[i] < lst[j]:
                lst[i], lst[j] = lst[j], lst[i]
    return lst",52
11014473710,distinct_substrings,"def distinct_substrings(s):
    n = len(s)
    substrings = set()
    for i in range(n):
        for j in range(i+1, n+1):
            substrings.add(s[i:j])
    return len(substrings)",52
70571586406,find_max_recursive,"def find_max_recursive(numbers):
    if len(numbers) == 1:
        return numbers[0]
    else:
        max_num = find_max_recursive(numbers[1:])
        return max_num if max_num > numbers[0] else numbers[0]",52
33086346963,smallest_divisor,"def smallest_divisor(n):
    if n <= 1:
        return n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return i
    return n",52
29546039911,max_product_of_three,"def max_product_of_three(nums):
    nums.sort()
    n = len(nums)
    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])",52
30158134447,stairs_climb,"def stairs_climb(n):
    if n <= 1:
        return n
    first, second = 1, 2
    for i in range(2, n):
        first, second = second, first + second
    return second",52
31313272471,smallest_common_multiple,"from math import gcd

def lcm(a, b):
    return a * b // gcd(a, b)

def smallest_common_multiple(numbers):
    scm = 1
    for n in numbers:
        scm = lcm(scm, n)
    return scm",52
798861809,find_majority_element,"def find_majority_element(nums):
    count = 0
    candidate = None
    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    return candidate",52
11444356205,median_of_three,"def median_of_three(a, b, c):
    if a <= b <= c or c <= b <= a:
        return b
    elif b <= a <= c or c <= a <= b:
        return a
    else:
        return c",52
6952435355,find_missing_element,"from collections import Counter

def find_missing_element(arr1, arr2):
    counter1 = Counter(arr1)
    counter2 = Counter(arr2)
    for k, v in counter1.items():
        if v != counter2[k]:
            return k",52
72102504949,lucas_series,"def lucas_series(n):
  if n == 0:
    return 2
  elif n == 1:
    return 1
  else:
    return lucas_series(n - 1) + lucas_series(n - 2)",52
36658645059,reverse_integer,"def reverse_integer(n):
    reversed_num = 0
    while n > 0:
        digit = n % 10
        reversed_num = reversed_num * 10 + digit
        n //= 10
    return reversed_num",52
4527465122,max_product_of_two_elements,"from typing import List

def max_product_of_two_elements(nums: List[int]) -> int:
    nums.sort()
    n = len(nums)
    return max(nums[0] * nums[1], nums[n-1] * nums[n-2])",52
35515791259,is_happy,"def is_happy(n):
    seen = set()
    while n not in seen:
        seen.add(n)
        n = sum(int(digit)**2 for digit in str(n))
        if n == 1:
            return True
    return False",52
32430385892,maxSubArray,"def maxSubArray(nums):
    max_sum = current_sum = nums[0]
    for n in nums[1:]:
        current_sum = max(n, current_sum + n)
        max_sum = max(max_sum, current_sum)
    return max_sum",52
4072840793,custom_sort,"def custom_sort(numbers):
    for i in range(len(numbers)):
        for j in range(i + 1, len(numbers)):
            if numbers[i] < numbers[j]:
                numbers[i], numbers[j] = numbers[j], numbers[i]
    return numbers",52
69996912184,vowel_strings,"def vowel_strings(strings):
    vowels = ['a', 'e', 'i', 'o', 'u']
    result = []
    for string in strings:
        if string[0].lower() in vowels:
            result.append(string)
    return result",52
9855796276,median_of_three,"def median_of_three(a, b, c):
    if a <= b <= c or c <= b <= a:
        return b
    elif b <= a <= c or c <= a <= b:
        return a
    else:
        return c",52
30821220842,staircase_ways,"def staircase_ways(n):
    a, b = 1, 2
    if n == 1:
        return a
    for i in range(2, n):
        a, b = b, a + b
    return b",52
9672239742,canAttendMeetings,"from operator import itemgetter

def canAttendMeetings(intervals):
    intervals.sort(key=itemgetter(0))

    return all(
        it[1] <= jt[0] for it, jt in zip(intervals, intervals[1:])
    )",52
14793780742,count_ab,"def count_ab(s):
  count = 0
  for i in range(len(s) - 1):
    if s[i] == 'a' and s[i + 1] == 'b':
      count += 1
  return count",52
15951282111,find_largest_smallest,"def find_largest_smallest(numbers):
    largest = smallest = numbers[0]
    for num in numbers[1:]:
        if num > largest:
            largest = num
        elif num < smallest:
            smallest = num
    return smallest, largest",52
73782738131,is_ideal_permutation,"def is_ideal_permutation(A):
    Max = -1
    for i in range(0, len(A)-2):
        Max = max(A[i], Max)
        if Max > A[i+2]:
            return False
    return True",52
10348021194,solution,"def solution(A):
    count = dict()
    for i in A:
        count[i] = count.get(i, 0) + 1
    for key in count:
        if count[key] % 2 != 0:
            return key",52
6318049865,dec_to_bin,"def dec_to_bin(num):
    if num == 0:
        return ""0""
    binary = """"
    while num > 0:
        binary = str(num % 2) + binary
        num = num // 2
    return binary",52
686601979,median_of_three,"def median_of_three(a, b, c):
    if a <= b <= c or c <= b <= a:
        return b
    elif b <= a <= c or c <= a <= b:
        return a
    else:
        return c",52
14636770396,case_reversal,"def case_reversal(s):
    result = """"
    for char in s:
        if char.islower():
            result += char.upper()
        elif char.isupper():
            result += char.lower()
        else:
            result += char
    return result",52
29048325625,dec_to_bin,"def dec_to_bin(n):
    if n == 0:
        return ""0""
    binary = []
    while n > 0:
        binary.append(str(n%2))
        n = n//2
    return """".join(binary[::-1])",52
18180825361,find_largest,"def find_largest(arr):
    if len(arr) == 1:
        return arr[0]
    else:
        max_rest = find_largest(arr[1:])
        return arr[0] if arr[0] > max_rest else max_rest",52
73183417162,count_Ways,"def count_Ways(n):
    if n <= 1:
        return n
    first, second = 1, 2
    for i in range(2, n):
        first, second = second, first + second
    return second",52
18647026379,max_sub_array,"def max_sub_array(nums):
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",52
7003282023,prime_numbers,"def prime_numbers(n):
  primes = []
  for num in range(2, n+1):
    if all(num%i!=0 for i in range(2, int(num**0.5)+1)):
      primes.append(num)
  return primes",52
37588292574,median_of_three,"def median_of_three(a, b, c):
    if a <= b <= c or c <= b <= a:
        return b
    elif b <= a <= c or c <= a <= b:
        return a
    else:
        return c",52
36260704989,sort_even_before_odd,"def sort_even_before_odd(nums):
    even_nums = [num for num in nums if num % 2 == 0]
    odd_nums = [num for num in nums if num % 2 != 0]
    return even_nums + odd_nums",52
9928075387,smallest_divisor,"def smallest_divisor(n):
    if n <= 1:
        return n
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return i
    return n",52
22957866773,int_to_binary,"def int_to_binary(n):
    if n == 0:
        return '0'
    binary = ''
    while n > 0:
        binary = str(n % 2) + binary
        n = n // 2
    return binary",52
39577324088,max_frequency,"def max_frequency(l):
    frequency_map = {}
    for num in l:
        if num in frequency_map:
            frequency_map[num] += 1
        else:
            frequency_map[num] = 1
    return max(frequency_map.values())",52
24175764455,most_frequent_integer,"from collections import Counter

def most_frequent_integer(numbers):
    if not numbers: return None
    counter = Counter(numbers)
    max_freq = max(counter.values())
    return min(key for key, value in counter.items() if value == max_freq)",52
10891464500,maxSubArray,"def maxSubArray(nums):
    current_sum = max_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum",52
34446727837,find_majority_element,"def find_majority_element(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    return candidate",52
27426884677,range_bitwise_and,"def range_bitwise_and(m, n):
    shift_count = 0
    while m != n and m > 0:
        n >>= 1
        m >>= 1
        shift_count += 1
    return m << shift_count",52
18735888249,custom_sort,"def custom_sort(nums):
    even_nums = sorted([num for num in nums if num % 2 == 0])
    odd_nums = sorted([num for num in nums if num % 2 != 0])
    return even_nums + odd_nums",52
30362678454,is_valid_parentheses,"def is_valid_parentheses(s):
    stack = []
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack:
                return False
            stack.pop()
    return not stack",52
23240910055,find_majority_element,"def find_majority_element(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    return candidate",52
6717553702,find_max_recursive,"def find_max_recursive(lst):
    if len(lst) == 1:
        return lst[0]
    else:
        max_rest = find_max_recursive(lst[1:])
        return lst[0] if lst[0] > max_rest else max_rest",52
71921078744,decimal_to_binary,"def decimal_to_binary(n):
    if n == 0:
        return ""0""
    binary = """"
    while n > 0:
        binary = str(n % 2) + binary
        n = n // 2
    return binary",52
16782791089,char_freq_and_positions,"def char_freq_and_positions(target, text):
    freq = 0
    positions = []
    for i, char in enumerate(text):
        if char == target:
            freq += 1
            positions.append(i)
    return (freq, positions)",52
44782810598,even_odd_sort,"def even_odd_sort(numbers):
    even = sorted([num for num in numbers if num % 2 == 0])
    odd = sorted([num for num in numbers if num % 2 != 0], reverse=True)
    return even + odd",52
20352470127,is_permutation,"def is_permutation(str1, str2):
    if len(str1) != len(str2):
        return False
    str1_sorted = sorted(str1)
    str2_sorted = sorted(str2)
    return str1_sorted == str2_sorted",52
17088696725,num_unique_substrings,"def num_unique_substrings(s):
    unique_substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            unique_substrings.add(s[i:j])
    return len(unique_substrings)",52
25892362647,rearrange_even_odd,"def rearrange_even_odd(nums):
    even_nums = [num for num in nums if num % 2 == 0]
    odd_nums = [num for num in nums if num % 2 != 0]
    return even_nums + odd_nums",52
40713201474,find_missing,"def find_missing(arr1, arr2):
  arr1.sort()
  arr2.sort()
  for i in range(len(arr2)):
    if arr1[i] != arr2[i]:
      return arr1[i]
  return arr1[-1]",52
9635938630,square_roots,"import math

def square_roots(numbers):
    result = []
    for num in numbers:
        if num >= 0:
            result.append(round(math.sqrt(num), 2))
        else:
            result.append(0.00)
    return result",52
33496013366,reverse_number,"def reverse_number(num):
    rev = 0
    while num > 0:
        rem = num % 10
        rev = (rev * 10) + rem
        num = num // 10
    return rev",52
27856888784,int_to_binary,"def int_to_binary(n):
    if n == 0:
        return ""0""
    binary = """"
    while n > 0:
        binary = str(n % 2) + binary
        n = n // 2
    return binary",52
38960477970,count_unique_characters,"def count_unique_characters(s):
    unique_chars = {}
    for char in s:
        if char not in unique_chars:
            unique_chars[char] = 1
        else:
            unique_chars[char] += 1
    return len(unique_chars)",52
18874895008,dec_to_bin,"def dec_to_bin(n):
    if n == 0:
        return ""0""
    binary = """"
    while n > 0:
        binary = str(n % 2) + binary
        n = n // 2
    return binary",52
23777063573,int_to_binary,"def int_to_binary(num):
    binary = ''
    if num == 0:
        return '0'
    while num > 0:
        binary = str(num % 2) + binary
        num = num // 2
    return binary",52
12213807973,generate_binary_strings,"def generate_binary_strings(n):
    if n == 0:
        return [""""]
    sub_list = generate_binary_strings(n-1)
    return ['0'+s for s in sub_list] + ['1'+s for s in sub_list]",52
17490227553,find_max_recursive,"def find_max_recursive(lst):
    if len(lst) == 1:
        return lst[0]
    else:
        max_rest = find_max_recursive(lst[1:])
        return lst[0] if lst[0] > max_rest else max_rest",52
71430918182,count_Ways,"def count_Ways(n):
    if n <= 1:
        return n
    a, b = 1, 1
    for _ in range(n - 1):
        a, b = b, a + b
    return b",52
22886588135,find_third_max,"def find_third_max(nums):
    unique_nums = list(set(nums))
    if len(unique_nums) < 3:
        return max(unique_nums)
    unique_nums.remove(max(unique_nums))
    unique_nums.remove(max(unique_nums))
    return max(unique_nums)",52
37415554300,max_not_divisible,"def max_not_divisible(numbers, k):
    max_num = None
    for num in numbers:
        if num % k != 0:
            if max_num is None or num > max_num:
                max_num = num
    return max_num",52
21738493481,find_majority_element,"def find_majority_element(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    return candidate",52
37333567369,dec_to_bin,"def dec_to_bin(n):
    if n == 0:
        return '0'
    binary = ''
    while n > 0:
        binary = str(n % 2) + binary
        n = n // 2
    return binary",52
2469945528,count_Stairs,"def count_Stairs(n):
    if n <= 1:
        return n
    first, second = 1, 2
    for _ in range(2, n):
        first, second = second, first + second
    return second",52
35284790688,median_of_three,"def median_of_three(a, b, c):
    if a <= b <= c or c <= b <= a:
        return b
    elif b <= a <= c or c <= a <= b:
        return a
    else:
        return c",52
33773323329,countWays,"def countWays(n):
    if n <= 1:
        return n
    a, b = 1, 2
    for _ in range(2, n):
        a, b = b, a + b
    return b",52
34495226231,binary_to_decimal,"def binary_to_decimal(binary_list):
    decimal_list = []
    for binary in binary_list:
        decimal = 0
        for digit in binary:
            decimal = decimal*2 + int(digit)
        decimal_list.append(decimal)
    return decimal_list",52
42879053083,sum_greater_than_half_max,"def sum_greater_than_half_max(nums):
    max_num = max(nums)
    half_max = max_num / 2
    sum = 0
    for num in nums:
        if num > half_max:
            sum += num
    return sum",52
33624896019,count_word_occurrences,"def count_word_occurrences(sentences, word):
    word = word.lower()
    count = 0
    for sentence in sentences:
        for w in sentence.lower().split():
            if w == word:
                count += 1
    return count",52
30721264249,decimal_to_binary,"def decimal_to_binary(decimal):
    if decimal == 0:
        return ""0""
    binary = """"
    while decimal > 0:
        binary = str(decimal % 2) + binary
        decimal = decimal // 2
    return binary",52
73496585647,pascal_row,"def pascal_row(n):
    row = [1]
    for i in range(n):
        row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]
    return row",52
40056573406,is_rotation,"def is_rotation(s1: str, s2: str) -> bool:
    if len(s1) != len(s2):
        return False
    s1s1 = s1 + s1
    return s2 in s1s1",52
28398549275,count_unique_substrings,"def count_unique_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            substrings.add(s[i:j])
    return len(substrings)",52
71456061684,max_two_numbers,"def max_two_numbers(l):
    unique_numbers = list(set(l))
    if len(unique_numbers) < 2:
        return (unique_numbers[0], None)
    unique_numbers.sort()
    return (unique_numbers[-1], unique_numbers[-2])",52
10103698087,calculate_discounted_price,"def calculate_discounted_price(base_price, discount_percentage, min_price):
    discounted_price = base_price * (1 - discount_percentage / 100)
    if discounted_price < min_price:
        return min_price
    else:
        return discounted_price",52
75341248488,robot_paths,"def robot_paths(m: int, n: int) -> int:
    if m == 1 or n == 1:
        return 1
    return robot_paths(m - 1, n) + robot_paths(m, n - 1)",52
39853381322,find_max_recursive,"def find_max_recursive(lst):
    if len(lst) == 1:
        return lst[0]
    else:
        max_rest = find_max_recursive(lst[1:])
        return max_rest if max_rest > lst[0] else lst[0]",52
34941209951,num_good_pairs,"from collections import defaultdict

def num_good_pairs(nums):
    cnt = defaultdict(int)
    ans = 0
    for num in nums:
        if num in cnt:
            ans += cnt[num]
        cnt[num] += 1
    return ans",52
3657604007,decimal_to_binary,"def decimal_to_binary(num):
    if num == 0:
        return '0'
    binary = ''
    while num > 0:
        binary = str(num % 2) + binary
        num = num // 2
    return binary",52
27677903090,dec2bin,"def dec2bin(n):
    if n == 0:
        return '0'
    binary = ''
    while n > 0:
        binary = str(n % 2) + binary
        n = n // 2
    return binary",52
18013874830,remove_duplicate_words,"def remove_duplicate_words(s):
    words = s.split()
    seen = set()
    result = []
    for word in words:
        if word not in seen:
            seen.add(word)
            result.append(word)
    return ' '.join(result)",51
71956005051,find_median,"def find_median(a, b, c):
    if a <= b <= c or c <= b <= a:
        return b
    elif b <= a <= c or c <= a <= b:
        return a
    else:
        return c",51
2480296973,remove_duplicates_preserve_order,"def remove_duplicates_preserve_order(s: str) -> str:
    seen = set()
    result = []
    for char in s:
        if char not in seen:
            seen.add(char)
            result.append(char)
    return ''.join(result)",51
3766025058,fib_sequence,"def fib_sequence(n):
  fib_seq = [0, 1]
  while fib_seq[-1] + fib_seq[-2] <= n:
    fib_seq.append(fib_seq[-1] + fib_seq[-2])
  return fib_seq",51
31014629268,is_narcissistic,"def is_narcissistic(num):
    num_str = str(num)
    num_digits = len(num_str)
    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)
    return sum_of_powers == num",51
70285592026,fib_sum,"def fib_sum(n):
    fib = [0, 1]
    for i in range(2, n+1):
        fib.append(fib[i-1] + fib[i-2])
    return sum(fib[:n+1])",51
75147415208,count_substring_overlap,"def count_substring_overlap(s, sub):
    count = 0
    for i in range(len(s) - len(sub) + 1):
        if s[i:i+len(sub)] == sub:
            count += 1
    return count",51
3966948527,third_max,"def third_max(nums):
    unique_nums = list(set(nums))
    if len(unique_nums) < 3:
        return max(unique_nums)
    unique_nums.remove(max(unique_nums))
    unique_nums.remove(max(unique_nums))
    return max(unique_nums)",51
74502792487,odd_even_sort,"def odd_even_sort(lst):
    odd_lst = sorted([i for i in lst if i%2 != 0])
    even_lst = sorted([i for i in lst if i%2 == 0])
    return odd_lst + even_lst",51
33493484345,character_frequency,"def character_frequency(str1):
    dict = {}
    for n in str1:
        keys = dict.keys()
        if n in keys:
            dict[n] += 1
        else:
            dict[n] = 1
    return dict",51
40124891020,check_power_of_2,"def check_power_of_2(n):
    if n <= 0:
        return False
    while n != 1:
        if n % 2 != 0:
            return False
        n = n // 2
    return True",51
15432725410,count_pattern,"def count_pattern(string, pattern):
    count = start = 0
    while True:
        start = string.find(pattern, start) + 1
        if start > 0:
            count += 1
        else:
            return count",51
3677358545,most_frequent_char,"def most_frequent_char(s):
    count = {}
    for char in s:
        if char in count:
            count[char] += 1
        else:
            count[char] = 1
    return max(count, key=count.get)",51
29242446374,pascals_triangle_row,"def pascals_triangle_row(n):
    row = [1]
    for i in range(1, n + 1):
        row.append(row[i - 1] * (n - i + 1) // i)
    return row",51
40713252584,smallest_divisible,"from math import gcd

def lcm(a, b):
    return a * b // gcd(a, b)

def smallest_divisible(numbers):
    result = 1
    for number in numbers:
        result = lcm(result, number)
    return result",51
6773996575,find_max_depth,"def find_max_depth(lst):
    max_depth = 1
    for elem in lst:
        if isinstance(elem, list):
            depth = 1 + find_max_depth(elem)
            max_depth = max(max_depth, depth)
    return max_depth",51
44528019536,find_Third_Maximum,"def find_Third_Maximum(nums):
    nums = list(set(nums))
    if len(nums) < 3:
        return max(nums)
    else:
        for _ in range(2):
            nums.remove(max(nums))
        return max(nums)",51
73980179410,longest_word,"def longest_word(word_list):
    max_length = 0
    longest_word = ''
    for word in word_list:
        if len(word) > max_length:
            max_length = len(word)
            longest_word = word
    return longest_word",51
70157551462,remove_min_max,"def remove_min_max(lst):
    if len(lst) <= 2:
        return []
    min_val = min(lst)
    max_val = max(lst)
    return [x for x in lst if x != min_val and x != max_val]",51
14032340190,third_max,"def third_max(nums):
    unique_nums = list(set(nums))
    if len(unique_nums) < 3:
        return max(unique_nums)
    unique_nums.remove(max(unique_nums))
    unique_nums.remove(max(unique_nums))
    return max(unique_nums)",51
71241446849,digits_to_num,"def digits_to_num(digits):
    try:
        if all(isinstance(x, int) and x >= 0 for x in digits):
            return int(''.join(map(str, digits)))
        else:
            return None
    except:
        return None",51
37262625848,stone_game,"def stone_game(n: int) -> str:
    if n <= 3:
        return ""Player 1""
    elif n % 4 == 0:
        return ""Player 2""
    else:
        return ""Player 1""",51
37883728139,frequent_Character,"def frequent_Character(str):
    frequency = {}
    for char in str:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return max(frequency, key=frequency.get)",51
7595683989,smallest_divisor,"def smallest_divisor(num):
    if num == 1:
        return 1
    for i in range(2, int(num**0.5)+1):
        if num % i == 0:
            return i
    return num",51
9711880160,count_words_vowel,"def count_words_vowel(words):
    count = 0
    for word in words:
        if word[-1] in set(""aeiou"") and word[0] in set(""aeiou""):
            count += 1
    return count",51
14311280058,min_deletions,"def min_deletions(s: str) -> int:
    ans = 0
    prev = ''
    for char in s:
        if char == prev:
            ans += 1
        else:
            prev = char
    return ans",51
30149251821,char_frequency,"def char_frequency(str1):
    dict = {}
    for n in str1:
        keys = dict.keys()
        if n in keys:
            dict[n] += 1
        else:
            dict[n] = 1
    return dict",51
20170288111,separate_and_sort,"def separate_and_sort(mixed_list):
    int_list = sorted([i for i in mixed_list if isinstance(i, int)])
    str_list = sorted([i for i in mixed_list if isinstance(i, str)])
    return int_list, str_list",51
72623564965,calculate_vowels,"def calculate_vowels(s): 
    count = 0
    vowels = set(""aeiouAEIOU"") 
    for alphabet in s: 
        if alphabet in vowels: 
            count = count + 1
    return count",51
37652184234,pattern_count,"def pattern_count(text, pattern):
    count = start = 0
    while True:
        start = text.find(pattern, start) + 1
        if start > 0:
            count += 1
        else:
            return count",51
2389694147,find_second_largest,"def find_second_largest(nums):
    if len(nums) < 2:
        return None
    nums = list(set(nums))
    if len(nums) < 2:
        return None
    nums.remove(max(nums))
    return max(nums)",51
72817664597,array_intersection,"def array_intersection(arr1, arr2):
    intersection = []
    set1 = set(arr1)
    set2 = set(arr2)
    for num in set1:
        if num in set2:
            intersection.append(num)
    return intersection",51
21052262140,number_to_digits,"def number_to_digits(number):
    if number == 0:
        return [0]
    digits = []
    while number > 0:
        digits.append(number % 10)
        number //= 10
    return digits[::-1]",51
1151722366,convert_to_uppercase,"def convert_to_uppercase(s):
    result = """"
    for char in s:
        if 'a' <= char <= 'z':
            result += chr(ord(char) - 32)
        else:
            result += char
    return result",51
5748766967,max_Profit,"def max_Profit(prices):
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            profit += prices[i] - prices[i-1]
    return profit",51
74822693873,factorial_list,"def factorial_list(nums):
    def factorial(n):
        if n == 0 or n == 1:
            return 1
        else:
            return n * factorial(n-1)
    return [factorial(n) for n in nums]",51
75157622931,find_modes,"from collections import Counter

def find_modes(num_list):
    count = Counter(num_list)
    max_count = max(list(count.values()))
    mode_val = [num for num, freq in count.items() if freq == max_count]
    return mode_val",51
11384589431,count_greater_followers,"def count_greater_followers(nums):
  count = 0
  for i in range(len(nums)):
    for j in range(i+1, len(nums)):
      if nums[j] > nums[i]:
        count += 1
  return count",51
1281915040,climb_Stairs,"def climb_Stairs(n):
    a, b = 1, 2
    for _ in range(3, n + 1):
        a, b = b, a + b
    return b if n > 1 else n",51
12545645269,char_frequency,"def char_frequency(str1):
    dict = {}
    for n in str1:
        keys = dict.keys()
        if n in keys:
            dict[n] += 1
        else:
            dict[n] = 1
    return dict",51
29354725545,is_ugly,"def is_ugly(num):
    if num <= 0:
        return False
    for i in [2, 3, 5]:
        while num % i == 0:
            num /= i
    return num == 1",51
43710415626,smallestCommonMultiple,"from math import gcd

def lcm(a, b):
    return a * b // gcd(a, b)

def smallestCommonMultiple(numbers):
    result = 1
    for number in numbers:
        result = lcm(result, number)
    return result",51
25058381795,most_common_words,"from collections import Counter

def most_common_words(words, N):
    word_counts = Counter(words)
    most_common = word_counts.most_common(N)
    return sorted(most_common, key=lambda x: (-x[1], x[0]))",51
1694177496,get_lucas,"def get_lucas(n):
  if (n == 0):
    return 2
  if (n == 1):
    return 1
  return get_lucas(n - 1) + get_lucas(n - 2)",51
40558022374,count_vowels,"def count_vowels(s):
    vowels = 'aeiou'
    count = {vowel: 0 for vowel in vowels}
    for char in s:
        if char in vowels:
            count[char] += 1
    return count",51
25200505337,calculate_average,"def calculate_average(numbers):
    if len(numbers) <= 2:
        raise ValueError(""The list must have more than two numbers"")
    numbers.sort()
    trimmed = numbers[1:-1]
    return sum(trimmed) / len(trimmed)",51
13540832425,check_happy,"def check_happy(n):
    seen = set()
    while n not in seen:
        seen.add(n)
        n = sum(int(i)**2 for i in str(n))
        if n == 1:
            return True
    return False",51
38043551120,third_max,"def third_max(nums):
    unique_nums = list(set(nums))
    if len(unique_nums) < 3:
        return max(unique_nums)
    unique_nums.remove(max(unique_nums))
    unique_nums.remove(max(unique_nums))
    return max(unique_nums)",51
14118397456,numIdenticalPairs,"def numIdenticalPairs(nums):
    counter = 0
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[i] == nums[j]:
                counter += 1
    return counter",51
11936012579,is_strictly_ascending,"def is_strictly_ascending(lst):
    if len(lst) <= 1:
        return True
    for i in range(1, len(lst)):
        if lst[i] <= lst[i-1]:
            return False
    return True",51
15104415400,convert_to_uppercase,"def convert_to_uppercase(s):
    uppercase = """"
    for char in s:
        if 'a' <= char <= 'z':
            uppercase += chr(ord(char) - 32)
        else:
            uppercase += char
    return uppercase",51
42393126259,find_longest_string,"def find_longest_string(strings):
    if not strings:
        return None
    longest_string = strings[0]
    for string in strings:
        if len(string) > len(longest_string):
            longest_string = string
    return longest_string",51
30816481062,find_longest_word,"def find_longest_word(words):
    longest_word = """"
    max_length = 0
    for word in words:
        if len(word) > max_length:
            longest_word = word
            max_length = len(word)
    return longest_word",51
72102509109,unique_substrings,"def unique_substrings(s):
  unique_substrings = set()
  for i in range(len(s)):
    for j in range(i+1, len(s)+1):
      unique_substrings.add(s[i:j])
  return len(unique_substrings)",51
5970491470,distinct_substrings,"def distinct_substrings(string):
    substrings = set()
    for i in range(len(string)):
        for j in range(i + 1, len(string) + 1):
            substrings.add(string[i:j])
    return len(substrings)",51
41232320980,find_anagrams_in_dictionary,"def find_anagrams_in_dictionary(input_string, dictionary):
    sorted_input_string = sorted(input_string)
    anagrams = []
    for word in dictionary:
        if sorted(word) == sorted_input_string:
            anagrams.append(word)
    return anagrams",51
6873808991,isPerfectSquare,"def isPerfectSquare(num):
    if num < 0:
        return False
    i = num
    while i * i > num:
        i = (i + num // i) // 2
    return i * i == num",51
43814389691,to_upper,"def to_upper(s):
    res = """"
    for char in s:
        if 97 <= ord(char) <= 122:
            res += chr(ord(char)-32)
        else:
            res += char
    return res",51
71936559195,max_toys,"def max_toys(prices, k):
    prices.sort()
    count = 0
    for price in prices:
        if k >= price:
            k -= price
            count += 1
        else:
            break
    return count",51
41033645692,dec_to_binary,"def dec_to_binary(dec):
    binary_num = ''
    while dec != 0:
        rem = dec % 2
        binary_num = str(rem) + binary_num
        dec = int(dec / 2)
    return binary_num",51
37881320589,third_max,"def third_max(nums):
    unique_nums = list(set(nums))
    if len(unique_nums) < 3:
        return max(unique_nums)
    unique_nums.remove(max(unique_nums))
    unique_nums.remove(max(unique_nums))
    return max(unique_nums)",51
69995366716,multiplication_table,"def multiplication_table(n):
    result = []
    for i in range(1, n+1):
        row = []
        for j in range(1, n+1):
            row.append(i*j)
        result.append(row)
    return result",51
28740175571,count_perfect_squares,"import math

def count_perfect_squares(nums):
    perfect_squares = 0
    for num in nums:
        if math.isqrt(num) ** 2 == num:
            perfect_squares += 1
    return perfect_squares",51
34943404038,numIdenticalPairs,"def numIdenticalPairs(nums):
    count = 0
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[i] == nums[j]:
                count += 1
    return count",51
18888858507,findKthLargest,"def findKthLargest(nums, k):
    """"""
    :type nums: List[int]
    :type k: int
    :rtype: int
    """"""
    import heapq
    return heapq.nlargest(k, nums)[-1]",51
8408968340,find_most_frequent,"from collections import Counter

def find_most_frequent(nums):
    num_counts = Counter(nums)
    most_common = num_counts.most_common(1)
    if most_common:
        return most_common[0][0]
    else:
        return None",51
36877574758,get_lucas,"def get_lucas(n):
  if (n == 0):
    return 2
  if (n == 1):
    return 1
  return get_lucas(n - 1) + get_lucas(n - 2)",51
33759484748,find_max_value,"def find_max_value(lst, key):
    max_value = None
    for d in lst:
        if key in d:
            if max_value is None or d[key] > max_value:
                max_value = d[key]
    return max_value",51
7108222829,find_number_count,"def find_number_count(list1):
    count_dict = {}
    for num in list1:
        if num in count_dict:
            count_dict[num] += 1
        else:
            count_dict[num] = 1
    return count_dict",51
5649858528,remove_adjacent_duplicates,"def remove_adjacent_duplicates(s: str) -> str:
    stack = []
    for ch in s:
        if stack and stack[-1] == ch:
            stack.pop()
        else:
            stack.append(ch)
    return """".join(stack)",51
35844017275,most_frequent_words,"from collections import Counter

def most_frequent_words(words):
    word_counts = Counter(words)
    most_common = word_counts.most_common(1)
    if most_common:
        return most_common[0][0]
    else:
        return None",51
27191933300,can_form_string,"def can_form_string(s, string_list):
    if not s:
        return True

    for string in string_list:
        if s.startswith(string):
            if can_form_string(s[len(string):], string_list):
                return True

    return False",51
75136265865,count_Inversions,"def count_Inversions(arr):
    count = 0
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] > arr[j]:
                count += 1
    return count",51
73971051346,last_letter_capitalize,"def last_letter_capitalize(words):
    result = []
    for word in words:
        if len(word) > 0:
            result.append(word[:-1] + word[-1].upper())
        else:
            result.append(word)
    return result",51
71204865020,count_bst,"def count_bst(n):
    if n <= 1:
        return 1
    total = 0
    for i in range(n):
        total += count_bst(i) * count_bst(n-i-1)
    return total",51
30075146819,count_sublist,"def count_sublist(lst, sublist):
    count = 0
    sublen = len(sublist)
    for i in range(len(lst)):
        if lst[i:i+sublen] == sublist:
            count += 1
    return count",51
29970895910,to_binary,"def to_binary(n):
    if n == 0:
        return '0'
    binary = ''
    while n > 0:
        binary = str(n % 2) + binary
        n = n // 2
    return binary",51
29810583808,unique_permutations,"from collections import Counter
from math import factorial

def unique_permutations(s):
    counter = Counter(s)
    total_permutations = factorial(len(s))
    for count in counter.values():
        total_permutations //= factorial(count)
    return total_permutations",51
20121048178,square_root_list,"import math

def square_root_list(input_list):
    output_list = []
    for num in input_list:
        if num >= 0:
            output_list.append(math.sqrt(num))
        else:
            output_list.append(0)
    return output_list",51
20928141411,happy_number,"def happy_number(n):
    seen = set()
    while n not in seen:
        seen.add(n)
        n = sum(int(digit)**2 for digit in str(n))
        if n == 1:
            return True
    return False",51
8847771958,is_narcissistic,"def is_narcissistic(n):
    num_str = str(n)
    num_digits = len(num_str)
    sum_of_powers = sum([int(digit)**num_digits for digit in num_str])
    return sum_of_powers == n",51
36472191760,transpose_matrix,"def transpose_matrix(matrix):
    """"""
    Returns the transpose of a given matrix.
    """"""
    # Transpose the matrix by switching columns with rows
    transposed_matrix = [list(row) for row in zip(*matrix)]
    return transposed_matrix",51
32654032955,is_Prime,"def is_Prime(num):
    if num > 1:
        for i in range(2, num):
            if (num % i) == 0:
                return False
        else:
            return True
    else:
        return False",51
71552480184,find_frequency,"def find_frequency(str1):
    dict = {}
    for n in str1:
        keys = dict.keys()
        if n in keys:
            dict[n] += 1
        else:
            dict[n] = 1
    return dict",51
4107710754,remove_consecutive_duplicates,"def remove_consecutive_duplicates(s):
    if not s:
        return s
    result = [s[0]]
    for char in s[1:]:
        if char != result[-1]:
            result.append(char)
    return ''.join(result)",51
21374366618,word_frequency,"def word_frequency(s):
    word_list = s.split()
    frequency = {}
    for word in word_list:
        if word in frequency:
            frequency[word] += 1
        else:
            frequency[word] = 1
    return frequency",51
31158203299,create_dict,"def create_dict(keys, values, default=None):
    result = {}
    for i, key in enumerate(keys):
        if i < len(values):
            result[key] = values[i]
        else:
            result[key] = default
    return result",51
5258934531,substring_count,"def substring_count(text, substr):
    count = start = 0
    while True:
        start = text.find(substr, start) + 1
        if start > 0:
            count += 1
        else:
            return count",51
26622433654,max_Profit,"def max_Profit(prices):
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            profit += prices[i] - prices[i-1]
    return profit",51
73504027672,find_missing_and_repeated,"def find_missing_and_repeated(nums):
    numsSet = set(nums)
    duplicated = sum(nums) - sum(numsSet)
    missed = len(nums)*(len(nums)+1)//2 - sum(numsSet)
    return [duplicated, missed]",51
70941969114,find_max_profit,"def find_max_profit(prices):
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            profit += prices[i] - prices[i-1]
    return profit",51
38484085628,find_kth_largest,"import heapq as hq
def find_kth_largest(nums, k):
    hq.heapify(nums)
    for i in range(len(nums) - k):
        hq.heappop(nums)
    return hq.heappop(nums)",51
41725993041,char_frequency,"def char_frequency(str1):
    dict = {}
    for n in str1:
        keys = dict.keys()
        if n in keys:
            dict[n] += 1
        else:
            dict[n] = 1
    return dict",51
16042243395,capitalize_words,"def capitalize_words(s):
    return ' '.join(word.capitalize() for word in s.split())

print(capitalize_words(""i love python programming""))
print(capitalize_words(""the quick brown fox""))
print(capitalize_words(""jumped over the lazy dog""))",51
25125765174,smallest_diff,"def smallest_diff(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(len(arr) - 1):
        min_diff = min(min_diff, arr[i + 1] - arr[i])
    return min_diff",51
16255714364,find_two_numbers,"def find_two_numbers(lst, target):
    num_dict = {}
    for i, num in enumerate(lst):
        if target - num in num_dict:
            return [target - num, num]
        num_dict[num] = i
    return []",51
40791588167,check_prime,"def check_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True",51
39826556747,distinct_substrings,"def distinct_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            substrings.add(s[i:j])
    return len(substrings)",51
8941683027,find_longest_word,"def find_longest_word(words):
    longest_word = """"
    max_length = 0
    for word in words:
        if len(word) > max_length:
            max_length = len(word)
            longest_word = word
    return longest_word",51
4636652825,find_majority,"def find_majority(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    return candidate",51
8801640723,unique_substrings,"def unique_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            substrings.add(s[i:j])
    return len(substrings)",51
70495168488,count_pattern,"def count_pattern(s, pattern):
    count = start = 0
    while True:
        start = s.find(pattern, start) + 1
        if start > 0:
            count += 1
        else:
            return count",51
25873830661,find_longest_string,"def find_longest_string(strings):
    if not strings:
        return """"
    longest_string = strings[0]
    for string in strings:
        if len(string) > len(longest_string):
            longest_string = string
    return longest_string",50
12843517921,can_form_sequence,"def can_form_sequence(A):
    if not A:
        return False
    A.sort()
    n = max(A)
    for i in range(n):
        if A[i] != i + 1:
            return False
    return True",50
25786145613,is_hexadecimal,"def is_hexadecimal(s: str) -> bool:
    hexadecimal = '0123456789ABCDEF'
    for char in s:
        if char.upper() not in hexadecimal:
            return False
    return True",50
32402834234,max_element,"def max_element(nums):
    if len(nums) == 1:
        return nums[0]
    else:
        sub_max = max_element(nums[1:])
        return nums[0] if nums[0] > sub_max else sub_max",50
40599630136,is_power_of_two,"def is_power_of_two(n):
    if n <= 0:
        return False
    while n != 1:
        if n % 2 != 0:
            return False
        n = n // 2
    return True",50
73881315771,find_product_pair,"def find_product_pair(numbers, target_product):
    seen = set()
    for number in numbers:
        complement = target_product // number
        if complement in seen:
            return (complement, number)
        seen.add(number)
    return None",50
12544759493,string_indices,"def string_indices(lst):
    indices_dict = {}
    for i, string in enumerate(lst):
        if string in indices_dict:
            indices_dict[string].append(i)
        else:
            indices_dict[string] = [i]
    return indices_dict",50
28513811926,staircase,"def staircase(n):
    if n <= 1:
        return n
    first, second = 1, 2
    for _ in range(2, n):
        first, second = second, first + second
    return second",50
69869721367,is_strictly_increasing,"def is_strictly_increasing(lst):
    if len(lst) <= 1:
        return True
    for i in range(len(lst)-1):
        if lst[i] >= lst[i+1]:
            return False
    return True",50
12234118440,to_uppercase,"def to_uppercase(s):
    result = """"
    for char in s:
        if 'a' <= char <= 'z':
            result += chr(ord(char) - 32)
        else:
            result += char
    return result",50
38932634689,separateEvenOdd,"def separateEvenOdd(nums):
    even = []
    odd = []
    for i in nums:
        if i % 2 == 0:
            even.append(i)
        else:
            odd.append(i)
    return (even, odd)",50
33848030960,second_largest,"def second_largest(numbers):
    if len(numbers) < 2:
        return None
    numbers = list(set(numbers))
    if len(numbers) < 2:
        return None
    numbers.remove(max(numbers))
    return max(numbers)",50
43642091363,tuple_addition,"def tuple_addition(tup1, tup2):
  res = tuple(tuple(a + b for a, b in zip(tup1, tup2)) for tup1, tup2 in zip(tup1, tup2))
  return res",50
18395512678,is_power_of_four,"def is_power_of_four(num):
    if num <= 0:
        return False
    while num != 1:
        if num % 4 != 0:
            return False
        num = num / 4
    return True",50
25042264316,find_max,"def find_max(lst):
    if len(lst) == 1:
        return lst[0]
    else:
        max_rest = find_max(lst[1:])
        return lst[0] if lst[0] > max_rest else max_rest",50
23047306202,fibo_recursive,"def fibo_recursive(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibo_recursive(n-1) + fibo_recursive(n-2)",50
5809120231,find_duplicates,"def find_duplicates(nums):
    num_set = set()
    duplicates = []
    for num in nums:
        if num in num_set:
            duplicates.append(num)
        else:
            num_set.add(num)
    return sorted(list(set(duplicates)))",50
11170397931,group_anagrams,"from collections import defaultdict

def group_anagrams(strs):
    anagrams = defaultdict(list)
    for word in strs:
        sorted_word = tuple(sorted(word))
        anagrams[sorted_word].append(word)
    return list(anagrams.values())",50
32254361446,string_indices,"def string_indices(lst):
    indices_dict = {}
    for index, value in enumerate(lst):
        if value in indices_dict:
            indices_dict[value].append(index)
        else:
            indices_dict[value] = [index]
    return indices_dict",50
70304293784,find_second_largest,"def find_second_largest(lst):
    if len(lst) < 2:
        return None
    lst = list(set(lst))
    if len(lst) < 2:
        return None
    lst.sort()
    return lst[-2]",50
34602036451,contains_nearby_duplicate,"def contains_nearby_duplicate(nums, k):
    d = {}
    for i, num in enumerate(nums):
        if num in d and i - d[num] <= k:
            return True
        d[num] = i
    return False",50
18988560906,contains_duplicate,"def contains_duplicate(nums):
    if nums is None or nums == []:
        return False
        
    hash = set()
    for i in nums:
        if i in hash:
            return True
        else:
            hash.add(i)
    return False",50
32230088659,is_happy_number,"def is_happy_number(n):
    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = sum(int(digit)**2 for digit in str(n))
    return n == 1",50
44211850324,count_substring,"def count_substring(text, pattern):
    count = 0
    for i in range(len(text) - len(pattern) + 1):
        if text[i:i+len(pattern)] == pattern:
            count += 1
    return count",50
74091335704,max_product_three,"def max_product_three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3]) if len(nums) >= 3 else None",50
26306000594,dict_to_tuples,"def dict_to_tuples(dict_input):
    result = []
    for key, value in dict_input.items():
        if isinstance(value, list):
            result.append((key, value))
        else:
            result.append((key, value))
    return result",50
4314477459,contains_nearby_duplicate,"def contains_nearby_duplicate(nums, k):
    res = {}
    for index, item in enumerate(nums):
        if item in res and index - res[item] <= k:
            return True
        res[item] = index
    return False",50
75154713066,third_max,"def third_max(nums):
    nums_set = set(nums)
    if len(nums_set) < 3:
        return max(nums_set)
    nums_set.remove(max(nums_set))
    nums_set.remove(max(nums_set))
    return max(nums_set)",50
21288786287,to_uppercase,"def to_uppercase(s):
    uppercase = """"
    for char in s:
        if 'a' <= char <= 'z':
            uppercase += chr(ord(char) - 32)
        else:
            uppercase += char
    return uppercase",50
36542546163,find_max,"def find_max(nums):
    if len(nums) == 1:
        return nums[0]
    else:
        max_rest = find_max(nums[1:])
        return nums[0] if nums[0] > max_rest else max_rest",50
35192898829,count_characters,"def count_characters(input_string):
    character_count = {}
    for char in input_string:
        if char in character_count:
            character_count[char] += 1
        else:
            character_count[char] = 1
    return character_count",50
75157631251,staircase_climbing,"def staircase_climbing(n):
    if n <= 1:
        return n
    first, second = 0, 1
    for _ in range(n):
        first, second = second, first + second
    return second",50
73589207385,next_smallest_palindrome,"def next_smallest_palindrome(n):
    n += 1
    while not is_palindrome(n):
        n += 1
    return n

def is_palindrome(n):
    return str(n) == str(n)[::-1]",50
42590442753,binary_xor,"def binary_xor(lst):
    result = lst[0]
    for i in range(1, len(lst)):
        result = ''.join(str(int(a) ^ int(b)) for a, b in zip(result, lst[i]))
    return result",50
44268524102,frequency_count,"def frequency_count(list_data):
    frequency_dict = {}
    for item in list_data:
        if item in frequency_dict:
            frequency_dict[item] += 1
        else:
            frequency_dict[item] = 1
    return frequency_dict",50
4210651760,find_element_in_list_of_lists,"def find_element_in_list_of_lists(list_of_lists, element):
    for i, sub_list in enumerate(list_of_lists):
        if element in sub_list:
            return (i, sub_list.index(element))
    return (-1, -1)",50
7419276060,numTrees,"def numTrees(n):
    if n <= 1:
        return 1
    total = 0
    for i in range(n):
        total += numTrees(i) * numTrees(n - i - 1)
    return total",50
5544597474,find_max,"def find_max(numbers):
    if len(numbers) == 1:
        return numbers[0]
    else:
        max_rest = find_max(numbers[1:])
        return numbers[0] if numbers[0] > max_rest else max_rest",50
19605783605,string_count,"def string_count(str_list):
    str_count = {}
    for str in str_list:
        if str in str_count:
            str_count[str] += 1
        else:
            str_count[str] = 1
    return str_count",50
41728326261,isPerfectSquare,"def isPerfectSquare(num):
    if num < 0:
        return False
    i = 1
    while i*i <= num:
        if i*i == num:
            return True
        i += 1
    return False",50
39787911213,is_string_palindrome,"def is_string_palindrome(s: str) -> bool:
    newS = """"
    
    for let in s:
        if let.lower().isalnum():
            newS += let.lower()
    
    return newS == newS[::-1]",50
3553878873,is_power_of_two,"def is_power_of_two(n):
    if n == 0:
        return False
    while n != 1:
        if n % 2 != 0:
            return False
        n = n // 2
    return True",50
34745174097,count_good_pairs,"def count_good_pairs(nums):
    count = 0
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[i] == nums[j]:
                count += 1
    return count",50
2968717195,is_permutation,"def is_permutation(A):
    if len(A) == 0:
        return False
    N = len(A)
    for i in range(1,N+1):
        if i not in A:
            return False
    return True",50
73276803713,staircase,"def staircase(n):
    if n <= 1:
        return n
    first, second = 1, 2
    for _ in range(2, n):
        first, second = second, first + second
    return second",50
24258182641,stupid_sort,"import random

def stupid_sort(lst):
    while not is_sorted(lst):
        random.shuffle(lst)
    return lst

def is_sorted(lst):
    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))",50
28506254018,is_power_of_two,"def is_power_of_two(n):
    if n == 0:
        return False
    while n != 1:
        if n % 2 != 0:
            return False
        n = n // 2
    return True",50
6499856228,replace_even_odd,"def replace_even_odd(lst):
    new_lst = []
    for num in lst:
        if num % 2 == 0:
            new_lst.append(num**3)
        else:
            new_lst.append(num**2)
    return new_lst",50
2335909872,middle_char,"def middle_char(s):
    length = len(s)
    middle = length // 2
    if length % 2 == 0:
        return s[middle-1:middle+1]
    else:
        return s[middle]",50
27613226219,find_non_zero_indices,"def find_non_zero_indices(arr):
    indices = []
    for i in range(len(arr)):
        for j in range(len(arr[i])):
            if arr[i][j] != 0:
                indices.append((i, j))
    return indices",50
34444780260,is_power_of_two,"def is_power_of_two(n):
    if n <= 0:
        return False
    while n != 1:
        if n % 2 != 0:
            return False
        n = n / 2
    return True",50
11233444202,column_sums,"def column_sums(matrix):
    sums = []
    for i in range(len(matrix[0])):
        sum = 0
        for j in range(len(matrix)):
            sum += matrix[j][i]
        sums.append(sum)
    return sums",50
9277427296,count_rotations,"def count_rotations(arr):
    n = len(arr)
    for i in range(n):
        if arr[i] > arr[(i + 1) % n]:
            return (i + 1) % n
    return 0",50
32934574426,replace_spaces,"def replace_spaces(string_list):
    # Join the list into a string
    string = """".join(string_list)
    
    # Replace spaces with '%20'
    new_string = string.replace("" "", ""%20"")
    
    return new_string",50
39963840897,majority_element,"def majority_element(arr):
    count = 0
    candidate = None
    for num in arr:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    return candidate",50
37768870688,word_count,"def word_count(word_list):
    word_dict = {}
    for word in word_list:
        if word in word_dict:
            word_dict[word] += 1
        else:
            word_dict[word] = 1
    return word_dict",50
40622656618,max_number_of_coins,"def max_number_of_coins(piles):
    piles.sort(reverse=True)
    i,res=1,0
    while i<2*(len(piles)//3):
        res+=piles[i]
        i+=2
    return res",50
26719198235,max_in_list,"def max_in_list(num_list):
    if not num_list:
        return None
    max_num = num_list[0]
    for num in num_list:
        if num > max_num:
            max_num = num
    return max_num",50
17225659548,chkPrime,"def chkPrime(num):
    if num > 1:
        for i in range(2, num):
            if (num % i) == 0:
                return False
        else:
            return True
    else:
        return False",50
2135314986,majority_Element,"def majority_Element(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    return candidate",50
41342350566,contains_duplicate_within_k,"def contains_duplicate_within_k(nums, k):
    dic = {}
    for i, v in enumerate(nums):
        if v in dic and i - dic[v] <= k:
            return True
        dic[v] = i
    return False",50
12382555436,count_string_occurrences,"def count_string_occurrences(strings):
    string_counts = {}
    for string in strings:
        if string in string_counts:
            string_counts[string] += 1
        else:
            string_counts[string] = 1
    return string_counts",50
44044087187,max_unique,"from collections import Counter

def max_unique(s):
    count = Counter(s)
    max_unique = 0
    for letter, freq in count.items():
        if freq > 0:
            max_unique += 1
    return max_unique",50
9352744687,find_longest,"def find_longest(words):
    if not words:
        return None
    longest_word = words[0]
    for word in words:
        if len(word) > len(longest_word):
            longest_word = word
    return longest_word",50
23289936662,smallest_prime_factors,"def smallest_prime_factors(nums):
    def smallest_prime(n):
        for i in range(2, n+1):
            if n % i == 0:
                return i
    return [smallest_prime(n) for n in nums]",50
37170336520,most_frequent_elements,"def most_frequent_elements(lst):
    from collections import Counter
    count = Counter(lst)
    max_count = max(list(count.values()))
    result = [item for item, freq in count.items() if freq == max_count]
    return result",50
20855679738,majority_element,"def majority_element(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    return candidate",50
34148973319,is_valid_number,"import re

def is_valid_number(s):
    pattern = r'^[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?$'
    return bool(re.match(pattern, s.strip()))",50
44750213484,minAdjDiff,"def minAdjDiff(arr):
    arr.sort()
    min_diff = float('inf')
    for i in range(1, len(arr)):
        min_diff = min(min_diff, arr[i] - arr[i-1])
    return min_diff",50
42821917832,max_element,"def max_element(lst):
    if len(lst) == 1:
        return lst[0]
    else:
        max_rest = max_element(lst[1:])
        return lst[0] if lst[0] > max_rest else max_rest",50
31772919835,count_same_letter_substrings,"def count_same_letter_substrings(s):
    count = 0
    for i in range(len(s)):
        for j in range(i, len(s)):
            if s[i] == s[j]:
                count += 1
    return count",50
1390062156,count_characters,"def count_characters(input_string):
    character_counts = {}
    for char in input_string:
        if char in character_counts:
            character_counts[char] += 1
        else:
            character_counts[char] = 1
    return character_counts",50
10375840552,smallest_element_index,"def smallest_element_index(input_list):
    smallest_index = 0
    for i in range(1, len(input_list)):
        if input_list[i] < input_list[smallest_index]:
            smallest_index = i
    return smallest_index",50
75157623251,find_substring,"def find_substring(s, sub):
    count = 0
    for i in range(len(s) - len(sub) + 1):
        if s[i:i+len(sub)] == sub:
            count += 1
    return count",50
21687024676,maxProfit,"def maxProfit(prices):
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            profit += prices[i] - prices[i-1]
    return profit",50
37957762773,find_mode,"from collections import Counter

def find_mode(nums):
    counts = Counter(nums)
    max_count = max(counts.values())
    modes = [num for num, count in counts.items() if count == max_count]
    return min(modes)",50
41581551142,harmonic_series,"def harmonic_series(n): 
    if (n < 1): 
        return 0
    elif (n == 1): 
        return 1
    else: 
        return 1/n + harmonic_series(n-1)",50
71725281426,count_inversions,"def count_inversions(arr):
    count = 0
    for i in range(len(arr)):
        for j in range(i+1, len(arr)):
            if arr[i] > arr[j]:
                count += 1
    return count",50
5652398948,can_form_triangle,"def can_form_triangle(sides):
    sides.sort()
    a, b, c = sides
    if a + b > c and a + c > b and b + c > a:
        return True
    else:
        return False",50
72655514767,third_largest,"def third_largest(list1): 
    unique_list = list(set(list1))
    if len(unique_list) < 3:
        return ""List does not contain enough unique elements""
    unique_list.sort()
    return unique_list[-3]",50
32695280044,isPrefixOfWord,"def isPrefixOfWord(sentence: str, searchWord: str) -> int:
    words = sentence.split()
    for i, word in enumerate(words):
        if word.startswith(searchWord):
            return i + 1
    return -1",50
12256786421,next_palindrome,"def next_palindrome(n):
    n = n + 1
    while not is_palindrome(n):
        n += 1
    return n

def is_palindrome(n):
    return str(n) == str(n)[::-1]",50
3987519645,count_binary_strings,"def count_binary_strings(N):
    a = b = 1
    for i in range(2, N + 1):
        temp = a + b
        a = b
        b = temp
    return a + b",49
72517976825,find_modes,"from collections import Counter

def find_modes(nums):
    count = Counter(nums)
    max_freq = max(count.values())
    modes = [num for num, freq in count.items() if freq == max_freq]
    return sorted(modes)",49
14977501996,strange_sort_list,"def strange_sort_list(lst):
    sorted_list = []
    while lst:
        sorted_list.append(min(lst))
        lst.remove(min(lst))
        if lst:
            sorted_list.append(max(lst))
            lst.remove(max(lst))
    return sorted_list",49
7092448757,sum_of_multiples,"def sum_of_multiples(n):
    sum = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",49
7992515576,convert_list_to_int,"def convert_list_to_int(int_list):
    result = 0
    multiplier = 1
    for i in reversed(int_list):
        result += i * multiplier
        multiplier *= 10 ** len(str(i))
    return result",49
17978477027,num_of_ways,"def num_of_ways(m, n):
    if m == 1 or n == 1:
        return 1
    return num_of_ways(m-1, n) + num_of_ways(m, n-1)",49
70162181419,count_tuple_elements,"def count_tuple_elements(test_tup):
    res = {}
    for item in test_tup:
        if item in res:
            res[item] += 1
        else:
            res[item] = 1
    return(res)",49
43116772457,unique_pair_sum,"def unique_pair_sum(nums):
    total_sum = 0
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            total_sum += nums[i] + nums[j]
    return total_sum",49
16231592397,smallest_k,"from collections import Counter
def smallest_k(arr, k):
    count = Counter(arr)
    freq_elements = [key for key, value in count.items() if value >= k]
    return min(freq_elements) if freq_elements else -1",49
10235857182,cube_even_square_odd,"def cube_even_square_odd(numbers):
    result = []
    for number in numbers:
        if number % 2 == 0:
            result.append(number ** 3)
        else:
            result.append(number ** 2)
    return result",49
75246672025,reverse_number,"def reverse_number(num):
    rev_num = 0
    while num > 0:
        rev_num = rev_num * 10 + num % 10
        num = num // 10
    return rev_num",49
37880400609,is_harshad_number,"def is_harshad_number(num: int) -> bool:
    if num < 1:
        return False
    digit_sum = sum(int(digit) for digit in str(num))
    return num % digit_sum == 0",49
28779934236,is_valid_hex,"def is_valid_hex(hex_str):
    hex_digits = set(""0123456789abcdefABCDEF"")
    for char in hex_str:
        if char not in hex_digits:
            return False
    return True",49
73605358098,is_unique,"def is_unique(s: str) -> bool:
    # Using a set to store unique characters
    chars = set()
    for char in s:
        if char in chars:
            return False
        chars.add(char)
    return True",49
3603931803,reverse_number,"def reverse_number(n):
    reversed_num = 0
    while n > 0:
        reversed_num = reversed_num * 10 + n % 10
        n = n // 10
    return reversed_num",49
39957745354,isNarcissistic,"def isNarcissistic(num):
    digits = [int(d) for d in str(num)]
    power = len(digits)
    sum_of_digits = sum([d**power for d in digits])
    return sum_of_digits == num",49
38450968838,reverse_number,"def reverse_number(n):
    reversed_num = 0
    while n > 0:
        reversed_num = reversed_num * 10 + n % 10
        n = n // 10
    return reversed_num",49
36086171383,find_largest_digit,"def find_largest_digit(n):
    n = abs(n)
    max_digit = 0
    while n:
        max_digit = max(max_digit, n % 10)
        n //= 10
    return max_digit",49
23070856696,word_frequency,"def word_frequency(words):
    words = words.split()
    freq = {}
    for word in words:
        if word in freq:
            freq[word] += 1
        else:
            freq[word] = 1
    return freq",49
19336923943,power,"def power(x, n):
    if n == 0:
        return 1
    elif n > 0:
        return x * power(x, n-1)
    else:
        return 1/power(x, -n)",49
10565860838,sum_of_multiples,"def sum_of_multiples(n):
    sum = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",49
74738122740,string_char_count,"def string_char_count(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    return char_count",49
25886401069,find_Min_Num,"def find_Min_Num(arr,n) : 
    arr.sort() 
    num = arr[0] 
    for i in range(1,n) : 
        num = num * 10 + arr[i] 
    return num",49
26740291850,find_value_recursively,"def find_value_recursively(arr, value, index):
    if index >= len(arr):
        return False
    if arr[index] == value:
        return True
    return find_value_recursively(arr, value, index + 1)",49
16900899881,mode,"from collections import Counter

def mode(lst):
    counts = Counter(lst)
    max_count = max(list(counts.values()))
    mode_vals = [val for val, count in counts.items() if count == max_count]
    return mode_vals",49
17756417213,get_pascal_row,"def get_pascal_row(n):
    row = [1]
    for i in range(1, n + 1):
        row.append(row[i-1] * (n - i + 1) // i)
    return row",49
7066151468,word_frequency,"def word_frequency(sentence):
    words = sentence.split()
    frequency = {}
    for word in words:
        if word in frequency:
            frequency[word] += 1
        else:
            frequency[word] = 1
    return frequency",49
22525369487,find_modes,"from collections import Counter
def find_modes(nums):
    count = Counter(nums)
    max_freq = max(count.values())
    modes = [num for num, freq in count.items() if freq == max_freq]
    return sorted(modes)",49
14851694604,count_unique_substrings,"def count_unique_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)",49
3779342041,product_of_evens,"def product_of_evens(nums):
    product = 1
    for num in nums:
        if num % 2 == 0:
            product *= num
    if product == 1:
        return 1
    return product",49
73980086930,find_Min_Num,"def find_Min_Num(arr,n) : 
    arr.sort() 
    num = arr[0] 
    for i in range(1,n) : 
        num = num * 10 + arr[i] 
    return num",49
72655522767,triangle_area,"import math

def triangle_area(a, b, c):
    s = (a + b + c) / 2
    return math.sqrt(s * (s - a) * (s - b) * (s - c))",49
34626097184,find_next_palindrome,"def find_next_palindrome(n):
    n += 1
    while not is_palindrome(n):
        n += 1
    return n

def is_palindrome(n):
    return str(n) == str(n)[::-1]",49
12664215480,check_valid_pins,"def check_valid_pins(pins):
    for pin in pins:
        if not pin[0].isupper() or not all(c.isupper() or c.isdigit() for c in pin[1:]):
            return False
    return True",49
32525909098,find_substring,"def find_substring(str1, substr):
    i = 0
    while i < len(str1):
        if str1[i:i+len(substr)] == substr:
            return i
        i += 1
    return -1",49
32837004627,convert_dates,"from datetime import datetime

def convert_dates(dates):
    converted_dates = []
    for date in dates:
        converted_dates.append(datetime.strptime(date, '%Y-%m-%d').strftime('%d/%m/%Y'))
    return converted_dates",49
28119674580,sort_odd_numbers,"def sort_odd_numbers(arr):
    odds = sorted((x for x in arr if x % 2 != 0), reverse=True)
    return [x if x % 2 == 0 else odds.pop() for x in arr]",49
14597480178,duplicate_count,"def duplicate_count(text):
    text = text.lower()
    seen = set()
    duplicates = set()
    for char in text:
        if char in seen:
            duplicates.add(char)
        seen.add(char)
    return len(duplicates)",49
5812213002,ways_to_reach,"def ways_to_reach(m, n):
    if m == 1 or n == 1:
        return 1
    return ways_to_reach(m-1, n) + ways_to_reach(m, n-1)",49
42097650644,word_frequency,"def word_frequency(sentence):
    words = sentence.split()
    frequency = {}
    for word in words:
        if word in frequency:
            frequency[word] += 1
        else:
            frequency[word] = 1
    return frequency",49
73931259799,max_common_points,"def max_common_points(list1, list2):
    if len(list1) != len(list2):
        return 0
    return sum([1 for i in range(len(list1)) if list1[i] == list2[i]])",49
8998438279,find_middle_element,"def find_middle_element(lst):
    n = len(lst)
    mid = n // 2
    if n % 2 == 0:
        return lst[mid-1:mid+1]
    else:
        return lst[mid]",49
41957612231,find_mode,"def find_mode(numbers):
    from collections import Counter
    count = Counter(numbers)
    max_count = max(count.values())
    mode = [num for num, freq in count.items() if freq == max_count]
    return sorted(mode)",49
70399022829,sum_of_multiples,"def sum_of_multiples(n):
    sum = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",49
11491122479,find_max_min_sum,"def find_max_min_sum(A):
    mx = mn = A[0]
    for ele in A:
        if ele>mx:
            mx = ele
        if ele<mn:
            mn = ele
    return mx + mn",49
14728196587,reverse_and_uppercase,"def reverse_and_uppercase(lst):
    result = []
    for elem in lst:
        if not isinstance(elem, str):
            return ""Invalid input. All elements must be strings.""
        result.append(elem[::-1].upper())
    return result",49
35602787597,prime_number,"def prime_number(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5)+1):
        if n % i == 0:
            return False
    return True",49
37456868664,unique_char_count,"def unique_char_count(s):
    char_count = {}
    for ch in s:
        if ch in char_count:
            char_count[ch] += 1
        else:
            char_count[ch] = 1
    return char_count",49
1537906051,find_next_palindrome,"def find_next_palindrome(n):
    n += 1
    while not is_palindrome(n):
        n += 1
    return n

def is_palindrome(n):
    return str(n) == str(n)[::-1]",49
34627033304,convert_to_reduced_form,"def convert_to_reduced_form(arr, n):
    set_arr = sorted(arr)
    map = {}
    for i in range(n):
        map[set_arr[i]] = i
    return [map[i] for i in arr]",49
26115648492,count_unique_substrings,"def count_unique_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)",49
34424958468,is_valid_number,"def is_valid_number(s):
    try:
        if s.lower().replace('.', '', 1).replace('e', '', 1).isdigit():
            float(s)
            return True
    except ValueError:
        return False
    return False",49
37464556369,longest_string,"def longest_string(strings):
    if not strings:
        return None
    longest_str = strings[0]
    for string in strings:
        if len(string) > len(longest_str):
            longest_str = string
    return longest_str",49
1703342803,find_modes,"from collections import Counter

def find_modes(arr):
    count = Counter(arr)
    max_count = max(count.values())
    modes = [num for num, freq in count.items() if freq == max_count]
    return sorted(modes)",49
25231917437,find_second_largest,"def find_second_largest(numbers):
    if (len(numbers)<2):
        return None
    numbers = list(set(numbers))
    if (len(numbers)<2):
        return None
    numbers.remove(max(numbers))
    return max(numbers)",49
73388294986,unique_chars,"def unique_chars(s):
    unique_chars = 0
    char_set = set()
    for char in s:
        if char not in char_set:
            unique_chars += 1
            char_set.add(char)
    return unique_chars",49
39856630970,chess_board,"def chess_board(square):
    return 2 ** (square - 1)

def total_grains():
    total = 0
    for i in range(1, 65):
        total += chess_board(i)
    return total",49
2262427650,third_smallest,"def third_smallest(numbers):
    if len(numbers) < 3:
        return None
    numbers = list(set(numbers))
    if len(numbers) < 3:
        return None
    numbers.sort()
    return numbers[2]",49
27867519436,sum_of_multiples,"def sum_of_multiples(number):
    sum = 0
    for i in range(1, number):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",49
30799575099,encode_message,"def encode_message(message):
    encoded_message = """"
    for char in message:
        if char.isalpha() and char.islower():
            encoded_message += str(ord(char) - 96) + "" ""
    return encoded_message.strip()",49
37872413309,pattern_count,"def pattern_count(text, pattern):
    count = 0
    for i in range(len(text) - len(pattern) + 1):
        if text[i:i+len(pattern)] == pattern:
            count += 1
    return count",49
25910173903,fibonacci,"def fibonacci(n: int) -> int:
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)",49
25763701448,pattern_count,"def pattern_count(text, pattern):
    count = 0
    for i in range(len(text) - len(pattern) + 1):
        if text[i:i+len(pattern)] == pattern:
            count += 1
    return count",49
29781746773,second_largest,"def second_largest(numbers):
    max_num = max(numbers)
    second_max = float('-inf')
    for num in numbers:
        if num > second_max and num < max_num:
            second_max = num
    return second_max",49
37382011135,nearest_power_of_2,"def nearest_power_of_2(n):
    power = 1
    while power <= n:
        next_power = power * 2
        if next_power > n:
            return power
        power = next_power
    return power",49
21696179790,count_integers,"def count_integers(nums):
    count_dict = {}
    for num in nums:
        if num in count_dict:
            count_dict[num] += 1
        else:
            count_dict[num] = 1
    return count_dict",49
17563693784,count_vowels,"def count_vowels(s: str) -> int:
    vowels = ""aeiouAEIOU""
    count = 0
    for char in s:
        if char in vowels:
            count += 1
    return count",49
70074612360,most_frequent_character,"from collections import Counter

def most_frequent_character(s: str) -> str:
    counter = Counter(s)
    max_count = max(counter.values())
    for char in s:
        if counter[char] == max_count:
            return char",49
73142241071,fibonacci_memo,"from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci_memo(n):
    if n < 2:
        return n
    return fibonacci_memo(n-1) + fibonacci_memo(n-2)",49
28484032524,factorial_digit_sum,"import math

def factorial_digit_sum(n):
    factorial = math.factorial(n)
    digit_sum = 0
    while factorial:
        digit_sum += factorial % 10
        factorial //= 10
    return digit_sum",49
41713860202,reverse_digits,"def reverse_digits(n):
    rev_num = 0
    while n > 0:
        rev_num = rev_num * 10 + n % 10
        n = n // 10
    return rev_num",49
33725531561,word_frequency,"def word_frequency(s):
    words = s.split()
    frequency = {}
    for word in words:
        if word in frequency:
            frequency[word] += 1
        else:
            frequency[word] = 1
    return frequency",49
14817715258,count_frequencies,"def count_frequencies(nums):
    freq_dict = {}
    for num in nums:
        if num in freq_dict:
            freq_dict[num] += 1
        else:
            freq_dict[num] = 1
    return freq_dict",49
32720631330,reverse_number,"def reverse_number(num):
    reversed_num = 0
    while num > 0:
        reversed_num = reversed_num * 10 + num % 10
        num = num // 10
    return reversed_num",49
30842563596,find_next_palindrome,"def find_next_palindrome(num):
    num += 1
    while not is_palindrome(num):
        num += 1
    return num

def is_palindrome(num):
    return str(num) == str(num)[::-1]",49
72916162264,find_element_positions,"def find_element_positions(arr, element):
    count = 0
    positions = []
    for i, e in enumerate(arr):
        if e == element:
            count += 1
            positions.append(i)
    return count, positions",49
2803810271,count_unique_substrings,"def count_unique_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)",49
30092814691,find_fibonacci,"def find_fibonacci(n):
    fibonacci = [0]
    a, b = 0, 1
    while b < n:
        fibonacci.append(b)
        a, b = b, a + b
    return fibonacci",49
12817787968,countPattern,"def countPattern(string, pattern):
    count = 0
    for i in range(len(string) - len(pattern) + 1):
        if string[i:i+len(pattern)] == pattern:
            count += 1
    return count",49
1764617842,contains_zero,"def contains_zero(nums):
    if len(nums) < 3:
        return False
    for i in range(1, len(nums) - 1):
        if nums[i] == 0:
            return True
    return False",49
21635632581,largest_duplicate,"def largest_duplicate(input_list):
    from collections import Counter
    c = Counter(input_list)
    return max([i for i in c if c[i]>1]) if any(i for i in c if c[i]>1) else None",49
30974218324,fibonacci,"def fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1 or n == 2:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)",49
72462677748,all_substrings,"def all_substrings(s):
    substrings = ['']
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            substrings.append(s[i:j])
    return substrings",49
1452713902,decimal_to_binary,"def decimal_to_binary(decimal_number):
    binary_number = ''
    while decimal_number > 0:
        binary_number = str(decimal_number % 2) + binary_number
        decimal_number = decimal_number // 2
    return binary_number",49
74067267994,next_Power_of_2,"def next_Power_of_2(n): 
    if n and not(n & (n - 1)): 
        return n 
    power = 1
    while power < n:
        power <<= 1
    return power",49
70538850297,sum_of_multiples,"def sum_of_multiples(n):
    sum = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",49
26956333342,word_frequency,"def word_frequency(string):
    words = string.split()
    freq = {}
    for word in words:
        if word in freq:
            freq[word] += 1
        else:
            freq[word] = 1
    return freq",49
8169698890,count_Trailing_Zeros,"def count_Trailing_Zeros(n): 
    count = 0
    while (n > 0 and n % 2 == 0): 
        count += 1
        n = n // 2
    return count",49
70961184511,find_next_palindrome,"def find_next_palindrome(num):
    num += 1
    while not is_palindrome(num):
        num += 1
    return num

def is_palindrome(num):
    return str(num) == str(num)[::-1]",49
24836372201,most_repeated_word,"from collections import Counter

def most_repeated_word(sentence):
    word_list = sentence.split()
    word_counts = Counter(word_list)
    most_common_word, _ = word_counts.most_common(1)[0]
    return most_common_word",49
26753274806,smallest_divisible,"from math import gcd
from functools import reduce

def smallest_divisible(n):
    def lcm(a, b):
        return a * b // gcd(a, b)
    return reduce(lcm, range(1, n + 1))",49
12559301625,is_hexadecimal,"def is_hexadecimal(s):
    hex_digits = set(""0123456789abcdefABCDEF"")
    for char in s:
        if not (char in hex_digits):
            return False
    return True",48
43329371838,string_freq,"def string_freq(lst):
    freq_dict = {}
    for item in lst:
        if item in freq_dict:
            freq_dict[item] += 1
        else:
            freq_dict[item] = 1
    return freq_dict",48
38385562921,interleave_lists,"def interleave_lists(list1, list2):
    interleaved_list = []
    for i in range(len(list1)):
        interleaved_list.append(list1[i])
        interleaved_list.append(list2[i])
    return interleaved_list",48
33495639456,count_chars,"def count_chars(s):
    char_dict = {}
    for char in s:
        if char in char_dict:
            char_dict[char] += 1
        else:
            char_dict[char] = 1
    return char_dict",48
71373057967,unique_substrings,"def unique_substrings(s):
    unique_subs = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            unique_subs.add(s[i:j])
    return len(unique_subs)",48
70194756908,word_count,"def word_count(words):
    word_dict = {}
    for word in words:
        if word in word_dict:
            word_dict[word] += 1
        else:
            word_dict[word] = 1
    return word_dict",48
5868880492,rotate,"def rotate(nums, k):
    if len(nums) == 0 or len(nums) == k: return nums
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]
    return nums",48
4568279427,unique_substrings,"def unique_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)",48
37651487414,character_count,"def character_count(s):
    count_dict = {}
    for char in s:
        if char in count_dict:
            count_dict[char] += 1
        else:
            count_dict[char] = 1
    return count_dict",48
72929299466,find_intersect,"def find_intersect(list1, list2):
    intersecting_elements = []
    for i in list1:
        if i in list2 and i not in intersecting_elements:
            intersecting_elements.append(i)
    return intersecting_elements",48
12955547024,total_volume,"def calculate_volume(length, width, height):
    return length * width * height

def total_volume(prism_dimensions):
    total = 0
    for dimensions in prism_dimensions:
        total += calculate_volume(*dimensions)
    return total",48
24484432476,distinct_substrings,"def distinct_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)",48
28814888562,construct_frequency,"def construct_frequency(s: str) -> dict:
    frequency = {}
    for char in s:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return frequency",48
23661386144,can_form_triangle,"def can_form_triangle(A):
    A = sorted(A)
    for idx in range(0, len(A)-2):
        if A[idx]+A[idx+1] > A[idx+2]:
            return True
    return False",48
43632282747,find_smallest_divisible,"from math import gcd

def find_smallest_divisible(n):
    result = 1
    for i in range(1, n + 1):
        result = (result * i)//gcd(result, i)
    return result",48
36744273864,count_elements,"def count_elements(nums):
    count_dict = {}
    for num in nums:
        if num in count_dict:
            count_dict[num] += 1
        else:
            count_dict[num] = 1
    return count_dict",48
9565124381,count_elements,"def count_elements(lst):
    count_dict = {}
    for element in lst:
        if element in count_dict:
            count_dict[element] += 1
        else:
            count_dict[element] = 1
    return count_dict",48
30980456599,count_digits,"def count_digits(number):
    if number == 0:
        return 1
    count = 0
    while number > 0:
        number = number // 10
        count += 1
    return count",48
17481901739,flatten_list,"def flatten_list(nested_list):
    flat_list = []
    for i in nested_list:
        if isinstance(i, list):
            flat_list.extend(flatten_list(i))
        else:
            flat_list.append(i)
    return flat_list",48
21874492068,character_count,"def character_count(string):
    count_dict = {}
    for char in string:
        if char in count_dict:
            count_dict[char] += 1
        else:
            count_dict[char] = 1
    return count_dict",48
4602088543,count_string,"def count_string(lst):
    count_dict = {}
    for i in lst:
        if i in count_dict:
            count_dict[i] += 1
        else:
            count_dict[i] = 1
    return count_dict",48
26308948731,flatten_list,"def flatten_list(nested_list):
    flattened_list = []
    for element in nested_list:
        if isinstance(element, list):
            flattened_list.extend(flatten_list(element))
        else:
            flattened_list.append(element)
    return flattened_list",48
22111197334,count_chars,"def count_chars(string):
    char_count = {}
    for char in string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    return char_count",48
37022539776,highest_product_three_elements,"def highest_product_three_elements(arr):
    arr.sort()
    n = len(arr)
    return max(arr[0]*arr[1]*arr[n-1], arr[n-3]*arr[n-2]*arr[n-1])",48
17205420175,string_count,"def string_count(strings):
    string_dict = {}
    for string in strings:
        if string in string_dict:
            string_dict[string] += 1
        else:
            string_dict[string] = 1
    return string_dict",48
32435168284,count_characters,"def count_characters(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    return char_count",48
18888667517,k_frequent_elements,"from collections import Counter

def k_frequent_elements(nums, k):
    freq = Counter(nums)
    result = list(dict(sorted(freq.items(), key=lambda item: item[1], reverse=True)).keys())
    return result[:k]",48
44173664018,remove_consecutive_duplicates,"def remove_consecutive_duplicates(s):
    if not s:
        return ''
    stack = []
    for char in s:
        if not stack or stack[-1] != char:
            stack.append(char)
    return ''.join(stack)",48
71439465270,count_prime_hex_digits,"def count_prime_hex_digits(hex_str):
    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}
    return sum(1 for char in hex_str if char in prime_hex_digits)",48
14764896710,min_unique,"def min_unique(arr):
    s = set()
    res = 0
    for i in arr:
        while i in s:
            res += 1
            i += 1
        s.add(i)
    return res",48
42573030614,fib_seq,"def fib_seq(n):
    fib_list = [0, 1]
    while len(fib_list) < n:
        fib_list.append(fib_list[-1] + fib_list[-2])
    return fib_list[:n]",48
28745370797,frequency_dict,"def frequency_dict(lst):
    freq_dict = {}
    for i in lst:
        if i in freq_dict:
            freq_dict[i] += 1
        else:
            freq_dict[i] = 1
    return freq_dict",48
34944051212,largest_divisible_number,"def largest_divisible_number(arr, target, divisor):
  valid_numbers = [num for num in arr if num < target and num % divisor == 0]
  if valid_numbers:
    return max(valid_numbers)
  return -1",48
2220256427,distinct_substrings,"def distinct_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)",48
41166227710,sum_multiples,"def sum_multiples(n):
    total = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            total += i
    return total",48
19710126529,string_count,"def string_count(strings):
    count_dict = {}
    for s in strings:
        if s in count_dict:
            count_dict[s] += 1
        else:
            count_dict[s] = 1
    return count_dict",48
13186063132,count_characters,"def count_characters(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    return char_count",48
27209590593,character_count,"def character_count(s: str) -> dict:
    d = {}
    for c in s:
        if c in d:
            d[c] += 1
        else:
            d[c] = 1
    return d",48
8629622288,josephus,"def josephus(n, k):
    if n == 1:
        return 1
    else:
        return (josephus(n - 1, k) + k - 1) % n + 1",48
28552718146,is_valid_float,"import re

def is_valid_float(s):
    pattern = r'^[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?$'
    return bool(re.match(pattern, s))",48
2338410211,smallest_absent_positive,"def smallest_absent_positive(arr):
    arr = set(filter(lambda x: x > 0, arr))
    i = 1
    while True:
        if i not in arr:
            return i
        i += 1",48
10868758257,sum_multiples,"def sum_multiples(n):
    sum = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",48
70784987864,count_digit,"def count_digit(n, digit):
    count = 0
    while n > 0:
        if n % 10 == digit:
            count += 1
        n = n // 10
    return count",48
35129052563,is_palindrome_ignoring_case_space_punctuation,"import string

def is_palindrome_ignoring_case_space_punctuation(s):
    s = s.lower()
    s = s.translate(str.maketrans('', '', string.punctuation + ' '))
    return s == s[::-1]",48
18738731058,count_special_chars,"import string

def count_special_chars(str1):
    count = 0
    for char in str1:
        if char not in string.ascii_letters and char not in string.digits:
            count += 1
    return count",48
22787139857,is_Power,"def is_Power(a, b):
    if a == 1:
        return True
    if a < 1 or (a % b != 0):
        return False
    return is_Power(a/b, b)",48
14144090856,josephus,"def josephus(n, k):
    if n == 1:
        return 1
    else:
        return (josephus(n - 1, k) + k - 1) % n + 1",48
15170622593,smallest_difference,"def smallest_difference(a, b, c):
    diff1 = abs(a - b)
    diff2 = abs(b - c)
    diff3 = abs(a - c)
    return min(diff1, diff2, diff3)",48
73382624757,fibonacci_sequence,"def fibonacci_sequence(n):
    fib_sequence = [0, 1]
    while len(fib_sequence) < n:
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
    return fib_sequence[:n]",48
19498426399,find_missing_numbers,"def find_missing_numbers(nums):
    result = []
    length = len(nums)
    count = set(nums)
    for i in range(1,length+1):
        if i not in count:
            result.append(i)
    return result",48
20789579921,count_elements,"def count_elements(arr):
    count_dict = {}
    for num in arr:
        if num in count_dict:
            count_dict[num] += 1
        else:
            count_dict[num] = 1
    return count_dict",48
23509003644,fib_sequence,"def fib_sequence(n):
    fib_series = [0, 1]
    while len(fib_series) < n:
        fib_series.append(fib_series[-1] + fib_series[-2])
    return fib_series[:n]",48
8145371357,fibonacci_sequence,"def fibonacci_sequence(n):
    fib_sequence = [0, 1]
    while len(fib_sequence) < n:
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
    return fib_sequence[:n]",48
37381984235,find_lowest_missing,"def find_lowest_missing(nums):
    nums = set(filter(lambda x: x > 0, nums))
    i = 1
    while True:
        if i not in nums:
            return i
        i += 1",48
12161187034,fibonacci_sequence,"def fibonacci_sequence(n):
    fib_sequence = [0, 1]
    while len(fib_sequence) < n:
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
    return fib_sequence[:n]",48
34112754920,transactions_result,"from collections import defaultdict

def transactions_result(transactions):
    balances = defaultdict(int)

    for name, amount in transactions:
        balances[name] += amount

    return sorted(balances.items(), key=lambda x: x[1])",48
12491730614,count_frequency,"def count_frequency(lst):
    freq_dict = {}
    for num in lst:
        if num in freq_dict:
            freq_dict[num] += 1
        else:
            freq_dict[num] = 1
    return freq_dict",48
15645288786,fibonacci_sequence,"def fibonacci_sequence(n):
    fib_sequence = [0, 1]
    while len(fib_sequence) < n:
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
    return fib_sequence[:n]",48
21672648490,count_elements,"def count_elements(lst):
    element_count = {}
    for element in lst:
        if element in element_count:
            element_count[element] += 1
        else:
            element_count[element] = 1
    return element_count",48
38138552731,sum_multiples,"def sum_multiples(n):
    sum = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",48
23703944753,replace_element,"def replace_element(matrix, target, replacement):
    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            if matrix[i][j] == target:
                matrix[i][j] = replacement
    return matrix",48
8676620407,fib_seq,"def fib_seq(n):
    fib_list = [0, 1]
    while len(fib_list) < n:
        fib_list.append(fib_list[-1] + fib_list[-2])
    return fib_list[:n]",48
42864724339,lucky_straight,"def lucky_straight(s):
    mid = len(s) // 2
    left = sum(int(num) for num in s[:mid])
    right = sum(int(num) for num in s[mid:])
    return left == right",48
74960771065,add_matrices,"def add_matrices(mat1, mat2):
    result = [[mat1[i][j] + mat2[i][j] for j in range(len(mat1[0]))] for i in range(len(mat1))]
    return result",48
41650449503,count_digit,"def count_digit(number, digit):
    count = 0
    while number > 0:
        if number % 10 == digit:
            count += 1
        number = number // 10
    return count",48
15505347152,count_unique_pairs,"from collections import Counter

def count_unique_pairs(nums):
    counter = Counter(nums)
    result = 0
    for value in counter.values():
        result += value * (value - 1) // 2
    return result",48
23775219901,max_k_sum_pairs,"from collections import Counter

def max_k_sum_pairs(nums, k):
    d = Counter(nums)
    c = 0
    for n in d:
        c += min(d[n], d[k-n])
    return c//2",48
479740804,count_characters,"def count_characters(string):
    char_count = {}
    for char in string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    return char_count",48
38003568411,find_power_of_two,"def find_power_of_two(n):
    power = 1
    while power <= n:
        next_power = power * 2
        if next_power > n:
            return power
        power = next_power
    return power",48
3553591043,sum_multiples,"def sum_multiples(n):
    sum = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",48
34085063216,binary_to_decimal,"def binary_to_decimal(binary_str):
    decimal = 0
    for i in range(len(binary_str)):
        decimal += int(binary_str[i]) * (2 ** (len(binary_str) - i - 1))
    return decimal",48
26741061190,segregate_even_odd,"def segregate_even_odd(nums):
    even = [num for num in nums if num % 2 == 0]
    odd = [num for num in nums if num % 2 != 0]
    return even + odd",48
39396446090,count_characters,"def count_characters(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    return char_count",48
26517856893,string_permutations,"from itertools import permutations

def string_permutations(s):
    # Generate all permutations of the string
    perms = [''.join(p) for p in permutations(s)]
    # Remove duplicates and return
    return sorted(set(perms))",48
70135359820,distinct_substrings,"def distinct_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)",48
14591716956,count_characters,"def count_characters(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    return char_count",48
10946215888,sum_of_perfect_squares,"def sum_of_perfect_squares(lst):
    def is_perfect_square(n):
        return int(n ** 0.5) ** 2 == n

    return sum(x for x in lst if is_perfect_square(x))",48
21455559726,next_palindrome,"def next_palindrome(n):
    n += 1
    while not is_palindrome(n):
        n += 1
    return n

def is_palindrome(n):
    return str(n) == str(n)[::-1]",48
18074126303,character_count,"def character_count(string):
    count_dict = {}
    for char in string:
        if char in count_dict:
            count_dict[char] += 1
        else:
            count_dict[char] = 1
    return count_dict",48
2512842138,adjacent_max_product,"def adjacent_max_product(numbers):
    max_product = float('-inf')
    for i in range(len(numbers) - 1):
        max_product = max(max_product, numbers[i] * numbers[i + 1])
    return max_product",48
70730945276,sum_multiples,"def sum_multiples(n):
    sum = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",48
29252118724,max_value_by_key,"def max_value_by_key(lst, key):
    max_value = float('-inf')
    for dictionary in lst:
        if dictionary.get(key) is not None:
            max_value = max(max_value, dictionary[key])
    return max_value",48
20047922932,word_count,"def word_count(words):
    word_dict = {}
    for word in words:
        if word in word_dict:
            word_dict[word] += 1
        else:
            word_dict[word] = 1
    return word_dict",48
71535696429,intersection_str,"def intersection_str(list1, list2):
    common_elements = []
    for i in list1:
        if i in list2:
            common_elements.append(str(i))
            list2.remove(i)
    return ''.join(common_elements)",48
74017753886,remove_duplicates_ignore_case,"def remove_duplicates_ignore_case(strings):
    unique_strings = set()
    result = []
    for string in strings:
        if string.lower() not in unique_strings:
            unique_strings.add(string.lower())
            result.append(string)
    return result",48
3785497271,sum_multiples,"def sum_multiples(n):
    sum = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",48
44878063614,character_count,"def character_count(s):
    char_dict = {}
    for char in s:
        if char in char_dict:
            char_dict[char] += 1
        else:
            char_dict[char] = 1
    return char_dict",48
10785703127,second_max,"def second_max(lst):
    if len(lst) < 2:
        return None
    lst = list(set(lst))
    if len(lst) < 2:
        return None
    lst.sort()
    return lst[-2]",48
3677382755,string_reverse,"def string_reverse(s):
    s = s.lower()
    if not s.isalnum():
        return ""Invalid Input""
    reversed_s = s[::-1]
    if s == reversed_s:
        return ""Palindrome""
    return reversed_s",48
4729571353,digit_count,"def digit_count(n, d):
    count = 0
    while n > 0:
        if n % 10 == d:
            count += 1
        n = n // 10
    return count",48
28109900377,distinct_substrings,"def distinct_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)",48
74673022345,smallest_integer,"def smallest_integer(lst):
    if len(lst) == 0:
        return None
    else:
        smallest = lst[0]
        for num in lst:
            if num < smallest:
                smallest = num
        return smallest",48
38902381241,count_characters,"def count_characters(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    return char_count",48
71950624941,square_or_cube,"def square_or_cube(numbers):
    result = []
    for number in numbers:
        if number % 2 == 0:
            result.append(number ** 2)
        else:
            result.append(number ** 3)
    return result",48
15907404888,next_palindrome,"def next_palindrome(n):
    n += 1
    while not is_palindrome(n):
        n += 1
    return n

def is_palindrome(n):
    return str(n) == str(n)[::-1]",48
39717604694,string_frequency,"def string_frequency(strings):
    frequency_dict = {}
    for string in strings:
        if string in frequency_dict:
            frequency_dict[string] += 1
        else:
            frequency_dict[string] = 1
    return frequency_dict",48
31821880010,char_count,"def char_count(str):
    char_dict = {}
    for char in str:
        if char in char_dict:
            char_dict[char] += 1
        else:
            char_dict[char] = 1
    return char_dict",48
37670476356,num_divisors,"def num_divisors(n):
    result = 0
    i = 1
    while(i <= n):
        if(n % i== 0):
            result += 1
        i += 1
    return result",48
28755840076,sum_multiples,"def sum_multiples(n):
    sum = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",48
35481246791,find_max_in_binary_tree,"def find_max_in_binary_tree(tree):
    if not tree:
        return None
    max_val = tree[0]
    for value in tree:
        if value > max_val:
            max_val = value
    return max_val",48
7061988875,missing_positive_integer,"def missing_positive_integer(A):
    A = set([a for a in A if a > 0])
    i = 1
    while True:
        if i not in A:
            return i
        i += 1",48
18587713311,factorial_last_digit,"def factorial_last_digit(n):
    if n < 0:
        return None
    factorial = 1
    for i in range(1, n + 1):
        factorial *= i
    return factorial % 10",48
20737007117,binary_to_decimal,"def binary_to_decimal(binary_list):
    decimal = 0
    length = len(binary_list)
    for i in range(length):
        decimal += binary_list[length - i - 1] * 2 ** i
    return decimal",48
10622295107,sum_divisible,"def sum_divisible(n):
    sum = 0
    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",48
42061636312,remove_vowels,"def remove_vowels(str):
    vowels = ('a', 'e', 'i', 'o', 'u') 
    result = """".join([char for char in str if char.lower() not in vowels])
    return result",48
34420538827,string_count,"def string_count(strings):
    string_dict = {}
    for string in strings:
        if string in string_dict:
            string_dict[string] += 1
        else:
            string_dict[string] = 1
    return string_dict",48
17454988973,find_duplicates,"from collections import defaultdict

def find_duplicates(nums):
    res=[]
    hashmap=defaultdict(int)
    for ele in nums:
        hashmap[ele]+=1
        if hashmap[ele]==2:
            res.append(ele)
    return res",48
3914972791,smallest_positive,"def smallest_positive(lst):
    positive_nums = set(filter(lambda x: x > 0, lst))
    i = 1
    while True:
        if i not in positive_nums:
            return i
        i += 1",48
30506007541,distinct_substrings,"def distinct_substrings(s):
    substrings = set()
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.add(s[i:j])
    return len(substrings)",48
2707555853,count_steps,"def count_steps(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return b",48
38242504661,char_count,"def char_count(str):
  char_dict = {}
  for char in str:
    if char in char_dict:
      char_dict[char] += 1
    else:
      char_dict[char] = 1
  return char_dict",48
30124291158,flatten_list,"def flatten_list(nested_list):
    result_list = []
    for i in nested_list:
        if isinstance(i, list):
            result_list.extend(flatten_list(i))
        else:
            result_list.append(i)
    return result_list",48
38484413808,most_frequent_element,"from collections import Counter

def most_frequent_element(lst):
    counter = Counter(lst)
    max_count = max(list(counter.values()))
    return [item for item, count in counter.items() if count == max_count][0]",47
69878232427,fibonacci,"def fibonacci(n):
    fib_sequence = [0, 1]
    while len(fib_sequence) < n:
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
    return fib_sequence[:n]",47
3087778145,k_most_frequent,"from collections import Counter

def k_most_frequent(nums, k):
    counter = Counter(nums)
    most_common = counter.most_common(k)
    result = [item[0] for item in most_common]
    return result",47
36269330824,find_anagrams,"def find_anagrams(str_list, target):
    target_sorted = sorted(target)
    anagrams = []
    for word in str_list:
        if sorted(word) == target_sorted:
            anagrams.append(word)
    return anagrams",47
28850758168,find_Missing_Number,"def find_Missing_Number(lst):
    n = len(lst) + 1
    total = n * (n + 1) // 2
    sum_of_lst = sum(lst)
    return total - sum_of_lst",47
73459941304,find_Max_Product,"def find_Max_Product(lst):
    lst.sort()
    n = len(lst)
    return max(lst[0]*lst[1]*lst[n-1], lst[n-3]*lst[n-2]*lst[n-1])",47
8047438747,pig_latin,"def pig_latin(word):
    vowels = 'aeiou'
    if word[0] in vowels:
        return word + 'ay'
    else:
        return word[1:] + word[0] + 'ay'",47
41048501706,remove_repeated_chars,"def remove_repeated_chars(s: str) -> str:
    res = """"
    seen = set()
    for char in s:
        if char not in seen:
            res += char
            seen.add(char)
    return res",47
16470531948,triangle_possible,"def triangle_possible(a, b, c):
    # Check the triangle inequality theorem
    if a + b > c and a + c > b and b + c > a:
        return True
    else:
        return False",47
39080087580,smallest_common_multiple,"def smallest_common_multiple(a, b):
    def gcd(x, y):
        while(y):
            x, y = y, x % y
        return x
    return (a * b) // gcd(a, b)",47
23413982,large_product,"def large_product(nums1, nums2, N):
    result = []
    for x in nums1:
        for y in nums2:
            result.append(x*y)
    result.sort(reverse=True)
    return result[:N]",47
17035963577,check_sum_representation,"def check_sum_representation(list, num):
    for i in range(len(list)):
        for j in range(i+1, len(list)):
            if list[i] + list[j] == num:
                return True
    return False",47
42578107457,reverse_num,"def reverse_num(num):
    reversed_num = 0
    while num > 0:
        reversed_num = reversed_num * 10 + num % 10
        num //= 10
    return reversed_num",47
21585072779,find_element,"from collections import Counter

def find_element(arr):
    n = len(arr)
    counter = Counter(arr)
    for num, freq in counter.items():
        if freq > n / 3:
            return num
    return None",47
4096933920,pig_latin,"def pig_latin(word):
    vowels = 'aeiou'
    if word[0] in vowels:
        return word + ""way""
    else:
        return word[1:] + word[0] + ""ay""",47
15952261271,second_frequent_string,"from collections import Counter

def second_frequent_string(lst):
    counter = Counter(lst)
    most_common = counter.most_common()
    return most_common[1][0] if len(most_common) > 1 else None",47
17297007728,find_anagrams,"def find_anagrams(word_list, word):
    word_sorted = sorted(word)
    anagrams = []
    for w in word_list:
        if sorted(w) == word_sorted:
            anagrams.append(w)
    return anagrams",47
71960448209,find_smallest_index,"def find_smallest_index(nums):
    smallest_index = 0
    for i in range(1, len(nums)):
        if nums[i] < nums[smallest_index]:
            smallest_index = i
    return smallest_index",47
74866389783,longest_row_length,"def longest_row_length(crossword):
    max_length = 0
    for row in crossword:
        row_length = len(row)
        if row_length > max_length:
            max_length = row_length
    return max_length",47
72565628674,smallest_multiple,"from math import gcd
from functools import reduce

def lcm(a, b):
    return a * b // gcd(a, b)

def smallest_multiple(n):
    return reduce(lcm, range(1, n + 1))",47
16692574676,largest_digit,"def largest_digit(lst):
    max_digit = 0
    for number in lst:
        for digit in str(number):
            if int(digit) > max_digit:
                max_digit = int(digit)
    return max_digit",47
35354255629,smallest_integer,"def smallest_integer(numbers):
    if len(numbers) == 0:
        return None

    smallest = numbers[0]
    for num in numbers[1:]:
        if num < smallest:
            smallest = num
    return smallest",47
37139286192,letter_frequency,"def letter_frequency(str1):
  frequency = {}
  for letter in str1:
    if letter in frequency:
      frequency[letter] += 1
    else:
      frequency[letter] = 1
  return frequency",47
39376792658,vowel_count,"def vowel_count(str1):
  count = 0
  vowels = set(""aeiouAEIOU"")
  for alphabet in str1:
    if alphabet in vowels:
      count = count + 1
  return count",47
25354297906,find_Missing_Number,"def find_Missing_Number(arr):
    n = len(arr) + 1
    total = n * (n + 1) // 2
    sum_of_arr = sum(arr)
    return total - sum_of_arr",47
13336987795,largest_fibonacci,"def largest_fibonacci(n):
    fib1, fib2 = 1, 1
    while fib2 <= n:
        fib1, fib2 = fib2, fib1 + fib2
    return fib1",47
18587689101,sum_proper_div,"def sum_proper_div(number):
    divisors = [1]
    for i in range(2, number):
        if (number % i) == 0:
            divisors.append(i)
    return sum(divisors)",47
8251178842,largest_fibonacci,"def largest_fibonacci(n):
    fib1, fib2 = 0, 1
    while fib2 <= n:
        fib1, fib2 = fib2, fib1 + fib2
    return fib1",47
9360050250,is_palindrome_recursive,"def is_palindrome_recursive(string):
    if len(string) <= 1:
        return True
    if string[0] != string[-1]:
        return False
    return is_palindrome_recursive(string[1:-1])",47
41033452151,remove_consecutive_duplicates,"def remove_consecutive_duplicates(nums):
    if not nums:
        return []

    result = [nums[0]]

    for num in nums[1:]:
        if num != result[-1]:
            result.append(num)

    return result",47
15907458688,find_minimum,"def find_minimum(numbers):
    if not numbers:
        return None

    min_num = numbers[0]
    for num in numbers[1:]:
        if num < min_num:
            min_num = num

    return min_num",47
32300335600,reverse_digits,"def reverse_digits(num):
    reversed_num = 0
    while num > 0:
        reversed_num = reversed_num * 10 + num % 10
        num //= 10
    return reversed_num",47
17232517906,fibonacci_recursive,"def fibonacci_recursive(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)",47
31155123461,find_smallest_index,"def find_smallest_index(lst):
    smallest_index = 0
    for i in range(1, len(lst)):
        if lst[i] < lst[smallest_index]:
            smallest_index = i
    return smallest_index",47
40344367506,isSelfDividingNumber,"def isSelfDividingNumber(n):
    nToString = str(n)
    for c in nToString:
        if (c == '0' or n % int(c) != 0):
            return False
    return True",47
42711405357,sum_of_square_digits,"def sum_of_square_digits(num):
    sum = 0
    while num > 0:
        digit = num % 10
        sum += digit ** 2
        num //= 10
    return sum",47
1519815963,max_frequency,"def max_frequency(arr):
    frequency = {}
    for i in arr:
        if i in frequency:
            frequency[i] += 1
        else:
            frequency[i] = 1
    return max(frequency.values())",47
34940400261,find_Missing_Number,"def find_Missing_Number(arr):
    n = len(arr) + 1
    total = n * (n + 1) // 2
    sum_of_arr = sum(arr)
    return total - sum_of_arr",47
70154565652,largestFibonacci,"def largestFibonacci(n):
    fib1, fib2 = 0, 1
    while fib2 <= n:
        fib1, fib2 = fib2, fib1 + fib2
    return fib1",47
36607582428,find_Missing_Number,"def find_Missing_Number(nums):
    n = len(nums) + 1
    total_sum = n * (n + 1) // 2
    list_sum = sum(nums)
    return total_sum - list_sum",47
15680854240,min_moves,"def min_moves(arr):
    arr.sort()
    median = arr[len(arr) // 2]
    moves = 0
    for i in range(len(arr)):
        moves += abs(arr[i] - median)
    return moves",47
13540221795,nth_largest,"def nth_largest(lst, n):
    unique_lst = list(set(lst))
    unique_lst.sort()
    if len(unique_lst) < n:
        return unique_lst[-1]
    else:
        return unique_lst[-n]",47
15284141601,find_Missing_Number,"def find_Missing_Number(arr):
    n = len(arr) + 1
    total = n * (n + 1) // 2
    sum_of_arr = sum(arr)
    return total - sum_of_arr",47
72916152664,student_move_count,"def student_move_count(heights):
    ans = 0
    hh = sorted(heights)
    for i, h in enumerate(heights):
        if hh[i] != h:
            ans += 1
    return ans",47
6321719324,find_min_val,"def find_min_val(n, x, y): 
    k = y 
    while k <= n: 
        if (k % x == y): 
            return k 
        k += 1
    return -1",47
14105949954,find_smallest_missing,"def find_smallest_missing(arr):
    n = len(arr)
    arr.sort()
    smallest = 1
    for i in range(n):
        if arr[i] <= smallest:
            smallest += arr[i]
    return smallest",47
27567861641,manhattan_distance,"def manhattan_distance(point1, point2):
    x1, y1 = point1
    x2, y2 = point2
    return abs(x1 - x2) + abs(y1 - y2)",47
2760625588,calc_row,"def calc_row(n):
    row = [1]
    for i in range(1, n + 1):
        row.append(row[i-1] * (n - i + 1) // i)
    return row",47
43970240642,find_largest_divisible,"def find_largest_divisible(nums, divisor):
    result = None
    for num in nums:
        if num % divisor == 0 and (result is None or num > result):
            result = num
    return result",47
6839435839,fibonacci_recursive,"def fibonacci_recursive(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)",47
21274506281,sum_of_powers_of_two,"def sum_of_powers_of_two(numbers):
    power_sum = 0
    for num in numbers:
        if (num & (num - 1)) == 0:
            power_sum += num
    return power_sum",47
37887270012,reverseList,"def reverseList(A, start, end):
    if start >= end:
        return A
    A[start], A[end] = A[end], A[start]
    return reverseList(A, start+1, end-1)",47
16245565577,is_odd_or_even,"def is_odd_or_even(n):
    sum = 0
    while n:
        sum += n % 10
        n //= 10
    return 'Odd' if sum % 2 else 'Even'",47
4529987956,find_SCM,"def find_SCM(a, b):
    def gcd(x, y):
        while(y):
            x, y = y, x % y
        return x
    return (a * b) // gcd(a, b)",47
73179298032,most_common_char,"def most_common_char(s):
    freq = {}
    for c in s:
        if c in freq:
            freq[c] += 1
        else:
            freq[c] = 1
    return max(freq.values())",47
36507648171,reverse_digits,"def reverse_digits(num):
    rev = 0
    while num > 0:
        rev = (rev * 10) + num % 10
        num = num // 10
    return rev",47
18954456603,check_number,"import re

def check_number(s):
    pattern = r'^-?\d+(\.\d+)?(e-?\d+)?$'
    if re.match(pattern, s):
        return True
    else:
        return False",47
37939771352,min_operations,"def min_operations(arr):
    n = len(arr)
    median = sorted(arr)[n//2]
    operations = 0
    for i in range(n):
        operations += abs(arr[i] - median)
    return operations",47
12367758083,product_series,"def product_series(number):
    if number == 0:
        return 1
    else:
        product = 1
        for i in range(1, number + 1):
            product *= i
        return product",47
14402906026,count_char_occurrences,"def count_char_occurrences(str1):
    result = {}
    for char in str1:
        if char in result:
            result[char] += 1
        else:
            result[char] = 1
    return result",47
39788010743,substrings,"def substrings(s):
    substrings_list = []
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings_list.append(s[i:j])
    return substrings_list",47
12725086790,is_rotation_of_palindrome,"def is_rotation_of_palindrome(s: str) -> bool:
    for i in range(len(s)):
        rotated = s[i:] + s[:i]
        if rotated == rotated[::-1]:
            return True
    return False",47
4356461675,remove_element,"def remove_element(nums, val):
    i = 0
    while i < len(nums):
        if nums[i] == val:
            nums.pop(i)
        else:
            i += 1
    return len(nums)",47
3297445274,min_moves_to_equal_elements,"def min_moves_to_equal_elements(nums):
    nums.sort()
    min_moves = 0
    for i in range(len(nums) - 1):
        min_moves += nums[-1] - nums[i]
    return min_moves",47
19903900096,find_duplicates,"def find_duplicates(lst):
    duplicates = []
    unique = set()
    for i in lst:
        if i in unique:
            duplicates.append(i)
        else:
            unique.add(i)
    return sorted(list(set(duplicates)))",47
20352427087,is_hexadecimal,"def is_hexadecimal(s):
    valid_hex = set('0123456789abcdefABCDEF')
    for char in s:
        if char not in valid_hex:
            return False
    return True",47
71501026285,is_hexadecimal,"def is_hexadecimal(s):
    hex_digits = set(""0123456789abcdefABCDEF"")
    for char in s:
        if char not in hex_digits:
            return False
    return True",47
10952823331,find_minimum,"def find_minimum(arr):
    if not arr:
        return None
    
    min_val = arr[0]
    for num in arr[1:]:
        if num < min_val:
            min_val = num
    return min_val",47
688064499,fibonacci_sequence,"def fibonacci_sequence(n):
  sequence = [0]
  a, b = 0, 1
  while b < n:
    sequence.append(b)
    a, b = b, a + b
  return sequence",47
30124436588,get_max_value,"def get_max_value(tuple_list):
    max_value = tuple_list[0][1]
    for tuple in tuple_list:
        if tuple[1] > max_value:
            max_value = tuple[1]
    return max_value",47
69796142395,isPalindrome,"def isPalindrome(s):
    return s == s[::-1]

print(isPalindrome(""radar""))
print(isPalindrome(""12321""))
print(isPalindrome(""test""))
print(isPalindrome(""123456""))",47
36465044418,round_to_even,"def round_to_even(numbers):
    return [round(num) if round(num) % 2 == 0 else round(num) + 1 if num > round(num) else round(num) - 1 for num in numbers]",47
11956824756,most_frequent_element,"from collections import Counter

def most_frequent_element(lst):
    counter = Counter(lst)
    max_count = max(list(counter.values()))
    return [item for item, count in counter.items() if count == max_count][0]",47
13161923192,smallest_evenly_divisible,"from math import gcd

def smallest_evenly_divisible(n):
    result = 1
    for i in range(1, n + 1):
        result = result * i // gcd(result, i)
    return result",47
7441072241,pow_recursion,"def pow_recursion(base, exp):
    if exp == 0:
        return 1
    elif exp == 1:
        return base
    else:
        return base * pow_recursion(base, exp-1)",47
34285741067,josephus,"def josephus(n, k):
    if n == 1:
        return 1
    else:
        return (josephus(n - 1, k) + k-1) % n + 1",47
4139187281,find_most_common_element,"from collections import Counter

def find_most_common_element(lst):
    counter = Counter(lst)
    max_count = max(list(counter.values()))
    return [item for item, count in counter.items() if count == max_count][0]",47
11316501672,find_mode,"from collections import Counter

def find_mode(numbers):
    counts = Counter(numbers)
    max_count = max(counts.values())
    modes = [num for num, count in counts.items() if count == max_count]
    return modes",47
73629577944,get_fibonacci,"def get_fibonacci(n):
  fib_sequence = [0, 1]
  while len(fib_sequence) < n:
    fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
  return fib_sequence",47
73310888941,count_price_increases,"def count_price_increases(prices):
    count = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i-1]:
            count += 1
    return count",47
27331014234,lucas,"def lucas(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        return lucas(n-1) + lucas(n-2)",47
69904961436,trailing_zeros_factorial,"def trailing_zeros_factorial(n):
    count = 0
    if n < 0:
        return -1
    while n >= 5:
        n //= 5
        count += n
    return count",46
40488752523,count_trailing_zeroes,"def count_trailing_zeroes(n):
    count = 0
    i = 5
    while n/i >= 1:
        count += int(n/i)
        i *= 5
    return int(count)",46
34531028466,minIncrementForEqualSum,"def minIncrementForEqualSum(nums):
    nums.sort()
    total_steps = 0
    for i in range(len(nums)-1):
        total_steps += (nums[-1] - nums[i])
    return total_steps",46
13557098040,is_perfect,"def is_perfect(num: int) -> bool:
    sum = 0
    for i in range(1, num):
        if num % i == 0:
            sum += i
    return sum == num",46
29927749242,missing_element,"def missing_element(A):
    N = len(A)
    total = (N + 1) * (N + 2) // 2
    sum_of_A = sum(A)
    return total - sum_of_A",46
39501406061,remove_element,"def remove_element(nums, val):
    i = 0
    for j in range(len(nums)):
        if nums[j] != val:
            nums[i] = nums[j]
            i += 1
    return i",46
70095544629,number_of_bits,"def number_of_bits(n):
    if n == 0:
        return 1
    bits = 0
    while n > 0:
        bits += 1
        n >>= 1
    return bits",46
38132117799,least_common_multiple,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def least_common_multiple(x, y):
    return (x * y) // gcd(x, y)",46
15663747696,pascals_triangle_row,"def pascals_triangle_row(n):
    row = [1]
    for _ in range(n):
        row = [x + y for x, y in zip([0]+row, row+[0])]
    return row",46
37014596606,find_Min_Num,"def find_Min_Num(arr,n) : 
    arr.sort()
    num = arr[0]
    for i in range(1,n) : 
        num = num * 10 + arr[i]
    return num",46
27199736188,generate_combinations,"from itertools import combinations

def generate_combinations(items):
    result = []
    for r in range(len(items) + 1):
        for subset in combinations(items, r):
            result.append(list(subset))
    return result",46
41361226848,is_rotation,"def is_rotation(s1: str, s2: str) -> bool:
    if len(s1) != len(s2):
        return False

    temp = s1 + s1
    return s2 in temp",46
43302930847,is_permutation,"from collections import Counter

def is_permutation(s1: str, s2: str) -> bool:
    c1, c2 = Counter(s1.lower()), Counter(s2.lower())
    return c1 == c2",46
72805917944,remove_value,"def remove_value(nums, val):
    j = 0
    for i in range(len(nums)):
        if nums[i] != val:
            nums[j] = nums[i]
            j += 1
    return j",46
37204506497,is_hex_color,"import re

def is_hex_color(code):
    pattern = r'^#([A-Fa-f0-9]{6})$'
    if re.match(pattern, code):
        return True
    else:
        return False",46
34656530184,num_ways,"def num_ways(m, n):
    if m == 1 or n == 1:
        return 1
    return num_ways(m-1, n) + num_ways(m, n-1)",46
39391016963,grid_ways,"def grid_ways(row, col):
    if row == 1 or col == 1:
        return 1
    return grid_ways(row-1, col) + grid_ways(row, col-1)",46
26862744711,sum_of_multiples,"def sum_of_multiples(n):
  sum = 0
  for i in range(n):
    if i % 3 == 0 or i % 5 == 0:
      sum += i
  return sum",46
2752978647,find_missing_number,"def find_missing_number(arr):
    n = len(arr) + 1
    total_sum = n * (n + 1) // 2
    arr_sum = sum(arr)
    return total_sum - arr_sum",46
28080464398,title_to_number,"def title_to_number(columnTitle: str) -> int:
    result = 0
    for char in columnTitle:
        result = result * 26 + (ord(char) - 64)
    return result",46
70570976485,find_most_common,"from collections import Counter

def find_most_common(lst):
    count = Counter(lst)
    max_count = max(count.values())
    return [(i, freq) for i, freq in count.items() if freq == max_count]",46
74960684985,count_digit,"def count_digit(n, d):
    count = 0
    while n > 0:
        if n % 10 == d:
            count += 1
        n //= 10
    return count",46
30211533669,tuple_subtraction,"def tuple_subtraction(test_tup1, test_tup2):
  res = tuple(ele1 - ele2 for ele1, ele2 in zip(test_tup1, test_tup2))
  return (res)",46
7446126989,sum_of_multiples,"def sum_of_multiples(number):
    sum = 0
    for i in range(number):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",46
16341494284,max_balloons,"from collections import Counter

def max_balloons(s):
    balloon_counter = Counter('balloon')
    s_counter = Counter(s)
    return min(s_counter[char] // balloon_counter[char] for char in balloon_counter)",46
27551363285,digit_count,"def digit_count(num, digit):
    count = 0
    while num > 0:
        if num % 10 == digit:
            count += 1
        num //= 10
    return count",46
13049181219,count_distinct_substrings,"def count_distinct_substrings(s, length):
    substrings = set()
    for i in range(len(s) - length + 1):
        substrings.add(s[i:i+length])
    return len(substrings)",46
39067872051,greatest_digit,"def greatest_digit(num):
    num = str(num)
    max_digit = 0
    for digit in num:
        if int(digit) > max_digit:
            max_digit = int(digit)
    return max_digit",46
16937742982,most_frequent_element,"from collections import Counter

def most_frequent_element(arr):
    counter = Counter(arr)
    max_count = max(list(counter.values()))
    for key in counter.keys():
        if counter[key] == max_count:
            return key",46
70067612631,find_intersection,"from collections import Counter

def find_intersection(list1, list2):
    counter1 = Counter(list1)
    counter2 = Counter(list2)
    intersection = counter1 & counter2
    return list(intersection.elements())",46
70866788179,smallest_divisor,"def smallest_divisor(n):
    if n <= 1:
        return n
    for i in range(2, n + 1):
        if n % i == 0:
            return i
    return n",46
2279330576,find_next_palindrome,"def find_next_palindrome(n):
    if str(n) == str(n)[::-1]:
        n += 1
    while str(n) != str(n)[::-1]:
        n += 1
    return n",46
36888610061,hamming_distance,"def hamming_distance(x, y):
    xor_result = x ^ y
    distance = 0
    while xor_result:
        distance += 1
        xor_result &= xor_result - 1
    return distance",46
34277829160,sum_proper_divisors,"def sum_proper_divisors(n):
    divisors = [1]
    for i in range(2, n):
        if n % i == 0:
            divisors.append(i)
    return sum(divisors)",46
35031346129,sum_of_multiples,"def sum_of_multiples(n):
    sum = 0
    for i in range(n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",46
74013528069,count_frequencies,"def count_frequencies(input_list):
    frequencies = {}
    for num in input_list:
        if num in frequencies:
            frequencies[num] += 1
        else:
            frequencies[num] = 1
    return frequencies",46
14921422862,transpose,"def transpose(matrix):
    result = []
    for i in range(len(matrix[0])):
        temp = []
        for j in range(len(matrix)):
            temp.append(matrix[j][i])
        result.append(temp)
    return result",46
46352394488,find_longest,"def find_longest(lst):
    if not lst:
        return None
    longest = lst[0]
    for s in lst:
        if len(s) > len(longest):
            longest = s
    return longest",46
4688463382,remove_nested_list,"def remove_nested_list(test_tup):
  res = tuple()
  for count, ele in enumerate(test_tup):
    if not isinstance(ele, list):
      res = res + (ele, )
  return (res)",46
73926121947,max_in_list,"def max_in_list(numbers):
    if not numbers:
        return None
    max_value = numbers[0]
    for number in numbers:
        if number > max_value:
            max_value = number
    return max_value",46
22852772316,reverse_queue,"def reverse_queue(queue, k):
    if k <= 0 or not queue:
        return queue
    
    k = min(k, len(queue))
    queue[:k] = queue[:k][::-1]
    return queue",46
29820451361,sum_proper_divisors,"def sum_proper_divisors(number):
    divisors = [1]
    for i in range(2, number):
        if number % i == 0:
            divisors.append(i)
    return sum(divisors)",46
41538934174,scm,"def scm(x, y):
    def gcd(a, b):
        while b != 0:
            a, b = b, a % b
        return a

    return x * y // gcd(x, y)",46
9338266535,transpose,"def transpose(matrix):
    result = []
    for i in range(len(matrix[0])):
        row = []
        for j in range(len(matrix)):
            row.append(matrix[j][i])
        result.append(row)
    return result",46
70402989158,fib_series,"def fib_series(n):
    fib = [0]
    a, b = 0, 1
    while b < n:
        fib.append(b)
        a, b = b, a+b
    return fib",46
6256055991,possible_sublists,"def possible_sublists(nums):
    results = [[]]
    for num in nums:
        new_results = []
        for result in results:
            new_results.append(result + [num])
        results += new_results
    return results",46
1246195574,find_trailing_zeros,"def find_trailing_zeros(n): 
    count = 0
    i=5
    while n/i>=1: 
        count += int(n/i) 
        i *= 5
    return int(count)",46
11131882061,flip_count,"def flip_count(s):
    count = 0
    pre = s[0]
    for i in s[1:]:
        if i != pre:
            count += 1
        pre = i
    return count",46
18958606070,strange_sort_list,"def strange_sort_list(lst):
    sorted_list = sorted(lst)
    result = []
    while sorted_list:
        result.append(sorted_list.pop(0))
        if sorted_list:
            result.append(sorted_list.pop())
    return result",46
27522553834,flatten,"def flatten(nested_list):
  flat_list = []
  for element in nested_list:
    if isinstance(element, list):
      flat_list.extend(flatten(element))
    else:
      flat_list.append(element)
  return flat_list",46
26625239022,filter_strings,"def filter_strings(lst):
    vowels = ['a', 'e', 'i', 'o', 'u']
    return [i for i in lst if len(i) > 5 and i[0] in vowels]",46
42880103598,is_harshad_number,"def is_harshad_number(n):
    arr = list(str(n))
    result = 0
    
    for i in range(len(arr)):
        result += int(arr[i])
    
    return n % result == 0",46
38003450051,find_modes,"from collections import Counter

def find_modes(nums):
    count = Counter(nums)
    max_count = max(count.values())
    modes = [num for num, freq in count.items() if freq == max_count]
    return modes",46
28172661672,longest_word_in_sentence,"def longest_word_in_sentence(sentence):
    words = sentence.split(' ')
    longest_word = ''
    for word in words:
        if len(word) > len(longest_word):
            longest_word = word
    return longest_word",46
9316290740,sum_of_multiples,"def sum_of_multiples(n):
    sum = 0
    for i in range(n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",46
9653309211,pattern_count,"def pattern_count(text, pattern):
    count = 0
    for i in range(len(text)-len(pattern)+1):
        if text[i:i+len(pattern)] == pattern:
            count += 1
    return count",46
20829747549,count_digit,"def count_digit(num, digit):
    count = 0
    while num > 0:
        if num % 10 == digit:
            count += 1
        num //= 10
    return count",46
19864151582,find_long_palindromes,"def find_long_palindromes(list_of_strings):
    result = []
    for word in list_of_strings:
        if len(word) > 3 and word == word[::-1]:
            result.append(word)
    return result",46
24187769475,unique_strings_preserve_order,"def unique_strings_preserve_order(strings):
    seen = set()
    unique_strings = []
    for string in strings:
        if string not in seen:
            seen.add(string)
            unique_strings.append(string)
    return unique_strings",46
14735076070,find_longest_string,"def find_longest_string(lst):
    if not lst:
        return """"
    longest = lst[0]
    for string in lst:
        if len(string) > len(longest):
            longest = string
    return longest",46
3707554761,sum_proper_divisors,"def sum_proper_divisors(num):
    divisors = [1]
    for i in range(2, num):
        if num % i == 0:
            divisors.append(i)
    return sum(divisors)",46
34556143272,is_valid_hex_color,"import re

def is_valid_hex_color(color_string):
    pattern = r'^#([A-Fa-f0-9]{6})$'
    if re.match(pattern, color_string):
        return True
    return False",46
13026868563,smallest_common_multiple,"def gcd(x, y):
    while(y):
        x, y = y, x % y
    return x

def smallest_common_multiple(a, b):
    return (a * b) // gcd(a, b)",46
40291171271,longest_zero_sequence,"def longest_zero_sequence(n):
    binary_str = bin(n)[2:]
    zero_sequence = binary_str.strip('0').split('1')
    longest = max([len(seq) for seq in zero_sequence])
    return longest",46
13971066029,heightChecker,"def heightChecker(heights):
    temp = sorted(heights)
    counter = 0
    for i in range(len(heights)):
        if heights[i] != temp[i]:
            counter += 1
    return counter",46
37650521815,smallest_Multiple,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def smallest_Multiple(num, multiple):
    return (num * multiple) // gcd(num, multiple)",46
13843767840,remove_common_elements,"def remove_common_elements(list1, list2):
    common_elements = set(list1) & set(list2)
    result = [item for item in list1 + list2 if item not in common_elements]
    return result",46
32882165488,decimal_to_binary,"def decimal_to_binary(decimal):
    binary = """"
    while decimal > 0:
        binary = str(decimal % 2) + binary
        decimal = decimal // 2
    return binary if binary else ""0""",46
4241012515,character_frequency,"def character_frequency(s):
    frequency = {}
    for character in s:
        if character in frequency:
            frequency[character] += 1
        else:
            frequency[character] = 1
    return frequency",45
21769174483,factorial_list,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def factorial_list(lst):
    return [factorial(i) for i in lst]",45
19130355555,count_palindrome_words,"def count_palindrome_words(sentence):
    words = sentence.split()
    palindrome_count = 0
    for word in words:
        if word == word[::-1]:
            palindrome_count += 1
    return palindrome_count",45
21204474744,is_rotation,"def is_rotation(s1, s2):
    if len(s1) != len(s2):
        return False
    s1s1 = s1 + s1
    return s2 in s1s1",45
3892292897,alternate_sort,"def alternate_sort(lst):
    sorted_lst = sorted(lst)
    result = []
    while sorted_lst:
        result.append(sorted_lst.pop(0))
        if sorted_lst:
            result.append(sorted_lst.pop())
    return result",45
36713122846,binary_to_decimal,"def binary_to_decimal(binary):
    binary = str(binary)[::-1]
    decimal = 0
    for i in range(len(binary)):
        decimal += int(binary[i]) * (2 ** i)
    return decimal",45
30751992534,count_frequency,"def count_frequency(element_list):
    frequency = {}
    for element in element_list:
        if element in frequency:
            frequency[element] += 1
        else:
            frequency[element] = 1
    return frequency",45
1340792752,third_maximum,"def third_maximum(nums):
    unique_nums = list(set(nums))
    unique_nums.sort()
    
    if len(unique_nums) < 3:
        return max(unique_nums)
    else:
        return unique_nums[-3]",45
26887680354,fib_sequence,"def fib_sequence(n):
    fib = [0, 1]
    for i in range(2, n):
        fib.append(fib[i-1] + fib[i-2])
    return fib[:n]",45
72462200948,lcm,"def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)",45
10877144581,smallest_divisible,"import math
def smallest_divisible(n):
    result = 1
    for i in range(1, n + 1):
        result = result * i // math.gcd(result, i)
    return result",45
41559979692,count_substring,"def count_substring(string, sub_string):
    count = 0
    for i in range(len(string)):
        if string[i:i+len(sub_string)] == sub_string:
            count += 1

    return count",45
3868513390,lcm,"def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)",45
21084873094,find_max,"def find_max(nums):
    if not nums:
        return None

    max_num = nums[0]
    for num in nums:
        if num > max_num:
            max_num = num

    return max_num",45
42614764966,is_power_of_two,"def is_power_of_two(n):
    if n <= 0:
        return False
    while n > 1:
        if n % 2:
            return False
        n /= 2
    return True",45
41342724476,trailing_zeros_factorial,"def trailing_zeros_factorial(n):
    count = 0
    i = 5
    while n/i >= 1:
        count += int(n/i)
        i *= 5
    return int(count)",45
12132266602,factorial_list,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def factorial_list(lst):
    return [factorial(x) for x in lst]",45
72139807030,find_missing,"def find_missing(nums):
    n = len(nums) + 1
    total_sum = n * (n + 1) // 2
    list_sum = sum(nums)
    return total_sum - list_sum",45
35370010109,factorial_list,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def factorial_list(lst):
    return [factorial(x) for x in lst]",45
41186043789,check_perfect_square,"import math

def check_perfect_square(n):
    root = math.sqrt(n)
    if int(root + 0.5) ** 2 == n:
        return int(root)
    else:
        return -1",45
72233521852,gcd,"def gcd(m, n):
    while m % n != 0:
        old_m = m
        old_n = n

        m = old_n
        n = old_m % old_n
    return n",45
33527742343,find_palindromes,"def find_palindromes(string_list):
    palindromes = []
    for string in string_list:
        if string == string[::-1]:
            palindromes.append(string)
    return palindromes",45
21672200041,find_longest_word,"def find_longest_word(s):
    words = s.split()
    longest_word = """"
    for word in words:
        if len(word) > len(longest_word):
            longest_word = word
    return longest_word",45
37579161192,find_substrings,"def find_substrings(s):
    substrings = []
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substrings.append(s[i:j])
    return substrings",45
2512707638,remove_element,"def remove_element(nums, val):
    i = 0
    while i < len(nums):
        if nums[i] == val:
            nums.pop(i)
        else:
            i += 1
    return nums",45
33813023942,find_largest_prime_factor,"def find_largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n",45
2697029219,min_Steps,"def min_Steps(arr,n):
    arr.sort()
    median = arr[n//2]
    steps = 0
    for i in range(n):
        steps += abs(arr[i] - median)
    return steps",45
5259196396,smallest_divisible,"from math import gcd

def smallest_divisible(n):
    result = 1
    for i in range(2, n + 1):
        result = result * i // gcd(result, i)
    return result",45
15951430061,longest_word_length,"def longest_word_length(sentence):
    words = sentence.split()
    max_length = 0
    for word in words:
        if len(word) > max_length:
            max_length = len(word)
    return max_length",45
31473758430,find_most_common,"def find_most_common(lst):
    from collections import Counter
    count = Counter(lst)
    max_val = max(list(count.values()))
    return next(key for key, val in count.items() if val == max_val)",45
32619302012,smallest_duplicate,"from collections import Counter

def smallest_duplicate(lst):
    freq = Counter(lst)
    duplicates = [num for num, count in freq.items() if count > 1]
    return min(duplicates) if duplicates else None",45
20855507970,average_positive,"def average_positive(lst):
    positive_nums = [num for num in lst if num > 0]
    if not positive_nums:
        return 0
    return sum(positive_nums) / len(positive_nums)",45
9088007439,factorial_list,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def factorial_list(nums):
    return [factorial(x) for x in nums]",45
30124328818,group_anagrams,"from collections import defaultdict

def group_anagrams(strs):
    anagrams = defaultdict(list)
    for word in strs:
        anagrams[''.join(sorted(word))].append(word)
    return list(anagrams.values())",45
27867756156,sum_multiples,"def sum_multiples(n):
    sum = 0
    for i in range(n):
        if i % 3 == 0 or i % 5 == 0:
            sum += i
    return sum",45
5702535597,sum_lists,"def sum_lists(list1, list2):
    min_len = min(len(list1), len(list2))
    result = [list1[i] + list2[i] for i in range(min_len)]
    return result",45
22870469135,least_common_multiple,"def least_common_multiple(a, b):
    def gcd(x, y):
        while(y):
            x, y = y, x % y
        return x
    return a * b // gcd(a, b)",45
20983771165,frequency_of_elements,"def frequency_of_elements(lst):
    frequency = {}
    for item in lst:
        if (item in frequency):
            frequency[item] += 1
        else:
            frequency[item] = 1
    return frequency",45
35545915775,rearrange_zigzag,"def rearrange_zigzag(nums):
    nums.sort()
    zigzag = []
    while nums:
        zigzag.append(nums.pop(0))
        if nums:
            zigzag.append(nums.pop())
    return zigzag",45
44020145398,find_missing,"def find_missing(A):
    A_set = set(A)
    n = len(A) + 1
    for i in range(1, n+1):
        if i not in A_set:
            return i",45
7264921486,letter_frequency,"def letter_frequency(string):
    frequency = {}
    for letter in string:
        if letter in frequency:
            frequency[letter] += 1
        else:
            frequency[letter] = 1
    return frequency",45
360085662,vowel_count,"def vowel_count(s):
  count = 0
  vowels = set(""aeiouAEIOU"")
  for alphabet in s:
    if alphabet in vowels:
      count = count + 1
  return count",45
287085361,factorial_list,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def factorial_list(lst):
    return [factorial(i) for i in lst]",45
29742871380,lcm,"def gcd(x, y):
    while(y):
        x, y = y, x % y
    return x

def lcm(x, y):
    lcm = (x*y)//gcd(x,y)
    return lcm",45
7348712199,nested_list_sum,"def nested_list_sum(lst):
    total = 0
    for i in lst:
        if type(i) == list:
            total += nested_list_sum(i)
        else:
            total += i
    return total",45
1372571493,remove_char,"def remove_char(s):
    if len(s) == 0:
        return []
    result = []
    for i in range(len(s)):
        result.append(s[:i] + s[i+1:])
    return result",45
8498990419,count_string_occurrences,"def count_string_occurrences(strings):
    occurrences = {}
    for string in strings:
        if string in occurrences:
            occurrences[string] += 1
        else:
            occurrences[string] = 1
    return occurrences",45
16909246854,maxToys,"def maxToys(prices, k):
    prices.sort()
    count = 0
    for price in prices:
        if k >= price:
            k -= price
            count += 1
    return count",45
2469819098,missing_number,"def missing_number(arr):
    n = len(arr) + 1
    total = n * (n + 1) // 2
    sum_of_arr = sum(arr)
    return total - sum_of_arr",45
17557143354,contains_palindrome,"def contains_palindrome(words):
    """"""
    :type words: List[str]
    :rtype: bool
    """"""
    for word in words:
        if word == word[::-1]:
            return True
    return False",45
31134115078,fibonacci_sequence,"def fibonacci_sequence(n):
    fib_sequence = [0, 1]
    while len(fib_sequence) < n:
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
    return fib_sequence",45
3308173298,find_Missing_Number,"def find_Missing_Number(nums):
    n = len(nums) + 1
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",45
70044482529,reverse_tuple_list,"def reverse_tuple_list(tuples_list):
    reversed_list = []
    for tuple_ in reversed(tuples_list):
        reversed_tuple = tuple(reversed(tuple_))
        reversed_list.append(reversed_tuple)
    return reversed_list",45
7332095408,find_unique_words,"from collections import Counter

def find_unique_words(word_list):
    word_counts = Counter(word_list)
    unique_words = [word for word, count in word_counts.items() if count == 1]
    return unique_words",45
70333249667,char_frequency,"def char_frequency(input_string):
    result = {}
    for char in input_string:
        if char in result:
            result[char] += 1
        else:
            result[char] = 1
    return result",45
15222471895,filter_duplicate_words,"def filter_duplicate_words(sentence):
    words = sentence.split()
    unique_words = []
    for word in words:
        if word not in unique_words:
            unique_words.append(word)
    return "" "".join(unique_words)",45
72634482625,find_missing,"def find_missing(l):
    n = len(l) + 1
    total = n * (n + 1) // 2
    sum_of_list = sum(l)
    return total - sum_of_list",45
12855870352,largest_divisible,"def largest_divisible(lst, divisor):
    max_num = -1
    for num in lst:
        if num % divisor == 0 and num > max_num:
            max_num = num
    return max_num",45
39856113379,can_form_triangle,"def can_form_triangle(nums):
    nums.sort()
    for i in range(2, len(nums)):
        if nums[i] < nums[i-1] + nums[i-2]:
            return True
    return False",45
7834951470,getRow,"def getRow(rowIndex):
    row = [1]
    for _ in range(rowIndex):
        row = [x + y for x, y in zip([0] + row, row + [0])]
    return row",45
33322322943,find_most_frequent_elements,"from collections import Counter

def find_most_frequent_elements(lst):
    count = Counter(lst)
    max_count = max(count.values())
    return [num for num, freq in count.items() if freq == max_count]",45
18138872728,is_sorted_and_unique,"def is_sorted_and_unique(arr):
    for i in range(len(arr) - 1):
        if arr[i] >= arr[i + 1]:
            return False
    return len(arr) == len(set(arr))",45
44205291750,smallest_divisible,"from math import gcd

def smallest_divisible(n):
    result = 1
    for i in range(2, n + 1):
        result = result * i // gcd(result, i)
    return result",45
23794942740,no_consecutive_ones,"def no_consecutive_ones(N):
    a, b = 1, 2
    for _ in range(2, N):
        a, b = b, a + b
    return a + b",45
10422337803,find_largest_smaller,"def find_largest_smaller(nums, target):
    nums.sort()
    result = None
    for num in nums:
        if num < target:
            result = num
        else:
            break
    return result",45
5512660754,find_next_greater,"def find_next_greater(lst, num):
    result = -1
    for i in lst:
        if i > num:
            if result == -1 or i < result:
                result = i
    return result",45
32045298699,sum_Digits,"def sum_Digits(n) : 
    sum = 0
    while (n != 0) : 
        sum += n % 10
        n = int(n/10)
    return sum",45
20383247274,pascal_row,"def pascal_row(n):
    row = [1]
    for i in range(1, n+1):
        row.append(row[i-1] * (n-i+1) // i)
    return row",45
16059914250,most_frequent_elements,"from collections import Counter

def most_frequent_elements(nums):
    count = Counter(nums)
    max_freq = max(count.values())
    return sorted([num for num, freq in count.items() if freq == max_freq])",45
38663566930,find_largest_prime_factor,"def find_largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n",45
34285703407,factorial_list,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def factorial_list(lst):
    return [factorial(x) for x in lst]",45
22573007434,max_element,"def max_element(lst):
    if not lst:
        return None
    max_num = lst[0]
    for num in lst:
        if num > max_num:
            max_num = num
    return max_num",45
12156442086,most_common_element,"def most_common_element(lst):
    from collections import Counter
    count = Counter(lst)
    max_count = max(list(count.values()))
    for num in lst:
        if count[num] == max_count:
            return num",45
42173241174,convert_to_base8,"def convert_to_base8(num):
    octal = """"
    while num > 0:
        octal = str(num % 8) + octal
        num = num // 8
    return octal",45
26972347616,find_palindrome_positions,"def find_palindrome_positions(numbers):
    def is_palindrome(num):
        return str(num) == str(num)[::-1]
    
    return [i for i, num in enumerate(numbers) if is_palindrome(num)]",45
35717579179,count_digit,"def count_digit(n, digit):
    if n == 0:
        return int(digit == 0)
    return int(n % 10 == digit) + count_digit(n // 10, digit)",45
12233865580,max_integer,"def max_integer(lst):
    if not lst:
        return None
    max_num = lst[0]
    for num in lst:
        if num > max_num:
            max_num = num
    return max_num",45
23441364847,list_to_dict,"def list_to_dict(lst):
    d = {}
    for key, value in lst:
        if key in d:
            d[key].append(value)
        else:
            d[key] = [value]
    return d",45
42072918624,replace_with_power,"def replace_with_power(numbers):
    result = []
    for num in numbers:
        if num > 0:
            result.append(num ** 3)
        else:
            result.append(num ** 2)
    return result",45
73272116158,is_sorted_and_unique,"def is_sorted_and_unique(nums):
    for i in range(len(nums) - 1):
        if nums[i] >= nums[i + 1]:
            return False
    return len(nums) == len(set(nums))",45
27470837287,find_missing_number,"def find_missing_number(nums): 
    n = len(nums) + 1
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",45
3685052834,isPowerOfThree,"def isPowerOfThree(n: int) -> bool:
    if n <= 0:
        return False
    while n % 3 == 0:
        n /= 3
    return n == 1",45
1186165254,square_or_cube,"def square_or_cube(lst):
    result = []
    for num in lst:
        if num >= 0:
            result.append(num ** 2)
        else:
            result.append(num ** 3)
    return result",45
73203105979,calculate_Tiling,"def calculate_Tiling(n): 
    if (n == 0 or n == 1): 
        return 1
    return calculate_Tiling(n - 1) + calculate_Tiling(n - 2)",45
31952957814,count_elements,"def count_elements(lst):
    freq = {}
    for elem in lst:
        if elem in freq:
            freq[elem] += 1
        else:
            freq[elem] = 1
    return freq",45
27551274515,find_largest_power_of_two,"def find_largest_power_of_two(n):
    if n == 0:
        return 0
    power = 1
    while power * 2 <= n:
        power *= 2
    return power",45
20094350065,subtract_until_less,"def subtract_until_less(a, b):
    if a > b:
        return 0
    cnt = 0
    while b >= a:
        b -= a
        cnt += 1
    return cnt",45
31836236711,find_min_recursive,"def find_min_recursive(nums, index=0):
    if index == len(nums) - 1:
        return nums[index]
    else:
        return min(nums[index], find_min_recursive(nums, index + 1))",45
2309784544,find_missing_element,"def find_missing_element(original, shuffled):
    original.sort()
    shuffled.sort()
    for i in range(len(shuffled)):
        if original[i] != shuffled[i]:
            return original[i]
    return original[-1]",45
26650250553,number_frequency,"def number_frequency(num_list):
    freq = {}
    for num in num_list:
        if num in freq:
            freq[num] += 1
        else:
            freq[num] = 1
    return freq",45
38424818911,second_max,"def second_max(lst):
    if len(lst) < 2:
        return None
    lst = list(set(lst))
    if len(lst) < 2:
        return None
    return sorted(lst)[-2]",45
22747356545,find_common_elements,"def find_common_elements(list1, list2):
    unique_elements = []
    for element in list1:
        if element in list2 and element not in unique_elements:
            unique_elements.append(element)
    return unique_elements",45
33624597429,sum_Digits,"def sum_Digits(n) :
    sum = 0
    while (n != 0) :
        sum = sum + n % 10
        n = n // 10
    return sum",45
80272710,product_of_largest_two,"def product_of_largest_two(nums):
    if len(nums) < 2:
        return -1
    nums.sort()
    return max(nums[-1]*nums[-2],nums[0]*nums[1])",45
36423590156,BinaryToDecimal,"def BinaryToDecimal(binary):
    binary = str(binary)[::-1]
    decimal = 0
    for i in range(len(binary)):
        decimal += int(binary[i]) * 2**i
    return decimal",45
21290394907,find_anagrams,"def find_anagrams(words, target):
    target_sorted = sorted(target)
    anagrams = []
    for word in words:
        if sorted(word) == target_sorted:
            anagrams.append(word)
    return anagrams",45
10737960190,group_anagrams,"from collections import defaultdict

def group_anagrams(strs):
    anagrams = defaultdict(list)
    for word in strs:
        anagrams[''.join(sorted(word))].append(word)
    return list(anagrams.values())",45
525094449,find_common_elements,"def find_common_elements(list1, list2):
    common_elements = []
    for i in list1:
        if i in list2 and i not in common_elements:
            common_elements.append(i)
    return common_elements",45
22633392364,isPowerOfTwo,"def isPowerOfTwo(n: int) -> bool:
    if n < 1:
        return False
    while n % 2 == 0:
        n /= 2
    return n == 1",45
72565142594,is_power_of_base,"def is_power_of_base(n, base):
    if n <= 0 or base <= 1:
        return False
    while n % base == 0:
        n /= base
    return n == 1",45
20004699651,missing_number,"def missing_number(nums):
    n = len(nums) + 1
    total = n * (n + 1) // 2
    sum_of_nums = sum(nums)
    return total - sum_of_nums",45
13641931955,sum_of_digits,"def sum_of_digits(number):
    sum = 0
    while(number > 0):
        digit = number % 10
        sum += digit
        number = number // 10
    return sum",45
23661402284,find_leader,"def find_leader(A):
    leader = A[-1]
    for i in range(len(A)-2, -1, -1):
        if A[i] > leader:
            leader = A[i]
    return leader",45
25102312408,find_Missing_Number,"def find_Missing_Number(nums):
    n = len(nums) + 1
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",45
33621443108,find_common_elements,"def find_common_elements(lst1, lst2):
    common_elements = []
    for element in lst1:
        if element in lst2 and element not in common_elements:
            common_elements.append(element)
    return common_elements",45
72203641490,most_frequent,"from collections import Counter

def most_frequent(arr):
    counter = Counter(arr)
    max_count = max(counter.values())
    return min([k for k, v in counter.items() if v == max_count])",44
28361867544,largest_of_three,"def largest_of_three(a, b, c):
    if a >= b and a >= c:
        return a
    elif b >= a and b >= c:
        return b
    else:
        return c",44
30111792689,smallest_common_multiple,"def smallest_common_multiple(a, b):
    def gcd(x, y):
        while(y):
            x, y = y, x % y
        return x
    return (a*b)//gcd(a,b)",44
874939898,smallest_common_multiple,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def smallest_common_multiple(x, y):
    return x * y // gcd(x, y)",44
33623962589,flatten_list,"def flatten_list(nested_list):
    result = []
    for i in nested_list:
        if isinstance(i, list):
            result.extend(flatten_list(i))
        else:
            result.append(i)
    return result",44
73562811409,twoSum,"def twoSum(nums, target):
        cache = {}
        for i, num in enumerate(nums):
            if target - num in cache:
                return [cache[target - num], i]
            cache[num] = i",44
70341297391,max_nested_list,"def max_nested_list(lst):
    max_depth = [1]
    for i in lst:
        if isinstance(i, list):
            max_depth.append(1 + max_nested_list(i))
    return max(max_depth)",44
12187608263,check_Perfect_Square,"import math
def check_Perfect_Square(num):
    root = math.sqrt(num)
    if int(root + 0.5) ** 2 == num:
        return True
    else:
        return False",44
5907109108,remove_vowels,"def remove_vowels(input_string):
    vowels = 'aeiouAEIOU'
    result = ''
    for char in input_string:
        if char not in vowels:
            result += char
    return result",44
32167214699,sum_nested_list,"def sum_nested_list(lst):
    total = 0
    for element in lst:
        if isinstance(element, list):
            total += sum_nested_list(element)
        else:
            total += element
    return total",44
71238503146,find_kth_smallest,"import heapq

def find_kth_smallest(nums, k):
    heapq.heapify(nums)
    for _ in range(k - 1):
        heapq.heappop(nums)
    return heapq.heappop(nums)",44
28293421364,count_strings,"def count_strings(lst):
    count = 0
    for s in lst:
        if len(s) >= 2 and s[0] == s[-1]:
            count += 1
    return count",44
31564283395,find_substring_position,"def find_substring_position(s, sub):
    for i in range(len(s) - len(sub) + 1):
        if s[i:i+len(sub)] == sub:
            return i
    return -1",44
40489295716,check_if_pangram,"def check_if_pangram(sentence: str) -> bool:
    for i in range(97, 123):
        if chr(i) not in sentence.lower():
            return False
    return True",44
19881569279,count_strings,"def count_strings(lst):
    count = 0
    for s in lst:
        if len(s) > 1 and s[0] == s[-1]:
            count += 1
    return count",44
10785598895,count_ways,"def count_ways(n):
    a, b = 1, 2
    for _ in range(3, n + 1):
        a, b = b, a + b
    return b",44
1933921225,find_next_larger,"def find_next_larger(lst, num):
    result = None
    for i in lst:
        if i > num:
            if result is None or i < result:
                result = i
    return result",44
43297807760,substrings,"def substrings(s):
    result = []
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            result.append(s[i:j])
    return result",44
12206727424,num_of_divisors,"def num_of_divisors(n):
    count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            count += 1
    return count",44
21881268054,find_longest_length,"def find_longest_length(list_of_strings):
    max_length = 0
    for string in list_of_strings:
        if len(string) > max_length:
            max_length = len(string)
    return max_length",44
43092871851,smallest_pos,"def smallest_pos(list1): 
    min = list1[0] 
    for x in list1: 
        if x > 0 and x < min: 
             min = x  
    return min",44
22474409562,max_product_pair,"def max_product_pair(arr):
    if len(arr) < 2:
        return None

    arr.sort()
    return max(arr[0] * arr[1], arr[-1] * arr[-2])",44
33527736963,count_vowels,"def count_vowels(s):
    vowels = 'aeiouAEIOU'
    count = 0
    for char in s:
        if char in vowels:
            count += 1
    return count",44
9965726149,find_char_frequency,"def find_char_frequency(str):
    d = {}
    for i in str:
        if i in d:
            d[i] += 1
        else:
            d[i] = 1
    return d",44
17724170755,fib_seq,"def fib_seq(n):
    fib = [0, 1]
    while fib[-1] + fib[-2] < n:
        fib.append(fib[-1] + fib[-2])
    return fib",44
26740450560,fib_memo,"from functools import cache

@cache
def fib_memo(n):
    if n <= 1:
        return n
    return fib_memo(n - 1) + fib_memo(n - 2)",44
1469608348,third_smallest,"def third_smallest(list1):
    unique_list = list(set(list1))
    unique_list.sort()
    if len(unique_list) >= 3:
        return unique_list[2]
    else:
        return None",44
14035583464,string_frequencies,"def string_frequencies(strings):
    frequencies = {}
    for string in strings:
        if string in frequencies:
            frequencies[string] += 1
        else:
            frequencies[string] = 1
    return frequencies",44
37304191248,smallest_common_multiple,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def smallest_common_multiple(x, y):
    return x * y // gcd(x, y)",44
20527986940,char_occurrences,"def char_occurrences(string):
  occurrences = {}
  for char in string:
    if char in occurrences:
      occurrences[char] += 1
    else:
      occurrences[char] = 1
  return occurrences",44
31464575939,most_frequent_elements,"from collections import Counter

def most_frequent_elements(lst):
    counter = Counter(lst)
    max_freq = max(counter.values())
    return [item for item, freq in counter.items() if freq == max_freq]",44
29878825211,find_most_frequent,"from collections import Counter

def find_most_frequent(list1):
    count = Counter(list1)
    max_count = max(count.values())
    return [i for i in count if count[i] == max_count]",44
70901250387,min_operations,"from typing import List

def min_operations(nums: List[int]) -> int:
    nums.sort()
    median = nums[len(nums) // 2]
    return sum(abs(num - median) for num in nums)",44
24460956333,find_missing,"def find_missing(nums):
    n = len(nums) + 1
    total = n * (n+1) // 2
    sum_of_nums = sum(nums)
    return total - sum_of_nums",44
40444310524,Check_Palindrome,"def Check_Palindrome(s):
    s = s.replace("" "", """") # remove spaces
    s = s.lower() # convert to lower case
    return s == s[::-1] # compare with reverse string",44
74960151998,most_common_word,"import re
from collections import Counter

def most_common_word(s):
    words = re.findall(r'\b\w+\b', s.lower())
    return Counter(words).most_common(1)[0][0]",44
25071670078,count_vowels,"def count_vowels(s):
    vowels = 'aeiouAEIOU'
    count = 0
    for char in s:
        if char in vowels:
            count += 1
    return count",44
14790535154,sum_multiples,"def sum_multiples(numbers):
    total = 0
    for number in numbers:
        if number % 3 == 0 or number % 5 == 0:
            total += number
    return total",44
37678142031,most_frequent_element,"from collections import Counter

def most_frequent_element(lst):
    count = Counter(lst)
    max_freq = max(count.values())
    for element in lst:
        if count[element] == max_freq:
            return element",44
44877964084,snake_to_camel,"def snake_to_camel(snake_str):
    components = snake_str.split('_')
    # Capitalize the first letter of each component and join them together
    return ''.join(x.title() for x in components)",44
73881327931,count_vowels,"def count_vowels(s):
    vowels = ""aeiouAEIOU""
    count = 0
    for char in s:
        if char in vowels:
            count += 1
    return count",44
14846110616,reverse_Bits,"def reverse_Bits(n):
    result = 0
    for i in range(32):
        result <<= 1
        result |= n & 1
        n >>= 1
    return result",44
24098442706,count_target_2D_list,"def count_target_2D_list(lst, target):
    count = 0
    for row in lst:
        for elem in row:
            if elem == target:
                count += 1
    return count",44
16163695408,num_of_digits,"def num_of_digits(n):
    if n == 0:
        return 1
    elif n < 0:
        return len(str(n)) - 1
    else:
        return len(str(n))",44
8289774598,count_set_bits,"def count_set_bits(A):
    count = 0
    while A:
        A &= A-1
        count += 1
    return count % 1000000007",44
42237057022,find_most_frequent,"from collections import Counter


def find_most_frequent(lst):
    counter = Counter(lst)
    max_count = max(counter.values())
    for element in lst:
        if counter[element] == max_count:
            return element",44
72889370357,find_Maximum,"def find_Maximum(a, b, c):
    if a >= b and a >= c:
        return a
    elif b >= a and b >= c:
        return b
    else:
        return c",44
12584648593,missingNumber,"def missingNumber(arr):
    n = len(arr) + 1
    total = n * (n+1) // 2
    sum_of_arr = sum(arr)
    return total - sum_of_arr",44
23173251265,missingNumber,"def missingNumber(nums):
    n = len(nums) + 1
    total = n * (n+1) // 2
    sum_of_nums = sum(nums)
    return total - sum_of_nums",44
6646114064,check_pattern,"import re

def check_pattern(string):
    text = re.compile(r""^[A-Z][a-z]+[0-9]+$"")
    if text.match(string):
        return True
    else:
        return False",44
1803733061,remove_vowels,"def remove_vowels(input_string):
    vowels = 'aeiouAEIOU'
    result = ''
    for char in input_string:
        if char not in vowels:
            result += char
    return result",44
13978510780,unique_chars_count,"def unique_chars_count(s):
    return len(set(s))

print(unique_chars_count(""hello"")) # 4
print(unique_chars_count(""apple"")) # 4
print(unique_chars_count(""banana"")) # 3",44
41695004864,find_second_smallest,"def find_second_smallest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return None
    else:
        unique_numbers.sort()
        return unique_numbers[1]",44
20736577275,first_repeated_char,"def first_repeated_char(s: str) -> str:
    char_set = set()
    for char in s:
        if char in char_set:
            return char
        char_set.add(char)
    return None",44
72442555704,series_sum,"def series_sum(n):
    sum_series = 0
    num = str(n)
    for i in range(1, n + 1):
        sum_series += int(num * i)
    return sum_series",44
40994389863,missing_number,"def missing_number(nums):
    n = len(nums) + 1
    total = n * (n + 1) // 2
    sum_nums = sum(set(nums))
    return total - sum_nums",44
8035432488,count_word_occurrences,"def count_word_occurrences(sentences, word):
    word_count = 0
    for sentence in sentences:
        words = sentence.lower().split()
        word_count += words.count(word.lower())
    return word_count",44
8880287265,find_lcm,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def find_lcm(a, b):
    return a * b // gcd(a, b)",44
5259009851,count_vowels,"def count_vowels(s):
  vowels = 'aeiouAEIOU'
  count = 0
  for char in s:
    if char in vowels:
      count += 1
  return count",44
38218478879,find_smallest,"def find_smallest(numbers):
    if not numbers:
        return None
    smallest = numbers[0]
    for num in numbers[1:]:
        if num < smallest:
            smallest = num
    return smallest",44
28674855363,find_anagrams,"def find_anagrams(word, word_list):
    sorted_word = sorted(word)
    result = []
    for w in word_list:
        if sorted(w) == sorted_word:
            result.append(w)
    return result",44
24008730710,lcm,"def gcd(n, m):
    while m != 0:
        n, m = m, n % m
    return n

def lcm(n, m):
    return n * m // gcd(n,m)",44
26568198455,removeSmallest,"def removeSmallest(numbers):
    if not numbers:
        return []
    min_value = min(numbers)
    min_index = numbers.index(min_value)
    return numbers[:min_index] + numbers[min_index+1:]",44
5663685033,remove_consecutive_duplicates,"def remove_consecutive_duplicates(lst):
    result = []
    for i in range(len(lst)):
        if i == 0 or lst[i] != lst[i-1]:
            result.append(lst[i])
    return result",44
15630130399,sort_even_indices,"def sort_even_indices(nums):
    even_nums = sorted(nums[::2])
    for i in range(0, len(nums), 2):
        nums[i] = even_nums.pop(0)
    return nums",44
73388250673,int_to_binary,"def int_to_binary(n):
    binary = []
    while n > 0:
        binary.append(str(n % 2))
        n = n // 2
    binary.reverse()
    return ''.join(binary)",44
21052388570,calculate_average,"def calculate_average(numbers):
    return sum(numbers) / len(numbers)

# Refactored function using map
def calculate_average_map(numbers):
    return map(lambda x: sum(numbers) / len(numbers), [1])",44
29523712713,set_intersection,"def set_intersection(set1, set2):
    result = []
    for element in set1:
        if element in set2 and element not in result:
            result.append(element)
    result.sort()
    return result",44
39325209711,find_frequent_characters,"from collections import Counter

def find_frequent_characters(s):
    counter = Counter(s)
    max_freq = max(counter.values())
    return [char for char, freq in counter.items() if freq == max_freq]",44
17190709211,generate_n_grams,"def generate_n_grams(text, n):
    n_grams = []
    for i in range(len(text) - n + 1):
        n_grams.append(text[i:i+n])
    return n_grams",44
41342442026,check_intervals,"def check_intervals(intervals):
    intervals.sort()
    for i in range(1, len(intervals)):
        if intervals[i][0] < intervals[i-1][1]:
            return False
    return True",44
24485454232,fibonacci,"def fibonacci(n):
  fib_sequence = [0, 1]
  while len(fib_sequence) < n:
    fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
  return fib_sequence",44
37283059568,convert_to_military_time,"def convert_to_military_time(time):
    hour = time // 100
    minute = time % 100
    return f""{hour}:{str(minute).zfill(2)}""",44
22369513431,max_element,"def max_element(arr):
    max_val = arr[0]
    for i in range(1, len(arr)):
        if arr[i] > max_val:
            max_val = arr[i]
    return max_val",44
11016924776,missing_Number,"def missing_Number(arr):
    n = len(arr) + 1
    total = n * (n+1) // 2
    sum_of_arr = sum(arr)
    return total - sum_of_arr",44
70630774791,most_frequent_elements,"from collections import Counter

def most_frequent_elements(lst):
    counter = Counter(lst)
    max_freq = max(counter.values())
    return [num for num, freq in counter.items() if freq == max_freq]",44
36199639935,count_words,"def count_words(string):
    words = {}
    for word in string.split():
        if word in words:
            words[word] += 1
        else:
            words[word] = 1
    return words",44
12647190075,max_length_word,"def max_length_word(sentence):
    words = sentence.split(' ')
    max_length = max(len(word) for word in words)
    longest_word = max(words, key=lambda i: len(i))
    return max_length",44
28964388204,longest_string,"def longest_string(strings):
    if not strings:
        return """"
    longest = strings[0]
    for string in strings:
        if len(string) > len(longest):
            longest = string
    return longest",44
25875533839,most_frequent_elements,"from collections import Counter

def most_frequent_elements(li):
    counter = Counter(li)
    max_count = max(counter.values())
    return [item for item, count in counter.items() if count == max_count]",44
15003798293,fibonacci_series,"def fibonacci_series(n):
    fib = [0, 1]
    while fib[-1] + fib[-2] < n:
        fib.append(fib[-1] + fib[-2])
    return fib",44
38339309941,is_palindrome_ignore_special,"import re

def is_palindrome_ignore_special(s: str) -> bool:
    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()
    return s == s[::-1]",44
72887218771,get_kth_digit,"def get_kth_digit(num, k):
    digits = [int(d) for d in str(num)]
    if len(digits) < k:
        return -1
    else:
        return digits[-k]",44
35621315945,find_sublist_count,"def find_sublist_count(lst, sublist):
    count = 0
    for i in range(len(lst)):
        if lst[i:i+len(sublist)] == sublist:
            count += 1
    return count",44
29491445423,modes,"from collections import Counter

def modes(nums):
    num_counts = Counter(nums)
    max_count = max(num_counts.values())
    return [num for num, count in num_counts.items() if count == max_count]",44
38047242100,binary_to_decimal,"def binary_to_decimal(binary_string):
    decimal = 0
    for i in range(len(binary_string)):
        decimal += int(binary_string[i]) * 2**(len(binary_string)-1-i)
    return decimal",44
24098214056,string_occurrences,"def string_occurrences(strings):
    occurrences = {}
    for s in strings:
        if s in occurrences:
            occurrences[s] += 1
        else:
            occurrences[s] = 1
    return occurrences",44
42426393386,most_frequent,"from collections import Counter
def most_frequent(nums):
    freq = Counter(nums)
    max_count = max(freq.values())
    for key, value in freq.items():
        if value == max_count:
            return key",44
72651283236,find_max_value,"def find_max_value(records, key):
    max_value = records[0][key]
    for record in records:
        if record[key] > max_value:
            max_value = record[key]
    return max_value",44
899443289,word_frequency,"import re

def word_frequency(text):
    text = text.lower()
    words = re.findall(r'\b\w+\b', text)
    return {word: words.count(word) for word in set(words)}",44
20789359341,single_number,"def single_number(nums):
    """"""
    :type nums: List[int]
    :rtype: int
    """"""
    a = 0
    for i in nums:
        a ^= i
    return a",43
11467158637,kth_smallest,"import heapq

def kth_smallest(arr, k):
    heapq.heapify(arr)
    for _ in range(k - 1):
        heapq.heappop(arr)
    return heapq.heappop(arr)",43
32033142609,highest_product,"def highest_product(arr):
    if len(arr) < 2:
        return None
    
    arr.sort()
    return max(arr[-1] * arr[-2], arr[0] * arr[1])",43
32418675978,intersect,"from typing import List

def intersect(nums1: List[int], nums2: List[int]) -> List[int]:
    intersection = list(set(nums1) & set(nums2))
    intersection.sort()
    return intersection",43
4151836272,sort_even,"def sort_even(arr):
    even_list = sorted(arr[::2])
    return [even_list.pop(0) if i % 2 == 0 else arr[i] for i in range(len(arr))]",43
28476099579,count_divisors,"def count_divisors(n):
    count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            count += 1
    return count",43
9465569809,find_most_frequent,"from collections import Counter

def find_most_frequent(lst):
    counter = Counter(lst)
    most_common = counter.most_common(1)
    return most_common[0][0] if most_common else None",43
2128598207,character_frequency,"def character_frequency(s):
    frequency = {}
    for char in s:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return frequency",43
24333733236,smallest_difference,"def smallest_difference(x,y,z):
  diff1 = abs(x-y)
  diff2 = abs(y-z)
  diff3 = abs(x-z)
  return min(diff1, diff2, diff3)",43
72420404393,remove_odd,"def remove_odd(nums):
    """"""
    Takes a list of integers and returns a new list with the odd numbers removed.
    """"""
    return [num for num in nums if num % 2 == 0]",43
69884539198,min_steps,"def min_steps(arr):
    arr.sort()
    median = arr[len(arr) // 2]
    steps = 0
    for i in arr:
        steps += abs(i - median)
    return steps",43
24662453378,count_frequency,"def count_frequency(s):
    frequency = {}
    for char in s:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return frequency",43
34074897704,all_substrings,"def all_substrings(input_string):
    length = len(input_string)
    return [input_string[i: j] for i in range(length) for j in range(i + 1, length + 1)]",43
38322978230,find_palindromes,"def find_palindromes(words):
    palindromes = []
    for word in words:
        if word == word[::-1]:
            palindromes.append(word)
    return palindromes",43
34057499408,find_duplicates,"def find_duplicates(lst):
    seen = set()
    duplicates = set()
    for element in lst:
        if element in seen:
            duplicates.add(element)
        else:
            seen.add(element)
    return duplicates",43
11835402655,divisors_of,"def divisors_of(n):
    divisors = []
    for i in range(1, n + 1):
        if n % i == 0:
            divisors.append(i)
    return divisors",43
70616889729,max_Product_Of_Three,"def max_Product_Of_Three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",43
3512437332,can_destroy_all_asteroids,"def can_destroy_all_asteroids(mass, asteroids):
    asteroids.sort()
    for asteroid in asteroids:
        if mass >= asteroid:
            mass += asteroid
        else:
            return False
    return True",43
32105468642,count_strings,"def count_strings(lst):
    result = {}
    for word in lst:
        if word in result:
            result[word] += 1
        else:
            result[word] = 1
    return result",43
23038465746,frequent_element,"from collections import Counter

def frequent_element(arr):
    counter = Counter(arr)
    max_count = max(list(counter.values()))
    for k,v in counter.items():
        if v == max_count:
            return k",43
35261167325,find_largest_number,"def find_largest_number(numbers):
    if not numbers:
        return None
    largest = numbers[0]
    for number in numbers:
        if number > largest:
            largest = number
    return largest",43
1981253754,string_count,"def string_count(lst):
    result = {}
    for string in lst:
        if string in result:
            result[string] += 1
        else:
            result[string] = 1
    return result",43
16184449332,second_largest_in_list,"def second_largest_in_list(lst):
    unique_nums = set(lst)
    if len(unique_nums) < 2:
        return None
    unique_nums.remove(max(unique_nums))
    return max(unique_nums)",43
6761317945,common_sorted_elements,"def common_sorted_elements(list1, list2):
    set1 = set(list1)
    set2 = set(list2)
    common_elements = list(set1.intersection(set2))
    return sorted(common_elements)",43
38186899131,word_frequency,"def word_frequency(words):
    frequency = {}
    for word in words:
        if word in frequency:
            frequency[word] += 1
        else:
            frequency[word] = 1
    return frequency",43
25792130874,sum_of_divisors,"def sum_of_divisors(n):
    sum = 0
    for i in range(1, n + 1):
        if n % i == 0:
            sum += i
    return sum",43
2739881595,char_frequency,"def char_frequency(string):
  freq = {}
  for i in string:
    if i in freq:
      freq[i] += 1
    else:
      freq[i] = 1
  return freq",43
33783270390,is_Palindrome_Ignore_Case_Spaces_Punctuation,"import re

def is_Palindrome_Ignore_Case_Spaces_Punctuation(s):
    s = re.sub(r'[\W_]+', '', s).lower()
    return s == s[::-1]",43
8379640277,remove_duplicate_tuples,"def remove_duplicate_tuples(test_list):
    seen = set()
    res = []
    for item in test_list:
        if item not in seen:
            seen.add(item)
            res.append(item)
    return res",43
23266328593,count_paths,"def count_paths(m, n):
    if m == 1 or n == 1:
        return 1
    return count_paths(m-1, n) + count_paths(m, n-1)",43
42089941302,string_frequency,"def string_frequency(strings):
    frequency = {}
    for string in strings:
        if string in frequency:
            frequency[string] += 1
        else:
            frequency[string] = 1
    return frequency",43
2288906969,reverse_string_stack,"def reverse_string_stack(input_string):
    stack = []
    for char in input_string:
        stack.append(char)
    reversed_string = """"
    while stack:
        reversed_string += stack.pop()
    return reversed_string",43
37383900515,clean_string,"import string

def clean_string(s):
    translator = str.maketrans('', '', string.digits + string.punctuation)
    cleaned_string = s.translate(translator).lower().strip()
    return cleaned_string",43
3765357938,sumOfDigits,"def sumOfDigits(number):
    sumDigits = 0
    while number > 0:
        sumDigits += number % 10
        number = number // 10
    return sumDigits",43
28291312404,find_divisors,"def find_divisors(num):
    divisors = []
    for i in range(1, num + 1):
        if num % i == 0:
            divisors.append(i)
    return divisors",43
27970504397,count_elements,"def count_elements(nums):
    frequency = {}
    for num in nums:
        if num in frequency:
            frequency[num] += 1
        else:
            frequency[num] = 1
    return frequency",43
27333224750,find_palindromes,"def find_palindromes(words):
    palindromes = []
    for word in words:
        if word == word[::-1]:
            palindromes.append(word)
    return palindromes",43
40257956127,find_largest_number,"def find_largest_number(arr, n):
    largest = arr[0]
    for i in range(1, n):
        if arr[i] > largest:
            largest = arr[i]
    return largest",43
72077039224,largest_prime_factor,"def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n",43
72042585567,kth_smallest_element,"import heapq

def kth_smallest_element(arr, k):
    heapq.heapify(arr)
    for _ in range(k-1):
        heapq.heappop(arr)
    return heapq.heappop(arr)",43
18523155151,character_frequency,"def character_frequency(string):
    frequency = {}
    for char in string:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return frequency",43
2323243384,character_frequency,"def character_frequency(s):
    frequency = {}
    for char in s:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return frequency",43
23558118192,get_largest_number,"def get_largest_number(nums):
    if not nums:
        return None
    largest = nums[0]
    for num in nums:
        if num > largest:
            largest = num
    return largest",43
40613772365,is_palindrome_enhanced,"import re

def is_palindrome_enhanced(s):
    cleaned_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()
    return cleaned_s == cleaned_s[::-1]",43
73928530812,is_concat_possible,"def is_concat_possible(str1, str2, concat_str):
    if str1 + str2 == concat_str or str2 + str1 == concat_str:
        return True
    else:
        return False",43
24942897535,find_most_common,"from collections import Counter

def find_most_common(lst):
    counter = Counter(lst)
    max_count = max(counter.values())
    for element in lst:
        if counter[element] == max_count:
            return element",43
40448023359,max_length_strings,"def max_length_strings(lst):
    if not lst:
        return []
    max_len = max(len(s) for s in lst)
    return [s for s in lst if len(s) == max_len]",43
32430299812,largest_prime_factor,"def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n",43
18481122105,findKthSmallest,"import heapq

def findKthSmallest(nums, k):
    heapq.heapify(nums)
    for _ in range(k-1):
        heapq.heappop(nums)
    return heapq.heappop(nums)",43
25793012506,sum_of_squares,"def sum_of_squares(n):
    sum_squares = 0
    for i in range(1, n + 1):
        sum_squares += i ** 2
    return sum_squares",43
41793114095,frequency_counter,"def frequency_counter(arr):
    frequency = {}
    for item in arr:
        if item in frequency:
            frequency[item] += 1
        else:
            frequency[item] = 1
    return frequency",43
26952667878,is_perfect_square,"import math

def is_perfect_square(num):
    if num < 0:
        return False
    root = math.sqrt(num)
    return int(root + 0.5) ** 2 == num",43
5809004561,largest_prime_factor,"def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n",43
27342174594,find_largest_number,"def find_largest_number(numbers):
    if not numbers:
        return None
    largest = numbers[0]
    for number in numbers:
        if number > largest:
            largest = number
    return largest",43
40994279573,find_duplicates,"def find_duplicates(lst):
    seen = set()
    duplicates = set()
    for i in lst:
        if i in seen:
            duplicates.add(i)
        seen.add(i)
    return list(duplicates)",43
31556545504,most_common,"from collections import Counter

def most_common(lst):
    counter = Counter(lst)
    max_count = max(list(counter.values()))
    for num in lst:
        if counter[num] == max_count:
            return num",43
42879327594,largest_prime_factor,"def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n",43
69880475551,string_frequency,"def string_frequency(strings):
    frequency = {}
    for string in strings:
        if string in frequency:
            frequency[string] += 1
        else:
            frequency[string] = 1
    return frequency",43
37217374431,extract_unique,"def extract_unique(lst):
    seen = set()
    unique_list = []
    for num in lst:
        if num not in seen:
            unique_list.append(num)
            seen.add(num)
    return unique_list",43
21258043471,sum_of_series,"def sum_of_series(n):
    sum = 0.0
    for i in range(1, n + 1):
        sum += 1.0 / (i * i)
    return sum",43
30149267961,palindrome_checker,"def palindrome_checker(s):
    # Reverse the string
    reversed_s = s[::-1]
    # If the original string is equal to the reversed string, it's a palindrome
    return s == reversed_s",43
13924570621,char_count,"def char_count(s):
    count = {}
    for char in s:
        if char in count:
            count[char] += 1
        else:
            count[char] = 1
    return count",43
32486465459,exchange_first_last,"def exchange_first_last(input_string):
    if len(input_string) <= 1:
        return input_string
    return input_string[-1] + input_string[1:-1] + input_string[0]",43
28463114200,swap_first_last,"def swap_first_last(str1):
  if len(str1) <= 1:
    return str1
  return str1[-1] + str1[1:-1] + str1[0]",43
20676833833,find_largest_number,"def find_largest_number(numbers):
    if not numbers:
        return None
    largest = numbers[0]
    for number in numbers:
        if number > largest:
            largest = number
    return largest",43
3765610798,reverse_sum,"def reverse_sum(n):
  num = str(n)
  sum = 0
  for i in range(len(num)-1, -1, -1):
    sum += int(num[i])
  return sum",43
44461824687,char_frequency,"def char_frequency(string):
    frequency = {}
    for char in string:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return frequency",43
9499208834,char_count,"def char_count(s):
  result = {}
  for char in s:
    if char in result:
      result[char] += 1
    else:
      result[char] = 1
  return result",43
39171554894,average_of_evens,"def average_of_evens(numbers):
    evens = [num for num in numbers if num % 2 == 0]
    return sum(evens) / len(evens) if evens else 0",43
70045351864,count_paths,"def count_paths(m, n):
    if m == 1 or n == 1:
        return 1
    return count_paths(m-1, n) + count_paths(m, n-1)",43
12638573239,is_valid_palindrome,"import re

def is_valid_palindrome(s: str) -> bool:
    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()
    return s == s[::-1]",43
44733454363,number_to_base,"def number_to_base(n):
    binary = bin(n)[2:]
    octal = oct(n)[2:]
    hexadecimal = hex(n)[2:].upper()
    return (binary, octal, hexadecimal)",43
37808513024,sum_of_digits,"def sum_of_digits(number):
    sum_digits = 0
    while number > 0:
        sum_digits += number % 10
        number = number // 10
    return sum_digits",43
32122983024,catalan_number,"def catalan_number(n):
    result = 1
    for i in range(2, n + 1):
        result = result * (n + i) / i
    return int(result)",43
36770267178,is_perfect_square,"import math

def is_perfect_square(n):
    if n < 0:
        return False
    root = math.sqrt(n)
    return int(root + 0.5) ** 2 == n",43
18983196887,num_divisors,"def num_divisors(n):
    count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            count += 1
    return count",43
74935981227,is_valid_palindrome,"import re

def is_valid_palindrome(s: str) -> bool:
    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()
    return s == s[::-1]",43
4916721034,find_next_larger,"def find_next_larger(lst, num):
    greater_nums = [x for x in lst if x > num]
    if greater_nums:
        return min(greater_nums)
    else:
        return -1",43
40714142974,find_missing_number,"def find_missing_number(nums):
    n = len(nums)
    expected_sum = (n * (n + 1)) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum",43
37936676240,trailing_zeros,"def trailing_zeros(n):
    count = 0
    i = 5
    while n/i >= 1:
        count += int(n/i)
        i *= 5
    return int(count)",43
27238756137,largest_prime_factor,"def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n",43
26714197223,count_divisors,"def count_divisors(n):
    count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            count += 1
    return count",43
38726774181,is_valid_palindrome,"import re

def is_valid_palindrome(s: str) -> bool:
    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()
    return s == s[::-1]",43
15550759863,character_frequency,"def character_frequency(s):
    freq = {}
    for char in s:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1
    return freq",43
4100465890,count_divisors,"def count_divisors(num):
    count = 0
    for i in range(1, num + 1):
        if num % i == 0:
            count += 1
    return count",43
37413581432,min_steps_to_equal,"def min_steps_to_equal(arr):
    arr.sort()
    mid = arr[len(arr)//2]
    steps = 0
    for i in arr:
        steps += abs(i - mid)
    return steps",43
18158226467,combine_lists,"def combine_lists(list1, list2):
    if len(list1) != len(list2):
        return None
    return [(list1[i], list2[i]) for i in range(len(list1))]",43
18738879008,character_frequency,"def character_frequency(string):
    freq = {}
    for i in string:
        if i in freq:
            freq[i] += 1
        else:
            freq[i] = 1
    return freq",43
21817641803,character_frequency,"def character_frequency(string):
    frequency = {}
    for char in string:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return frequency",43
21278640419,num_divisors,"def num_divisors(n):
    count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            count += 1
    return count",43
33402389213,count_divisors,"def count_divisors(n):
    count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            count += 1
    return count",43
22003307723,character_count,"def character_count(s):
    count = {}
    for char in s:
        if char in count:
            count[char] += 1
        else:
            count[char] = 1
    return count",43
20101939649,count_digits,"def count_digits(n):
    if n == 0:
        return 1
    count = 0
    while n:
        n //= 10
        count += 1
    return count",43
24563773463,char_count,"def char_count(s):
    dic = {}
    for char in s:
        if char in dic:
            dic[char] += 1
        else:
            dic[char] = 1
    return dic",43
16821509271,char_frequency,"def char_frequency(string):
    freq = {}
    for i in string:
        if i in freq:
            freq[i] += 1
        else:
            freq[i] = 1
    return freq",43
15378059950,string_count,"def string_count(strings):
    counts = {}
    for string in strings:
        if string in counts:
            counts[string] += 1
        else:
            counts[string] = 1
    return counts",43
9237955726,unique_words_count,"def unique_words_count(sentences):
    result = {}
    for sentence in sentences:
        words = sentence.split()
        unique_words = set(words)
        result[sentence] = len(unique_words)
    return result",43
28619292833,count_frequency,"def count_frequency(s):
    freq = {}
    for char in s:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1
    return freq",43
71656100156,largest_prime_factor,"def largest_prime_factor(num):
    i = 2
    while i * i <= num:
        if num % i:
            i += 1
        else:
            num //= i
    return num",43
15251529557,topKFrequent,"from collections import Counter

def topKFrequent(nums, k):
    hashmap = Counter(nums)
    sortedMap = sorted(hashmap, key=hashmap.get, reverse=True)
    return sortedMap[:k]",43
72691165064,find_next_power_of_2,"def find_next_power_of_2(n):
    if n and not(n & (n - 1)):
        return n
    else:
        return 1 << (n - 1).bit_length()",43
3487992028,max_product_of_two,"def max_product_of_two(lst):
    if len(lst) < 2:
        return None
    lst.sort()
    return max(lst[-1]*lst[-2], lst[0]*lst[1])",43
12487154426,find_Missing_Number,"def find_Missing_Number(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    sum_of_nums = sum(nums)
    return total - sum_of_nums",43
73227734986,flatten,"def flatten(lst):
    flat_list = []
    for i in lst:
        if isinstance(i, list):
            flat_list.extend(flatten(i))
        else:
            flat_list.append(i)
    return flat_list",43
24735718048,largest_product,"def largest_product(arr):
    if len(arr) < 2:
        return None

    arr.sort()

    return max(arr[0] * arr[1], arr[-1] * arr[-2])",43
21820621019,check_perfect_square,"import math

def check_perfect_square(num):
    if num < 0:
        return False
    root = math.sqrt(num)
    return int(root + 0.5) ** 2 == num",43
17010479689,convert_base,"def convert_base(n, base):
    new_num = """"
    while n > 0:
        new_num = str(n % base) + new_num
        n = n // base
    return new_num",43
40836521637,char_count,"def char_count(s):
    result = {}
    for char in s:
        if char in result:
            result[char] += 1
        else:
            result[char] = 1
    return result",43
16142651919,string_frequency,"def string_frequency(strings):
    frequency = {}
    for string in strings:
        if string in frequency:
            frequency[string] += 1
        else:
            frequency[string] = 1
    return frequency",43
1418501807,sum_of_squares,"def sum_of_squares(n):
    sum_squares = 0
    for i in range(1, n + 1):
        sum_squares += i ** 2
    return sum_squares",43
9627471981,sum_odd_numbers,"def sum_odd_numbers(start, end):
    sum = 0
    for i in range(start, end+1):
        if i % 2 != 0:
            sum += i
    return sum",43
22516305547,largest_divisible,"def largest_divisible(list1, divisor):
    largest = -1
    for num in list1:
        if num % divisor == 0 and num > largest:
            largest = num
    return largest",43
8724733551,sum_of_cubes,"def sum_of_cubes(n):
    sum_of_cubes = 0
    for digit in str(n):
        sum_of_cubes += int(digit) ** 3
    return sum_of_cubes",43
38729778845,largest_prime_factor,"def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n",43
14093236710,count_characters,"def count_characters(s):
    freq = {}
    for char in s:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1
    return freq",43
25564655670,largest_prime_factor,"def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n",43
3410987490,max_nested_list,"def max_nested_list(lst):
    max_val = float('-inf')
    for sublist in lst:
        for num in sublist:
            if num > max_val:
                max_val = num
    return max_val",43
26816979353,char_count,"def char_count(s):
    result = {}
    for char in s:
        if char in result:
            result[char] += 1
        else:
            result[char] = 1
    return result",43
16735442504,find_palindromes,"def find_palindromes(words):
    palindromes = []
    for word in words:
        if word == word[::-1]:
            palindromes.append(word)
    return palindromes",43
12163043201,reverse_bits,"def reverse_bits(n):
    res = 0
    for i in range(32):
        res <<= 1
        res |= n & 1
        n >>= 1
    return res",43
4138982841,reverse_and_remove_non_alpha,"def reverse_and_remove_non_alpha(s: str) -> str:
    alpha_str = """"
    for char in s:
        if char.isalpha():
            alpha_str += char
    return alpha_str[::-1]",43
24810694708,count_strings,"def count_strings(lst):
    result = {}
    for string in lst:
        if string in result:
            result[string] += 1
        else:
            result[string] = 1
    return result",43
32793424685,find_modes,"from collections import Counter

def find_modes(numbers):
    counts = Counter(numbers)
    max_count = max(counts.values())
    return [num for num, count in counts.items() if count == max_count]",43
40596214762,char_frequency,"def char_frequency(string):
    freq = {}
    for char in string:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1
    return freq",43
41413570149,list_to_dict,"def list_to_dict(keys, values, multipliers):
    result = {}
    for key, value, multiplier in zip(keys, values, multipliers):
        result[key] = value * multiplier
    return result",43
21292291357,num_divisors,"def num_divisors(n):
    count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            count += 1
    return count",43
1520271393,power_of_two,"def power_of_two(n):
    i = 1
    while i < n:
        i *= 2
    if i > n:
        return i // 2
    else:
        return i",43
35849803729,find_closest,"def find_closest(lst, target):
    closest = lst[0]
    for num in lst:
        if abs(num - target) < abs(closest - target):
            closest = num
    return closest",43
27803046582,string_count,"def string_count(lst):
    result = {}
    for s in lst:
        if s in result:
            result[s] += 1
        else:
            result[s] = 1
    return result",43
70473290649,word_frequency,"def word_frequency(words):
  frequency = {}
  for word in words:
    if word in frequency:
      frequency[word] += 1
    else:
      frequency[word] = 1
  return frequency",43
4728732077,character_count,"def character_count(s):
    dict = {}
    for char in s:
        if char in dict:
            dict[char] += 1
        else:
            dict[char] = 1
    return dict",43
25465604600,remove_duplicates_preserve_order,"def remove_duplicates_preserve_order(lst):
    seen = set()
    result = []
    for item in lst:
        if item not in seen:
            seen.add(item)
            result.append(item)
    return result",43
19852562863,kth_smallest_element,"import heapq

def kth_smallest_element(nums, k):
    heapq.heapify(nums)
    for _ in range(k-1):
        heapq.heappop(nums)
    return heapq.heappop(nums)",43
5489466949,is_valid_number,"def is_valid_number(s):
    try:
        if '.' in s or 'e' in s:
            float(s)
        else:
            int(s)
        return True
    except ValueError:
        return False",43
7470026773,find_kth_smallest,"import heapq

def find_kth_smallest(nums, k):
    heapq.heapify(nums)
    for _ in range(k-1):
        heapq.heappop(nums)
    return heapq.heappop(nums)",43
73696191339,most_common_char,"from collections import Counter

def most_common_char(s):
    counter = Counter(s)
    max_count = max(counter.values())
    for char in s:
        if counter[char] == max_count:
            return char",43
23249394614,character_count,"def character_count(s):
    dict = {}
    for char in s:
        if char in dict:
            dict[char] += 1
        else:
            dict[char] = 1
    return dict",43
73438523384,max_product_three,"def max_product_three(nums):
    nums = sorted(nums)
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",43
9114755605,find_missing_element,"def find_missing_element(A):
    n = len(A)
    total = (n + 1)*(n + 2)/2
    sum_of_A = sum(A)
    return total - sum_of_A",43
30343205447,move_zeros,"def move_zeros(arr):
  non_zero = [num for num in arr if num != 0]
  zeros = [0] * (len(arr) - len(non_zero))
  return non_zero + zeros",43
27331062654,string_list_to_dict,"def string_list_to_dict(lst):
    result = {}
    for i, s in enumerate(lst):
        if s not in result:
            result[s] = []
        result[s].append(i)
    return result",43
47622697769,min_steps,"def min_steps(nums):
    nums.sort()
    median = nums[len(nums) // 2]
    steps = 0
    for num in nums:
        steps += abs(num - median)
    return steps",43
70684353345,find_missing,"def find_missing(nums):
    n = len(nums) + 1
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",43
30194646389,string_count,"def string_count(strings):
    counts = {}
    for string in strings:
        if string in counts:
            counts[string] += 1
        else:
            counts[string] = 1
    return counts",43
31676738240,check_perfect_square,"import math

def check_perfect_square(num):
    if num < 0:
        return False
    root = math.sqrt(num)
    return int(root + 0.5) ** 2 == num",43
4730890534,character_frequency,"def character_frequency(string):
    frequency = {}
    for char in string:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return frequency",43
3707981004,largest_prime_factor,"def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n",43
41073498768,find_kth_smallest,"import heapq

def find_kth_smallest(arr, k):
    heapq.heapify(arr)
    for _ in range(k-1):
        heapq.heappop(arr)
    return heapq.heappop(arr)",43
188805574,product_of_digits,"def product_of_digits(number):
    product = 1
    while number > 0:
        digit = number % 10
        product *= digit
        number //= 10
    return product",43
6912625424,largest_divisible_by_3,"def largest_divisible_by_3(nums):
    largest = -1
    for num in nums:
        if num % 3 == 0 and num > largest:
            largest = num
    return largest",43
30637957230,count_frequency,"def count_frequency(nums):
    result = {}
    for num in nums:
        if num in result:
            result[num] += 1
        else:
            result[num] = 1
    return result",43
73468128119,most_frequent,"from collections import Counter

def most_frequent(lst):
    counter = Counter(lst)
    max_count = max(counter.values())
    for num in lst:
        if counter[num] == max_count:
            return num",43
31541173126,char_count,"def char_count(s):
    result = {}
    for char in s:
        if char in result:
            result[char] += 1
        else:
            result[char] = 1
    return result",43
33561953530,char_frequency,"def char_frequency(string):
    frequency = {}
    for char in string:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return frequency",43
39603319235,character_frequency,"def character_frequency(string):
    frequency = {}
    for char in string:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return frequency",43
1098150279,is_valid_palindrome,"import re

def is_valid_palindrome(s: str) -> bool:
    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()
    return s == s[::-1]",43
36878118138,character_count,"def character_count(s):
    res = {}
    for c in s:
        if c in res:
            res[c] += 1
        else:
            res[c] = 1
    return res",43
7335122837,smallest_divisor,"def smallest_divisor(n):
    if n < 2:
        return None
    for i in range(2, n + 1):
        if n % i == 0:
            return i",42
4210431180,find_smallest,"def find_smallest(numbers):
    if not numbers:
        return None
    smallest = numbers[0]
    for num in numbers:
        if num < smallest:
            smallest = num
    return smallest",42
12955573924,is_perfect_number,"def is_perfect_number(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n",42
26717774269,odd_digit_sum,"def odd_digit_sum(number):
    total = 0
    for digit in str(number):
        if int(digit) % 2 != 0:
            total += int(digit)
    return total",42
483786862,sum_of_squares_of_evens,"def sum_of_squares_of_evens(lst):
    res = 0
    for num in lst:
        if num % 2 == 0:
            res += num**2
    return res",42
70689295425,find_missing_number,"def find_missing_number(nums):
  n = len(nums)
  total_sum = n * (n + 1) // 2
  current_sum = sum(nums)
  return total_sum - current_sum",42
20337838068,second_smallest,"def second_smallest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return None
    unique_numbers.remove(min(unique_numbers))
    return min(unique_numbers)",42
37785499808,find_occurrences,"def find_occurrences(string, sub):
    count = 0
    for i in range(len(string)):
        if string[i:i+len(sub)] == sub:
            count += 1
    return count",42
26329053709,count_vowels,"def count_vowels(s):
    vowels = ""aeiou""
    count = 0
    for char in s.lower():
        if char in vowels:
            count += 1
    return count",42
27525839668,sum_dig,"def sum_dig(num):
    sum = 0
    while(num > 0):
        sum = sum + num % 10
        num = num // 10
    return sum",42
71982260207,convert_to_int,"def convert_to_int(lst):
    result = []
    for i in lst:
        try:
            num = int(i)
            result.append(num)
        except ValueError:
            result.append(None)
    return result",42
18483194059,kthSmallest,"import heapq

def kthSmallest(arr, k):
    heapq.heapify(arr)
    for _ in range(k-1):
        heapq.heappop(arr)
    return heapq.heappop(arr)",42
43150696713,is_perfect_cube,"def is_perfect_cube(number):
    if number < 0:
        number = -number
    cube_root = round(number ** (1 / 3))
    return cube_root ** 3 == number",42
24052575158,is_sorted_and_unique,"def is_sorted_and_unique(lst):
    for i in range(len(lst)-1):
        if lst[i] >= lst[i+1]:
            return False
    return len(lst) == len(set(lst))",42
72213085593,list_to_dict,"def list_to_dict(list1):
    result = {}
    for item in list1:
        key = item[0]
        value = item[1:]
        result[key] = value
    return result",42
27239859928,middle_chars,"def middle_chars(s):
    idx = int(len(s)/2)
    if len(s)%2==0:
        return s[idx-1:idx+1]
    else:
        return s[idx]",42
14031137760,total_price,"def total_price(items):
    total = 0
    for item in items:
        if item[""quantity""] >= 1:
            total += item[""price""] * item[""quantity""]
    return total",42
23249976886,find_longest_word,"def find_longest_word(words):
    longest_word = words[0]
    for word in words:
        if len(word) > len(longest_word):
            longest_word = word
    return longest_word",42
36794485725,find_mode,"from collections import Counter

def find_mode(nums):
    count = Counter(nums)
    max_count = max(count.values())
    return [num for num, freq in count.items() if freq == max_count]",42
24545881446,decimal_to_base,"def decimal_to_base(n, k):
    result = ''
    while n > 0:
        result = str(n % k) + result
        n = n // k
    return int(result)",42
34478518852,count_vowels,"def count_vowels(string):
  count = 0
  vowels = ""aeiou""
  for char in string.lower():
    if char in vowels:
      count += 1
  return count",42
1368003290,highest_product_of_three,"def highest_product_of_three(nums):
    nums.sort()
    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])",42
683782977,largest_non_adjacent_sum,"def largest_non_adjacent_sum(nums):
    prev, curr = 0, 0
    for num in nums:
        prev, curr = curr, max(curr, prev + num)
    return curr",42
3295444525,highest_product_of_three,"def highest_product_of_three(nums):
    nums.sort()
    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])",42
72605674548,sum_Proper_Divisors,"def sum_Proper_Divisors(n):
    result = 0
    for i in range(1, n):
        if n % i == 0:
            result += i
    return result",42
71373120367,closest_number,"def closest_number(nums, target):
    closest = nums[0]
    for num in nums:
        if abs(num - target) < abs(closest - target):
            closest = num
    return closest",42
40151955338,isPerfectSquare,"import math

def isPerfectSquare(n):
    if n < 0:
        return False
    root = math.sqrt(n)
    return int(root + 0.5) ** 2 == n",42
2172945196,kth_smallest,"import heapq

def kth_smallest(arr, k):
    heapq.heapify(arr)
    for _ in range(k-1):
        heapq.heappop(arr)
    return heapq.heappop(arr)",42
36299276479,is_valid_identifier,"def is_valid_identifier(s):
    import re
    if re.match(""^[a-zA-Z_][a-zA-Z0-9_]*$"", s):
        return True
    else:
        return False",42
26913407897,swap_list,"def swap_list(input_list):
    if len(input_list) > 1:
        input_list[0], input_list[-1] = input_list[-1], input_list[0]
    return input_list",42
40599124416,is_power_of_two,"def is_power_of_two(n):
    if n <= 0:
        return False
    while n % 2 == 0:
        n = n // 2
    return n == 1",42
72310701285,check_Perfect_Number,"def check_Perfect_Number(num):
    sum = 0
    for i in range(1, num):
        if(num % i == 0):
            sum += i
    return sum == num",42
36855241588,count_element,"def count_element(nums, element):
    if len(nums) == 0:
        return 0
    else:
        return (element == nums[0]) + count_element(nums[1:], element)",42
294442389,find_largest,"def find_largest(lst):
    if not lst:
        return None
    largest = lst[0]
    for num in lst:
        if num > largest:
            largest = num
    return largest",42
1703388533,find_missing_number,"def find_missing_number(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    sum_of_nums = sum(nums)
    return total - sum_of_nums",42
3097576330,max_product_of_three,"def max_product_of_three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",42
43601405933,missingNumber,"def missingNumber(arr):
    n = len(arr)+1
    total = n * (n+1) // 2
    sum_of_arr = sum(arr)
    return total - sum_of_arr",42
16174646834,is_valid_pincode,"def is_valid_pincode(pincode):
    if len(pincode) != 6:
        return False
    for digit in pincode:
        if not digit.isdigit():
            return False
    return True",42
71888579689,test_duplicate,"def test_duplicate(strlist):
    str_set = set()
    for s in strlist:
        if s.lower() in str_set:
            return True
        str_set.add(s.lower())
    return False",42
2288820889,largest_num,"def largest_num(n):
  num_list = [int(i) for i in str(n)]
  num_list.sort(reverse=True)
  res = int("""".join(map(str, num_list)))
  return res",42
70300164091,count_digit_three,"def count_digit_three(n):
    count = 0
    for i in range(1, n+1):
        if '3' in str(i):
            count += 1
    return count",42
38902262881,max_sum_non_adjacent,"def max_sum_non_adjacent(nums):
    prev, curr = 0, 0
    for num in nums:
        prev, curr = curr, max(curr, prev + num)
    return curr",42
13340817857,second_highest,"def second_highest(lst):
    unique_nums = list(set(lst))
    unique_nums.sort()
    if len(unique_nums) > 1:
        return unique_nums[-2]
    else:
        return None",42
33402217053,max_product_of_three,"def max_product_of_three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",42
37434975035,check_triangle,"def check_triangle(a, b, c):
    if a + b > c and a + c > b and b + c > a:
        return ""Yes""
    else:
        return ""No""",42
17533491512,largest_Number,"def largest_Number(n):
    num_list = [int(i) for i in str(n)]
    num_list.sort(reverse=True)
    return int(''.join([str(i) for i in num_list]))",42
37285407938,largest_in_list,"def largest_in_list(numbers):
    if not numbers:
        return None
    largest = numbers[0]
    for num in numbers:
        if num > largest:
            largest = num
    return largest",42
32793303635,largest_product_of_three,"def largest_product_of_three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",42
10751371856,count_unique_digits,"def count_unique_digits(n):
    unique_digits = set()
    while n > 0:
        unique_digits.add(n % 10)
        n //= 10
    return len(unique_digits)",42
4120872763,find_missing_number,"def find_missing_number(nums):
    n = len(nums)
    total_sum = n * (n + 1) // 2
    array_sum = sum(nums)
    return total_sum - array_sum",42
28113960421,split_list,"def split_list(lst):
    mid = len(lst) // 2
    if len(lst) % 2 != 0:
        mid += 1
    return lst[:mid], lst[mid:]",42
41069714331,find_Mode,"from collections import Counter

def find_Mode(lst):
    count = Counter(lst)
    max_count = max(count.values())
    return [num for num, freq in count.items() if freq == max_count]",42
12329733498,has_unique_chars,"def has_unique_chars(str):
  for i in range(len(str)):
    for j in range(i+1, len(str)):
      if str[i] == str[j]:
        return False
  return True",42
41390197234,find_mode,"from collections import Counter

def find_mode(numbers):
    count = Counter(numbers)
    max_count = max(count.values())
    return [num for num, freq in count.items() if freq == max_count]",42
7530684995,find_largest_not_greater,"def find_largest_not_greater(numbers, target):
    numbers = list(set(numbers))
    numbers.sort()
    for i in reversed(numbers):
        if i <= target:
            return i
    return -1",42
28109763187,check_palindrome,"import re

def check_palindrome(s: str) -> bool:
    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()
    return s == s[::-1]",42
25699835485,find_Missing_Number,"def find_Missing_Number(nums):
    n = len(nums)
    total = n * (n+1) // 2
    sum_of_nums = sum(nums)
    return total - sum_of_nums",42
72309814105,count_vowels,"def count_vowels(text):
    vowels = ""aeiou""
    count = 0
    for char in text.lower():
        if char in vowels:
            count += 1
    return count",42
23341429264,find_divisible,"def find_divisible(numbers):
  result = []
  for num in numbers:
    if num % 3 == 0 or num % 5 == 0:
      result.append(num)
  return result",42
32493829466,harmonicSeriesSum,"def harmonicSeriesSum(n): 
    sum = 0
    for i in range(1, n + 1): 
        sum += 1 / (i * i) 
    return sum",42
10108219269,find_longest_word,"def find_longest_word(word_list):
    max_length = 0
    for word in word_list:
        if len(word) > max_length:
            max_length = len(word)
    return max_length",42
30833304322,is_point_in_rectangle,"def is_point_in_rectangle(p_x, p_y, start_x, start_y, end_x, end_y):
  return start_x <= p_x <= end_x and start_y <= p_y <= end_y",42
43651998130,largest_product_of_three,"def largest_product_of_three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",42
26436681220,lcm,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)",42
25803663690,find_last_occurrence,"def find_last_occurrence(str1, char):
    index = -1
    for i in range(len(str1)):
        if str1[i] == char:
            index = i
    return index",42
35206516571,remove_vowels,"def remove_vowels(string):
    vowels = 'aeiouAEIOU'
    result = ''
    for char in string:
        if char not in vowels:
            result += char
    return result",42
38426650801,string_permutations,"from itertools import permutations

def string_permutations(s):
    perm_set = set(permutations(s))
    perm_list = [''.join(p) for p in perm_set]
    return sorted(perm_list)",42
8135683230,missing_num,"def missing_num(arr):
    total = int(((101*100)/2))
    sum_of_arr = sum(arr)
    missing_num = total - sum_of_arr
    return missing_num",42
28449723731,is_permutation,"def is_permutation(lst1, lst2):
    if len(lst1) != len(lst2):
        return False
    lst1.sort()
    lst2.sort()
    return lst1 == lst2",42
20602778133,find_mode,"from collections import Counter

def find_mode(arr):
    counter = Counter(arr)
    max_count = max(counter.values())
    return [key for key, value in counter.items() if value == max_count]",42
30529198367,find_modes,"from collections import Counter
def find_modes(numbers):
    count = Counter(numbers)
    max_count = max(count.values())
    return [num for num, freq in count.items() if freq == max_count]",42
71752144758,largestNumber,"def largestNumber(n):
    num_str = str(n)
    num_list = list(num_str)
    num_list.sort(reverse=True)
    largest_num = int(''.join(num_list))
    return largest_num",42
10565908679,find_longest_strings,"def find_longest_strings(strings):
    max_len = max(len(string) for string in strings)
    longest_strings = [string for string in strings if len(string) == max_len]
    return longest_strings",42
28081830120,valid_hex_color,"import re

def valid_hex_color(s):
    pattern = ""^#([A-Fa-f0-9]{6})$""
    if re.match(pattern, s):
        return True
    return False",42
4161159738,find_mode,"from collections import Counter

def find_mode(nums):
    count = Counter(nums)
    max_count = max(count.values())
    return [num for num, freq in count.items() if freq == max_count]",42
34776638241,is_power_of_two,"def is_power_of_two(n):
    if n <= 0:
        return False
    while n % 2 == 0:
        n = n // 2
    return n == 1",42
37496052461,find_longest_strings,"def find_longest_strings(strings):
    max_length = max(len(s) for s in strings)
    longest_strings = [s for s in strings if len(s) == max_length]
    return longest_strings",42
1132079408,is_perfect_number,"def is_perfect_number(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n",42
39303219243,max_product_of_three,"def max_product_of_three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",42
12235966470,sum_digits,"def sum_digits(number):
    sum = 0
    while number > 0:
        digit = number % 10
        sum += digit
        number //= 10
    return sum",42
6400769379,remove_vowels,"def remove_vowels(s):
    vowels = 'aeiouAEIOU'
    res = ''
    for char in s:
        if char not in vowels:
            res += char
    return res",42
36860792995,remove_vowels,"def remove_vowels(s):
    vowels = ""aeiouAEIOU""
    result = """"
    for char in s:
        if char not in vowels:
            result += char
    return result",42
25265138887,find_unique,"def find_unique(A):
    if not A:
        return 0
    res = A[0]
    for i in range(1, len(A)):
        res ^= A[i]
    return res",42
14110587249,find_num_positions,"def find_num_positions(nums, target):
    positions = []
    for i in range(len(nums)):
        if nums[i] == target:
            positions.append(i)
    return (len(positions), positions)",42
16832221237,second_highest,"def second_highest(lst):
    unique_lst = list(set(lst))
    unique_lst.sort()
    if len(unique_lst) >= 2:
        return unique_lst[-2]
    else:
        return None",42
22916609121,check_perfect_number,"def check_perfect_number(num):
    sum = 0
    for i in range(1, num):
        if num % i == 0:
            sum += i
    return sum == num",42
70115517970,is_perfect_number,"def is_perfect_number(n):
    sum = 0
    for x in range(1, n):
        if n % x == 0:
            sum += x
    return sum == n",42
39110992369,smallest_divisor,"def smallest_divisor(n):
    if n <= 1:
        return n
    for i in range(2, n + 1):
        if n % i == 0:
            return i",42
4120805513,missingNumber,"def missingNumber(nums):
    n = len(nums)+1
    total = n * (n+1) // 2
    sum_of_nums = sum(nums)
    return total - sum_of_nums",42
2726089952,split_string,"def split_string(s, separator=None, index=0):
    if separator is None:
        substrings = s.split()
    else:
        substrings = s.split(separator)
    return substrings[index]",42
7425826167,missingNumber,"def missingNumber(arr):
    n = len(arr)
    total = (n + 1)*(n + 2)/2
    sum_of_A = sum(arr)
    return total - sum_of_A",42
28671308364,duplicate_count,"def duplicate_count(text):
    text = text.lower()
    result = 0
    for c in set(text):
        if text.count(c) > 1:
            result+=1
    return result",42
23097305496,most_common,"from collections import Counter

def most_common(lst):
    count = Counter(lst)
    max_count = max(count.values())
    return [item for item, freq in count.items() if freq == max_count]",42
11150362958,check_palindrome,"import re

def check_palindrome(s: str) -> bool:
    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()
    return s == s[::-1]",42
39163731426,first_repeating,"def first_repeating(arr):
    seen = set()
    for i in range(len(arr)):
        if arr[i] in seen:
            return arr[i]
        seen.add(arr[i])
    return -1",42
2827277589,mode,"from collections import Counter

def mode(nums):
    count = Counter(nums)
    max_count = max(list(count.values()))
    return [num for num, freq in count.items() if freq == max_count]",42
71238505706,remove_vowels,"def remove_vowels(text):
    vowels = ""aeiouAEIOU""
    result = """"
    for char in text:
        if char not in vowels:
            result += char
    return result",42
5329292704,cube_odd_sum,"def cube_odd_sum(n): 
    sum = 0
    for i in range(1, 2*n, 2): 
        sum = sum + (i*i*i)
    return sum",42
26569193914,min_operations,"def min_operations(nums):
    nums.sort()
    median = nums[len(nums) // 2]
    return sum(abs(num - median) for num in nums)

# Time complexity: O(N log N)",42
35024247455,find_highest_product,"def find_highest_product(arr):
    arr.sort()
    return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])",42
1821662783,sum_odd_numbers,"def sum_odd_numbers(n):
    sum = 0
    for i in range(1, n+1):
        if i % 2 != 0:
            sum += i
    return sum",42
6625359875,is_power_of_two,"def is_power_of_two(n):
    if n <= 0:
        return False
    while n % 2 == 0:
        n = n // 2
    return n == 1",42
18586938054,count_factors,"def count_factors(n):
    count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            count += 1
    return count",42
37580185728,find_Min_Num,"def find_Min_Num(arr,n):
    arr.sort()
    num = arr[0]
    for i in range(1,n):
        num = num * 10 + arr[i]
    return num",42
16209249174,find_longest_word,"def find_longest_word(words):
    longest_word = words[0]
    for word in words:
        if len(word) > len(longest_word):
            longest_word = word
    return longest_word",42
41660405012,check_power_of_two,"def check_power_of_two(n):
    if n <= 0:
        return False
    while n % 2 == 0:
        n = n / 2
    return n == 1",42
24990566267,unique_pairs,"def unique_pairs(numbers):
    pairs = []
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            pairs.append((numbers[i], numbers[j]))
    return pairs",42
31905796151,find_modes,"from collections import Counter
def find_modes(nums):
    count = Counter(nums)
    max_count = max(count.values())
    return [num for num, freq in count.items() if freq == max_count]",42
34311332984,count_paths,"def count_paths(m,n):
    if m == 1 or n == 1:
        return 1
    return count_paths(m-1, n) + count_paths(m, n-1)",42
13398971978,get_permutations,"from itertools import permutations

def get_permutations(nums):
    res = []
    for perm in permutations(nums):
        if list(perm) not in res:
            res.append(list(perm))
    return res",42
37281636558,to_camel_case,"def to_camel_case(text):
    words = text.split('_') if '_' in text else text.split(' ')
    return words[0] + ''.join(word.capitalize() for word in words[1:])",42
70460813881,is_power_of_two,"def is_power_of_two(n):
    if n <= 0:
        return False
    while n % 2 == 0:
        n = n // 2
    return n == 1",42
9564103954,smallest_divisor_greater_than,"def smallest_divisor_greater_than(n, threshold):
    for i in range(threshold + 1, n + 1):
        if n % i == 0:
            return i
    return n",42
34940220031,check_sorted_unique,"def check_sorted_unique(nums):
    for i in range(1, len(nums)):
        if nums[i] <= nums[i-1]:
            return False
    return len(set(nums)) == len(nums)",42
70171509248,unique_preserve_order,"def unique_preserve_order(lst):
    seen = set()
    result = []
    for item in lst:
        if item not in seen:
            seen.add(item)
            result.append(item)
    return result",42
6831983938,check_anagrams,"def check_anagrams(list):
    sorted_list = [''.join(sorted(word)) for word in list]
    if len(set(sorted_list)) == 1:
        return True
    else:
        return False",42
70676322377,smallest_missing,"def smallest_missing(arr):
    arr.sort()
    smallest_missing = 1
    for num in arr:
        if num > smallest_missing:
            break
        smallest_missing += num
    return smallest_missing",42
23260138964,check_Perfect,"def check_Perfect(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n",41
73894567040,maximum_product,"def maximum_product(nums):
    nums.sort()
    p = nums[0]*nums[1]*nums[-1]
    return max(p, nums[-1]*nums[-2]*nums[-3])",41
29416611204,is_perfect,"def is_perfect(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n",41
42582511605,longest_string_length,"def longest_string_length(string_list):
    max_length = 0
    for string in string_list:
        if len(string) > max_length:
            max_length = len(string)
    return max_length",41
74180850660,calculate_score,"def calculate_score(word):
    score = 0
    for char in word:
        score += ord(char) - 96 # Subtract 96 to get the alphabetical position
    return score",41
43826399813,find_smallest,"def find_smallest(arr):
    smallest = arr[0][0]
    for sublist in arr:
        for value in sublist:
            if value < smallest:
                smallest = value
    return smallest",41
73030140649,perfect_square,"import math

def perfect_square(number):
    root = math.sqrt(number)
    if int(root + 0.5) ** 2 == number:
        return True
    else:
        return False",41
72605677748,smallest_divisor_greater_than,"def smallest_divisor_greater_than(n, val):
    for i in range(val + 1, n + 1):
        if n % i == 0:
            return i
    return n",41
8330919327,mult_lists,"def mult_lists(list1, list2):
  result = map(lambda x, y: x * y, list1[:len(list2)], list2[:len(list1)])
  return list(result)",41
42605417665,factors,"def factors(num):
    factor_list = []
    for i in range(1, num + 1):
        if num % i == 0:
            factor_list.append(i)
    return factor_list",41
34602133291,find_longest_string,"def find_longest_string(string_list):
    longest_string = """"
    for string in string_list:
        if len(string) > len(longest_string):
            longest_string = string
    return longest_string",41
37985041619,smallest_largest,"def smallest_largest(numbers):
    if numbers: 
        min_num = min(numbers)
        max_num = max(numbers)
        return (min_num, max_num)
    else: 
        return None",41
10788544445,vowel_count,"def vowel_count(s):
    vowels = 'aeiou'
    count = 0
    for char in s:
        if char.lower() in vowels:
            count += 1
    return count",41
42318529370,smallest_common_multiple,"from math import gcd
from functools import reduce

def lcm(a, b):
    return a * b // gcd(a, b)

def smallest_common_multiple(numbers):
    return reduce(lcm, numbers)",41
72564802105,find_longest,"def find_longest(strings):
    longest_string = strings[0]
    for string in strings:
        if len(string) > len(longest_string):
            longest_string = string
    return longest_string",41
72042475487,max_string_length,"def max_string_length(str_list):
    max_len = 0
    for string in str_list:
        if len(string) > max_len:
            max_len = len(string)
    return max_len",41
10316282833,most_frequent_item_count,"from collections import Counter

def most_frequent_item_count(lst):
    if not lst:
        return 0
    counter = Counter(lst)
    max_count = max(counter.values())
    return max_count",41
39085873135,max_product_three,"def max_product_three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",41
31078606745,maxProduct,"from typing import List

def maxProduct(nums: List[int]) -> int:
    nums = sorted(nums)
    return max(nums[0]*nums[1], nums[-1]*nums[-2])",41
33258886741,is_perfect,"def is_perfect(n):
    sum = 0
    for x in range(1, n):
        if n % x == 0:
            sum += x
    return sum == n",41
70944409080,last_index,"def last_index(arr, target):
    for i in range(len(arr) - 1, -1, -1):
        if arr[i] == target:
            return i
    return -1",41
30472583461,isPalindrome,"import re
def isPalindrome(s: str) -> bool:
    s = re.sub('[^A-Za-z0-9]+', '', s).lower()
    return s == s[::-1]",41
18023897031,find_longest_string_length,"def find_longest_string_length(strings):
    longest_length = 0
    for string in strings:
        if len(string) > longest_length:
            longest_length = len(string)
    return longest_length",41
41412959386,remove_punctuation,"import string
def remove_punctuation(s: str) -> str:
    result = """"
    for char in s:
        if char not in string.punctuation:
            result += char
    return result",41
38729813815,is_perfect,"def is_perfect(n):
    sum = 0
    for x in range(1, n):
        if n % x == 0:
            sum += x
    return sum == n",41
23853234807,max_product_three,"def max_product_three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",41
37698266324,mode,"from collections import Counter

def mode(numbers):
    count = Counter(numbers)
    max_count = max(count.values())
    return [num for num, freq in count.items() if freq == max_count]",41
17817268507,find_LargestNumber,"def find_LargestNumber(n):
    digits = [int(d) for d in str(n)]
    digits.sort(reverse=True)
    return int(''.join([str(d) for d in digits]))",41
294358999,missing_number,"def missing_number(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    sum_of_nums = sum(nums)
    return total - sum_of_nums",41
11841089259,find_Missing_Number,"def find_Missing_Number(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",41
9584454389,find_missing_number,"def find_missing_number(arr):
    n = len(arr)
    total = (n+1)*(n+2)/2
    sum_of_arr = sum(arr)
    return total - sum_of_arr",41
42546368348,find_second_smallest,"def find_second_smallest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return None
    unique_numbers.sort()
    return unique_numbers[1]",41
1307722958,largest_number,"def largest_number(nums):
    if not nums:
        return None
    largest = nums[0]
    for num in nums:
        if num > largest:
            largest = num
    return largest",41
41456942289,product_of_positive,"def product_of_positive(lst):
    product = 1
    for num in lst:
        if num > 0:
            product *= num
    return product if product > 1 else 1",41
21144173849,calculate_account_balance,"def calculate_account_balance(transactions):
    balance = 0
    for transaction in transactions:
        balance += transaction
        if balance < 0:
            return 'Insufficient funds'
    return balance",41
26685320027,find_second_largest,"def find_second_largest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return None
    unique_numbers.sort()
    return unique_numbers[-2]",41
31440883543,missing_Number,"def missing_Number(nums):
    n = len(nums)
    total_sum = n * (n + 1) // 2
    list_sum = sum(nums)
    return total_sum - list_sum",41
1021797268,sum_even,"def sum_even(matrix):
    result = 0
    for row in matrix:
        for num in row:
            if num % 2 == 0:
                result += num
    return result",41
18809513388,calculate_discounted_price,"def calculate_discounted_price(original_price, discount_percentage):
    discount_amount = original_price * (discount_percentage / 100)
    final_price = original_price - discount_amount
    return final_price",41
19062486704,find_decreasing_indexes,"def find_decreasing_indexes(lst):
    indexes = []
    for i in range(1, len(lst)):
        if lst[i] < lst[i-1]:
            indexes.append(i)
    return indexes",41
35470720815,sum_to_10,"def sum_to_10(nums):
    for i in range(len(nums)-1):
        if nums[i] + nums[i+1] == 10:
            return True
    return False",41
26088576475,remove_non_alpha,"def remove_non_alpha(lst):
    result = []
    for string in lst:
        new_string = ''.join(c for c in string if c.isalpha())
        result.append(new_string)
    return result",41
74022841432,is_convertible_to_int,"def is_convertible_to_int(s):
    try:
        float_s = float(s)
        int_s = int(float_s)
        return float_s == int_s
    except ValueError:
        return False",41
10816864711,process_numbers,"def process_numbers(numbers):
    result = []
    for num in numbers:
        if num > 0:
            result.append(num**3)
        else:
            result.append(abs(num))
    return result",41
72551178275,shift_right,"def shift_right(lst, shift_count):
    if len(lst) == 0:
        return lst
    shift_count %= len(lst)
    return lst[-shift_count:] + lst[:-shift_count]",41
6786559169,can_form_word,"def can_form_word(word, chars):
    for char in word:
        if char in chars:
            chars = chars.replace(char, '', 1)
        else:
            return False
    return True",41
9838808418,find_min,"def find_min(lst):
    min_element = lst[0]
    for i in range(len(lst)):
        if lst[i] < min_element:
            min_element = lst[i]
    return min_element",41
38901950841,max_product_three,"def max_product_three(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",41
23941880544,is_sorted_by_sum,"def is_sorted_by_sum(list_of_lists):
    return all(sum(list_of_lists[i]) <= sum(list_of_lists[i + 1]) for i in range(len(list_of_lists) - 1))",41
26322289997,is_string_palindrome,"def is_string_palindrome(s):
    alphanumeric_s = """"
    for char in s:
        if char.isalnum():
            alphanumeric_s += char.lower()
    return alphanumeric_s == alphanumeric_s[::-1]",41
5493732016,check_pangram,"import string

def check_pangram(sentence):
    alphabet = set(string.ascii_lowercase)
    sentence = sentence.lower()
    sentence_set = set(sentence)
    return alphabet.issubset(sentence_set)",41
14627619190,sum_list,"def sum_list(input_list):
  if len(input_list) == 1:
    return input_list[0]
  else:
    return input_list[0] + sum_list(input_list[1:])",41
26621698982,rearrange_list,"def rearrange_list(nums):
    negative = [num for num in nums if num < 0]
    positive = [num for num in nums if num >= 0]
    return negative + positive",41
37248582815,first_recurring_char,"def first_recurring_char(input_string):
    seen_chars = set()
    for char in input_string:
        if char in seen_chars:
            return char
        seen_chars.add(char)
    return None",41
22570480372,is_valid_hex_color,"import re

def is_valid_hex_color(color):
    if re.search(r'^#([A-Fa-f0-9]{6})$', color):
        return True
    else:
        return False",41
40526691558,count_equal_elements,"def count_equal_elements(lst):
    max_count = 1
    for i in lst:
        if lst.count(i) > max_count:
            max_count = lst.count(i)
    return max_count",41
43957125180,longest_word_length,"def longest_word_length(word_list):
    max_length = 0
    for word in word_list:
        if len(word) > max_length:
            max_length = len(word)
    return max_length",41
24276820735,matrix_transpose,"def matrix_transpose(matrix):
    # transpose the matrix
    result = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]
    return result",41
6867669698,is_valid_hex_color,"import re
def is_valid_hex_color(code):
  if re.match(r'^#([A-Fa-f0-9]{6})$', code):
    return True
  else:
    return False",41
34104075189,shortest_palindrome,"def shortest_palindrome(s):
    r = s[::-1]
    for i in range(len(s) + 1):
        if s.startswith(r[i:]):
            return r[:i] + s",41
20301117019,flatten_array,"def flatten_array(arr):
    result = []
    for i in arr:
        if isinstance(i, list):
            result.extend(flatten_array(i))
        else:
            result.append(i)
    return result",41
70676344137,unique_combinations,"from itertools import combinations

def unique_combinations(nums, target):
    unique_comb = set()
    for combination in combinations(nums, target):
        unique_comb.add(combination)
    return len(unique_comb)",41
37704680539,find_second_smallest,"def find_second_smallest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return None
    unique_numbers.sort()
    return unique_numbers[1]",41
3193197794,missingNumber,"def missingNumber(nums):
    n = len(nums)
    total_sum = n * (n + 1) // 2
    array_sum = sum(nums)
    return total_sum - array_sum",41
30554945031,is_ascending,"def is_ascending(test_list):
  for i in range(len(test_list) - 1):
    if test_list[i] > test_list[i + 1]:
      return False
  return True",41
9890211315,reverse_string_stack,"def reverse_string_stack(s):
    stack = []
    for char in s:
        stack.append(char)
    reversed_string = """"
    while stack:
        reversed_string += stack.pop()
    return reversed_string",41
72441806512,find_divisible,"def find_divisible(numbers, divisor, threshold):
    result = []
    for number in numbers:
        if number > threshold and number % divisor == 0:
            result.append(number)
    return result",41
30412925865,duplicate_number,"def duplicate_number(nums):
    res = 0
    for num in nums:
        res ^= num
    for i in range(1, len(nums)):
        res ^= i
    return res",41
42797748887,missingNumber,"def missingNumber(nums):
    n = len(nums)
    expected_sum = n * (n + 1) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum",41
32625919905,find_LCM,"import math

def find_LCM(nums):
    lcm = nums[0]
    for i in nums[1:]:
        lcm = lcm*i//math.gcd(lcm, i)
    return lcm",41
40123653620,count_binary,"def count_binary(target, arr):
    target_int = int(target, 2)
    arr_int = [int(i, 2) for i in arr]
    return arr_int.count(target_int)",41
6778166814,remove_dups,"def remove_dups(lst):
    seen = set()
    res = []
    for i in lst:
        if i not in seen:
            seen.add(i)
            res.append(i)
    return res",41
24491587324,substrings,"def substrings(str):
    result = []
    for i in range(len(str)):
        for j in range(i+1, len(str)+1):
            result.append(str[i:j])
    return result",41
12405183462,find_third_largest,"def find_third_largest(nums):
    unique_nums = list(set(nums))
    if len(unique_nums) < 3:
        return None
    unique_nums.sort()
    return unique_nums[-3]",41
41477866813,isPerfectNumber,"def isPerfectNumber(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n",41
634261223,transform_date,"from datetime import datetime

def transform_date(date_string):
    date_time_obj = datetime.strptime(date_string, '%d %b %Y')
    return date_time_obj.strftime('%Y-%m-%d')",41
1694212466,find_max_product,"def find_max_product(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",41
33306700155,is_palindrome_ignore_case_nonalnum,"import re

def is_palindrome_ignore_case_nonalnum(s):
    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()
    return s == s[::-1]",41
14844219991,three_max_product,"def three_max_product(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",41
1646120210,is_perfect,"def is_perfect(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n",41
23703985103,find_Max_Product,"def find_Max_Product(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",41
13795086486,is_rotation_substring,"def is_rotation_substring(source: str, target: str) -> bool:
    if len(target) > len(source):
        return False
    source = source + source
    return target in source",41
8956355931,num_of_digits,"def num_of_digits(n):
    if n > 0:
        return len(str(n))
    elif n == 0:
        return 1
    else:
        return len(str(-n))",41
19151735826,second_highest,"def second_highest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return -1
    unique_numbers.sort()
    return unique_numbers[-2]",41
26577581182,text_match,"import re
def text_match(text):
  patterns = '^a'
  if re.search(patterns,  text):
    return ('Found a match!')
  else:
    return ('Not matched!')",41
23998193300,find_pattern,"def find_pattern(s, pattern):
    count = 0
    for i in range(len(s)):
        if s[i:i+len(pattern)] == pattern:
            count += 1
    return count",41
33615260889,count_divisions_by_2,"def count_divisions_by_2(num):
    count = 0
    while num >= 1:
        num /= 2
        count += 1
    return count - 1",40
32324407105,second_smallest,"def second_smallest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return None
    unique_numbers.sort()
    return unique_numbers[1]",40
34330839746,generate_ngrams,"def generate_ngrams(text, n):
    ngrams = []
    for i in range(len(text) - n + 1):
        ngrams.append(text[i:i+n])
    return ngrams",40
19643934878,can_form_triangle,"def can_form_triangle(a, b, c):
    if a + b > c and a + c > b and b + c > a:
        return True
    else:
        return False",40
72852625944,missingNumber,"def missingNumber(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    for num in nums:
        total -= num
    return total",40
24525459240,find_largest,"def find_largest(list1):
    max_num = list1[0]
    for num in list1:
        if num > max_num:
            max_num = num
    return max_num",40
15259521281,is_strictly_increasing,"def is_strictly_increasing(lst):
    for i in range(len(lst) - 1):
        if lst[i] >= lst[i + 1]:
            return False
    return True",40
39153580019,unique_sorted_list,"def unique_sorted_list(list):
    unique_list = []
    for i in list:
        if i not in unique_list:
            unique_list.append(i)
    unique_list.sort()
    return unique_list",40
34029633927,list_intersection,"def list_intersection(list1, list2):
    result = []
    for i in list1:
        if i in list2 and i not in result:
            result.append(i)
    return result",40
32820333360,second_smallest,"def second_smallest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return None
    unique_numbers.sort()
    return unique_numbers[1]",40
72788240783,maxProduct,"def maxProduct(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",40
9770715825,maxProduct,"def maxProduct(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",40
8801629963,dec_to_bin,"def dec_to_bin(n):
    binary = ''
    while n > 0:
        binary = str(n % 2) + binary
        n = n // 2
    return binary",40
72655503887,find_target_indices,"def find_target_indices(nums, target):
    nums.sort()
    indices = []
    for i in range(len(nums)):
        if nums[i] == target:
            indices.append(i)
    return indices",40
2274695097,fibonacci_sequence,"def fibonacci_sequence(n):
    sequence = [0, 1]
    while len(sequence) < n:
        sequence.append(sequence[-1] + sequence[-2])
    return sequence[:n]",40
12307079245,get_node_val,"def get_node_val(linked_list, index):
    if index < 0 or index >= len(linked_list):
        return 'Index out of bounds'
    return linked_list[index][1]",40
71036650583,intersect,"def intersect(list1, list2):
    result = []
    for i in list1:
        if i in list2:
            result.append(i)
            list2.remove(i)
    return result",40
43661803894,unique_strings,"def unique_strings(strings):
    seen = set()
    result = []
    for string in strings:
        if string not in seen:
            seen.add(string)
            result.append(string)
    return result",40
27525805278,third_smallest,"def third_smallest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 3:
        return None
    unique_numbers.sort()
    return unique_numbers[2]",40
22342402430,reduce_consecutive_duplicates,"def reduce_consecutive_duplicates(s):
    result = []
    for char in s:
        if not result or result[-1] != char:
            result.append(char)
    return ''.join(result)",40
30485589854,perfect_number,"def perfect_number(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n",40
489642423,is_strictly_ascending,"def is_strictly_ascending(lst):
    for i in range(len(lst) - 1):
        if lst[i] >= lst[i + 1]:
            return False
    return True",40
38720302376,isPerfect,"def isPerfect(n):
    sum = 0
    for x in range(1, n):
        if n % x == 0:
            sum += x
    return sum == n",40
74601011516,pair_elements,"def pair_elements(lst):
    result = []
    for i in range(0, len(lst)-1, 2):
        result.append((lst[i], lst[i+1]))
    return result",40
74612494971,intersection_lists,"def intersection_lists(list1, list2):
    intersection = []
    for i in list1:
        if i in list2 and i not in intersection:
            intersection.append(i)
    return intersection",40
17428543717,count_long_strings,"def count_long_strings(list_of_strings):
    count = 0
    for string in list_of_strings:
        if len(string) > 3:
            count += 1
    return count",40
70960358911,find_missing_num,"def find_missing_num(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",40
31535726,common_elements,"def common_elements(list1, list2):
    common = []
    for element in list1:
        if element in list2 and element not in common:
            common.append(element)
    return common",40
26422262358,unique_list,"def unique_list(l):
    seen = set()
    result = []
    for item in l:
        if item not in seen:
            seen.add(item)
            result.append(item)
    return result",40
6922244388,is_power_of_three,"def is_power_of_three(n):
    if n < 1:
        return False
    while n % 3 == 0:
        n /= 3
    return n == 1",40
18589562474,consecutive_numbers,"def consecutive_numbers(nums):
    nums.sort()
    for i in range(len(nums)-1):
        if nums[i] + 1 == nums[i+1]:
            return True
    return False",40
72277550398,isAlphanumericPalindrome,"def isAlphanumericPalindrome(s):
    import re
    s = re.sub(r'[^A-Za-z0-9]+', '', s).lower()
    return s == s[::-1]",40
73589224985,unique_elements,"def unique_elements(lst):
    seen = set()
    result = []
    for i in lst:
        if i not in seen:
            result.append(i)
            seen.add(i)
    return result",40
74795326516,unique_strings,"def unique_strings(strings):
    seen = set()
    unique = []
    for string in strings:
        if string not in seen:
            seen.add(string)
            unique.append(string)
    return unique",40
23424411090,is_strictly_increasing,"def is_strictly_increasing(numbers):
    for i in range(len(numbers) - 1):
        if numbers[i] >= numbers[i + 1]:
            return False
    return True",40
34430447939,sum_Digits,"def sum_Digits(n):
    sum = 0
    while(n > 0):
        sum += n % 10
        n = n // 10
    return sum",40
41043934739,remove_duplicates,"def remove_duplicates(xs):
    seen = set()
    result = []
    for x in xs:
        if x not in seen:
            seen.add(x)
            result.append(x)
    return result",40
42822764689,intersect_arrays,"def intersect_arrays(arr1, arr2):
    result = []
    for num in arr1:
        if num in arr2 and num not in result:
            result.append(num)
    return result",40
17346718126,intersection_of_lists,"def intersection_of_lists(list1, list2):
    set1 = set(list1)
    set2 = set(list2)
    intersection = sorted(list(set1 & set2))
    return intersection",40
34075336435,sum_of_divisors,"def sum_of_divisors(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum",40
6904231369,maxProduct,"def maxProduct(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",40
72100952078,is_strictly_ascending,"def is_strictly_ascending(numbers):
    for i in range(len(numbers) - 1):
        if numbers[i] >= numbers[i + 1]:
            return False
    return True",40
13998621731,find_divisors,"def find_divisors(number):
    divisors = []
    for i in range(1, number):
        if number % i == 0:
            divisors.append(i)
    return divisors",40
30855557345,isPowerOfThree,"def isPowerOfThree(num):
    if num < 1:
        return False
    while num % 3 == 0:
        num /= 3
    return num == 1",40
38902779361,find_intersection,"def find_intersection(list1, list2):
    intersection = []
    for i in list1:
        if i in list2 and i not in intersection:
            intersection.append(i)
    return intersection",40
29336172821,rotate_list,"def rotate_list(lst, k):
    if not lst or k == 0:
        return lst
    k = k % len(lst)
    return lst[-k:] + lst[:-k]",40
15259303438,second_highest,"def second_highest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return None
    unique_numbers.sort()
    return unique_numbers[-2]",40
19905706827,perfect_number,"def perfect_number(n):
    sum = 0
    for x in range(1, n):
        if n % x == 0:
            sum += x
    return sum == n",40
42708360838,perfect_number,"def perfect_number(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n",40
37413354780,sum_of_digits,"def sum_of_digits(n):
    sum = 0
    while(n > 0):
        sum += n % 10
        n = n // 10
    return sum",40
25646114592,has_duplicates,"def has_duplicates(arr):
    arr_set = set()
    for i in arr:
        if i in arr_set:
            return True
        else:
            arr_set.add(i)
    return False",40
19161497015,char_count,"def char_count(test_str):
    res = {}
    for char in test_str:
        res[char] = 1 if char not in res else res[char] + 1
    return res",40
1679394786,decimal_to_binary,"def decimal_to_binary(num):
    binary = """"
    while num > 0:
        binary = str(num % 2) + binary
        num = num // 2
    return binary",40
70451685685,is_strictly_ascending,"def is_strictly_ascending(nums):
    for i in range(len(nums) - 1):
        if nums[i] >= nums[i + 1]:
            return False
    return True",40
2731773177,unique_numbers,"def unique_numbers(numbers):
    unique = []
    seen = set()
    for num in numbers:
        if num not in seen:
            unique.append(num)
            seen.add(num)
    return unique",40
16969569351,maxProduct,"def maxProduct(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",40
14443216752,perfect_num,"def perfect_num(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n",40
18599349821,unique_elements,"def unique_elements(lst):
    seen = set()
    result = []
    for item in lst:
        if item not in seen:
            seen.add(item)
            result.append(item)
    return result",40
14123604546,is_strictly_increasing,"def is_strictly_increasing(lst):
    for i in range(len(lst) - 1):
        if lst[i] >= lst[i + 1]:
            return False
    return True",40
10208813259,unique_strings,"def unique_strings(strings):
    seen = set()
    result = []
    for s in strings:
        if s not in seen:
            result.append(s)
            seen.add(s)
    return result",40
22465582416,find_squares,"import math
def find_squares(numbers):
    squares = []
    for num in numbers:
        if math.sqrt(num) % 1 == 0:
            squares.append(num)
    return squares",40
15574996008,unique_elements,"def unique_elements(lst):
    seen = set()
    result = []
    for i in lst:
        if i not in seen:
            result.append(i)
            seen.add(i)
    return result",40
8666893741,second_minimum,"def second_minimum(nums):
    unique_nums = set(nums)
    if len(unique_nums) < 2:
        return None
    unique_nums.remove(min(unique_nums))
    return min(unique_nums)",40
30688868052,replace_chars,"def replace_chars(s, dictionary):
    result = """"
    for char in s:
        if char in dictionary:
            result += dictionary[char]
        else:
            result += char
    return result",40
42393019788,lcm,"def gcd(a,b):
    if b==0:
        return a
    else:
        return gcd(b,a%b)

def lcm(a,b):
    return a*b//gcd(a,b)",40
26459957232,longest_word,"import re

def longest_word(s):
    words = re.findall(r'\b[a-zA-Z]+\b', s)
    if not words:
        return ''
    return max(words, key=len)",40
30398174101,longest_word,"def longest_word(word_list):
    max_len = 0
    for word in word_list:
        if len(word) > max_len:
            max_len = len(word)
    return max_len",40
26435844630,sum_Digit,"def sum_Digit(n):
    sum = 0
    while n != 0:
        sum += n % 10
        n = n // 10
    return sum",40
13086913985,second_smallest,"def second_smallest(numbers):
    unique_numbers = list(set(numbers))
    if len(unique_numbers) < 2:
        return None
    unique_numbers.sort()
    return unique_numbers[1]",40
29920065051,unique_elements,"def unique_elements(nums):
    seen = set()
    unique = []
    for num in nums:
        if num not in seen:
            unique.append(num)
            seen.add(num)
    return unique",40
14295988696,find_missing_number,"def find_missing_number(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",40
71179408986,sum_of_divisors,"def sum_of_divisors(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum",40
4248406485,intersect_lists,"def intersect_lists(list1, list2):
    result = []
    for item in list1:
        if item in list2 and item not in result:
            result.append(item)
    return result",40
75040363952,sum_of_cubes,"def sum_of_cubes(nums):
    total = 0
    for num in nums:
        if num % 2 == 0:
            total += num ** 3
    return total",40
2220458177,remove_duplicates,"def remove_duplicates(lst):
    seen = set()
    result = []
    for item in lst:
        if item not in seen:
            seen.add(item)
            result.append(item)
    return result",40
28965219798,first_repeating,"def first_repeating(s):
    char_map = {}
    for char in s:
        if char in char_map:
            return char
        char_map[char] = 1
    return None",40
73819648209,is_valid_hex_color,"import re

def is_valid_hex_color(color):
    if re.match(r'^#[0-9A-Fa-f]{6}$', color):
        return True
    else:
        return False",40
397952176,find_odd_occurrences,"from collections import Counter

def find_odd_occurrences(arr):
    counter = Counter(arr)
    for num, freq in counter.items():
        if freq % 2 != 0:
            return num",40
44152975696,common_Elements,"def common_Elements(arr1,arr2) :
    set1 = set(arr1)
    set2 = set(arr2)
    common = set1.intersection(set2)
    return len(common)",40
4327209390,maxProduct,"def maxProduct(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",40
16518086187,is_power_of_three,"def is_power_of_three(n):
    if n <= 0:
        return False
    while n % 3 == 0:
        n /= 3
    return n == 1",40
41145183588,third_largest,"def third_largest(lst):
    unique_nums = list(set(lst))
    if len(unique_nums) < 3:
        return None
    unique_nums.sort()
    return unique_nums[-3]",40
28858263344,count_even_digits,"def count_even_digits(nums):
    count = 0
    for elem in nums:
        if len(str(elem)) % 2 == 0:
            count += 1
    return count",40
2476084503,find_Missing,"def find_Missing(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",40
42241132727,count_pattern_occurrences,"import re
def count_pattern_occurrences(text, pattern):
    pattern = pattern.replace('*', '.*')
    regex = re.compile(pattern)
    matches = regex.findall(text)
    return len(matches)",40
19735400511,min_numbers,"def min_numbers(x, k):
    if x % k != 0:
        return (1, [x])
    else:
        return (2, [1, x - 1])",40
15170547273,count_duplicates,"from collections import Counter

def count_duplicates(arr):
    counter = Counter(arr)
    duplicates = {k: v for k, v in counter.items() if v > 1}
    return duplicates",40
21009164609,largest_product,"def largest_product(arr):
    arr.sort()
    return max(arr[0] * arr[1] * arr[-1], arr[-1] * arr[-2] * arr[-3])",40
35090734469,valid_identifier,"import re

def valid_identifier(identifier):
    if re.match(""^[a-zA-Z_][a-zA-Z0-9_]*$"", identifier):
        return True
    else:
        return False",40
5629937107,unique_elements,"def unique_elements(lst):
    seen = set()
    result = []
    for num in lst:
        if num not in seen:
            seen.add(num)
            result.append(num)
    return result",40
17026951751,highest_product,"def highest_product(lst):
    lst.sort()
    return max(lst[-1] * lst[-2] * lst[-3], lst[0] * lst[1] * lst[-1])",40
27356015174,has_unique_chars,"def has_unique_chars(str1):
    char_set = set()
    for char in str1:
        if char in char_set:
            return False
        char_set.add(char)
    return True",40
7885027854,check_duplicates,"def check_duplicates(nums):
    hashset = set()
    for n in nums:
        if n in hashset:
            return True
        else:
            hashset.add(n)
    return False",40
30794926852,running_average,"def running_average(stream):
    res = []
    for i in range(1, len(stream)+1):
        ans = sum(stream[:i])/i
        res.append(ans)
    return res",40
17489509323,remove_duplicates,"def remove_duplicates(lst):
    result = []
    seen = set()
    for item in lst:
        if item not in seen:
            result.append(item)
            seen.add(item)
    return result",40
11145958593,match_any_regex,"import re

def match_any_regex(strings, regexes):
    for string in strings:
        for regex in regexes:
            if re.match(regex, string):
                return True
    return False",40
23483890747,remove_consecutive_duplicates,"def remove_consecutive_duplicates(string):
    result = []
    for char in string:
        if not result or result[-1] != char:
            result.append(char)
    return ''.join(result)",40
41418242529,is_strictly_increasing,"def is_strictly_increasing(lst):
    for i in range(len(lst) - 1):
        if lst[i] >= lst[i + 1]:
            return False
    return True",40
16613384646,second_highest,"def second_highest(lst):
    unique_lst = list(set(lst))
    if len(unique_lst) < 2:
        return None
    unique_lst.sort()
    return unique_lst[-2]",40
31594777908,all_subarrays,"def all_subarrays(nums):
    result = []
    for i in range(len(nums)):
        for j in range(i, len(nums)):
            result.append(nums[i:j+1])
    return result",40
38729794985,largest_product,"def largest_product(nums):
    nums.sort()
    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])",40
1693817036,sum_single_digits,"def sum_single_digits(s):
    sum = 0
    for char in s:
        if char.isdigit() and len(char) == 1:
            sum += int(char)
    return sum",40
16821000861,sum_of_divisors,"def sum_of_divisors(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum",40
73132380139,sum_of_divisors,"def sum_of_divisors(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum",40
16042353685,get_fibonacci,"def get_fibonacci(n):
    if n <= 1:
        return n
    else:
        return get_fibonacci(n-1) + get_fibonacci(n-2)",40
15887906508,sort_tuples,"def sort_tuples(tuples, order):
    tuples_sorted = sorted(tuples, key=lambda x: x[1])
    if order == ""desc"":
        tuples_sorted.reverse()
    return tuples_sorted",40
20089037278,string_occurrences,"def string_occurrences(list1, string): 
    count = 0
    for i in list1:
        if i == string:
            count = count + 1
    return count",40
3546779657,sum_of_divisors,"def sum_of_divisors(n):
    result = 0
    for i in range(1, n):
        if n % i == 0:
            result += i
    return result",40
32393287673,second_largest,"def second_largest(lst):
    unique_lst = list(set(lst))
    if len(unique_lst) < 2:
        return None
    unique_lst.sort()
    return unique_lst[-2]",40
781254945,clean_string,"def clean_string(input_string):
    cleaned_string = """"
    for char in input_string:
        if char.isalnum() or char.isspace():
            cleaned_string += char
    return cleaned_string",39
21452702947,product_of_evens,"def product_of_evens(input_list):
    product = 1
    for num in input_list:
        if num % 2 == 0:
            product *= num
    return product",39
41011924430,count_vowels,"def count_vowels(s):
    count = 0
    for char in s:
        if char in 'aeiouAEIOU':
            count += 1
    return count",39
4713964887,count_string_in_list,"def count_string_in_list(s, lst):
    count = 0
    for i in lst:
        if i.lower() == s.lower():
            count += 1
    return count",39
3718879792,binaryStrings,"def binaryStrings(s):
    count = 0
    for i in range(len(s)):
        if s[i] == '?':
            count += 1
    return 2**count",39
72679243410,sum_of_cubes,"def sum_of_cubes(n) : 
    sum = 0
    while n > 0:
        sum += (n*n*n)
        n -= 1
    return sum",39
28589913357,get_Trailing_Zeros,"def get_Trailing_Zeros(num):
    count = 0
    while num & 1 == 0:
        count+=1
        num = num>>1
    return count",39
22631424318,sum_Digits,"def sum_Digits(n): 
    sum = 0
    while n: 
        sum += n % 10
        n = n // 10
    return sum",39
21143430680,longest_word_length,"def longest_word_length(words):
    max_length = 0
    for word in words:
        if len(word) > max_length:
            max_length = len(word)
    return max_length",39
71195516248,remove_duplicates_preserve_order,"def remove_duplicates_preserve_order(lst):
    seen = set()
    seen_add = seen.add
    return [x for x in lst if not (x in seen or seen_add(x))]",39
12081346,find_longest_word,"def find_longest_word(words):
    longest_word = """"
    for word in words:
        if len(word) > len(longest_word):
            longest_word = word
    return longest_word",39
13085364033,match_lists_to_dict,"def match_lists_to_dict(keys, values):
    if len(keys) != len(values):
        return 'Length of lists are not equal'
    else:
        return dict(zip(keys, values))",39
43653340026,sum_digits,"def sum_digits(number):
    sum = 0
    while number > 0:
        sum += number % 10
        number = number // 10
    return sum",39
6710281438,unique_strings,"def unique_strings(string_list):
   from collections import Counter
   string_counts = Counter(string_list)
   return [string for string, count in string_counts.items() if count == 1]",39
2873349687,is_rotation,"def is_rotation(str1, str2):
    if len(str1) != len(str2):
        return False
    temp = str1 + str1
    return str2 in temp",39
20854894650,digit_sum,"def digit_sum(n):
    sum = 0
    while n != 0:
        sum += n % 10
        n = n // 10
    return sum",39
24383115316,missing_number,"def missing_number(nums):
    n = 100
    total = n*(n+1)/2
    sum_of_nums = sum(nums)
    return total - sum_of_nums",39
28344614270,reverse_sentence,"def reverse_sentence(sentence: str) -> str:
    words = sentence.split()
    reversed_words = words[::-1]
    reversed_sentence = ' '.join(reversed_words)
    return reversed_sentence",39
44157895706,longest_string_length,"def longest_string_length(strings):
    max_length = 0
    for string in strings:
        if len(string) > max_length:
            max_length = len(string)
    return max_length",39
26623252654,count_trailing_zeros,"def count_trailing_zeros(n: int) -> int:
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",39
25123712331,second_minimum,"def second_minimum(nums):
    unique_nums = list(set(nums))
    if len(unique_nums) < 2:
        return None
    unique_nums.sort()
    return unique_nums[1]",39
41630548743,rotate,"def rotate(nums, k):
    k %= len(nums)
    nums.reverse()
    nums[:k] = reversed(nums[:k])
    nums[k:] = reversed(nums[k:])
    return nums",39
70404537669,count_Even_Numbers,"def count_Even_Numbers(nums):
    count = 0
    for num in nums:
        if num % 2 == 0:
            count += 1
    return count",39
13125042570,sum_even_numbers,"def sum_even_numbers(nums):
    sum_even = 0
    for num in nums:
        if num % 2 == 0:
            sum_even += num
    return sum_even",39
38095113247,is_valid_palindrome,"import re

def is_valid_palindrome(s: str) -> bool:
    s = re.sub(r'[\W_]', '', s).lower()
    return s == s[::-1]",39
23795332790,is_rotation,"def is_rotation(str1, str2):
    if len(str1) != len(str2):
        return False
    temp = str1 + str1
    return str2 in temp",39
26088756279,can_rearrange,"def can_rearrange(arr):
    arr.sort()
    for i in range(len(arr)-1):
        if arr[i+1] <= arr[i]:
            return False
    return True",39
37608861350,add_tuples,"def add_tuples(list1, list2):
    return [(x + y, z + w) for (x, z), (y, w) in zip(list1, list2)]",39
4307554208,largest_Number,"def largest_Number(n):
    digits = [int(d) for d in str(n)]
    digits.sort(reverse=True)
    return int(''.join([str(d) for d in digits]))",39
72465357428,odd_Square_Sum,"def odd_Square_Sum(n):
    sum = 0
    for i in range(1, 2*n, 2):
        sum += i * i
    return sum",39
8713258149,second_minimum,"def second_minimum(arr):
    unique_nums = list(set(arr))
    if len(unique_nums) < 2:
        return None
    unique_nums.sort()
    return unique_nums[1]",39
71548651626,largest_Product_Of_Three,"def largest_Product_Of_Three(lst):
    lst.sort()
    return max(lst[0]*lst[1]*lst[-1], lst[-1]*lst[-2]*lst[-3])",39
28755799726,missing_number,"def missing_number(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",39
72282141272,divisors,"def divisors(n):
    lst = []
    for i in range(1, n + 1):
        if n % i == 0:
            lst.append(i)
    return lst",39
14430979373,largest_sum,"def largest_sum(nums):
    prev, curr = 0, 0
    for num in nums:
        prev, curr = curr, max(curr, prev + num)
    return curr",39
17338608768,find_strings_by_start_char,"def find_strings_by_start_char(lst, start_char):
    result = []
    for s in lst:
        if s[0] == start_char:
            result.append(s)
    return result",39
121717524,find_all_integers_in_ranges,"def find_all_integers_in_ranges(ranges):
    result = []
    for start, end in ranges:
        result.extend(range(start, end + 1))
    return list(set(result))",39
34049263750,sum_odd,"def sum_odd(n):
    sum = 0
    for i in range(1,n+1):
        if i%2 != 0:
            sum += i
    return sum",39
31646688236,isValidHTMLTag,"def isValidHTMLTag(s):
    if s[0] != ""<"" or s[-1] != "">"" or ""<"" in s[1:-1]:
        return False
    return True",39
5601170616,sum_Odd_Elements,"def sum_Odd_Elements(list1):
    sum = 0
    for i in list1:
        if i%2 != 0:
            sum += i
    return sum",39
71319143613,is_palindrome_ignore_special,"import re

def is_palindrome_ignore_special(s):
    s = re.sub(r'[^A-Za-z0-9]', '', s).lower()
    return s == s[::-1]",39
4308221328,reverse_digits,"def reverse_digits(nums):
    reversed_nums = []
    for num in nums:
        reversed_num = int(str(num)[::-1])
        reversed_nums.append(reversed_num)
    return reversed_nums",39
71836066114,binary_to_decimal,"def binary_to_decimal(binary_str):
    if not all(char in '01' for char in binary_str):
        return ""Invalid binary number""
    return int(binary_str, 2)",39
14627594980,first_recurring_char,"def first_recurring_char(s):
    char_set = set()
    for char in s:
        if char in char_set:
            return char
        char_set.add(char)
    return None",39
72655401710,duplicate_count,"from collections import Counter

def duplicate_count(text):
    text = text.lower()
    counter = Counter(text)
    return sum(1 for c in counter if counter[c] > 1)",39
19999599669,sum_digits,"def sum_digits(num):
    sum = 0
    while(num > 0):
        sum += num % 10
        num = num // 10
    return sum",39
38425854561,smallest_divisor,"def smallest_divisor(n, start):
    for i in range(start + 1, n + 1):
        if n % i == 0:
            return i
    return n",39
43339402797,reverse_in_groups,"def reverse_in_groups(lst, k):
    for i in range(0, len(lst), k):
        lst[i:i+k] = lst[i:i+k][::-1]
    return lst",39
22077995585,missing_number,"def missing_number(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",39
7272409565,longest_word_length,"def longest_word_length(words):
    max_length = 0
    for word in words:
        if len(word) > max_length:
            max_length = len(word)
    return max_length",39
27027931445,min_positive_sum,"def min_positive_sum(nums):
    result = 1
    nums.sort()
    for num in nums:
        if num > result:
            break
        result += num
    return result",39
2247003737,nth_fibonacci,"def nth_fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a",39
42097435444,find_fibonacci,"def find_fibonacci(n):
    a, b = 0, 1
    for i in range(n):
        a, b = b, a + b
    return a",39
72042431327,is_valid_scrabble_word,"def is_valid_scrabble_word(dictionary, word):
    word = sorted(word)
    for d_word in dictionary:
        if sorted(d_word) == word:
            return True
    return False",39
20438564450,lucas_number,"def lucas_number(n): 
    a, b = 2, 1
    for _ in range(n):
        a, b = b, a + b
    return a",39
13097067825,concatenate_lists,"def concatenate_lists(list1, list2):
    return list(zip(list1[:min(len(list1), len(list2))], list2[:min(len(list1), len(list2))]))",39
5209129710,is_rotation,"def is_rotation(str1, str2):
    if len(str1) != len(str2):
        return False
    temp = str1 + str1
    return str2 in temp",39
7054812896,longest_string_length,"def longest_string_length(strings):
    max_length = 0
    for string in strings:
        if len(string) > max_length:
            max_length = len(string)
    return max_length",39
3765204287,missing_number,"def missing_number(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",39
1230022498,reverse_list,"def reverse_list(lst):
    reversed_list = []
    for i in range(len(lst) - 1, -1, -1):
        reversed_list.append(lst[i])
    return reversed_list",39
6371923809,find_unique_elements,"def find_unique_elements(lst):
    unique_elements = []
    for element in lst:
        if lst.count(element) == 1:
            unique_elements.append(element)
    return sorted(unique_elements)",39
43192478568,count_unique_permutations,"from itertools import permutations
from collections import Counter

def count_unique_permutations(s):
    unique_perms = set([''.join(p) for p in permutations(s)])
    return len(unique_perms)",39
18031567073,lucas_num,"def lucas_num(n): 
    a, b = 2, 1
    for _ in range(n):
        a, b = b, a + b
    return a",39
73846683450,reverse_string,"def reverse_string(s):
    reversed_string = """"
    for i in range(len(s) - 1, -1, -1):
        reversed_string += s[i]
    return reversed_string",39
4485740193,find_longest_word,"def find_longest_word(words):
    longest_word = """"
    for word in words:
        if len(word) > len(longest_word):
            longest_word = word
    return longest_word",39
16839716164,is_sorted_alphabetically,"def is_sorted_alphabetically(words):
    for i in range(len(words) - 1):
        if words[i] > words[i + 1]:
            return False
    return True",39
29772783218,check_repeating_chars,"def check_repeating_chars(s):
    char_set = set()
    for char in s:
        if char in char_set:
            return True
        char_set.add(char)
    return False",39
12284946418,intersection,"def intersection(list1, list2):
    result = []
    for element in list1:
        if element in list2 and element not in result:
            result.append(element)
    return result",39
14192481277,missing_number,"def missing_number(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",39
32661225209,first_char,"def first_char(lists):
    result = []
    for i in lists:
        temp = i.split("" "")
        for j in temp:
            result.append(j[0])
    return result",39
12618941165,find_largest,"def find_largest(lst):
    if len(lst) == 1:
        return lst[0]
    else:
        return max(lst[0], find_largest(lst[1:]))",39
34825404499,largest_number,"def largest_number(n):
    digits = [int(d) for d in str(n)]
    digits.sort(reverse=True)
    return int(''.join([str(d) for d in digits]))",39
21674695435,has_duplicates,"def has_duplicates(nums):
    h = {}
    for num in nums:
        if num in h:
            return True
        else:
            h[num] = 1
    return False",39
14904361375,digit_sum,"def digit_sum(number):
    sum = 0
    while number > 0:
        sum += number % 10
        number = number // 10
    return sum",39
22313931815,remove_odd_index,"def remove_odd_index(s):
    result = """"
    for i in range(len(s)):
        if i % 2 == 0:
            result = result + s[i]
    return result",39
70461346386,find_last_occurrence,"def find_last_occurrence(lst, target):
    index = -1
    for i in range(len(lst)):
        if lst[i] == target:
            index = i
    return index",39
30282889064,min_steps,"def min_steps(arr):
    min_val = min(arr)
    steps = 0
    for i in range(len(arr)):
        steps += arr[i] - min_val
    return steps",39
44859905439,odd_cubes,"def odd_cubes(numbers):
    result = {}
    for num in numbers:
        if num % 2 != 0:
            result[num] = num ** 3
    return result",39
22129970708,max_unique_word,"def max_unique_word(words):
    def count_unique_chars(word):
        return len(set(word))

    words.sort()
    max_unique = max(words, key=count_unique_chars)
    return max_unique",39
41454108928,common_elements,"def common_elements(list1, list2):
    result=[]
    for i in list1:
        if i in list2 and i not in result:
            result.append(i)
    return result",39
25651559770,calculate_average,"def calculate_average(numbers):
    if len(numbers) <= 2:
        return None
    numbers.remove(max(numbers))
    numbers.remove(min(numbers))
    return sum(numbers) / len(numbers)",39
42207426242,rotate_array,"def rotate_array(arr, d):
    n = len(arr)
    d = d % n  # Handle rotations greater than length of array
    return arr[d:] + arr[:d]",39
6522828784,digit_sum,"def digit_sum(num):
    sum = 0
    while(num > 0):
        sum += num % 10
        num = num // 10
    return sum",39
11016989336,max_heap,"import heapq

def max_heap(arr):
    # heap solution
    arr = [-x for x in arr]
    heapq.heapify(arr)
    return -heapq.heappop(arr)",39
40532215719,smallest_positive_number,"def smallest_positive_number(numbers):
    positive_numbers = [num for num in numbers if num >= 0]
    if not positive_numbers:
        return None
    return min(positive_numbers)",39
17253784245,min_moves,"def min_moves(arr):
    min_val = min(arr)
    moves = 0
    for i in range(len(arr)):
        moves += arr[i] - min_val
    return moves",39
10715793070,solution,"def solution(n):
    answer = 0
    for x in range(1,n+1):
        if (n % x == 0):
            answer += x
    return answer",39
42120935756,max_product_pairs,"def max_product_pairs(numbers):
    numbers.sort()
    n = len(numbers)
    return max(numbers[0] * numbers[1], numbers[n-1] * numbers[n-2])",39
2128461337,sum_of_odd,"def sum_of_odd(numbers):
    sum_odd = 0
    for num in numbers:
        if num % 2 != 0:
            sum_odd += num
    return sum_odd",39
43070550216,missing_number,"def missing_number(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    sum_nums = sum(nums)
    return total - sum_nums",39
70183217945,lucas_num,"def lucas_num(n): 
    a, b = 2, 1
    for _ in range(n):
        a, b = b, a + b
    return a",39
18809559118,avg_nested_list,"def avg_nested_list(nested_list):
    avg = sum(sum(sub_list) for sub_list in nested_list) / sum(len(sub_list) for sub_list in nested_list)
    return avg",39
69821286011,sum_of_evens,"def sum_of_evens(list1):
    sum = 0
    for num in list1:
        if num % 2 == 0:
            sum += num
    return sum",39
21752232991,find_two_sum,"def find_two_sum(numbers, target):
    seen = set()
    for number in numbers:
        if target - number in seen:
            return True
        seen.add(number)
    return False",39
75016138620,is_alphanumeric_palindrome,"import re

def is_alphanumeric_palindrome(s):
    s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()
    return s == s[::-1]",39
27470829217,find_missing_number,"def find_missing_number(nums, n):
    expected_sum = (n * (n + 1)) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum",39
8869144186,reverse_digits,"def reverse_digits(numbers):
    reversed_numbers = []
    for number in numbers:
        reversed_number = int(str(number)[::-1])
        reversed_numbers.append(reversed_number)
    return reversed_numbers",39
21147622212,count_anagrams,"from collections import Counter

def count_anagrams(dictionary, word):
    word_counter = Counter(word)
    return sum(1 for dict_word in dictionary if Counter(dict_word) == word_counter)",39
30472626501,find_first_duplicate,"def find_first_duplicate(nums):
    hash_set = set()
    for num in nums:
        if num in hash_set:
            return num
        hash_set.add(num)
    return -1",39
14259338665,is_rotation,"def is_rotation(str1, str2):
    if len(str1) != len(str2):
        return False
    temp = str1 + str1
    return str2 in temp",39
27604256602,find_longest_word,"def find_longest_word(words):
    longest_word = """"
    for word in words:
        if len(word) > len(longest_word):
            longest_word = word
    return longest_word",39
30138200715,sum_of_factors,"def sum_of_factors(n):
    total = 0
    for i in range(1, n):
        if n % i == 0:
            total += i
    return total",39
26890480339,second_min,"def second_min(arr):
    unique_arr = list(set(arr))
    if len(unique_arr) < 2:
        return None
    unique_arr.sort()
    return unique_arr[1]",39
31098057896,is_valid_palindrome,"import re

def is_valid_palindrome(s):
    s = re.sub(r'[^A-Za-z0-9]', '', s).lower()
    return s == s[::-1]",38
19605019645,find_elements,"def find_elements(arr, divisor, remainder):
    count = 0
    for num in arr:
        if num % divisor == remainder:
            count += 1
    return count",38
26207667936,combine_lists,"def combine_lists(list1, list2):
    result = []
    for i in list1:
        for j in list2:
            result.append([i, j])
    return result",38
3765917458,has_unique_chars,"def has_unique_chars(str):
    char_set = set()
    for char in str:
        if char in char_set:
            return False
        char_set.add(char)
    return True",38
31707886,find_missing,"def find_missing(arr, n):
    total = (n * (n + 1)) // 2
    sum_of_arr = sum(arr)
    return total - sum_of_arr",38
25200497267,is_pattern_match,"import re
def is_pattern_match(s: str, p: str) -> bool:
    pattern = re.compile(p)
    match = pattern.fullmatch(s)
    return bool(match)",38
1305435553,square_roots,"import math

def square_roots(nums):
    result = []
    for num in nums:
        result.append(math.sqrt(num) if num >= 0 else 0)
    return result",38
32142885849,smallest_fibonacci,"def smallest_fibonacci(n):
    a, b = 0, 1
    while b < n:
        a, b = b, a + b
    return b",38
36890674428,is_valid_palindrome,"import re

def is_valid_palindrome(s: str) -> bool:
    s = re.sub(r'[\W_]', '', s.lower())
    return s == s[::-1]",38
73617155870,containsDuplicate,"def containsDuplicate(nums):
    hashmap = {}
    for num in nums:
        if num in hashmap:
            return True
        else:
            hashmap[num] = True
        
    return False",38
74795396745,largest_product_of_three,"def largest_product_of_three(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",38
13056437099,largest_number,"def largest_number(numbers):
  max_num = numbers[0]
  for num in numbers[1:]:
    if num > max_num:
      max_num = num
  return max_num",38
27866049006,recursive_list_sum,"def recursive_list_sum(lst):
    if len(lst) == 1:
        return lst[0]
    else:
        return lst[0] + recursive_list_sum(lst[1:])",38
7117093016,calculate_factorial,"def calculate_factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * calculate_factorial(n - 1)",38
37305769875,is_sorted_ascending,"def is_sorted_ascending(numbers):
    for i in range(len(numbers) - 1):
        if numbers[i] > numbers[i + 1]:
            return False
    return True",38
1515255319,count_distinct_chars,"def count_distinct_chars(s):
    s = s.lower()
    distinct_chars = set()
    for char in s:
        distinct_chars.add(char)
    return len(distinct_chars)",38
29169246425,last_occurrence,"def last_occurrence(string, char):
    index = -1
    for i in range(len(string)):
        if string[i] == char:
            index = i
    return index",38
6758162692,n_grams,"def n_grams(s, n):
    if len(s) < n:
        return []
    return [s[i:i+n] for i in range(len(s)-n+1)]",38
14128659806,frequency_counter,"from collections import defaultdict

def frequency_counter(arr):
    freq_dict = defaultdict(int)
    for num in arr:
        freq_dict[num] += 1
    return dict(freq_dict)",38
4195785597,group_by_first_char,"from collections import defaultdict

def group_by_first_char(strings):
    result = defaultdict(list)
    for string in strings:
        result[string[0]].append(string)
    return dict(result)",38
42806553254,bin_to_decimal,"def bin_to_decimal(binary):
    binary = str(binary)
    decimal = 0
    for digit in binary:
        decimal = decimal*2 + int(digit)
    return decimal",38
4458601320,sum_OddSquares,"def sum_OddSquares(n): 
    sum = 0
    for i in range(1,2*n,2): 
        sum += i*i
    return sum",38
42578090598,sum_even_numbers,"def sum_even_numbers(list1):
    result = 0
    for num in list1:
        if num % 2 == 0:
            result += num
    return result",38
29744660230,sum_divisible_by_three,"def sum_divisible_by_three(numbers):
    total = 0
    for number in numbers:
        if number % 3 == 0:
            total += number
    return total",38
20352362530,text_to_word_list,"import re

def text_to_word_list(text):
    # Use regex to split the text into words and punctuation
    return re.findall(r'\w+|[^\w\s]', text)",38
28851780368,find_k_largest,"import heapq

def find_k_largest(nums, k):
    if len(nums) < k:
        return sorted(nums, reverse=True)
    return heapq.nlargest(k, nums)",38
74319536905,even_index_sum,"def even_index_sum(arr):
    even_sum = 0
    for index in range(0, len(arr), 2):
        even_sum += arr[index]
    return even_sum",38
28683662046,find_largest_product,"def find_largest_product(numbers):
    numbers.sort()
    return max(numbers[0]*numbers[1]*numbers[-1], numbers[-1]*numbers[-2]*numbers[-3])",38
74965843234,max_product_three_nums,"def max_product_three_nums(lst):
    lst.sort()
    return max(lst[0]*lst[1]*lst[-1], lst[-1]*lst[-2]*lst[-3])",38
27380946782,is_strictly_increasing,"def is_strictly_increasing(numbers):
    for i in range(1, len(numbers)):
        if numbers[i] <= numbers[i-1]:
            return False
    return True",38
17041603897,find_intersection,"def find_intersection(list1, list2):
    set1 = set(list1)
    set2 = set(list2)
    intersection = sorted(set1.intersection(set2))
    return intersection",38
448621964,isPangram,"import string
def isPangram(s):
    alphabet = string.ascii_lowercase
    for char in alphabet:
        if char not in s.lower():
            return False
    return True",38
38022371205,reverse_subarrays,"def reverse_subarrays(lst, k):
    result = []
    for i in range(0, len(lst), k):
        result.extend(reversed(lst[i:i+k]))
    return result",38
27029049041,max_product_three_numbers,"def max_product_three_numbers(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",38
31957037954,count_string,"def count_string(string_list, target_string):
    count = 0
    for string in string_list:
        if string == target_string:
            count += 1
    return count",38
44572503825,sum_divisible_by_three,"def sum_divisible_by_three(arr):
    sum = 0
    for i in arr:
        if i % 3 == 0:
            sum += i
    return sum",38
17190811431,lucas,"def lucas(n): 
    a, b = 2, 1
    for i in range(n):
        a, b = b, a + b
    return a",38
18969924648,is_sorted_ascending,"def is_sorted_ascending(lst):
    for i in range(len(lst) - 1):
        if lst[i] > lst[i + 1]:
            return False
    return True",38
15229626875,sum_of_digits,"def sum_of_digits(n):
    if n == 0:
        return 0
    else:
        return n % 10 + sum_of_digits(n // 10)",38
21001848426,sum_list,"def sum_list(nums):
    if not nums:
        return 0
    else:
        total = 0
        for num in nums:
            total += num
        return total",38
20941387620,alphanumeric_value,"def alphanumeric_value(word):
    total = 0
    for char in word:
        if char.isalpha():
            total += ord(char.lower()) - 96
    return total",38
10786941205,is_pangram,"def is_pangram(sentence):
    alphabet = ""abcdefghijklmnopqrstuvwxyz""
    for char in alphabet:
        if sentence.lower().count(char) == 0:
            return False
    return True",38
72959740268,count_element,"def count_element(listval, element):
    count = 0
    for i in listval:
        if i == element:
            count = count + 1
    return count",38
24079204929,longest_word,"def longest_word(words):
    max_length = 0
    for word in words:
        if len(word) > max_length:
            max_length = len(word)
    return max_length",38
13762419370,greatest_divisor,"def greatest_divisor(n):
    for i in range(n//2, 0, -1):
        if n % i == 0:
            return i
    return 1",38
10490300687,count_word_occurrences,"def count_word_occurrences(word_list, word):
    count = 0
    for w in word_list:
        if w == word:
            count += 1
    return count",38
21658046745,valid_palindrome,"def valid_palindrome(s: str) -> bool:
    s = ''.join([c for c in s if c.isalnum()]).lower()
    return s == s[::-1]",38
17378759886,count_word_occurrences,"def count_word_occurrences(words, target_word):
    count_word_occurrences = len(list(filter(lambda x: x.lower() == target_word.lower(), words)))
    return count_word_occurrences",38
9747529442,reverse_string_recursively,"def reverse_string_recursively(s):
    if len(s) == 0:
        return s
    else:
        return reverse_string_recursively(s[1:]) + s[0]",38
18466208311,cartesian_product,"def cartesian_product(list1, list2):
    result = []
    for i in list1:
        for j in list2:
            result.append((i, j))
    return result",38
35023101515,divisor_sum,"def divisor_sum(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum",38
31906283041,has_unique_chars,"def has_unique_chars(s):
    char_set = set()
    for char in s:
        if char in char_set:
            return False
        char_set.add(char)
    return True",38
19104386376,largest_triplet_product,"def largest_triplet_product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",38
867690209,max_product_of_three,"def max_product_of_three(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",38
22389081417,find_largest_number,"def find_largest_number(numbers):
    largest_number = numbers[0]
    for number in numbers:
        if number > largest_number:
            largest_number = number
    return largest_number",38
20069903730,reverse_string_stack,"def reverse_string_stack(s):
    stack = []
    for char in s:
        stack.append(char)
    result = """"
    while stack:
        result += stack.pop()
    return result",38
3005887101,find_pair,"def find_pair(lst, target):
  seen = set()
  for num in lst:
    if target - num in seen:
      return True
    seen.add(num)
  return False",38
35160789368,smallest_positive,"def smallest_positive(nums):
    positive_nums = [num for num in nums if num >= 0]
    if not positive_nums:
        return None
    return min(positive_nums)",38
72464518388,nth_fibonacci,"def nth_fibonacci(n):
  a, b = 0, 1
  for _ in range(n):
    a, b = b, a+b
  return a",38
20371984163,lucas_number,"def lucas_number(n):
    a, b = 2, 1
    for _ in range(n):
        a, b = b, a + b
    return a",38
15630002965,find_duplicates,"def find_duplicates(lst):
    duplicates = []
    for num in lst:
        if lst.count(num) > 1 and num not in duplicates:
            duplicates.append(num)
    return duplicates",38
73784284050,is_sorted_ascending,"def is_sorted_ascending(nums):
    for i in range(len(nums) - 1):
        if nums[i] > nums[i + 1]:
            return False
    return True",38
72617903745,find_missing,"def find_missing(numbers):
    for i in range(len(numbers)-1):
        if numbers[i+1] - numbers[i] != 1:
            return numbers[i] + 1",38
18874307847,unique_char_in_order,"def unique_char_in_order(input_str):
    unique_chars = []
    for char in input_str:
        if char not in unique_chars:
            unique_chars.append(char)
    return unique_chars",38
73903685428,lucas,"def lucas(n): 
    a, b = 2, 1
    for i in range(n):
        a, b = b, a + b
    return a",38
32518721669,count_word_occurrences,"def count_word_occurrences(words, target_word):
    count = 0
    for word in words:
        if word == target_word:
            count += 1
    return count",38
11940435866,sort_odd_numbers,"def sort_odd_numbers(numbers):
    # Use list comprehension to filter out odd numbers and sort them
    return sorted([num for num in numbers if num % 2 != 0])",38
33495923810,longest_word,"def longest_word(words):
    max_length = 0
    for word in words:
        if len(word) > max_length:
            max_length = len(word)
    return max_length",38
6588145523,cartesian_product,"def cartesian_product(list1, list2):
    result = []
    for i in list1:
        for j in list2:
            result.append((i, j))
    return result",38
9392675547,filter_palindromes,"def filter_palindromes(lst):
    def is_palindrome(s):
        return s == s[::-1]
    
    return [s for s in lst if is_palindrome(s)]",38
16923883817,sum_of_n_natural_numbers,"def sum_of_n_natural_numbers(n):
    if n == 1:
        return 1
    else:
        return n + sum_of_n_natural_numbers(n-1)",38
38303180020,largest_product_of_three,"def largest_product_of_three(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",38
11015496786,find_longest,"def find_longest(strings):
    longest_string = """"
    for string in strings:
        if len(string) > len(longest_string):
            longest_string = string
    return longest_string",38
18470802433,reverse_string,"def reverse_string(s):
    reversed_string = """"
    for i in range(len(s)-1, -1, -1):
        reversed_string += s[i]
    return reversed_string",37
44771886976,find_longest,"def find_longest(lst):
    longest = lst[0]
    for string in lst:
        if len(string) > len(longest):
            longest = string
    return longest",37
37218818942,find_duplicates,"from collections import Counter

def find_duplicates(lst):
    count = Counter(lst)
    return {(k, v) for k, v in count.items() if v > 1}",37
24923451520,find_largest_element,"def find_largest_element(list1):
    largest = list1[0]
    for num in list1:
        if num > largest:
            largest = num
    return largest",37
15519634959,recursive_factorial,"def recursive_factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * recursive_factorial(n-1)",37
39228067608,sum_of_powers,"def sum_of_powers(n, k):
    sum = 0
    for i in range(1, n+1):
        sum += i**k
    return sum",37
30782805642,largest_number_from_digits,"def largest_number_from_digits(n):
    digits = [int(d) for d in str(n)]
    digits.sort(reverse=True)
    return int(''.join(map(str, digits)))",37
39641370446,smallest_multiple,"def smallest_multiple(divisor, value):
    if value % divisor == 0:
        return value
    else:
        return ((value // divisor) + 1) * divisor",37
33917539526,largest_product_three,"def largest_product_three(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",37
15550305253,is_valid_pin,"import re

def is_valid_pin(pin):
    if re.match(r'^[1-9]\d{5}$', pin):
        return True
    else:
        return False",37
10741219239,is_valid_palindrome,"def is_valid_palindrome(s: str) -> bool:
    s = ''.join(ch.lower() for ch in s if ch.isalnum())
    return s == s[::-1]",37
28617372173,remove_vowels,"def remove_vowels(s):
    vowels = 'aeiouAEIOU'
    s = ''.join([char for char in s if char not in vowels])
    return s",37
72817551317,find_unique_elements,"def find_unique_elements(nums):
    unique_elements = []
    for num in nums:
        if nums.count(num) == 1:
            unique_elements.append(num)
    return unique_elements",37
38224378692,rotate_string,"def rotate_string(s, n):
    if n == 0:
        return s
    n = n % len(s)
    return s[-n:] + s[:-n]",37
37648689434,series_sum,"def series_sum(n):
    sum = 0.0
    for i in range(1, n+1):
        sum += 1/(i*i)
    return sum",37
40791886757,find_max_product,"def find_max_product(nums):
    nums.sort()
    return max(nums[-1]*nums[-2]*nums[-3], nums[0]*nums[1]*nums[-1])",37
29495457670,find_max_number,"def find_max_number(numbers):
    max_number = numbers[0]
    for number in numbers:
        if number > max_number:
            max_number = number
    return max_number",37
24485384292,max_product_three,"def max_product_three(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",37
35851794738,second_highest,"def second_highest(numbers):
    numbers = list(set(numbers))
    if len(numbers) < 2:
        return None
    numbers.remove(max(numbers))
    return max(numbers)",37
2696062619,max_in_list,"def max_in_list(numbers):
    max_num = numbers[0]
    for num in numbers:
        if num > max_num:
            max_num = num
    return max_num",37
25621183281,largest_divisor,"from math import gcd

def largest_divisor(nums):
    result = nums[0]
    for i in nums[1:]:
        result = gcd(result, i)
    return result",37
19073981567,reverse_list,"def reverse_list(lst):
    reversed_list = []
    for i in range(len(lst)-1, -1, -1):
        reversed_list.append(lst[i])
    return reversed_list",37
22709811155,cumulative_sum,"def cumulative_sum(numbers):
    result = []
    current_sum = 0
    for num in numbers:
        current_sum += num
        result.append(current_sum)
    return result",37
32518643659,remove_consecutive_duplicates,"def remove_consecutive_duplicates(nums):
    result = []
    for num in nums:
        if not result or result[-1] != num:
            result.append(num)
    return result",37
25570968939,sum_multiply,"def sum_multiply(lst):
    if not lst:
        return 0
    else:
        even_sum = sum(lst[::2])
        return even_sum * lst[-1]",37
13448194724,even_sum,"def even_sum(list1):
  sum = 0
  for num in list1:
    if num % 2 == 0:
      sum += num
  return sum",37
29539630993,find_longest,"def find_longest(strings):
    longest = strings[0]
    for string in strings:
        if len(string) > len(longest):
            longest = string
    return longest",37
1532174324,reverse_and_check_palindrome,"def reverse_and_check_palindrome(input_string):
    reversed_string = input_string[::-1]
    is_palindrome = input_string == reversed_string
    return reversed_string, is_palindrome",37
38125732129,kth_smallest_element,"def kth_smallest_element(lst, k):
    if k > len(lst):
        return -1
    sorted_lst = sorted(lst)
    return sorted_lst[k-1]",37
40713134224,is_palindrome,"import re

def is_palindrome(s):
    s = re.sub(r'[^A-Za-z0-9]', '', s).lower()
    return s == s[::-1]",37
15001526400,find_top_k_frequent,"from collections import Counter

def find_top_k_frequent(nums, k):
    counter = Counter(nums)
    return [x[0] for x in counter.most_common(k)]",37
25390940709,reverse_words_in_sentence,"def reverse_words_in_sentence(sentence):
    words = sentence.split("" "")
    reversed_words = [word[::-1] for word in words]
    return "" "".join(reversed_words)",37
3769753234,calc_factorial,"def calc_factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * calc_factorial(n-1)",37
42570674452,largest_product_three,"def largest_product_three(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",37
73965182520,is_palindrome,"def is_palindrome(s: str) -> bool:
    s = ''.join([c.lower() for c in s if c.isalnum()])
    return s == s[::-1]",37
10344550999,vowel_count,"def vowel_count(s):
    count = 0
    for char in s:
        if char in ""aeiouAEIOU"":
            count += 1
    return count",37
6775268945,largest_possible_number,"def largest_possible_number(num):
  str_num = str(num)
  sorted_num = sorted(str_num, reverse=True)
  res = int("""".join(sorted_num))
  return res",37
16049394325,sum_of_odds,"def sum_of_odds(l):
    sum = 0
    for i in l:
        if i % 2 != 0:
            sum += i
    return sum",37
21891722010,first_of_largest_last,"def first_of_largest_last(tuples_list):
    if not tuples_list:
        return None
    return max(tuples_list, key=lambda x: x[-1])[0]",37
70223461117,longest_string,"def longest_string(list_of_strings):
    longest = """"
    for string in list_of_strings:
        if len(string) > len(longest):
            longest = string
    return longest",37
7921159364,get_odd_numbers,"def get_odd_numbers(numbers):
  odd_numbers = []
  for number in numbers:
    if number % 2 != 0:
      odd_numbers.append(number)
  return odd_numbers",37
21316330884,is_string_palindrome,"def is_string_palindrome(s: str) -> bool:
    s = ''.join(c.lower() for c in s if c.isalnum())
    return s == s[::-1]",37
74270057303,is_sorted,"def is_sorted(arr):
    i=1
    while i<len(arr) and arr[i]>=arr[i-1]:
        i+=1
    return i==len(arr)",37
21151169534,is_rotation,"def is_rotation(A: str, B: str) -> bool:
    if len(A) != len(B):
        return False
    A += A
    return B in A",37
36190738206,find_longest,"def find_longest(lst):
    longest = lst[0]
    for string in lst:
        if len(string) > len(longest):
            longest = string
    return longest",37
21259186503,max_in_list,"def max_in_list(lst):
    max_num = lst[0]
    for num in lst:
        if num > max_num:
            max_num = num
    return max_num",37
18426727632,count_evens,"def count_evens(nums):
  count = 0
  for num in nums:
    if num % 2 == 0:
      count += 1
  return count",37
25427873452,reverse_words_in_sentence,"def reverse_words_in_sentence(sentence):
    words = sentence.split("" "")
    reversed_words = [word[::-1] for word in words]
    return "" "".join(reversed_words)",37
24987295227,trailing_zeroes_factorial,"def trailing_zeroes_factorial(n):
    result = 0
    while n > 0:
        n = n // 5
        result += n
    return result",37
5787742694,length_longest_string,"def length_longest_string(strings):
    if not strings:  # Check if the list is empty
        return 0
    return max(len(string) for string in strings)",37
12497909540,sum_of_digits,"def sum_of_digits(num):
    sum = 0
    while num:
        sum += num % 10
        num = num // 10
    return sum",37
24980677611,most_frequent_elements,"from collections import Counter
def most_frequent_elements(lists):
    flat_list = [item for sublist in lists for item in sublist]
    return dict(Counter(flat_list))",37
5875959190,cumulative_sum,"def cumulative_sum(lst):
    cumsum = []
    total = 0
    for i in lst:
        total += i
        cumsum.append(total)
    return cumsum",37
38804180788,find_max_number,"def find_max_number(num):
    num_str = str(num)
    num_list = list(num_str)
    num_list.sort(reverse=True)
    return int(''.join(num_list))",37
41031393090,check_perfect_square,"import math
def check_perfect_square(num):
  if (math.sqrt(num) - int(math.sqrt(num))) == 0:
    return True
  else:
    return False",37
8621053019,sum_Of_Cubes,"def sum_Of_Cubes(n): 
    result = 0
    for i in range(1, n + 1):
        result += i**3
    return result",37
70716748662,recursive_factorial,"def recursive_factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * recursive_factorial(n-1)",37
40604140327,msb_decimal_value,"def msb_decimal_value(num):
    for i in range(31, -1, -1):
        if num & (1 << i):
            return 1 << i",37
26972460596,find_digits_in_string,"import re

def find_digits_in_string(s):
    pattern = r'\b\d+\b'
    result = re.findall(pattern, s)
    return list(map(int, result))",37
26890577179,can_construct,"from collections import Counter

def can_construct(ransomNote: str, magazine: str) -> bool:
    return (Counter(ransomNote) - Counter(magazine)) == {}",37
22222569938,find_largest,"def find_largest(lst):
    max_num = lst[0]
    for num in lst:
        if num > max_num:
            max_num = num
    return max_num",37
34917876034,merge_dicts,"from collections import Counter
def merge_dicts(*dicts):
    merged_dict = Counter()
    for dictionary in dicts:
        merged_dict.update(dictionary)
    return dict(merged_dict)",37
20057176360,max_in_list,"def max_in_list(numbers):
    max_value = numbers[0]
    for number in numbers:
        if number > max_value:
            max_value = number
    return max_value",37
36037321748,isAnagram,"def isAnagram(s: str, t: str) -> bool:
    if len(s) != len(t):
        return False
    return sorted(s) == sorted(t)",37
11311805303,is_unique,"def is_unique(string):
    char_set = set()
    for char in string:
        if char in char_set:
            return False
        char_set.add(char)
    return True",37
365529097,swap_edge_chars,"def swap_edge_chars(s):
    if len(s) <= 1:
        return s
    return s[-1] + s[1:-1] + s[0]",37
17411614994,max_product_three,"def max_product_three(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",37
71118730424,smallest_divisor,"def smallest_divisor(num, divisors):
    divisors.sort()
    for divisor in divisors:
        if num % divisor == 0:
            return divisor
    return num",37
3473660914,is_strictly_increasing,"def is_strictly_increasing(lst):
    for i in range(len(lst)-1):
        if lst[i] >= lst[i+1]:
            return False
    return True",37
737468861,is_perfect_cube,"def is_perfect_cube(n):
    if n < 0:
        n = -n
    return round(n ** (1. / 3)) ** 3 == n",37
26089948375,sum_of_list,"def sum_of_list(input_list):
    total_sum = 0
    for sublist in input_list:
        for number in sublist:
            total_sum += number
    return total_sum",37
74687831037,reverse_string_keep_words,"def reverse_string_keep_words(s):
    words = s.split("" "")
    reversed_words = [word[::-1] for word in words]
    return "" "".join(reversed_words)",37
26542170850,find_longest,"def find_longest(strings):
    longest = strings[0]
    for string in strings:
        if len(string) > len(longest):
            longest = string
    return longest",37
32282359038,longest_uncommon_subsequence,"def longest_uncommon_subsequence(a: str, b: str) -> int:
    if a == b:
        return -1
    return max(len(a), len(b))",37
1340007949,remove_odd_index,"def remove_odd_index(s):
    result = """"
    for i in range(len(s)):
        if i % 2 == 0:
            result += s[i]
    return result",37
15073404707,check_sum,"def check_sum(nums, target):
    seen = set()
    for num in nums:
        if target-num in seen:
            return True
        seen.add(num)
    return False",37
15951050771,count_ones_in_binary,"def count_ones_in_binary(n):
    if n < 0:
        return []
    return [bin(i).count('1') for i in range(n + 1)]",37
4581587410,find_max_product,"def find_max_product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",37
39592376162,square_sum_odd,"def square_sum_odd(n):
    sum = 0
    for i in range(1, 2*n, 2):
        sum += i**2
    return sum",37
22865718784,catalan_number,"import math

def catalan_number(n):
    return int((math.factorial(2*n)) / ((math.factorial(n)) * (math.factorial(n + 1))))",37
28090620733,is_unique,"def is_unique(string):
    dict = {}
    for s in string:
        if s in dict:
            return False
        dict[s] = 1
    return True",36
10604615168,maxProduct,"def maxProduct(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
71575839545,max_Product,"def max_Product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
39469187909,check_anagram,"def check_anagram(str1, str2):
    if len(str1) != len(str2):
        return False
    return sorted(str1) == sorted(str2)",36
4194892517,sum_to_zero,"def sum_to_zero(lst):
    seen = set()
    for num in lst:
        if -num in seen:
            return True
        seen.add(num)
    return False",36
4108008352,word_count,"def word_count(word_list, word):
    count = 0
    for w in word_list:
        if w == word:
            count += 1
    return count",36
31403450905,is_perfect_square,"def is_perfect_square(n):
    if n < 0:
        return False
    else:
        return int(n ** 0.5) ** 2 == n",36
22003571343,sum_of_naturals,"def sum_of_naturals(n):
    if n == 1:
        return 1
    else:
        return n + sum_of_naturals(n-1)",36
5751072099,squareOfSum,"def squareOfSum(n): 
    sum = 0
    for i in range(1,n + 1): 
        sum += i
    return sum * sum",36
15210953989,max_number,"def max_number(nums):
    max_num = nums[0]
    for num in nums:
        if num > max_num:
            max_num = num
    return max_num",36
72042738207,maximum_product,"def maximum_product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
2040896458,max_number,"def max_number(list):
    max_num = list[0]
    for num in list:
        if num > max_num:
            max_num = num
    return max_num",36
34908877856,is_valid_hex_color,"import re

def is_valid_hex_color(color):
    pattern = r'^#[0-9a-fA-F]{6}$'
    return bool(re.match(pattern, color))",36
41407718932,arrange_coins,"import math

def arrange_coins(n: int) -> int:
    # Mathematics
    return int((math.sqrt(8 * n + 1)-1)/2)",36
22363512647,has_consecutive_duplicates,"def has_consecutive_duplicates(nums):
    for i in range(1, len(nums)):
        if nums[i] == nums[i-1]:
            return True
    return False",36
20225877556,sum_digits,"def sum_digits(n):
    if n == 0:
        return 0
    else:
        return n % 10 + sum_digits(n // 10)",36
70466060420,find_two_largest,"def find_two_largest(lst):
    largest = max(lst)
    lst.remove(largest)
    second_largest = max(lst)
    return [second_largest, largest]",36
16953608199,largest_product,"def largest_product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
31691770090,max_product,"def max_product(nums):
  nums.sort()
  return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
11294330733,sum_of_series,"def sum_of_series(n):
    sum = 0
    for i in range(1, n+1):
        sum += 1/(i*i)
    return sum",36
29490121806,sum_of_powers,"def sum_of_powers(lst):
    return sum([i for i in lst if (i & (i - 1) == 0) and i != 0])",36
42414280235,checkPerfectSquare,"import math

def checkPerfectSquare(num):
    if (int(math.sqrt(num))**2) == num:
        return ""Yes""
    else:
        return ""No""",36
31249196953,is_valid_hex_color,"import re

def is_valid_hex_color(color):
    pattern = r'^#[0-9a-fA-F]{6}$'
    return bool(re.match(pattern, color))",36
35589294197,reverse_sublist,"def reverse_sublist(lst, start, end):
    if start < end:
        lst[start:end+1] = lst[start:end+1][::-1]
    return lst",36
17808144575,sum_of_odd,"def sum_of_odd(numbers):
    total = 0
    for num in numbers:
        if num % 2 != 0:
            total += num
    return total",36
17524463374,reverse_words_in_sentence,"def reverse_words_in_sentence(sentence):
    words = sentence.split()
    reversed_words = [word[::-1] for word in words]
    return ' '.join(reversed_words)",36
70592327480,sum_of_cubes,"def sum_of_cubes(n):
    sum = 0
    for i in range(1, n+1):
        sum += i ** 3
    return sum",36
39954358404,sum_of_even,"def sum_of_even(nums):
    total = 0
    for num in nums:
        if num % 2 == 0:
            total += num
    return total",36
30529771337,max_product,"def max_product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
41140621003,maxProduct,"def maxProduct(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
40685244307,find_max,"def find_max(nums):
    max_num = nums[0]
    for num in nums:
        if num > max_num:
            max_num = num
    return max_num",36
20374471737,cumulative_sum,"def cumulative_sum(nums):
    list=[nums[0]]
    for i in range(1,len(nums)):
        list.append(list[i-1]+nums[i])
    return list",36
38839775957,contains_consecutive_duplicates,"def contains_consecutive_duplicates(nums):
    for i in range(1, len(nums)):
        if nums[i] == nums[i-1]:
            return True
    return False",36
22954686356,filter_and_sort_even_numbers,"def filter_and_sort_even_numbers(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",36
10294878337,sum_of_odd_numbers,"def sum_of_odd_numbers(n):
    sum = 0
    for i in range(1, 2*n, 2):
        sum += i
    return sum",36
21558734992,is_sorted,"def is_sorted(nums):
    for i in range(len(nums) - 1):
        if nums[i] > nums[i + 1]:
            return False
    return True",36
23964480490,count_key_occurrence,"def count_key_occurrence(lst, key):
    count = 0
    for item in lst:
        if item == key:
            count += 1
    return count",36
73597712928,check_repeated,"import re
def check_repeated(string):
    regex = r'(.)\1'
    if re.search(regex, string):
        return True
    else:
        return False",36
27433902113,find_greater,"def find_greater(arr, num):
    try:
        return next(i for i, x in enumerate(arr) if x > num)
    except StopIteration:
        return -1",36
14263161472,maximum_product,"def maximum_product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
8468529891,is_anagram,"def is_anagram(str1, str2):
    if len(str1) != len(str2):
        return False
    return sorted(str1) == sorted(str2)",36
2371282545,max_number,"def max_number(numbers):
    max_num = numbers[0]
    for num in numbers:
        if num > max_num:
            max_num = num
    return max_num",36
72799227976,is_sorted,"def is_sorted(nums):
    for i in range(len(nums) - 1):
        if nums[i] > nums[i + 1]:
            return False
    return True",36
2471193636,maximum_product,"def maximum_product(arr):
    arr.sort()
    return max(arr[0]*arr[1]*arr[-1], arr[-1]*arr[-2]*arr[-3])",36
44878327234,count_char,"def count_char(test_str, char):
  count = 0
  for i in test_str:
    if i == char:
      count += 1
  return count",36
24620750710,max_number,"def max_number(nums):
    max_num = nums[0]
    for num in nums:
        if num > max_num:
            max_num = num
    return max_num",36
413700548,max_num,"def max_num(lst):
    max_num = lst[0]
    for num in lst:
        if num > max_num:
            max_num = num
    return max_num",36
27151168977,check_valid_permutation,"def check_valid_permutation(A):
    A.sort()
    for i in range(len(A)):
        if A[i] != i+1:
            return False
    return True",36
32087580360,find_next_larger,"def find_next_larger(nums, target):
    nums = sorted(set(nums))
    for num in nums:
        if num > target:
            return num
    return -1",36
28024028580,max_number,"def max_number(numbers):
    max_num = numbers[0]
    for num in numbers:
        if num > max_num:
            max_num = num
    return max_num",36
32848473467,find_min,"def find_min(numbers):
    min_num = numbers[0]
    for num in numbers:
        if num < min_num:
            min_num = num
    return min_num",36
3512418502,longest_word,"def longest_word(words):
    longest = words[0]
    for word in words:
        if len(word) > len(longest):
            longest = word
    return longest",36
26224579967,count_char_occurrences,"def count_char_occurrences(string, char):
    count = 0
    for i in string:
        if i == char:
            count += 1
    return count",36
21981169904,first_recurring_char,"def first_recurring_char(s):
    seen = set()
    for char in s:
        if char in seen:
            return char
        seen.add(char)
    return None",36
1850593984,fibonacci_recursive,"def fibonacci_recursive(n):
    if n <= 1:
       return n
    else:
       return(fibonacci_recursive(n-1) + fibonacci_recursive(n-2))",36
5983903688,filter_and_sort_evens,"def filter_and_sort_evens(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",36
25745518466,unique_strings,"def unique_strings(list):
  unique_list = []
  for item in list:
    if list.count(item) == 1:
      unique_list.append(item)
  return unique_list",36
74144772969,find_max_length_strings,"def find_max_length_strings(strings):
    max_length = max(len(s) for s in strings)
    return [s for s in strings if len(s) == max_length]",36
69872789784,max_num,"def max_num(lst):
    max_num = lst[0]
    for num in lst:
        if num > max_num:
            max_num = num
    return max_num",36
34651316589,maxProduct,"def maxProduct(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
18404837829,minMovesToMakeArrayEqual,"def minMovesToMakeArrayEqual(A):
    A.sort()
    median = A[len(A)//2]
    return sum([abs(i-median) for i in A])",36
74733366060,sum_as_string,"def sum_as_string(a, b):
    if not isinstance(a, int) or not isinstance(b, int):
        return ""Invalid input""
    return str(a + b)",36
27978645087,containsDuplicate,"def containsDuplicate(nums):
    count = {}
    for x in nums:
        if x in count:
            return True
        count[x] = 1
    return False",36
8135757808,rotate_list,"def rotate_list(lst, k):
    k = k % len(lst)  # Handle rotations greater than the list length
    return lst[-k:] + lst[:-k]",36
4495357729,last_even,"def last_even(nums):
  last_even = -1
  for el in nums:
    if el%2==0:
      last_even = el
  return last_even",36
30865588127,is_perfect_square,"def is_perfect_square(n):
    if n < 0:
        return False
    root = int(n ** 0.5)
    return root * root == n",36
86738166641,count_Set_Bits,"def count_Set_Bits(n): 
    count = 0
    while n: 
        count += n & 1
        n >>= 1
    return count",36
20004586671,max_product,"def max_product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
41339255282,largest_Number,"def largest_Number(n):
    num_str = str(n)
    num_list = list(num_str)
    num_list.sort(reverse=True)
    return int("""".join(num_list))",36
8315885203,find_unique,"def find_unique(l):
    unique_list = []
    for i in l:
        if l.count(i) == 1:
            unique_list.append(i)
    return unique_list",36
16864746158,first_repeating_element,"def first_repeating_element(arr):
    seen = set()
    for num in arr:
        if num in seen:
            return num
        seen.add(num)
    return None",36
4367931517,filter_and_sort_even_numbers,"def filter_and_sort_even_numbers(nums):
    even_nums = [num for num in nums if num % 2 == 0]
    even_nums.sort()
    return even_nums",36
26623134294,find_odd,"from collections import Counter

def find_odd(seq):
    A = Counter(seq)
    for k in A:
        if A[k]%2 != 0:
            return(k)",36
21258412001,convert_to_binary,"def convert_to_binary(decimals):
    binary_list = []
    for decimal in decimals:
        binary = bin(decimal)[2:]
        binary_list.append(binary)
    return binary_list",36
16838464045,check_perfect_square,"import math

def check_perfect_square(n):
    if n < 0:
        return False
    root = math.isqrt(n)
    return n == root * root",36
32236256269,max_Product,"def max_Product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
15947994402,heap_queue_kthsmallest,"import heapq as hq
def heap_queue_kthsmallest(nums,k):
  smallest_nums = hq.nsmallest(k, nums)
  return smallest_nums[-1]",36
71634378328,find_next_greater,"def find_next_greater(arr, k):
    arr.sort()
    for i in range(len(arr)):
        if arr[i] > k:
            return arr[i]
    return None",36
2881120054,sort_list_of_tuples,"def sort_list_of_tuples(tuples_list: list[tuple]) -> list[tuple]:
    return sorted(tuples_list, key=lambda x: x[1], reverse=True)",36
17086781445,count_char_occurrences,"def count_char_occurrences(str, char):
    count = 0
    for c in str:
        if c == char:
            count += 1
    return count",36
12235759340,count_digits,"def count_digits(n): 
    count = 0
    while(n > 0): 
        count+=1
        n = n//10
    return count",36
71921802127,sum_even_numbers,"def sum_even_numbers(numbers):
    sum = 0
    for num in numbers:
        if num % 2 == 0:
            sum += num
    return sum",36
74006260266,largest_product,"def largest_product(arr):
    arr.sort()
    return max(arr[0]*arr[1]*arr[-1], arr[-1]*arr[-2]*arr[-3])",36
25881921897,contains_duplicates,"def contains_duplicates(nums):
  stat = {}
  for num in nums:
    if num in stat:
      return True
    stat[num] = 1
  return False",36
72595096747,missingInteger,"def missingInteger(nums):
    nums = set(nums)
    for i in range(1, len(nums) + 2):
        if i not in nums:
            return i",36
37101701150,count_even,"def count_even(arr):
    count = 0
    for i in arr:
        if i % 2 == 0:
            count += 1
    return count",36
43665070427,count_char_occurrences,"def count_char_occurrences(s, char):
    count = 0
    for c in s:
        if c == char:
            count += 1
    return count",36
16080831663,cubeSum,"def cubeSum(n):
    sum = 0
    for i in range(1,n+1) :
        sum = sum + (i*i*i)
    return sum",36
22852688926,list_difference,"def list_difference(arr1, arr2):
    result = []
    for element in arr1:
        if element not in arr2:
            result.append(element)
    return result",36
370797556,count_uppercase,"def count_uppercase(text):
    uppercase_count = 0
    for char in text:
        if char.isupper():
            uppercase_count += 1
    return uppercase_count",36
70034080707,is_perfect_square,"def is_perfect_square(n):
    if n < 0:
        return False
    root = int(n ** 0.5)
    return root * root == n",36
39576980714,find_occurrences,"def find_occurrences(nums, target):
    indices = []
    for i in range(len(nums)):
        if nums[i] == target:
            indices.append(i)
    return indices",36
30791047028,max_value,"def max_value(numbers):
    max_num = numbers[0]
    for num in numbers:
        if num > max_num:
            max_num = num
    return max_num",36
44169994535,is_palindrome,"def is_palindrome(s: str) -> bool:
    s = ''.join(ch.lower() for ch in s if ch.isalnum())
    return s == s[::-1]",36
6913819460,smallest_missing,"def smallest_missing(A):
    A = set(A)
    smallest_missing = 1
    while smallest_missing in A:
        smallest_missing += 1
    return smallest_missing",36
1790465985,maximum_product,"def maximum_product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
15575176238,find_longest_strings,"def find_longest_strings(strings):
    max_length = max(len(s) for s in strings)
    return [s for s in strings if len(s) == max_length]",36
40366424430,are_anagrams,"def are_anagrams(str1, str2):
    if len(str1) != len(str2):
        return False
    return sorted(str1) == sorted(str2)",36
73980215250,check_perfect_square,"import math

def check_perfect_square(num):
    if num < 0:
        return False
    root = math.isqrt(num)
    return root * root == num",36
25990101482,extract_unique,"def extract_unique(numbers):
    unique_numbers = []
    for number in numbers:
        if numbers.count(number) == 1:
            unique_numbers.append(number)
    return unique_numbers",36
43931181876,filter_and_sort_evens,"def filter_and_sort_evens(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",36
5329833394,sum_of_even,"def sum_of_even(nums):
    sum = 0
    for i in nums:
        if i % 2 == 0:
            sum += i
    return sum",36
11868112140,count_uppercase,"def count_uppercase(lst):
    count = 0
    for word in lst:
        if word[0].isupper():
            count += 1
    return count",36
23759800510,sort_even_numbers,"def sort_even_numbers(num_list):
    even_numbers = [num for num in num_list if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",36
36597604651,is_rotation_substring,"def is_rotation_substring(source, target):
    if len(target) > len(source):
        return False
    doubled_source = source + source
    return target in doubled_source",36
37580266428,count_word_occurrences,"def count_word_occurrences(lst, word):
  count = 0
  for w in lst:
    if w == word:
      count += 1
  return count",36
10628732120,exchange_chars,"def exchange_chars(s):
    if len(s) <= 1:
        return s
    return s[-1] + s[1:-1] + s[0]",36
6400836629,find_max,"def find_max(lst):
    max_num = lst[0]
    for num in lst:
        if num > max_num:
            max_num = num
    return max_num",36
17086679225,is_perfect_square,"def is_perfect_square(n):
    if n < 0:
        return False
    root = int(n ** 0.5)
    return root * root == n",36
22396707931,highest_product,"def highest_product(nums):
    nums.sort()
    return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])",36
73096142104,first_recurring_char,"def first_recurring_char(s):
    seen = set()
    for char in s:
        if char in seen:
            return char
        seen.add(char)
    return None",36
17870627881,is_sorted,"def is_sorted(arr):
    for i in range(len(arr) - 1):
        if arr[i] > arr[i + 1]:
            return False
    return True",36
74960712505,isPerfectCube,"def isPerfectCube(n):
    if n < 0:
        return False
    x = int(round(n ** (1/3)))
    return x**3 == n",36
4729052187,find_max,"def find_max(lst):
    max_num = lst[0]
    for num in lst:
        if num > max_num:
            max_num = num
    return max_num",36
10514717001,square_and_convert,"def square_and_convert(nums):
    result = []
    for num in nums:
        squared = int(num) ** 2
        result.append(str(squared))
    return result",36
37902274558,trailing_zeros_factorial,"def trailing_zeros_factorial(n):
    count = 0
    while n > 0:
        n = n // 5
        count += n
    return count",36
29133129674,build_staircase,"def build_staircase(height):
    staircase = []
    for i in range(1, height + 1):
        staircase.append('*' * i)
    return staircase",35
12236757330,find_Trailing_Zeroes,"def find_Trailing_Zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",35
71439434550,sum_even_index,"def sum_even_index(lst):
    sum = 0
    for i in range(0, len(lst), 2):
        sum += lst[i]
    return sum",35
21105288213,sum_of_cubes,"def sum_of_cubes(n):
    sum = 0
    for i in range(1, n+1):
        sum += i**3
    return sum",35
23779485392,count_ones,"def count_ones(n):
    count = 0
    while n:
        n = n & (n-1)
        count += 1
    return count",35
70027569050,count_trailing_zeroes,"def count_trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",35
40214228487,count_occurrences,"def count_occurrences(string, char):
    count = 0
    for c in string:
        if c == char:
            count += 1
    return count",35
41434038388,get_factorial,"def get_factorial(n): 
    if n == 0: 
        return 1
    else: 
        return n * get_factorial(n-1)",35
30343081707,common_elements,"def common_elements(list1, list2):
    result = []
    for element in list1:
        if element in list2:
            result.append(element)
    return result",35
22011192749,count_occurrences,"def count_occurrences(arr, target):
    count = 0
    for i in arr:
        if i == target:
            count += 1
    return count",35
74249337594,top_k_frequent,"from collections import Counter

def top_k_frequent(nums, k):
    count = Counter(nums)
    return [num for num, _ in count.most_common(k)]",35
26569056724,first_duplicate,"def first_duplicate(arr):
    seen = set()
    for num in arr:
        if num in seen:
            return num
        seen.add(num)
    return -1",35
36751128160,reverse_word_chars,"def reverse_word_chars(sentence):
    words = sentence.split()
    reversed_words = [word[::-1] for word in words]
    return ' '.join(reversed_words)",35
14637138926,k_most_frequent,"from collections import Counter

def k_most_frequent(nums, k):
    count = Counter(nums)
    return [item for item, _ in count.most_common(k)]",35
40211297508,is_isogram,"def is_isogram(string):
    string = string.lower()
    for char in string:
        if string.count(char) > 1:
            return False
    return True",35
31262080048,single_number,"from collections import Counter

def single_number(nums):
    dic = Counter(nums)
    for i, k in dic.items():
        if k == 1:
            return i",35
43290025957,min_operations_to_book,"def min_operations_to_book(n):
    operations = 0
    while n > 1:
        n //= 2
        operations += 1
    return operations",35
72511161852,convert_list_to_dict,"def convert_list_to_dict(list_of_lists):
  dict = {}
  for list in list_of_lists:
    dict[list[0]] = list[1:]
  return dict",35
41407907232,sumPositive,"def sumPositive(nums):
    positive_sum = 0
    for num in nums:
        if num > 0:
            positive_sum += num
    return positive_sum",35
3553526483,find_max_occurrences,"def find_max_occurrences(arr):
    max_val = max(arr)
    return [(i, val) for i, val in enumerate(arr) if val == max_val]",35
7214588563,sum_odd,"def sum_odd(arr):
    sum = 0
    for i in arr:
        if i % 2 != 0:
            sum += i
    return sum",35
73646515857,fact_trailing_zeroes,"def fact_trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",35
26956150422,sum_diagonal_elements,"def sum_diagonal_elements(matrix):
    sum_elements = 0
    for i in range(len(matrix)):
        sum_elements += matrix[i][i]
    return sum_elements",35
22110224642,find_largest_digit,"def find_largest_digit(n):
    if n < 0:
        n = n * -1
    return max([int(i) for i in str(n)])",35
71267945766,filter_and_sort_even,"def filter_and_sort_even(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",35
40132363992,find_char_count,"def find_char_count(str, char):
    count = 0
    for i in str:
        if i == char:
            count += 1
    return count",35
7215963671,find_duplicate,"def find_duplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return -1",35
1478043205,sum_of_cubes,"def sum_of_cubes(n):
    sum = 0
    for i in range(1, n+1):
        sum += i**3
    return sum",35
10786992315,isPalindrome,"def isPalindrome(s):
    s = s.lower()
    s = ''.join([i for i in s if i.isalnum()])
    return s == s[::-1]",35
21865388097,sum_of_cubes,"def sum_of_cubes(n):
    sum = 0
    for i in range(1, n+1):
        sum += i**3
    return sum",35
73838716663,round_numbers,"import math

def round_numbers(numbers):
    return [math.ceil(num) if num - int(num) == 0.5 else round(num) for num in numbers]",35
40931616252,count_trailing_zeroes,"def count_trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",35
541626067,is_Anagram,"def is_Anagram(str1,str2):
    if len(str1) != len(str2):
        return False
    return sorted(str1) == sorted(str2)",35
8699678149,is_isogram,"def is_isogram(string):
    string = string.lower()
    for char in string:
        if string.count(char) > 1:
            return False
    return True",35
34817142325,find_first_duplicate,"def find_first_duplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None",35
71931542607,sum_list,"def sum_list(lst):
    if len(lst) == 0:
        return 0
    else:
        return lst[0] + sum_list(lst[1:])",35
43207926770,count_trailing_zeroes,"def count_trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",35
40250997547,is_valid_permutation,"def is_valid_permutation(arr):
    arr_set = set(arr)
    return len(arr_set) == len(arr) == max(arr) and min(arr) == 1",35
32814046591,top_k_frequent,"from collections import Counter

def top_k_frequent(nums, k):
    count = Counter(nums)
    return [item for item, _ in count.most_common(k)]",35
72296529713,k_most_frequent,"from collections import Counter
def k_most_frequent(nums, k):
   count = Counter(nums)
   return [item for item, _ in count.most_common(k)]",35
44369178558,checkIfPangram,"def checkIfPangram(sentence):
    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')
    sentence_set = set(sentence.lower())
    return alphabet_set.issubset(sentence_set)",35
26383896737,count_word_occurrences,"import re

def count_word_occurrences(text, word):
    words = re.findall(r'\b' + word + r'\b', text)
    return len(words)",35
34364122087,decimal_to_binary_with_db,"def decimal_to_binary_with_db(decimal_number):
    binary_string = bin(decimal_number).replace(""0b"", """")
    return ""db"" + binary_string + ""db""",35
32619759312,find_three_consecutive,"def find_three_consecutive(n):
    start = (n // 3) - 1
    return [start, start + 1, start + 2]",35
71922457033,sum_even,"def sum_even(l):
  result = 0
  for num in l:
    if num % 2 == 0:
      result += num
  return result",35
29388203023,sum_series,"def sum_series(n, k):
    sum = 0
    for i in range(1, n+1):
        sum += i**k
    return sum",35
5258447641,bits_needed,"def bits_needed(num):
  bits = 0
  while num > 0:
    bits += 1
    num = num >> 1
  return bits",35
75157597011,count_occurrences,"def count_occurrences(text, character):
    count = 0
    for char in text:
        if char == character:
            count += 1
    return count",35
29820444473,find_max_frequency,"def find_max_frequency(freq_list):
    freq_dict = dict(freq_list)
    max_freq_key = max(freq_dict, key=freq_dict.get)
    return max_freq_key",35
6836028304,count_unique_permutations,"from itertools import permutations
def count_unique_permutations(s): 
    perm = [''.join(p) for p in set(permutations(s))]
    return len(perm)",35
12221795932,reverse_list_of_lists,"def reverse_list_of_lists(list1):
    reversed_list = []
    for sublist in reversed(list1):
        reversed_list.append(list(reversed(sublist)))
    return reversed_list",35
11247309537,is_isogram,"def is_isogram(string):
    string = string.lower()
    for i in string:
        if string.count(i) > 1:
            return False
    return True",35
17411620374,first_repeated,"def first_repeated(arr):
    seen = set()
    for num in arr:
        if num in seen:
            return num
        seen.add(num)
    return None",35
70027555930,first_duplicate,"def first_duplicate(a):
    seen = set()
    for num in a:
        if num in seen:
            return num
        seen.add(num)
    return -1",35
4527919732,check_pangram,"def check_pangram(sentence):    
    alphabet = ""abcdefghijklmnopqrstuvwxyz""
    for char in alphabet:
        if char not in sentence.lower():
            return False
    return True",35
48069128458,reverse_word_order,"def reverse_word_order(sentence):
    if not sentence:
        return """"
    words = sentence.split()
    reversed_words = "" "".join(reversed(words))
    return reversed_words",35
27238710407,sum_list,"def sum_list(lst):
    if len(lst) == 0:
        return 0
    else:
        return lst[0] + sum_list(lst[1:])",35
73804338084,sum_of_cubes,"def sum_of_cubes(n):
    sum = 0
    for i in range(1, n+1):
        sum += i**3
    return sum",35
32359288300,count_uppercase,"def count_uppercase(str1):
  count = 0
  for char in str1:
    if char.isupper():
      count += 1
  return count",35
29253012003,factorial_recursive,"def factorial_recursive(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial_recursive(n-1)",35
30424403553,list_intersection,"def list_intersection(nums1, nums2):
    intersection = []
    for num in nums1:
        if num in nums2:
            intersection.append(num)
    return intersection",35
72153839834,binary_conversion,"def binary_conversion(lst):
    max_length = len(bin(max(lst)))-2
    return [bin(x)[2:].zfill(max_length) for x in lst]",35
2447542990,intersection_elements,"def intersection_elements(test_tup1, test_tup2):
  res = tuple(set(test_tup1) & set(test_tup2))
  return (res)",35
70016672118,multiply_without_operator,"def multiply_without_operator(x, y):
    result = 0
    while(y > 0):
        result += x
        y -= 1
    return result",35
18113991280,find_first_duplicate,"def find_first_duplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None",35
25434917670,is_isogram,"def is_isogram(string):
    string = string.lower()
    for char in string:
        if string.count(char) > 1:
            return False
    return True",35
36410051059,sum_even,"def sum_even(nums):
    total = 0
    for num in nums:
        if num % 2 == 0:
            total += num
    return total",35
10551418246,max_length_strings,"def max_length_strings(lst):
    max_length = max(len(x) for x in lst)
    return [x for x in lst if len(x) == max_length]",35
6758081992,count_set_bits,"def count_set_bits(n):
    count = 0
    while n:
        n = n & (n-1)
        count += 1
    return count",35
13342462637,sum_even_indices,"def sum_even_indices(lst):
    total = 0
    for i in range(0, len(lst), 2):
        total += lst[i]
    return total",35
32352794419,max_length_strings,"def max_length_strings(lst):
    max_length = max(len(x) for x in lst)
    return [x for x in lst if len(x) == max_length]",35
30252543052,is_palindrome_ignoring_special,"import re
def is_palindrome_ignoring_special(str):
    str = re.sub(r'\W+', '', str).lower()
    return str == str[::-1]",35
6167136097,sum_even,"def sum_even(numbers):
    result = 0
    for num in numbers:
        if num % 2 == 0:
            result += num
    return result",35
1406231807,is_harshad_number,"def is_harshad_number(n):
    sum_of_digits = sum(int(digit) for digit in str(n))
    return n % sum_of_digits == 0",35
1235518057,second_smallest,"def second_smallest(numbers):
    unique_numbers = set(numbers)
    if len(unique_numbers) < 2:
        return None
    return sorted(unique_numbers)[1]",35
5570423838,is_harshad_num,"def is_harshad_num(num):
  sum_of_digits = sum(int(digit) for digit in str(num))
  return num % sum_of_digits == 0",35
953737694,count_occurrences,"def count_occurrences(numbers, target):
    count = 0
    for num in numbers:
        if num == target:
            count += 1
    return count",35
43552475804,flatten_list,"def flatten_list(nested_list):
    flat_list = []
    for sublist in nested_list:
        for item in sublist:
            flat_list.append(item)
    return flat_list",35
19289986700,num_trailing_zeroes,"def num_trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",35
26931364233,first_duplicate,"def first_duplicate(arr):
  seen = set()
  for num in arr:
    if num in seen:
      return num
    seen.add(num)
  return -1",35
70533873990,factorial_Trailing_Zeroes,"def factorial_Trailing_Zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",35
14227773947,factorial_trailing_zeroes,"def factorial_trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",35
27399633208,count_trailing_zeroes,"def count_trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",35
26067706078,reverse_words_in_sentence,"def reverse_words_in_sentence(s):
    res = ''
    for word in s.split(' '):
        res += word[::-1] + ' '
    return res.strip()",35
30335557777,max_of_three,"def max_of_three(a, b, c):
    return a if a > b and a > c else (b if b > a and b > c else c)",35
23726336819,max_length_strings,"def max_length_strings(lst):
    max_len = max(len(s) for s in lst)
    return [s for s in lst if len(s) == max_len]",35
72730648118,sum_even_indices,"def sum_even_indices(lst):
    sum = 0
    for i in range(0, len(lst), 2):
        sum += lst[i]
    return sum",35
36860636975,sum_of_odd,"def sum_of_odd(list1):
    sum=0
    for i in list1:
        if i%2!=0:
            sum+=i
    return sum",35
31580086276,sum_of_odd,"def sum_of_odd(n):
  sum = 0
  for i in range(1, 2*n, 2):
    sum += i
  return sum",35
25426442372,recursive_sum,"def recursive_sum(lst):
    if len(lst) == 0:
        return 0
    else:
        return lst[0] + recursive_sum(lst[1:])",35
34332070471,count_trailing_zeroes,"def count_trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",35
38960545220,sum_of_cubes,"def sum_of_cubes(n):
    sum = 0
    for i in range(1, n+1):
        sum += i**3
    return sum",35
35613238135,list_to_number,"def list_to_number(list1): 
    str1 = [str(x) for x in list1]
    res = int("""".join(str1))
    return res",35
2377114910,first_duplicate,"def first_duplicate(arr):
    seen = set()
    for num in arr:
        if num in seen:
            return num
        seen.add(num)
    return -1",35
8682622711,find_num_times,"def find_num_times(array, num):
    count = 0
    for i in array:
        if i == num:
            count += 1
    return count",35
21463772368,checkAnagrams,"def checkAnagrams(str_list):
    sorted_strs = [''.join(sorted(s)) for s in str_list]
    return len(set(sorted_strs)) == 1",35
15552698656,matrix_transpose,"def matrix_transpose(matrix):
    result = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]
    return result",35
22489054873,max_length_strings,"def max_length_strings(lst):
    max_len = max(len(s) for s in lst)
    return [s for s in lst if len(s) == max_len]",35
31771590820,count_unique_chars,"def count_unique_chars(s: str) -> int:
    unique_chars = set()
    for char in s:
        unique_chars.add(char)
    return len(unique_chars)",35
36401542459,is_Perfect_Square,"import math
def is_Perfect_Square(n):
    if n < 0:
        return False
    root = math.sqrt(n)
    return root.is_integer()",35
3458617411,trailing_zeroes_factorial,"def trailing_zeroes_factorial(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",35
37119603271,max_length_strings,"def max_length_strings(strings):
    max_length = max(len(s) for s in strings)
    return [s for s in strings if len(s) == max_length]",35
12934043845,count_occurrences,"def count_occurrences(arr, element):
    count = 0
    for i in arr:
        if i == element:
            count += 1
    return count",35
10741474789,top_k_frequent,"from collections import Counter

def top_k_frequent(nums, k):
    count = Counter(nums)
    return [item for item, freq in count.most_common(k)]",35
9216888481,is_hex_color,"import re

def is_hex_color(code):
    pattern = r'^#[0-9a-fA-F]{6}$'
    return bool(re.match(pattern, code))",35
37516659529,find_trailing_zeroes,"def find_trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",35
36757212642,remove_duplicates,"def remove_duplicates(lst):
    unique_list = []
    for i in lst:
        if i not in unique_list:
            unique_list.append(i)
    return unique_list",34
14171817418,consecutive_numbers,"def consecutive_numbers(lst):
    for i in range(len(lst)-1):
        if lst[i]+1 == lst[i+1]:
            return True
    return False",34
3955043418,count_char,"def count_char(s, char):
    count = 0
    for c in s:
        if c == char:
            count += 1
    return count",34
28462950110,even_and_sort,"def even_and_sort(nums):
    even_nums = [num for num in nums if num % 2 == 0]
    even_nums.sort()
    return even_nums",34
18179440011,find_intersection,"def find_intersection(nums1, nums2):
    set1 = set(nums1)
    set2 = set(nums2)
    return list(set1 & set2)",34
35602935547,digit_count,"def digit_count(n):
    if n < 10:
        return 1
    else:
        return 1 + digit_count(n // 10)",34
23794506960,count_char,"def count_char(string, char):
    count = 0
    for c in string:
        if c == char:
            count += 1
    return count",34
22313692935,sum_of_squares,"def sum_of_squares(n):
    sum = 0
    for i in range(1,n+1):
        sum += i**2
    return sum",34
28701719550,reverse_integer,"def reverse_integer(n):
    sign = [1,-1][n < 0]
    rst = int(str(abs(n))[::-1])
    return sign * rst",34
27674133950,count_char,"def count_char(s, char):
    count = 0
    for c in s:
        if c == char:
            count += 1
    return count",34
44733443603,sort_even_numbers,"def sort_even_numbers(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",34
39249365696,count_trailing_zeros,"def count_trailing_zeros(n):
    count = 0
    while n > 0:
        n //= 5
        count += n
    return count",34
28868145205,capitalize_words,"def capitalize_words(sentence):
    words = sentence.split()
    capitalized_words = [word.capitalize() for word in words]
    return ' '.join(capitalized_words)",34
74002253246,isPangram,"def isPangram(s):
    alphabet = ""abcdefghijklmnopqrstuvwxyz""
    for char in alphabet:
        if char not in s.lower():
            return False
    return True",34
8092417276,word_count,"def word_count(words, target):
    count = 0
    for word in words:
        if word == target:
            count += 1
    return count",34
22658909315,count_number,"def count_number(numbers, target):
    count = 0
    for num in numbers:
        if num == target:
            count += 1
    return count",34
34035538689,sort_odd_numbers,"def sort_odd_numbers(numbers):
    odd_numbers = [num for num in numbers if num % 2 != 0]
    odd_numbers.sort()
    return odd_numbers",34
29210198194,count_number,"def count_number(nums, target):
    count = 0
    for num in nums:
        if num == target:
            count += 1
    return count",34
42131780081,sort_odd_numbers,"def sort_odd_numbers(numbers):
    odd_numbers = [num for num in numbers if num % 2 != 0]
    odd_numbers.sort()
    return odd_numbers",34
13160229257,is_sorted,"def is_sorted(nums):
    for i in range(1, len(nums)):
        if nums[i] < nums[i-1]:
            return False
    return True",34
17487214136,sum_of_series,"def sum_of_series(n):
    sum = 0
    for i in range(1, n+1):
        sum += i**3
    return sum",34
41560848562,count_number,"def count_number(numbers, num):
    count = 0
    for i in numbers:
        if i == num:
            count += 1
    return count",34
4129011136,find_smallest_missing,"def find_smallest_missing(nums):
    nums = set(nums)
    smallest = 1
    while smallest in nums:
        smallest += 1
    return smallest",34
4184225943,check_Pangram,"def check_Pangram(sentence):
    alphabet = ""abcdefghijklmnopqrstuvwxyz""
    for char in alphabet:
        if char not in sentence.lower():
            return False
    return True",34
35414375264,square_sum,"def square_sum(n):
    sum = 0
    for i in range(1, n + 1):
        sum += i * i
    return sum",34
22110165462,is_harshad,"def is_harshad(n):
    sum_of_digits = sum(int(digit) for digit in str(n))
    return n % sum_of_digits == 0",34
40709844354,count_char,"def count_char(s, char):
    count = 0
    for c in s:
        if c == char:
            count += 1
    return count",34
6697688047,count_element,"def count_element(lst, element):
    count = 0
    for i in lst:
        if i == element:
            count += 1
    return count",34
31712340094,cumulative_sum,"def cumulative_sum(lst):
    result = []
    total = 0
    for num in lst:
        total += num
        result.append(total)
    return result",34
11577682995,trailing_zeros_factorial,"def trailing_zeros_factorial(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",34
12613674672,count_element,"def count_element(lst, element):
    count = 0
    for i in lst:
        if i == element:
            count += 1
    return count",34
16145367682,count_alphabetic,"def count_alphabetic(s):
    count = 0
    for char in s:
        if char.isalpha():
            count += 1
    return count",34
32026465966,find_substring,"def find_substring(main_string, sub_string):
    main_string = main_string.lower()
    sub_string = sub_string.lower()
    return main_string.count(sub_string)",34
6033479474,reverse_sentence,"def reverse_sentence(sentence):
    words = sentence.split()
    reversed_words = words[::-1]
    reversed_sentence = "" "".join(reversed_words)
    return reversed_sentence",34
31263217883,count_num,"def count_num(lst, num):
    count = 0
    for i in lst:
        if i == num:
            count += 1
    return count",34
11988281187,get_largest_number,"def get_largest_number(arr):
    largest = arr[0]
    for i in arr:
        if i > largest:
            largest = i
    return largest",34
33759928598,capitalize_words,"def capitalize_words(sentence):
    words = sentence.split()
    capitalized_words = [word.capitalize() for word in words]
    return ' '.join(capitalized_words)",34
40124170100,num_trailing_zeros,"def num_trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",34
73628371657,is_pangram,"def is_pangram(sentence):
    alphabet = ""abcdefghijklmnopqrstuvwxyz""
    for char in alphabet:
        if char not in sentence.lower():
            return False
    return True",34
9925795068,longest_strings,"def longest_strings(lst):
    max_length = max(len(word) for word in lst)
    return [word for word in lst if len(word) == max_length]",34
26875514499,list_sum,"def list_sum(nums):
    total_sum = 0
    for sublist in nums:
        for number in sublist:
            total_sum += number
    return total_sum",34
31331930546,is_harshad,"def is_harshad(n):
    sum_of_digits = sum(int(digit) for digit in str(n))
    return n % sum_of_digits == 0",34
32146603273,perfect_square,"import math
def perfect_square(x):
  if x < 0:
    return False
  root = math.isqrt(x)
  return root * root == x",34
32619727032,flatten,"def flatten(nested_list):
    flat_list = []
    for sublist in nested_list:
        for item in sublist:
            flat_list.append(item)
    return flat_list",34
12964988143,count_num,"def count_num(nums, num):
    count = 0
    for n in nums:
        if n == num:
            count += 1
    return count",34
27790119545,sort_even_numbers,"def sort_even_numbers(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",34
17088922685,count_trailing_zeros,"def count_trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",34
25886968659,cumulative_product,"def cumulative_product(nums):
    result = []
    product = 1
    for num in nums:
        product *= num
        result.append(product)
    return result",34
555158785,count_element,"def count_element(lst, element):
    count = 0
    for i in lst:
        if i == element:
            count += 1
    return count",34
9294933292,sum_of_power_digits,"def sum_of_power_digits(number, power):
    total = 0
    for digit in str(number ** power):
        total += int(digit)
    return total",34
2426813818,fibo,"def fibo(n):
    if n <= 1:
       return n
    else:
       return(fibo(n-1) + fibo(n-2))",34
71073739905,find_smallest_square_with_trailing_zeroes,"def find_smallest_square_with_trailing_zeroes(n):
    result = 1
    for i in range(n):
        result *= 5
    return result",34
30630960015,trailing_zeros_factorial,"def trailing_zeros_factorial(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",34
23919556414,even_numbers_sort,"def even_numbers_sort(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",34
15546317591,convert_to_hours_min,"def convert_to_hours_min(minutes):
    hours = minutes // 60
    remaining_minutes = minutes % 60
    return (hours, remaining_minutes)",34
5769787308,list_to_int,"def list_to_int(num_list):
    str_list = [str(i) for i in num_list]
    result = int("""".join(str_list))
    return result",34
27843615222,sum_adjacent,"def sum_adjacent(numbers):
    result = []
    for i in range(len(numbers)-1):
        result.append(numbers[i]+numbers[i+1])
    return result",34
10951471932,split_string,"def split_string(s: str, n: int) -> list:
    return [s[i:i+n] for i in range(0, len(s), n)]",34
71118662904,find_largest_number,"def find_largest_number(nums):
    largest = nums[0]
    for num in nums:
        if num > largest:
            largest = num
    return largest",34
6222350609,count_word,"def count_word(lst, word):
    count = 0
    for w in lst:
        if w == word:
            count += 1
    return count",34
23045919495,find_missing,"def find_missing(lst):
    n = len(lst)+1
    total = n * (n+1) // 2
    return total - sum(lst)",34
74799437418,running_sum,"def running_sum(nums):
    result = []
    sum = 0
    for num in nums:
        sum += num
        result.append(sum)
    return result",34
34298356254,count_letter_a,"def count_letter_a(word):
    count = 0
    for letter in word:
        if letter == 'a':
            count += 1
    return count",34
39175075617,is_valid_palindrome,"import re

def is_valid_palindrome(s):
    s = re.sub(r'[\W_]', '', s).lower()
    return s == s[::-1]",34
26650573353,cumulative_sum,"def cumulative_sum(numbers):
    result = []
    sum = 0
    for number in numbers:
        sum += number
        result.append(sum)
    return result",34
37678139341,count_char,"def count_char(s, c):
    count = 0
    for char in s:
        if char == c:
            count += 1
    return count",34
71645486133,count_character,"def count_character(s, c):
    count = 0
    for char in s:
        if char == c:
            count += 1
    return count",34
23866442300,unique_strings,"def unique_strings(lst):
    unique_list = []
    for item in lst:
        if item not in unique_list:
            unique_list.append(item)
    return unique_list",34
26708459716,get_odd_occurrence,"def get_odd_occurrence(arr):
    xor = arr[0]
    for i in range(1, len(arr)):
        xor ^= arr[i]
    return xor",34
26956783923,count_trailing_zeros,"def count_trailing_zeros(n):
    count = 0
    while n > 0:
        n //= 5
        count += n
    return count",34
39130040183,even_nums_sorted,"def even_nums_sorted(nums):
    even_nums = [num for num in nums if num % 2 == 0]
    even_nums.sort()
    return even_nums",34
74666385380,factorial_trailing_zeros,"def factorial_trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",34
28965800552,word_count,"def word_count(words, target):
  count = 0
  for word in words:
    if word == target:
      count += 1
  return count",34
14572302875,even_and_sorted,"def even_and_sorted(nums):
    even_nums = [num for num in nums if num % 2 == 0]
    even_nums.sort()
    return even_nums",34
8894425573,trailing_zeros_factorial,"def trailing_zeros_factorial(n):
    count = 0
    while n > 0:
        n //= 5
        count += n
    return count",34
21687176591,count_char,"def count_char(s, c):
    count = 0
    for char in s:
        if char == c:
            count += 1
    return count",34
25428127968,sum_natural_numbers,"def sum_natural_numbers(n):
    if n <= 0:
        return 0
    else:
        return n + sum_natural_numbers(n-1)",34
73699369047,find_largest_number,"def find_largest_number(numbers):
    largest = numbers[0]
    for number in numbers:
        if number > largest:
            largest = number
    return largest",34
19434196447,char_count,"def char_count(string, char):
    count = 0
    for c in string:
        if c == char:
            count += 1
    return count",34
71513443961,count_trailing_zeros,"def count_trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",34
71944750104,calculate_power,"def calculate_power(base, exponent):
  if exponent == 0:
    return 1
  else:
    return base * calculate_power(base, exponent-1)",34
26212313026,count_elements,"def count_elements(arr, element):
  count = 0
  for e in arr:
    if e == element:
      count += 1
  return count",34
34412220763,k_smallest_elements,"def k_smallest_elements(lst, k):
    lst.sort(key=lambda x: x[1])
    return [i[0] for i in lst[:k]]",34
12638581309,find_intersection,"def find_intersection(list1, list2):
    set1 = set(list1)
    set2 = set(list2)
    return list(set1.intersection(set2))",34
2050330204,longest_string_length,"from functools import reduce

def longest_string_length(strings):
    length = reduce(lambda x, y: max(x, len(y)), strings, 0)
    return length",34
73459977144,unique_list,"def unique_list(lst):
    unique_elements = []
    for element in lst:
        if element not in unique_elements:
            unique_elements.append(element)
    return unique_elements",34
27345351786,count_trailing_zeros,"def count_trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",34
15262858663,find_longest,"def find_longest(strings):
    longest = """"
    for s in strings:
        if len(s) > len(longest):
            longest = s
    return longest",34
28077338862,perfect_square,"def perfect_square(n):
    if n < 0:
        return False
    root = int(n ** 0.5)
    return root * root == n",34
40853050041,bin_to_dec,"def bin_to_dec(binary_str):
    decimal = 0
    for digit in binary_str:
        decimal = decimal*2 + int(digit)
    return decimal",34
33665595998,has_duplicates,"def has_duplicates(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    return False",34
42813709300,check_pangram,"def check_pangram(sentence):
    alphabet = ""abcdefghijklmnopqrstuvwxyz""
    for char in alphabet:
        if char not in sentence.lower():
            return False
    return True",34
10896552716,find_missing_element,"def find_missing_element(arr1, arr2):
    result = 0
    for num in arr1 + arr2:
        result ^= num
    return result",34
13518002266,find_indices,"def find_indices(nums, target):
    indices = []
    for i, num in enumerate(nums):
        if num == target:
            indices.append(i)
    return indices",34
3937345112,find_number,"def find_number(nums,n): 
    count = 0
    for num in nums:
        if num == n:
            count += 1
    return count",34
6557271261,even_and_sorted,"def even_and_sorted(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",34
5702952547,count_element,"def count_element(lst, element):
  count = 0
  for i in lst:
    if i == element:
      count += 1
  return count",34
2969282095,countSetBits,"def countSetBits(n):
    count = 0
    while n:
        n &= (n - 1)
        count += 1
    return count",34
23955613293,capitalize_words,"def capitalize_words(sentence):
    words = sentence.split()
    capitalized_words = [word.capitalize() for word in words]
    return ' '.join(capitalized_words)",34
72916114904,is_sorted,"def is_sorted(arr):
    for i in range(1, len(arr)):
        if arr[i] < arr[i-1]:
            return False
    return True",34
787193288,is_isogram,"def is_isogram(string: str) -> bool:
    string = string.lower().replace(""-"", """").replace("" "", """")
    return len(string) == len(set(string))",34
8855269632,count_target,"def count_target(nums, target):
    count = 0
    for num in nums:
        if num == target:
            count += 1
    return count",34
28122178387,is_pangram,"def is_pangram(sentence):
  alphabet = ""abcdefghijklmnopqrstuvwxyz""
  for char in alphabet:
    if char not in sentence.lower():
      return False
  return True",34
9697315276,count_target,"def count_target(lst, target):
    count = 0
    for i in lst:
        if i == target:
            count += 1
    return count",34
32028495071,sum_of_integers,"def sum_of_integers(n):
    sum = 0
    for i in range(1, n + 1):
        sum += i
    return sum",34
74586916305,count_char,"def count_char(s, char):
    count = 0
    for c in s:
        if c == char:
            count += 1
    return count",34
1520953060,largest_palindrome,"def largest_palindrome(n):
    for i in range(n, -1, -1):
        if str(i) == str(i)[::-1]:
            return i",34
27387719638,find_largest_number,"def find_largest_number(n):
    str_n = str(n)
    sorted_n = sorted(str_n, reverse=True)
    return int(''.join(sorted_n))",34
18180432621,find_missing_number,"def find_missing_number(lst):
  for i in range(len(lst)-1):
    if lst[i+1]-lst[i]>1:
      return lst[i]+1",34
73477975881,sort_even_numbers,"def sort_even_numbers(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",34
1520966510,reverse_sentence,"def reverse_sentence(sentence):
  words = sentence.split()
  reversed_words = words[::-1]
  reversed_sentence = ' '.join(reversed_words)
  return reversed_sentence",34
441170831,count_trailing_zeros,"def count_trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",34
4356496645,fibonacci_recursive,"def fibonacci_recursive(n):
    if n <= 1:
        return n
    else:
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)",34
25792181984,missing_num,"def missing_num(nums):
    nums = set(nums)
    for i in range(1, len(nums)+2):
        if i not in nums:
            return i",34
3623269807,even_and_sort,"def even_and_sort(lst):
    even_nums = [num for num in lst if num % 2 == 0]
    even_nums.sort()
    return even_nums",34
28402667959,find_largest_num,"def find_largest_num(arr):
    largest = arr[0]
    for num in arr:
        if num > largest:
            largest = num
    return largest",34
5827830910,get_even_sorted,"def get_even_sorted(nums):
    even_nums = [num for num in nums if num % 2 == 0]
    even_nums.sort()
    return even_nums",34
10848977042,cumulative_sum,"def cumulative_sum(numbers):
    result = []
    sum = 0
    for number in numbers:
        sum += number
        result.append(sum)
    return result",34
23104916119,capitalize_words,"def capitalize_words(sentence):
    words = sentence.split()
    capitalized_words = [word.capitalize() for word in words]
    return "" "".join(capitalized_words)",34
7994915243,trailing_zeros_factorial,"def trailing_zeros_factorial(num):
    count = 0
    while num >= 5:
        num //= 5
        count += num
    return count",34
73784280530,is_pangram,"def is_pangram(sentence):
  alphabet = ""abcdefghijklmnopqrstuvwxyz""
  for char in alphabet:
    if char not in sentence.lower():
      return False
  return True",34
39658779280,count_uppercase_letters,"def count_uppercase_letters(s):
    count = 0
    for char in s:
        if char.isupper():
            count += 1
    return count",34
15736436240,rotate_left,"def rotate_left(lst, n):
    n = n % len(lst)  # handle rotation greater than list length
    return lst[n:] + lst[:n]",34
74160324919,find_smallest_number,"def find_smallest_number(numbers):
    smallest = numbers[0]
    for number in numbers:
        if number < smallest:
            smallest = number
    return smallest",34
29398112307,is_pangram,"def is_pangram(sentence):
    alphabet = ""abcdefghijklmnopqrstuvwxyz""
    for char in alphabet:
        if char not in sentence.lower():
            return False
    return True",34
27185477890,diagonal_elements,"def diagonal_elements(matrix):
    """"""
    Return the diagonal elements of a square matrix.
    """"""
    return [matrix[i][i] for i in range(len(matrix))]",34
72617877825,remove_duplicates,"def remove_duplicates(lst):
    new_lst = []
    for i in lst:
        if i not in new_lst:
            new_lst.append(i)
    return new_lst",34
70915223096,count_target,"def count_target(nums, target):
    count = 0
    for i in nums:
        if i == target:
            count += 1
    return count",34
29021215544,count_trailing_zeros,"def count_trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",34
25877333445,count_number,"def count_number(lst,n) :
    count = 0
    for i in lst:
        if i == n:
            count += 1
    return count",34
30505838071,find_common,"def find_common(list1, list2):
    set1 = set(list1)
    set2 = set(list2)
    return list(set1.intersection(set2))",34
9838733098,findSmallestNumber,"def findSmallestNumber(nums):
    smallest = nums[0]
    for num in nums:
        if num < smallest:
            smallest = num
    return smallest",34
30283607294,largest_sum_from_distinct,"def largest_sum_from_distinct(nums):
    nums.sort(reverse=True)
    total = 0
    for num in nums:
        total += num
    return total",34
6303041270,even_and_sorted,"def even_and_sorted(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",34
28546316877,get_even_sorted,"def get_even_sorted(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",34
71653645176,get_even_sorted,"def get_even_sorted(nums):
    even_nums = [num for num in nums if num % 2 == 0]
    even_nums.sort()
    return even_nums",34
29157499009,maxDepth,"def maxDepth(L):
    if isinstance(L, list):
        return 1 + max(maxDepth(item) for item in L)
    else:
        return 0",34
10565967859,even_and_sort,"def even_and_sort(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",34
1057306057,count_element,"def count_element(lst, element):
    count = 0
    for i in lst:
        if i == element:
            count += 1
    return count",34
2871098163,count_element,"def count_element(lst, element):
    count = 0
    for i in lst:
        if i == element:
            count += 1
    return count",34
38475253452,is_Perfect_Square,"import math 
def is_Perfect_Square(n):
    if (int(math.sqrt(n))**2 == n):
        return True
    else:
        return False",34
37334161859,is_pangram,"def is_pangram(sentence):
    alphabet = ""abcdefghijklmnopqrstuvwxyz""
    for char in alphabet:
        if char not in sentence.lower():
            return False
    return True",34
13751772180,minMoves,"def minMoves(nums):
    nums.sort()
    median = nums[len(nums) // 2]
    return sum([abs(i - median) for i in nums])",34
8868815100,string_to_list,"def string_to_list(s):
    result = []
    for char in s:
        result.append(ord(char) - ord('a') + 1)
    return result",34
10125543255,sum_above_threshold,"def sum_above_threshold(arr, threshold):
    total = 0
    for num in arr:
        if num > threshold:
            total += num
    return total",34
42204616778,smallest_abs_difference,"def smallest_abs_difference(list_nums):
    list_nums.sort()
    return min(abs(a-b) for a, b in zip(list_nums, list_nums[1:]))",34
23620453143,count_trailing_zeros,"def count_trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",34
72624087704,count_elements,"def count_elements(numbers, target):
  count = 0
  for num in numbers:
    if num >= target:
      count += 1
  return count",34
5272174188,fibonacci_recursive,"def fibonacci_recursive(n):
    if n <= 1:
        return n
    else:
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)",34
28736011793,unique_elements,"def unique_elements(lst):
    unique_list = []
    for item in lst:
        if item not in unique_list:
            unique_list.append(item)
    return unique_list",34
27438868721,is_sorted,"def is_sorted(nums):
    for i in range(1, len(nums)):
        if nums[i] < nums[i-1]:
            return False
    return True",34
29398324817,is_pangram,"def is_pangram(s):
  alphabet = ""abcdefghijklmnopqrstuvwxyz""
  for char in alphabet:
    if char not in s.lower():
      return False
  return True",34
4134735055,factorial_trailing_zeros,"def factorial_trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",34
36160270067,largest_divisor,"def largest_divisor(n):
  for i in range(n // 2, 0, -1):
    if n % i == 0:
      return i",34
43113969511,count_Set_Bits,"def count_Set_Bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",34
36013539747,even_and_sorted,"def even_and_sorted(lst):
    even_numbers = [num for num in lst if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",34
15633216198,sum_digits,"def sum_digits(num):
    sum = 0
    while num:
        sum += num % 10
        num //= 10
    return sum",34
2897408823,check_pangram,"def check_pangram(str):
    alphabet = ""abcdefghijklmnopqrstuvwxyz""
    for char in alphabet:
        if char not in str.lower():
            return False

    return True",34
41390263962,cumulative_sum,"def cumulative_sum(lst):
    result = []
    sum = 0
    for num in lst:
        sum += num
        result.append(sum)
    return result",34
29549309983,is_pangram,"def is_pangram(text):
    alphabet = ""abcdefghijklmnopqrstuvwxyz""
    for char in alphabet:
        if char not in text.lower():
            return False
    return True",34
44936444478,sum_even,"def sum_even(n):
    sum = 0
    for i in range(2, n+1, 2):
        sum += i
    return sum",34
2308504104,create_dict,"def create_dict(lst):
    result = {}
    for item in lst:
        if isinstance(item, str):
            result[item] = len(item)
    return result",33
41151357884,find_factorial,"def find_factorial(n) :
    if n == 0:
        return 1
    else:
        return n * find_factorial(n-1)",33
20801595101,longest_string_length,"def longest_string_length(strings):
    if not strings: # To handle empty list
        return 0
    return max(len(string) for string in strings)",33
40713540414,is_palindrome,"import re

def is_palindrome(s):
    s = re.sub(r'[\W_]', '', s).lower()
    return s == s[::-1]",33
71203063525,multiply_list,"def multiply_list(arr1, arr2):
    result = map(lambda x, y: x * y, arr1, arr2)
    return list(result)",33
27110206222,find_Largest,"def find_Largest(nums):
    largest = nums[0]
    for num in nums:
        if num > largest:
            largest = num
    return largest",33
71779481801,count_nodes,"def count_nodes(tree):
    count = 0
    for node in tree:
        if node is not None:
            count += 1
    return count",33
10788765025,min_operations,"def min_operations(nums):
    nums.sort()
    median = nums[len(nums) // 2]
    return sum(abs(num - median) for num in nums)",33
14133622856,count_word_occurrences,"def count_word_occurrences(words_list, word):
    word = word.lower()
    return sum(1 for w in words_list if w.lower() == word)",33
22526184557,count_number,"def count_number(arr, num):
    count = 0
    for i in arr:
        if i == num:
            count+=1
    return count",33
32021251442,trailing_zeroes,"def trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",33
71439457910,count_set_bits,"def count_set_bits(n):
    count = 0
    while n:
        n &= n - 1
        count += 1
    return count",33
3998918027,is_sorted,"def is_sorted(nums):
  for i in range(len(nums)-1):
    if nums[i] > nums[i+1]:
      return False
  return True",33
42982791916,binary_to_int,"def binary_to_int(binary_list):
    int_list = []
    for binary in binary_list:
        int_list.append(int(binary, 2))
    return int_list",33
10209593986,distinct_permutations,"from itertools import permutations

def distinct_permutations(s):
    perm = [''.join(p) for p in permutations(s)]
    return sorted(list(set(perm)))",33
23588076302,sum_of_numbers_in_string,"import re

def sum_of_numbers_in_string(s):
    numbers = re.findall(r'\d+', s)
    return sum(int(num) for num in numbers)",33
41117467252,count_uppercase,"def count_uppercase(s):
    count = 0
    for char in s:
        if char.isupper():
            count += 1
    return count",33
32717962705,trailingZeroes,"def trailingZeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",33
13354879930,find_next_larger,"def find_next_larger(lst, val):
    for i in range(len(lst)):
        if lst[i] > val:
            return lst[i]
    return None",33
24361160151,repeat_by_length,"def repeat_by_length(strings):
    result = []
    for string in strings:
        if string:
            result.extend([string] * len(string))
    return result",33
8283374861,find_count,"def find_count(arr,n):
    count = 0
    for i in arr:
        if i == n:
            count += 1
    return count",33
40123096790,count_set_bits,"def count_set_bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",33
37811249182,missing_elements,"def missing_elements(lst):
    start, end = lst[0], lst[-1]
    return sorted(set(range(start, end + 1)).difference(lst))",33
24142007804,n_choose_r,"import math

def n_choose_r(n, r):
    return math.factorial(n) / (math.factorial(r) * math.factorial(n - r))",33
22324136204,largest_power_of_2,"def largest_power_of_2(n):
    p = 1
    while (p <= n):
        p *= 2
    return p // 2",33
38217974859,num_set_bits,"def num_set_bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",33
22594203898,case_converter,"def case_converter(s):
    if s.isupper():
        return s.lower()
    elif s.islower():
        return s.upper()
    else:
        return s",33
32368902865,is_Perfect_Square,"import math
def is_Perfect_Square(n):
    if int(math.sqrt(n))**2 == n:
        return True
    else:
        return False",33
74092698993,even_sorted,"def even_sorted(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",33
74958532907,return_largest,"def return_largest(lst):
  largest = lst[0]
  for i in lst:
    if i > largest:
      largest = i
  return largest",33
16205722969,check_palindrome,"def check_palindrome(s):
    s = ''.join([i for i in s if i.isalnum()]).lower()
    return s == s[::-1]",33
1057445937,even_sorted,"def even_sorted(nums):
    even_nums = [num for num in nums if num % 2 == 0]
    even_nums.sort()
    return even_nums",33
72702335727,count_alphanumeric,"def count_alphanumeric(s):
    count = 0
    for char in s:
        if char.isalnum():
            count += 1
    return count",33
29750318576,binary_to_decimal,"def binary_to_decimal(binary):
    decimal = 0
    for digit in binary:
        decimal = decimal * 2 + int(digit)
    return decimal",33
36533756254,count_alpha_chars,"def count_alpha_chars(s):
    count = 0
    for char in s:
        if char.isalpha():
            count += 1
    return count",33
14694736445,count_character,"def count_character(string):
    count = 0
    for char in string:
        if char == 'a':
            count += 1
    return count",33
73385064276,trailing_zeroes,"def trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",33
37173522030,sum_of_digits,"def sum_of_digits(number):
    sum_digits = 0
    for digit in str(abs(number)):
        sum_digits += int(digit)
    return sum_digits",33
1155356509,count_one_bits,"def count_one_bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",33
35572250559,unique_elements,"def unique_elements(nums):
    unique = []
    for num in nums:
        if nums.count(num) == 1:
            unique.append(num)
    return unique",33
22580718925,find_largest,"def find_largest(numbers):
    largest = numbers[0]
    for number in numbers:
        if number > largest:
            largest = number
    return largest",33
11404343126,count_uppercase,"def count_uppercase(s):
    count = 0
    for char in s:
        if char.isupper():
            count += 1
    return count",33
33357191736,remove_vowels,"def remove_vowels(s):
    vowels = 'aeiouAEIOU'
    return ''.join([char for char in s if char not in vowels])",33
27281094609,findUniqueNumbers,"from collections import Counter

def findUniqueNumbers(numbers):
    freq = Counter(numbers)
    return [num for num in numbers if freq[num] == 1]",33
13078188753,sum_between_10_and_100,"def sum_between_10_and_100(lst):
    return sum(x for x in lst if 10 < x < 100)",33
28109733597,sort_even,"def sort_even(nums):
    even_nums = [num for num in nums if num % 2 == 0]
    even_nums.sort()
    return even_nums",33
10670828051,find_number,"def find_number(list_of_lists, number):
    count = 0
    for sublist in list_of_lists:
        count += sublist.count(number)
    return count",33
17190935171,unique_elements,"def unique_elements(nums):
    unique = []
    for num in nums:
        if nums.count(num) == 1:
            unique.append(num)
    return unique",33
74047552000,sum_natural_numbers,"def sum_natural_numbers(n):
    sum = 0
    for i in range(1, n+1):
        sum += i
    return sum",33
73881337531,calculate_factorial,"def calculate_factorial(n):
  if n == 0:
    return 1
  else:
    return n * calculate_factorial(n - 1)",33
11570304457,powerset,"def powerset(lst):
    result = [[]]
    for elem in lst:
        result.extend([subset + [elem] for subset in result])
    return result",33
74241207469,even_sort,"def even_sort(lst):
    even_lst = [num for num in lst if num % 2 == 0]
    even_lst.sort()
    return even_lst",33
3330898706,count_uppercase,"def count_uppercase(s):
    count = 0
    for char in s:
        if char.isupper():
            count += 1
    return count",33
33702978478,string_to_list,"import string

def string_to_list(s):
    result = []
    for c in s:
        if c.isalnum():
            result.append(c)
    return result",33
6981569678,is_Palindrome,"def is_Palindrome(s):
    s = ''.join([c.lower() for c in s if c.isalnum()])
    return s == s[::-1]",33
12423182741,multiply_list,"def multiply_list(nums1,nums2):
  result = map(lambda x, y: x * y, nums1, nums2)
  return list(result)",33
71023780312,find_largest,"def find_largest(numbers):
    largest = numbers[0]
    for number in numbers:
        if number > largest:
            largest = number
    return largest",33
29178288544,reverse_words_in_string,"def reverse_words_in_string(s: str) -> str:
    words = s.split()
    reversed_words = ' '.join(reversed(words))
    return reversed_words",33
39499722121,trailing_zeroes,"def trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",33
9722223043,hamming_weight,"def hamming_weight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",33
6070467623,string_lengths,"def string_lengths(list_of_strings):
    lengths_dict = {}
    for string in list_of_strings:
        lengths_dict[string] = len(string)
    return lengths_dict",33
10267066332,hasEqual3And7,"def hasEqual3And7(numbers):
    count3 = numbers.count(3)
    count7 = numbers.count(7)
    return count3 == count7",33
72675972296,shuffle,"def shuffle(nums, n):
    res = []
    for i in range(n):
        res.append(nums[i])
        res.append(nums[i+n])
    return res",33
31446781569,most_frequent_word,"from collections import Counter

def most_frequent_word(words):
    word_counts = Counter(words)
    return word_counts.most_common(1)[0][0]",33
26615129248,count_uppercase,"def count_uppercase(s):
    count = 0
    for char in s:
        if char.isupper():
            count += 1
    return count",33
12979713191,subsequence,"def subsequence(s: str, t: str) -> bool:
    t_iter = iter(t)
    return all(char in t_iter for char in s)",33
70474513901,sum_from_string,"import re

def sum_from_string(s: str) -> int:
    numbers = re.findall(r'\d+', s)
    return sum(map(int, numbers))",33
72543230745,uniquify,"def uniquify(lst):
    unique = []
    for i in lst:
        if lst.count(i) == 1:
            unique.append(i)
    return unique",33
4317207255,min_moves_to_equal,"def min_moves_to_equal(nums):
    median = sorted(nums)[len(nums) // 2]
    return sum(abs(num - median) for num in nums)",33
22506343910,reverse_digits,"def reverse_digits(lst):
    return [int(str(abs(num))[::-1]) * (-1 if num < 0 else 1) for num in lst]",33
11922086233,kth_smallest,"from typing import List

def kth_smallest(arr: List[int], k: int) -> int:
    arr.sort()
    return arr[k-1]",33
364213225,even_sort,"def even_sort(nums):
  even_nums = [num for num in nums if num % 2 == 0]
  even_nums.sort()
  return even_nums",33
8975284702,trailing_zeroes,"def trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",33
41522220258,camel_to_snake,"def camel_to_snake(s):
    return ''.join(['_' + i.lower() if i.isupper() else i for i in s]).lstrip('_')",33
70854646202,reverse_sentence,"def reverse_sentence(sentence: str) -> str:
    words = sentence.split()
    reversed_words = words[::-1]
    return ' '.join(reversed_words)",33
15105353831,str_occurrences,"def str_occurrences(string1, string2):
    if string2 in string1:
        return string1.count(string2)
    else:
        return -1",33
26691243077,find_smallest,"def find_smallest(lst):
    smallest = lst[0]
    for num in lst:
        if num < smallest:
            smallest = num
    return smallest",33
20383201544,count_set_bits,"def count_set_bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",33
14472714953,count_set_bits,"def count_set_bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",33
9813773563,sum_of_abs_digits,"def sum_of_abs_digits(number):
    if number < 0:
        number = -number
    return sum(int(digit) for digit in str(number))",33
70944403000,find_largest,"def find_largest(nums):
    largest = nums[0]
    for num in nums:
        if num > largest:
            largest = num
    return largest",33
39825184847,powerset,"def powerset(lst):
    result = [[]]
    for x in lst:
        result.extend([subset + [x] for subset in result])
    return result",33
11922478973,remove_vowels,"def remove_vowels(s):
    vowels = 'aeiouAEIOU'
    return ''.join([char for char in s if char not in vowels])",33
30472179961,trailing_zeroes,"def trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",33
33848735776,factorial_iterative,"def factorial_iterative(n):
    fact = 1
    for i in range(1,n+1):
        fact = fact * i
    return fact",33
26006058492,calculate_set_bits,"def calculate_set_bits(number):
    count = 0
    while number:
        count += number & 1
        number >>= 1
    return count",33
15892831876,string_length_index,"def string_length_index(string_list):
    result = []
    for i, string in enumerate(string_list):
        result.append([i, len(string)])
    return result",33
27216011288,min_steps,"def min_steps(nums):
    nums.sort()
    median = nums[len(nums) // 2]
    return sum(abs(num - median) for num in nums)",33
19543743842,calculate_series_sum,"def calculate_series_sum(n):
    sum = 0
    for i in range(1,n+1):
        sum += i**3
    return sum",33
4602067023,count_positive,"def count_positive(nums):
    count = 0
    for num in nums:
        if num > 0:
            count += 1
    return count",33
39815628750,trailing_zeroes,"def trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",33
43825603573,count_ones,"def count_ones(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",33
71073730625,largest_number_from_digits,"def largest_number_from_digits(n):
    s = str(n)
    digits = list(s)
    digits.sort(reverse=True)
    return int(''.join(digits))",33
970726189,sort_even,"def sort_even(nums):
    even_nums = [num for num in nums if num % 2 == 0]
    even_nums.sort()
    return even_nums",33
17502749434,recursive_factorial,"def recursive_factorial(n):
    if n == 1:
        return 1
    else:
        return n * recursive_factorial(n - 1)",33
13242731866,count_set_bits,"def count_set_bits(n):
    count = 0
    while n:
        n &= n - 1
        count += 1
    return count",33
36161292267,countSetBits,"def countSetBits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",33
32649013252,count_set_bits,"def count_set_bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",33
27426973447,count_one_bits,"def count_one_bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",33
13300940306,find_common_elements,"def find_common_elements(list1, list2):
    common_elements = list(set(list1) & set(list2))
    common_elements.sort()
    return common_elements",33
72837275657,is_Palindrome,"def is_Palindrome(s):
    s = ''.join([i.lower() for i in s if i.isalnum()])
    return s == s[::-1]",33
39808869081,count_set_bits,"def count_set_bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count",33
20183399082,trailing_zeroes,"def trailing_zeroes(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",33
36890682498,find_largest,"def find_largest(numbers):
    largest = numbers[0]
    for number in numbers:
        if number > largest:
            largest = number
    return largest",33
35851609128,count_number,"def count_number(l,n):
    count = 0
    for i in l:
        if i == n:
            count += 1
    return count",33
11072691503,even_sorted,"def even_sorted(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    even_numbers.sort()
    return even_numbers",33
1160714697,count_uppercase,"def count_uppercase(s):
    count = 0
    for char in s:
        if char.isupper():
            count += 1
    return count",33
10734735658,check_permutation,"from collections import Counter

def check_permutation(s1: str, s2: str) -> bool:
    return Counter(s1) == Counter(s2)",33
2561817343,is_harshad_number,"def is_harshad_number(n):
    digit_sum = sum(int(digit) for digit in str(n))
    return n % digit_sum == 0",33
31440547293,reverseWords,"def reverseWords(s: str) -> str:
    words = s.strip().split()
    reversed_words = "" "".join(reversed(words))
    return reversed_words",33
26739172810,sum_of_diagonal,"def sum_of_diagonal(matrix):
    sum = 0
    for i in range(len(matrix)):
        sum += matrix[i][i]
    return sum",32
4066528482,find_largest_product,"def find_largest_product(arr):
    arr.sort()
    return max(arr[0] * arr[1], arr[-1] * arr[-2])",32
34074549172,strip_vowels,"def strip_vowels(text):
    vowels = 'aeiou'
    return ''.join([char for char in text if char.lower() not in vowels])",32
32370191075,heap_queue_smallest,"import heapq as hq

def heap_queue_smallest(nums, n):
  smallest_nums = hq.nsmallest(n, nums)
  return smallest_nums",32
6268949632,sum_consecutive_numbers,"def sum_consecutive_numbers(nums):
    result = [a + b for a, b in zip(nums[:-1], nums[1:])]
    return result",32
4879332491,check_perfect_square,"import math
def check_perfect_square(n):
  root = math.sqrt(n)
  return int(root + 0.5) ** 2 == n",32
16248964421,calculate_area,"def calculate_area(width, height):
    if width > 0 and height > 0:
        return width * height
    else:
        return -1",32
17768776998,recursive_factorial,"def recursive_factorial(num):
    if num == 1:
        return num
    else:
        return num * recursive_factorial(num - 1)",32
28548510041,odd_and_sorted,"def odd_and_sorted(numbers):
    odd_numbers = [num for num in numbers if num % 2 != 0]
    return sorted(odd_numbers)",32
14627422820,trailing_zeros,"def trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",32
5767461213,get_factorial,"def get_factorial(n):
    if n == 0:
        return 1
    else:
        return n * get_factorial(n-1)",32
70046754355,find_factorial,"def find_factorial(n):
    if n == 0:
        return 1
    else:
        return n * find_factorial(n-1)",32
33951206906,trailing_zeros,"def trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",32
28435380737,trailing_zeros,"def trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",32
25200104527,minMoves,"def minMoves(nums):
    nums.sort()
    median = nums[len(nums)//2]
    return sum([abs(i-median) for i in nums])",32
39212826613,least_common,"from collections import Counter

def least_common(lst):
    count = Counter(lst)
    return min(count.items(), key=lambda x: x[1])[0]",32
2614170643,smallest_k,"import heapq

def smallest_k(arr, k):
    heapq.heapify(arr)
    return [heapq.heappop(arr) for _ in range(k)]",32
34200597047,calculate_factorial,"def calculate_factorial(n):
    if n == 0:
        return 1
    else:
        return n * calculate_factorial(n-1)",32
28918771109,smallest_number,"def smallest_number(numbers):
    smallest = numbers[0]
    for number in numbers:
        if number < smallest:
            smallest = number
    return smallest",32
4747144030,contains_duplicate,"def contains_duplicate(nums):
    number_set = set(nums)
    if len(nums) != len(number_set):
        return True
    else:
        return False",32
19350514855,find_smallest_greater,"def find_smallest_greater(numbers, target):
    numbers.sort()
    for num in numbers:
        if num > target:
            return num
    return None",32
11316240742,calculate_factorial,"def calculate_factorial(n):
    if n == 0:
        return 1
    else:
        return n * calculate_factorial(n-1)",32
14041602381,sum_diagonal_elements,"def sum_diagonal_elements(matrix):
    sum = 0
    for i in range(len(matrix)):
        sum += matrix[i][i]
    return sum",32
35378966664,recursive_factorial,"def recursive_factorial(n):
    if n == 0:
        return 1
    else:
        return n * recursive_factorial(n-1)",32
11136659269,find_MissingNumber,"def find_MissingNumber(nums):
    missing = len(nums)
    for i, num in enumerate(nums):
        missing ^= i ^ num
    return missing",32
14443394292,string_to_list,"import string

def string_to_list(s):
    result=[]
    for char in s:
        if char.isalnum():
            result.append(char)
    return result",32
40210125283,power,"def power(x, n):
    if n == 0:
        return 1
    else:
        return x * power(x, n-1)",32
4091446229,missing_integer,"def missing_integer(nums):
    nums = set(nums)
    i = 1
    while i in nums:
        i += 1
    return i",32
18308835984,minimum_moves,"def minimum_moves(arr):
    arr.sort()
    mid = arr[len(arr)//2]
    return sum([abs(i-mid) for i in arr])",32
33830789298,calculate_factorial,"def calculate_factorial(n):
    if n == 0:
        return 1
    else:
        return n * calculate_factorial(n-1)",32
29250290835,find_high,"def find_high(numbers):
  highest = numbers[0]
  for num in numbers:
    if num > highest:
      highest = num
  return highest",32
32811460460,find_max_integer,"def find_max_integer(lst):
    if not lst or not all(isinstance(x, int) for x in lst):
        return None
    return max(lst)",32
25021557451,power,"def power(x, n):
    if n == 0:
        return 1
    else:
        return x * power(x, n-1)",32
21136767399,find_factorial,"def find_factorial(n):
    if n == 0:
        return 1
    else:
        return n * find_factorial(n-1)",32
27270115165,calculate_factorial,"def calculate_factorial(n):
    if n == 0:
        return 1
    else:
        return n * calculate_factorial(n-1)",32
21525889540,largest_number,"def largest_number(numbers):
    largest = numbers[0]
    for number in numbers:
        if number > largest:
            largest = number
    return largest",32
34133089982,largest_possible_number,"def largest_possible_number(num):
    num = str(num)
    num = list(num)
    num.sort(reverse=True)
    return int(''.join(num))",32
1981825731,generate_numbers,"def generate_numbers(x, n):
    result = []
    for i in range(n):
        result.append(x * (i + 1))
    return result",32
38038115415,is_Anagram,"def is_Anagram(str1,str2): 
    if(sorted(str1)== sorted(str2)): 
        return True
    else: 
        return False",32
9181048562,count_Digits,"def count_Digits(string):
    count = 0
    for s in string:
        if s.isdigit():
            count += 1
    return count",32
39658690510,is_bst_inorder,"def is_bst_inorder(seq):
    return all(seq[i] < seq[i + 1] for i in range(len(seq) - 1))",32
20288921197,bin_to_dec,"def bin_to_dec(binary):
  decimal = 0
  for digit in binary:
    decimal = decimal*2 + int(digit)
  return decimal",32
12243787760,n_pairs,"def n_pairs(nums,n):
    result=[]
    for i in range(0,len(nums),n):
        result.append(nums[i:i+n])
    return result",32
41167118588,recursive_factorial,"def recursive_factorial(n):
    if n == 0:
        return 1
    else:
        return n * recursive_factorial(n-1)",32
71122193072,find_factorial,"def find_factorial(n):
    if n == 0:
        return 1
    else:
        return n * find_factorial(n-1)",32
26635415932,smallest_integer,"def smallest_integer(arr):
    smallest = arr[0]
    for num in arr:
        if num < smallest:
            smallest = num
    return smallest",32
73589225305,fahrenheit_to_celsius,"def fahrenheit_to_celsius(fahrenheit):
    celsius = (fahrenheit - 32) * 5 / 9
    return celsius",32
24491544284,trailing_zeros,"def trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",32
20298952932,harmonic_series,"def harmonic_series(n):
    if n < 1:
        return 0
    else:
        return 1/n + harmonic_series(n-1)",32
25190605037,happy_string,"def happy_string(s):
    if ""aaa"" in s or ""bbb"" in s or ""ccc"" in s:
        return False
    return True",32
3625115237,max_num,"def max_num(nums):
    max = nums[0]
    for num in nums:
        if num > max:
            max = num
    return max",32
10789687695,is_Palindrome,"import re

def is_Palindrome(s):
    s = re.sub(r'\W+', '', s).lower()
    return s == s[::-1]",32
40810233422,check_perfect_squares,"import math
def check_perfect_squares(numbers):
    return [(num, math.isqrt(num) ** 2 == num) for num in numbers]",32
71156963966,find_factorial,"def find_factorial(n):
    if n == 0:
        return 1
    else:
        return n * find_factorial(n-1)",32
27838539979,word_count,"import re
from collections import Counter

def word_count(text):
    words = re.findall(r'\w+', text.lower())
    return dict(Counter(words))",32
73471520206,add_prefix_suffix,"def add_prefix_suffix(lst, prefix, suffix):
    result = []
    for string in lst:
        result.append(prefix + string + suffix)
    return result",32
22485696920,rotate_list,"def rotate_list(lst, n):
  n = n % len(lst) if lst else 0
  return lst[-n:] + lst[:-n]",32
2730680645,list_to_int,"def list_to_int(arr):
    result = 0
    for i in arr:
        result = result * 10 + i
    return result",32
71548658986,find_factorial,"def find_factorial(n):
    if n == 0:
        return 1
    else:
        return n * find_factorial(n-1)",32
18987352530,is_perfect_square,"import math
def is_perfect_square(number):
    root = math.sqrt(number)
    return int(root + 0.5) ** 2 == number",32
34037818979,factorialDigitSum,"import math

def factorialDigitSum(n):
    factorial = math.factorial(n)
    return sum([int(digit) for digit in str(factorial)])",32
2469687288,calculate_factorial,"def calculate_factorial(n):
    if n == 0:
        return 1
    else:
        return n * calculate_factorial(n-1)",32
40525354083,calculate_factorial,"def calculate_factorial(n):
    if n == 0:
        return 1
    else:
        return n * calculate_factorial(n-1)",32
38223496372,calculate_simple_interest,"def calculate_simple_interest(principal, rate, time):
    simple_interest = (principal * rate * time) / 100
    return simple_interest",32
41129659165,find_power,"def find_power(base, exp):
    if exp == 0:
        return 1
    return base * find_power(base, exp - 1)",32
18138966878,check_palindrome,"def check_palindrome(s):
    s = ''.join([c.lower() for c in s if c.isalnum()])
    return s == s[::-1]",32
17392583481,get_sorted_evens,"def get_sorted_evens(numbers):
    evens = [num for num in numbers if num % 2 == 0]
    return sorted(evens)",32
19948598905,celsius_to_fahrenheit,"def celsius_to_fahrenheit(celsius_list):
    return [celsius * 9/5 + 32 for celsius in celsius_list]",32
12523352406,max_min,"def max_min(test_list):
    test_list.sort(key = lambda x: x[1])
    return (test_list[0], test_list[-1])",32
1445830188,countSetBits,"def countSetBits(n):
    count = 0
    while n:
        n &= n-1
        count += 1
    return count",32
24814236753,fib,"def fib(n):
    if n <= 1:
       return n
    else:
       return(fib(n-1) + fib(n-2))",32
30819730582,permutation,"from itertools import permutations

def permutation(s):
    unique_perms = set(''.join(p) for p in permutations(s))
    return sorted(list(unique_perms))",32
45492286744,convert_to_uppercase,"import re

def convert_to_uppercase(s):
    return re.sub(r'\(([^)]+)\)', lambda x: x.group().lower(), s.upper())",32
74893229174,find_largest_smallest,"def find_largest_smallest(list1):
    largest = max(list1)
    smallest = min(list1)
    return (largest,smallest)",32
16090856755,list_to_int,"def list_to_int(arr):
    result = 0
    for i in arr:
        result = result * 10 + i
    return result",32
37316756157,recursive_factorial,"def recursive_factorial(n):
    if n == 0:
        return 1
    else:
        return n * recursive_factorial(n-1)",32
74326261512,sort_and_reverse_dicts,"def sort_and_reverse_dicts(list1, key):
    sorted_list = sorted(list1, key=lambda x: x[key], reverse=True)
    return sorted_list",32
22380349096,has_anagrams,"def has_anagrams(words):
    sorted_words = [''.join(sorted(word)) for word in words]
    return len(set(sorted_words)) < len(words)",32
34205908678,replace,"def replace(a,target,new):
    for i in range(len(a)):
        if a[i] == target:
            a[i] = new
    return a",32
73913654839,sum_of_digits,"def sum_of_digits(n):
    if n < 0:
        n = -n
    return sum(int(digit) for digit in str(n))",32
4367928827,ordered_intersection,"def ordered_intersection(list1, list2):
    set2 = set(list2)
    return [value for value in list1 if value in set2]",32
31081969245,get_even_sorted,"def get_even_sorted(numbers):
    even_numbers = [num for num in numbers if num % 2 == 0]
    return sorted(even_numbers)",32
41636877123,recursive_factorial,"def recursive_factorial(n):
  if n == 0:
    return 1
  else:
    return n * recursive_factorial(n-1)",32
7066388188,power,"def power(x, n):
  if n == 0:
    return 1
  else:
    return x * power(x, n-1)",32
41956928971,trailing_zeros,"def trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",32
40419173498,ordered_intersection,"def ordered_intersection(list1, list2):
    set2 = set(list2)
    return [value for value in list1 if value in set2]",32
25407538398,sum_natural,"def sum_natural(n):
    if n == 1:
        return 1
    else:
        return n + sum_natural(n-1)",32
42465341359,even_and_sort,"def even_and_sort(lst):
    even_numbers = [num for num in lst if num % 2 == 0]
    return sorted(even_numbers)",32
8133422642,find_substring,"def find_substring(strings, target):
    result = []
    for string in strings:
        if target in string:
            result.append(string)
    return result",32
6785163060,fib,"def fib(n):
    if n <= 1:
       return n
    else:
       return(fib(n-1) + fib(n-2))",32
14789841649,calculate_factorial,"def calculate_factorial(n):
    if n == 0:
        return 1
    else:
        return n * calculate_factorial(n-1)",32
379298022,find_factorial,"def find_factorial(n):
  if n == 0:
    return 1
  else:
    return n * find_factorial(n-1)",32
17303928621,binary_to_decimal,"def binary_to_decimal(binary):
  decimal = 0
  for digit in binary:
    decimal = decimal*2 + int(digit)
  return decimal",32
33258983581,power,"def power(base, exponent):
    if exponent == 0:
        return 1
    else:
        return base * power(base, exponent-1)",32
20069224580,trailing_zeros,"def trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",32
22129050728,find_factorial,"def find_factorial(n):
    if n == 0:
        return 1
    else:
        return n * find_factorial(n-1)",32
26890248999,max_depth,"def max_depth(d):
    if isinstance(d, dict):
        return 1 + max(max_depth(v) for v in d.values())
    return 0",32
20763761209,count_Unique_Characters,"def count_Unique_Characters(s):
    unique_chars = set()
    for char in s:
        unique_chars.add(char)
    return len(unique_chars)",32
20020932696,calculate_simple_interest,"def calculate_simple_interest(principal, rate, time):
    simple_interest = (principal * rate * time) / 100
    return simple_interest",32
33029493250,trailing_zeros,"def trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",32
9529173112,filter_strings_by_length,"def filter_strings_by_length(strings, min_length):
    filtered_list = [string for string in strings if len(string) > min_length]
    return filtered_list",32
70758220996,fact_recursion,"def fact_recursion(n):
    if n == 1:
        return 1
    else:
        return n * fact_recursion(n-1)",32
24951567324,can_be_sum_of_four_evens,"def can_be_sum_of_four_evens(n):
    if n < 8 or n % 2 != 0:
        return False
    return True",32
25881892307,trailing_zeros,"def trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",32
21821002999,fib,"def fib(n):
    if n <= 1:
       return n
    else:
       return(fib(n-1) + fib(n-2))",32
37326152230,reformat_date,"def reformat_date(date_string):
    year, month, day = date_string.split('-')
    return ""{}/{}/{}"".format(day, month, year)",32
35150153010,get_factorial,"def get_factorial(n):
    if n == 0:
        return 1
    else:
        return n * get_factorial(n-1)",32
71797999085,merge_and_sort_lists,"def merge_and_sort_lists(arr1, arr2):
    merged_list = list(set(arr1 + arr2))
    merged_list.sort()
    return merged_list",32
5729526804,calculate_factorial,"def calculate_factorial(n):
    if n == 0:
        return 1
    else:
        return n * calculate_factorial(n-1)",32
23706595844,ordered_intersection,"def ordered_intersection(list1, list2):
    set2 = set(list2)
    return [value for value in list1 if value in set2]",32
10565970549,fib,"def fib(n):
    if n <= 1:
        return n
    else:
        return(fib(n-1) + fib(n-2))",32
30767993001,recursive_factorial,"def recursive_factorial(n):
    if n == 0:
        return 1
    else:
        return n * recursive_factorial(n-1)",32
35122281696,trailing_zeros,"def trailing_zeros(n):
    count = 0
    while n >= 5:
        n //= 5
        count += n
    return count",32
7609593557,factorial_recursion,"def factorial_recursion(n):
    if n == 0:
        return 1
    else:
        return n * factorial_recursion(n-1)",32
3658862927,sum_of_digits,"def sum_of_digits(number):
    sum_digits = 0
    for digit in str(number):
        sum_digits += int(digit)
    return sum_digits",32
7281292232,find_factorial,"def find_factorial(n):
    if n == 0:
        return 1
    else:
        return n * find_factorial(n-1)",32
10363383047,remove_nth,"def remove_nth(lst, n):
    return [lst[i] for i in range(len(lst)) if (i+1) % n != 0]",32
18479302732,most_frequent_element,"from collections import Counter

def most_frequent_element(lst):
    count = Counter(lst)
    return count.most_common(1)[0][0]",31
11516270426,recursive_digit_sum,"def recursive_digit_sum(n):
    while n >= 10:
        n = sum(int(digit) for digit in str(n))
    return n",31
32384365892,check_anagrams,"def check_anagrams(s1, s2):
    if sorted(s1) == sorted(s2):
        return True
    else:
        return False",31
15927474412,check_divisible_by_3,"def check_divisible_by_3(nums):
    result = map(lambda x: x % 3 == 0, nums)
    return list(result)",31
20887610895,staircase_area,"def staircase_area(height):
    total_area = 0
    for i in range(height):
        total_area += height - i
    return total_area",31
71456040884,sum_single_digit,"def sum_single_digit(num):
    while num >= 10:
        num = sum(int(digit) for digit in str(num))
    return num",31
8291761332,list_sum,"def list_sum(lst):
    if not lst:
        return 0
    else:
        return lst[0] + list_sum(lst[1:])",31
41074956064,is_Anagram,"def is_Anagram(str1, str2):
    if sorted(str1) == sorted(str2):
        return True
    else:
        return False",31
74799588138,multiply_lists,"def multiply_lists(list1, list2):
  result = list(map(lambda x, y: x*y, list1, list2))
  return result",31
30371507931,can_form_word,"def can_form_word(word1, word2):
    if sorted(word1) == sorted(word2):
        return True
    else:
        return False",31
71868535319,max_min,"def max_min(list1):
    max_num = max(list1)
    min_num = min(list1)
    return (max_num, min_num)",31
42797713917,max_sum_of_three_unique,"def max_sum_of_three_unique(lst):
    unique_nums = list(set(lst))
    unique_nums.sort(reverse=True)
    return sum(unique_nums[:3])",31
1455968301,max_product_pair,"def max_product_pair(nums):
    nums.sort()
    return max(nums[0] * nums[1], nums[-1] * nums[-2])",31
660113403,is_palindrome,"def is_palindrome(s):
    s = ''.join(c for c in s if c.isalnum()).lower()
    return s == s[::-1]",31
17740071246,is_monotonic,"def is_monotonic(arr):
    return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))",31
72795562103,matrix_transpose,"def matrix_transpose(matrix):
    return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]",31
18563533039,rotate_Array,"def rotate_Array(nums, k):
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]
    return nums",31
30974498084,fahrenheit_to_celsius,"def fahrenheit_to_celsius(fahrenheit):
    celsius = (fahrenheit - 32) * 5/9
    return celsius",31
4568844327,rotate_list,"def rotate_list(nums, k):
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]
    return nums",31
12456638898,fahrenheit_to_celsius,"def fahrenheit_to_celsius(temp_f):
    temp_c = (temp_f - 32) * 5/9
    return temp_c",31
7921207784,is_power_of_2,"def is_power_of_2(n):
    if n <= 0:
        return False
    return n & (n-1) == 0",31
26371830103,max_product_two,"def max_product_two(nums):
    nums.sort()
    return max(nums[0] * nums[1], nums[-1] * nums[-2])",31
29691088719,reverse_words,"def reverse_words(s: str) -> str:
    words = s.split()
    reversed_words = ' '.join(reversed(words))
    return reversed_words",31
72685980157,fib,"def fib(n):
  if n <= 1:
    return n
  else:
    return fib(n-1) + fib(n-2)",31
15645272646,are_anagrams,"def are_anagrams(lst):
    sorted_lst = [''.join(sorted(word)) for word in lst]
    return len(set(sorted_lst)) == 1",31
10741176199,reverse_words,"def reverse_words(sentence: str) -> str:
    words = sentence.split()
    reversed_words = ' '.join(reversed(words))
    return reversed_words",31
70977328514,smallest_divisor,"def smallest_divisor(n):
    for i in range(2, n + 1):
        if n % i == 0:
            return i",31
17460426919,string_combinations,"from itertools import combinations

def string_combinations(strings, combination_length):
    return [''.join(combination) for combination in combinations(strings, combination_length)]",31
16034726691,sum_diagonal,"def sum_diagonal(matrix):
    sum = 0
    for i in range(len(matrix)):
        sum += matrix[i][i]
    return sum",31
291432130,rotate_array,"def rotate_array(nums, k):
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]
    return nums",31
4294670421,sum_of_elements,"def sum_of_elements(list1):
    if len(list1) == 0:
        return 0
    else:
        return sum(list1)",31
25200647907,unique_chars,"def unique_chars(in_string):
    unique_set = set()
    for char in in_string:
        unique_set.add(char)
    return len(unique_set)",31
26972530536,check_anagram,"def check_anagram(str1, str2):
    if sorted(str1) == sorted(str2):
        return True
    else:
        return False",31
6499813197,rotate_list,"def rotate_list(nums, k):
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]
    return nums",31
17271706636,fib,"def fib(n):
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)",31
37030364136,count_pattern_occurrences,"import re

def count_pattern_occurrences(text, pattern):
  regex = re.compile(pattern)
  matches = regex.findall(text)
  return len(matches)",31
39240679791,is_Anagram,"def is_Anagram(lst):
    sorted_lst = [''.join(sorted(word)) for word in lst]
    return len(set(sorted_lst)) == 1",31
7352467701,matrix_transpose,"def matrix_transpose(matrix):
    return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]",31
32620609352,celsius_to_fahrenheit,"def celsius_to_fahrenheit(celsius):
    fahrenheit = (celsius * 9/5) + 32
    return fahrenheit",31
73798090911,sort_even,"def sort_even(lst):
    even_lst = [num for num in lst if num % 2 == 0]
    return sorted(even_lst)",31
40542788904,check_anagram,"def check_anagram(s1, s2):
    if sorted(s1) == sorted(s2):
        return True
    else:
        return False",31
35375846086,is_binary,"def is_binary(s):
    for c in s:
        if c != '0' and c != '1':
            return False
    return True",31
41548950787,recursive_sum,"def recursive_sum(lst):
    if not lst:
        return 0
    else:
        return lst[0] + recursive_sum(lst[1:])",31
43552855094,unique_list,"def unique_list(l):
    ulist = []
    [ulist.append(x) for x in l if x not in ulist]
    return ulist",31
12833126286,is_sorted_ascending,"def is_sorted_ascending(lst):
    return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1))",31
74795033225,heap_queue_largest,"import heapq as hq
def heap_queue_largest(nums,n):
  largest_nums = hq.nlargest(n, nums)
  return largest_nums",31
42386746709,generate_cubes,"def generate_cubes(n):
    cubes_dict = {i: i**3 for i in range(1, n+1)}
    return cubes_dict",31
23744515162,single_digit_sum,"def single_digit_sum(num):
    while num >= 10:
        num = sum(int(digit) for digit in str(num))
    return num",31
37142081648,find_palindromes,"def find_palindromes(words):
    result = [word for word in words if word.lower() == word[::-1].lower()]
    return result",31
1411338728,max_product_pair,"def max_product_pair(nums):
    nums.sort()
    return max(nums[0] * nums[1], nums[-1] * nums[-2])",31
2067324643,rotate_list,"def rotate_list(nums, k):
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]
    return nums",31
13476938340,get_Value,"def get_Value(arr,criteria):
    if criteria == 'max':
        return max(arr)
    elif criteria == 'min':
        return min(arr)",31
28507112664,count_word,"def count_word(sentence, target):
    sentence = sentence.lower()
    target = target.lower()
    words = sentence.split()
    return words.count(target)",31
2095766572,word_length,"def word_length(word_list):
    length_dict = {}
    for word in word_list:
        length_dict[word] = len(word)
    return length_dict",31
15993331365,isPerfectSquare,"import math
def isPerfectSquare(n):
    if(int(math.sqrt(n))**2 == n):
        return True
    else:
        return False",31
32376233385,heap_queue_smallest,"import heapq as hq
def heap_queue_smallest(nums,n):
  smallest_nums = hq.nsmallest(n, nums)
  return smallest_nums",31
8326008913,have_common_member,"def have_common_member(list1, list2):
    for i in list1:
        if i in list2:
            return True
    return False",31
12472832580,max_product_list,"def max_product_list(lists):
    return max(lists, key=lambda x: functools.reduce(lambda a, b: a*b, x))

import functools",31
913567335,heap_queue_smallest,"import heapq as hq
def heap_queue_smallest(nums,n):
  smallest_nums = hq.nsmallest(n, nums)
  return smallest_nums",31
19999085879,fib,"def fib(n):
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)",31
70941978074,check_anagram,"def check_anagram(str1, str2):
    if sorted(str1) == sorted(str2):
        return True
    else:
        return False",31
1372504243,list_intersection,"def list_intersection(list1, list2):
    result = [value for value in list1 if value in list2]
    return list(set(result))",31
35673984558,max_value,"def max_value(list_of_tuples):
    max_val = max(list_of_tuples, key=lambda x: x[1])
    return max_val[1]",31
40311362142,palindrome_strings,"def palindrome_strings(arr):
    result = []
    for word in arr:
        if word == word[::-1]:
            result.append(word)
    return result",31
1184882124,fib,"def fib(n):
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)",31
72042878687,even_sort,"def even_sort(numbers):
  even_numbers = [num for num in numbers if num % 2 == 0]
  return sorted(even_numbers)",31
17463731926,swap_first_last,"def swap_first_last(lst):
    if lst:
        lst[0], lst[-1] = lst[-1], lst[0]
    return lst",31
14435730487,most_frequent_item_count,"from collections import Counter

def most_frequent_item_count(lst):
    count = Counter(lst)
    max_count = max(count.values())
    return max_count",31
32977391775,most_frequent_element,"from collections import Counter

def most_frequent_element(lst):
    count = Counter(lst)
    return count.most_common(1)[0][0]",31
1510533211,find_max_and_index,"def find_max_and_index(lst):
  max_num = max(lst)
  index = lst.index(max_num)
  return (max_num, index)",30
7005667903,get_common_elements,"def get_common_elements(list1, list2):
    common_elements = list(set(list1) & set(list2))
    return sorted(common_elements)",30
6277801771,most_frequent,"from collections import Counter

def most_frequent(lst):
    counter = Counter(lst)
    return counter.most_common(1)[0][0]",30
20203750978,unique_list,"def unique_list(l):
    unique = []
    for i in l:
        if i not in unique:
            unique.append(i)
    return unique",30
15952282791,unique_elements,"def unique_elements(numbers):
    unique = []
    for num in numbers:
        if num not in unique:
            unique.append(num)
    return unique",30
12234836670,check_substrings,"def check_substrings(string, substrings):
    for substring in substrings:
        if substring not in string:
            return False
    return True",30
410799495,factorial_recursive,"def factorial_recursive(n):
    if n == 1:
        return 1
    else:
        return n * factorial_recursive(n-1)",30
28402676029,find_common_elements,"def find_common_elements(list1, list2):
    common_elements = list(set(list1) & set(list2))
    return sorted(common_elements)",30
14677368512,check_anagrams,"def check_anagrams(str1,str2):
    if sorted(str1) == sorted(str2):
        return True
    else:
        return False",30
17870644021,sum_digits_largest,"def sum_digits_largest(list1):
    max_num = max(list1)
    return sum(int(digit) for digit in str(max_num))",30
10729205699,reverse_strings,"def reverse_strings(string_list):
    reversed_list = []
    for string in string_list:
        reversed_list.append(string[::-1])
    return reversed_list",30
19765577081,rotate_list,"def rotate_list(nums,k):
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]
    return nums",30
33759737608,digit_sum,"def digit_sum(n):
    while n >= 10:
        n = sum(int(digit) for digit in str(n))
    return n",30
28351322473,sum_digits,"def sum_digits(n):
    while n >= 10:
        n = sum(int(digit) for digit in str(n))
    return n",30
28932362486,factorial_recursive,"def factorial_recursive(n):
    if n == 0:
        return 1
    else:
        return n * factorial_recursive(n-1)",30
17375923083,cumulative_sum,"def cumulative_sum(lst):
    for i in range(1, len(lst)):
        lst[i] += lst[i - 1]
    return lst",30
1688258655,flatten_list,"def flatten_list(lists):
    result = []
    for sublist in lists:
        for item in sublist:
            result.append(item)
    return result",30
12921439115,gcd_list,"from math import gcd
from functools import reduce

def gcd_list(nums):
    return reduce(lambda x, y: gcd(x, y), nums)",30
33687724409,factorial_recursive,"def factorial_recursive(n):
    if n == 0:
        return 1
    else:
        return n * factorial_recursive(n-1)",30
12139840947,power,"def power(base, exponent):
    if exponent == 0:
        return 1
    return base * power(base, exponent - 1)",30
29140271338,rotate,"def rotate(nums, k):
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]
    return nums",30
73871109970,nested_sum,"def nested_sum(nested_list):
    total = 0
    for sublist in nested_list:
        total += sum(sublist)
    return total",30
8060692762,string_combinations,"from itertools import product

def string_combinations(length, characters):
    return [''.join(char) for char in product(characters, repeat=length)]",30
32572877805,is_subset,"def is_subset(test_tup1, test_tup2):
  return set(test_tup1).issubset(set(test_tup2))",30
39926902916,is_Harshad,"def is_Harshad(num):
    total = sum(int(digit) for digit in str(num))
    return num % total == 0",30
38217878019,count_unique_chars,"def count_unique_chars(s):
    unique_chars = set()
    for char in s:
        unique_chars.add(char)
    return len(unique_chars)",30
5964429992,string_permutations,"from itertools import permutations

def string_permutations(str_list):
    result = [''.join(p) for p in permutations(str_list)]
    return result",30
22095681087,smallest_pos,"def smallest_pos(list1): 
    list1 = [i for i in list1 if i > 0]
    return min(list1)",30
946711789,fact_rec,"def fact_rec(n):
    if n == 0:
        return 1
    else:
        return n * fact_rec(n-1)",30
28221340835,calc_average,"def calc_average(lst):
    if len(lst) == 0:
        return 0.0
    return sum(lst) / len(lst)",30
29545539571,factorial_recursive,"def factorial_recursive(n):
    if n == 1:
        return 1
    else:
        return n * factorial_recursive(n-1)",30
6785727959,euclidean_gcd,"def euclidean_gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a",30
11031211773,sum_nums,"from functools import reduce

def sum_nums(nums):
    sum_nums = reduce(lambda x, y: x + y, nums)
    return sum_nums",30
6371735509,is_Perfect_Square,"import math

def is_Perfect_Square(n):
    sqrt = math.sqrt(n)
    return (sqrt - math.floor(sqrt)) == 0",30
36195336326,digit_sum,"def digit_sum(n):
    while n >= 10:
        n = sum(int(digit) for digit in str(n))
    return n",30
40289463121,find_divisible_by_nine,"def find_divisible_by_nine(numbers):
    result = [num for num in numbers if num % 9 == 0]
    return result",30
32246933920,matrix_number_count,"def matrix_number_count(matrix, target):
    count = 0
    for row in matrix:
        count += row.count(target)
    return count",30
7654881845,count_digits,"def count_digits(n):
    if n == 0:
        return 0
    return 1 + count_digits(n // 10)",30
11448943827,total_cost,"def total_cost(shopping_list):
  total = 0
  for item in shopping_list:
    total += item[1]
  return total",30
6981593888,cumulative_sum,"def cumulative_sum(nums):
    for i in range(1, len(nums)):
        nums[i] += nums[i - 1]
    return nums",30
31152468956,most_common_element,"from collections import Counter

def most_common_element(lst):
    data = Counter(lst)
    return data.most_common(1)[0][0]",30
33308948995,replace_punctuation,"import string

def replace_punctuation(sentence):
    for punctuation in string.punctuation:
        sentence = sentence.replace(punctuation, "" "")
    return sentence",30
27357883627,factorial_recursive,"def factorial_recursive(n):
    if n == 0:
        return 1
    else:
        return n * factorial_recursive(n-1)",30
24294653166,square_pyramidal_number,"def square_pyramidal_number(n):
  return n * (n + 1) * (2 * n + 1) // 6",30
22958302983,generate_n_grams,"def generate_n_grams(s, n):
    return [s[i:i+n] for i in range(len(s) - n + 1)]",30
13095493440,days_between_dates,"from datetime import date

def days_between_dates(date1, date2):
    delta = date2 - date1
    return abs(delta.days)",30
207432179,int_to_binary,"def int_to_binary(nums):
    binary_list = []
    for num in nums:
        binary_list.append(bin(num)[2:])
    return binary_list",30
10198463554,smallest_k,"def smallest_k(arr, k):
    if arr is None or k is None:
        return []
    arr.sort()
    return arr[:k]",30
38795759632,max_product_of_two,"def max_product_of_two(lst):
    lst.sort()
    return max(lst[-1]*lst[-2], lst[0]*lst[1])",30
27239875177,sum_digits,"def sum_digits(n):
    while n >= 10:
        n = sum(int(digit) for digit in str(n))
    return n",30
13148179199,nested_sum,"def nested_sum(nested_list):
    total = 0
    for sublist in nested_list:
        total += sum(sublist)
    return total",30
6939180347,factorial_recursive,"def factorial_recursive(n):
    if n == 0:
        return 1
    else:
        return n * factorial_recursive(n-1)",30
74410315953,greatest_common_divisor,"def greatest_common_divisor(a, b):
    while b != 0:
        a, b = b, a % b
    return a",30
34495129391,most_common_element,"from collections import Counter

def most_common_element(lst):
    counter = Counter(lst)
    return counter.most_common(1)[0][0]",30
22118337838,substring_count,"def substring_count(main_string, substring):
    main_string = main_string.lower()
    substring = substring.lower()
    return main_string.count(substring)",30
30108923545,diag_sum,"def diag_sum(matrix):
    sum = 0
    for i in range(len(matrix)):
        sum += matrix[i][i]
    return sum",30
9625751497,most_common_element,"from collections import Counter

def most_common_element(lst):
    count = Counter(lst)
    return count.most_common(1)[0][0]",30
71057583086,first_max_index,"def first_max_index(lst):
    if not lst:
        return -1
    max_val = max(lst)
    return lst.index(max_val)",30
74844087075,factorial_recursive,"def factorial_recursive(n):
    if n == 0:
        return 1
    else:
        return n * factorial_recursive(n-1)",30
31676404680,sum_of_str_int,"def sum_of_str_int(str_list):
    sum = 0
    for str in str_list:
        sum += int(str)
    return sum",30
18335151840,even_indexed_chars,"def even_indexed_chars(s):
    return ''.join([s[i] for i in range(len(s)) if i%2 == 0])",30
29188540570,factorial_recursive,"def factorial_recursive(n):
    if n == 0:
        return 1
    else:
        return n * factorial_recursive(n-1)",30
9946207661,unique_list,"def unique_list(l):
    unique = []
    for i in l:
        if i not in unique:
            unique.append(i)
    return unique",30
21067203615,volume_cylinder,"import math
def volume_cylinder(radius, height):
  volume= math.pi * radius * radius * height
  return round(volume,2)",30
18634241951,is_sorted_asc,"def is_sorted_asc(lst):
    return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1))",30
36205923144,digital_root,"def digital_root(n):
    while n >= 10:
        n = sum(int(digit) for digit in str(n))
    return n",30
33446547361,merge_and_sort_lists,"def merge_and_sort_lists(list1, list2):
    merged_list = list1 + list2
    merged_list.sort()
    return merged_list",30
6923433622,fact_rec,"def fact_rec(n):
  if n == 0:
    return 1
  else:
    return n * fact_rec(n-1)",30
1560808531,most_common_element,"from collections import Counter

def most_common_element(lst):
    count = Counter(lst)
    return count.most_common(1)[0][0]",30
9819008969,average_list,"def average_list(nums):
    if len(nums) == 0:
        return 0
    else:
        return sum(nums)/len(nums)",30
27687908341,average_list,"def average_list(lst):
    if len(lst) == 0:
        return 0
    else:
        return sum(lst)/len(lst)",30
42930489152,count_digits,"def count_digits(num):
    if num > 0:
        return len(str(num))
    else:
        return ""Please provide a positive integer.""",30
70034026307,max_product,"def max_product(nums):
    nums.sort()
    return max(nums[0] * nums[1], nums[-1] * nums[-2])",30
42184150369,find_next_power_of_2,"def find_next_power_of_2(n):
    power = 1
    while power < n:
        power *= 2
    return power",30
7834144470,is_perfect_square,"import math
def is_perfect_square(n):
    sr = math.sqrt(n)
    return ((sr - math.floor(sr)) == 0)",30
30953231683,digit_sum,"def digit_sum(n):
    while n >= 10:
        n = sum(int(digit) for digit in str(n))
    return n",30
33625536239,first_even,"def first_even(nums):
  first_even = next((el for el in nums if el%2==0),-1)
  return first_even",30
28122256397,convert_to_binary,"def convert_to_binary(numbers):
    binary_list = []
    for number in numbers:
        binary_list.append(bin(number)[2:])
    return binary_list",30
74952626697,is_strictly_increasing,"def is_strictly_increasing(lst):
    return all(lst[i] < lst[i+1] for i in range(len(lst)-1))",30
70629380314,largest_common_divisor,"def largest_common_divisor(a, b):
    while b != 0:
        a, b = b, a % b
    return a",30
5322669104,rotate,"def rotate(nums, k):
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]
    return nums",30
28172720852,list_sum,"from functools import reduce

def list_sum(lst):
    list_sum = reduce(lambda x, y: x + y, lst)
    return list_sum",30
8683665455,convert_to_list,"def convert_to_list(s):
    result = []
    for char in s:
        if char.isalnum():
            result.append(char)
    return result",30
594076894,reverse_in_range,"def reverse_in_range(lst, start, end):
    lst[start:end+1] = lst[start:end+1][::-1]
    return lst",30
7153723403,even_numbers,"def even_numbers(numbers):
    even = [num for num in numbers if num % 2 == 0]
    even.sort()
    return even",30
40124054430,remove_duplicates,"def remove_duplicates(lst):
    result = []
    for i in lst:
        if i not in result:
            result.append(i)
    return result",30
1452229702,unique_list,"def unique_list(lst):
    unique = []
    for i in lst:
        if i not in unique:
            unique.append(i)
    return unique",30
27805440617,factorial_recursive,"def factorial_recursive(n):
    if n == 0:
        return 1
    else:
        return n * factorial_recursive(n-1)",30
45127287647,rotate_array,"def rotate_array(nums,k):
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]
    return nums",30
29526656729,second_largest_num,"def second_largest_num(num_list):
    unique_nums = set(num_list)
    unique_nums.remove(max(unique_nums))
    return max(unique_nums)",30
23329058125,rec_fact,"def rec_fact(n):
    if n == 0:
        return 1
    else:
        return n * rec_fact(n-1)",30
4902544745,transpose,"def transpose(matrix):
    return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]",29
28449678001,total_cost,"def total_cost(cart):
    total = 0.0
    for item in cart:
        total += item[1]
    return total",29
13369152032,check_ascending_no_duplicates,"def check_ascending_no_duplicates(lst):
    return all(lst[i] < lst[i+1] for i in range(len(lst)-1))",29
9849116169,reverse_word_order,"def reverse_word_order(s):
    words = s.split()
    reversed_words = ' '.join(reversed(words))
    return reversed_words.strip()",29
17272169316,frequent_item,"from collections import Counter

def frequent_item(lst):
    counter = Counter(lst)
    return counter.most_common(1)[0][0]",29
781069335,find_max_min,"def find_max_min(numbers):
    max_num = max(numbers)
    min_num = min(numbers)
    return (max_num, min_num)",29
13743547083,convertAscii,"def convertAscii(numberList):
    asciiList = []
    for number in numberList:
        asciiList.append(chr(number))
    return asciiList",29
14088256256,most_common,"from collections import Counter

def most_common(lst):
    data = Counter(lst)
    return data.most_common(1)[0][0]",29
20720563405,most_common,"from collections import Counter

def most_common(lst):
    data = Counter(lst)
    return data.most_common(1)[0][0]",29
35060325538,count_target,"def count_target(matrix, target):
    count = 0
    for row in matrix:
        count += row.count(target)
    return count",29
16184772132,smallest_even_multiple,"def smallest_even_multiple(n):
    if n % 2 == 0:
        return n
    else:
        return n * 2",29
12347336143,most_common,"from collections import Counter

def most_common(lst):
    data = Counter(lst)
    return data.most_common(1)[0][0]",29
36038922693,is_Binary_Palindrome,"def is_Binary_Palindrome(n):
    binary = bin(n).replace(""0b"","""")
    return binary == binary[::-1]",29
71223265955,unique_chars,"def unique_chars(string):
    char_set = set()
    for char in string:
        char_set.add(char)
    return len(char_set)",29
74184813045,n_grams,"def n_grams(s, n):
    return [s[i:i+n] for i in range(len(s) - n + 1)]",29
40220434972,is_isogram,"def is_isogram(string):
    string = string.lower()
    return len(string) == len(set(string.replace('-', '').replace(' ', '')))",29
34200621257,calculate_cost_with_discount,"def calculate_cost_with_discount(price, discount):
    discounted_price = price - (price * discount / 100)
    return discounted_price",29
72631076004,intersect_sorted,"def intersect_sorted(list1, list2):
    intersection = list(set(list1) & set(list2))
    intersection.sort()
    return intersection",29
11031569543,string_length,"def string_length(lst):
    length_dict = {}
    for word in lst:
        length_dict[word] = len(word)
    return length_dict",29
15382895147,median_three,"def median_three(x, y, z):
  numbers = [x, y, z]
  numbers.sort()
  return numbers[1]",29
42010199084,running_sum,"def running_sum(nums):
    for i in range(1, len(nums)):
        nums[i] += nums[i-1]
    return nums",29
40566665103,remove_substring,"def remove_substring(text, substring):
    while substring in text:
        text = text.replace(substring, """", 1)
    return text",29
8283362673,snake_to_camel,"def snake_to_camel(snake_str):
    components = snake_str.split('_')
    return ''.join(x.title() for x in components)",29
12497893400,get_even_numbers,"def get_even_numbers(numbers):
    even_numbers = [number for number in numbers if number % 2 == 0]
    return even_numbers",29
31654107994,transpose,"def transpose(matrix):
    return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]",29
17642906591,remove_smallest,"def remove_smallest(numbers):
    min_index = numbers.index(min(numbers))
    return numbers[:min_index] + numbers[min_index+1:]",29
72269291634,f_to_c,"def f_to_c(fahrenheit):
    celsius = (fahrenheit - 32) * 5/9
    return celsius",29
13784981041,generate_combinations,"from itertools import product

def generate_combinations(elements, length):
    return [''.join(e) for e in product(elements, repeat=length)]",29
40283034433,max_abs_difference,"def max_abs_difference(nums):
    max_num = max(nums)
    min_num = min(nums)
    return abs(max_num - min_num)",29
71729555351,count_digits,"def count_digits(n: int) -> int:
    if n == 0:
        return 1
    return len(str(abs(n)))",29
43827919663,second_frequent,"from collections import Counter

def second_frequent(arr):
    cnt = Counter(arr)
    return sorted(cnt, key=cnt.get)[-2]",29
6902390276,repeat_characters,"def repeat_characters(text):
    repeated_text = """"
    for char in text:
        repeated_text += char * 2
    return repeated_text",29
37936466420,frequent_char,"from collections import Counter

def frequent_char(string):
    count = Counter(string)
    return count.most_common(1)[0][0]",29
71677381860,unique_chars,"def unique_chars(s):
    unique_chars = set()
    for char in s:
        unique_chars.add(char)
    return len(unique_chars)",29
8015826976,transpose,"def transpose(matrix):
    return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]",29
43417263467,str_to_dict,"def str_to_dict(list1):
    result = {}
    for string in list1:
        result[string] = len(string)
    return result",29
14444150182,get_gcd,"def get_gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a",29
72559187840,find_power_of_2,"def find_power_of_2(n):
    power = 1
    while power < n:
        power *= 2
    return power",29
7419297580,square_or_cube,"def square_or_cube(lst):
    return [i**3 if i % 2 == 0 else i**2 for i in lst]",29
73295369989,manhattan_distance,"def manhattan_distance(point1, point2):
    return sum(abs(a-b) for a, b in zip(point1, point2))",29
33302700894,length_of_strings,"def length_of_strings(list_of_strings):
    length_dict = {string: len(string) for string in list_of_strings}
    return length_dict",29
35092225235,most_common,"from collections import Counter

def most_common(lst):
    data = Counter(lst)
    return data.most_common(1)[0][0]",29
37996825365,reverse_if_multiple_of_four,"def reverse_if_multiple_of_four(s):
    if len(s) % 4 == 0:
        return s[::-1]
    return s",29
70212568522,most_common,"from collections import Counter

def most_common(lst):
    data = Counter(lst)
    return data.most_common(1)[0][0]",29
34728783816,find_max_min,"def find_max_min(numbers):
    max_num = max(numbers)
    min_num = min(numbers)
    return (max_num, min_num)",29
36743873054,get_max_min,"def get_max_min(l):
    max_element = max(l)
    min_element = min(l)
    return (max_element, min_element)",29
71033195638,get_even_numbers,"def get_even_numbers(nums):
    even_nums = [x for x in nums if x % 2 == 0]
    return even_nums",29
75047299536,find_min_max,"def find_min_max(numbers):
    min_num = min(numbers)
    max_num = max(numbers)
    return (min_num, max_num)",29
20978485812,max_abs_difference,"def max_abs_difference(arr):
    max_val = max(arr)
    min_val = min(arr)
    return abs(max_val - min_val)",29
40810067763,square_roots,"import math

def square_roots(nums):
    result = [round(math.sqrt(num), 2) for num in nums]
    return result",29
74929399094,max_value_in_list_of_dicts,"def max_value_in_list_of_dicts(list_of_dicts, key):
    return max(list_of_dicts, key=lambda x: x[key])[key]",29
40287243871,square_roots_to_two_decimal_places,"def square_roots_to_two_decimal_places(numbers):
    return [round(number ** 0.5, 2) for number in numbers]",29
73903730868,remove_non_alphanumeric,"def remove_non_alphanumeric(input_string):
    alphanumeric_string = ''.join(char for char in input_string if char.isalnum())
    return alphanumeric_string",29
73468187319,union_sets,"def union_sets(sets_list):
    result = set()
    for s in sets_list:
        result = result.union(s)
    return result",29
6257817307,count_char,"def count_char(string, target_char):
    string = string.lower()
    target_char = target_char.lower()
    return string.count(target_char)",29
19388796458,is_anagram,"def is_anagram(str1,str2):
    if(sorted(str1)== sorted(str2)):
        return True
    else:
        return False",29
477355253,string_combinations,"from itertools import product

def string_combinations(s, n):
    return [''.join(p) for p in product(s, repeat=n)]",29
6726309420,sumOfDigits,"def sumOfDigits(number):
    sum = 0
    for digit in str(number):
        sum += int(digit)
    return sum",29
12624816232,sum_of_squares_of_evens,"def sum_of_squares_of_evens(nums):
    return sum(x**2 for x in nums if x % 2 == 0)",29
73255962177,is_binary,"def is_binary(s):
    for char in s:
        if char not in ['0', '1']:
            return False
    return True",29
20072943844,cumulative_sum,"def cumulative_sum(lst):
    for i in range(1, len(lst)):
        lst[i] += lst[i-1]
    return lst",29
28345996930,string_length,"def string_length(strings):
    length_dict = {}
    for string in strings:
        length_dict[string] = len(string)
    return length_dict",29
2053321484,reverse_Words,"def reverse_Words(s):
    words = s.split("" "")
    reversed_words = "" "".join(reversed(words))
    return reversed_words",28
44647774200,tower_of_hanoi,"def tower_of_hanoi(n):
    if n == 0:
        return 0
    return 2 ** n - 1",28
70034288707,factorial,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)",28
22570464232,repeat_string,"def repeat_string(lst):
    result = []
    for string in lst:
        result.extend([string] * len(string))
    return result",28
27738189892,fact,"def fact(n):
    if n == 0:
        return 1
    else:
        return n * fact(n-1)",28
14572725205,even_indexed_chars,"def even_indexed_chars(s):
    return sum(1 for i in range(len(s)) if i % 2 == 0)",28
44174737896,square_even,"def square_even(nums):
    result = [i**2 for i in nums if i % 2 == 0]
    return result",28
21576131047,reverse_sentence_order,"def reverse_sentence_order(sentence):
    words = sentence.split("" "")
    reversed_sentence = "" "".join(reversed(words))
    return reversed_sentence",28
10682953477,factorial,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)",28
40711071444,factorial,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)",28
5738558070,findIntersection,"def findIntersection(list1, list2):
    intersection = list(set(list1) & set(list2))
    return sorted(intersection)",28
11473297983,permute_strings,"from itertools import permutations

def permute_strings(s):
    result = [''.join(p) for p in permutations(s)]
    return result",28
25315281113,factorial,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)",28
8701596945,is_sorted_unique,"def is_sorted_unique(nums):
    if sorted(nums) != nums:
        return False
    return len(set(nums)) == len(nums)",28
22580732375,sum_except_divisible_by_3,"def sum_except_divisible_by_3(lst):
    return sum([i for i in lst if i % 3 != 0])",28
8152672172,intersection_lists,"def intersection_lists(list1, list2):
    result = [value for value in list1 if value in list2]
    return result",28
383536470,reverse_words_in_sentence,"def reverse_words_in_sentence(sentence):
    words = sentence.split()
    reversed_sentence = ' '.join(reversed(words))
    return reversed_sentence",28
42599314603,string_tuple,"def string_tuple(lst):
    return [(s, len(s)) for s in lst if not any(c.isdigit() for c in s)]",28
19002844498,is_strictly_decreasing,"def is_strictly_decreasing(lst):
    return all(x > y for x, y in zip(lst, lst[1:]))",28
552537941,max_list,"from functools import reduce

def max_list(lst):
    return reduce(lambda a, b: a if a > b else b, lst)",28
8939272251,check_perfect_square,"import math

def check_perfect_square(n):
    sqrt_n = math.isqrt(n)
    return sqrt_n * sqrt_n == n",28
7108195929,count_words,"import re

def count_words(string):
    words = re.findall(r'\b\w+\b', string)
    return len(words)",28
14198437653,find_first_greater,"def find_first_greater(lst, num):
    for element in lst:
        if element > num:
            return element
    return -1",28
14728108535,replace_substring,"def replace_substring(original_string, old_substring, new_substring):
    return original_string.replace(old_substring, new_substring)",28
12457924512,find_substring_index,"def find_substring_index(string, substring):
    index = string.find(substring)
    return index if index != -1 else -1",28
7435583266,intersection_lists,"def intersection_lists(list1, list2):
    intersection = [x for x in list1 if x in list2]
    return intersection",28
30256503301,remove_substring,"def remove_substring(s, part):
    while part in s:
        s = s.replace(part, """", 1)
    return s",28
30548369151,reverse_sentence_words,"def reverse_sentence_words(sentence):
  words = sentence.split("" "")
  reversed_sentence = "" "".join(words[::-1])
  return reversed_sentence",28
28482881204,is_strictly_ascending,"def is_strictly_ascending(lst):
    return all(x < y for x, y in zip(lst, lst[1:]))",28
42591776993,circle_area,"import math

def circle_area(radius):
    area = math.pi * (radius ** 2)
    return round(area, 2)",28
35206979251,factorial,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)",28
30843026276,create_zero_matrix,"def create_zero_matrix(rows, cols):
    matrix = [[0 for _ in range(cols)] for _ in range(rows)]
    return matrix",28
44204619250,reverse_strings,"def reverse_strings(strings):
    reversed_strings = []
    for string in strings:
        reversed_strings.append(string[::-1])
    return reversed_strings",28
73327735708,filter_prefix,"def filter_prefix(string_list, prefix):
    filtered_list = [string for string in string_list if string.startswith(prefix)]
    return filtered_list",28
4087342916,get_items_less_than_five,"def get_items_less_than_five(lst):
    new_lst = [i for i in lst if i < 5]
    return new_lst",28
13894553016,factorial,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)",28
70085488506,permute_string,"from itertools import permutations

def permute_string(s):
    return sorted([''.join(p) for p in set(permutations(s))])",28
2969274025,permute_string,"from itertools import permutations

def permute_string(s):
    return [''.join(p) for p in sorted(set(permutations(s)))]",28
6127347564,reverse_words_in_sentence,"def reverse_words_in_sentence(sentence):
    words = sentence.split()
    reversed_sentence = "" "".join(reversed(words))
    return reversed_sentence",28
7704079825,factorial,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)",28
42514511718,find_smallest_k,"import heapq

def find_smallest_k(arr, k):
    heapq.heapify(arr)
    return heapq.nsmallest(k, arr)",28
12917752789,max_product_tuple,"def max_product_tuple(list1):
    result_max = max([x * y for x, y in list1])
    return result_max",28
20734901617,sum_numbers_string,"import re

def sum_numbers_string(s):
    numbers = re.findall(r'\d+', s)
    return sum(map(int, numbers))",28
19764353131,factorial,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)",28
70044470369,check_strictly_ascending,"def check_strictly_ascending(lst):
    return all(x < y for x, y in zip(lst, lst[1:]))",28
32021149893,factorial,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)",28
38841504349,common_elements,"def common_elements(list1, list2):
    result = [value for value in list1 if value in list2]
    return result",28
31449946532,factorial,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)",28
785369468,is_hexadecimal,"def is_hexadecimal(s):
    try:
        int(s, 16)
        return True
    except ValueError:
        return False",28
2274689717,maximum_product,"def maximum_product(arr):
    arr.sort()
    return max(arr[0]*arr[1], arr[-1]*arr[-2])",28
46948200892,first_negative,"def first_negative(nums):
    first_negative = next((el for el in nums if el < 0), None)
    return first_negative",28
4294613631,replace_string,"def replace_string(s, replacements):
    for key, value in replacements.items():
        s = s.replace(key, value)
    return s",28
32240483657,positive_sort,"def positive_sort(numbers):
    positive_numbers = [num for num in numbers if num >= 0]
    return sorted(positive_numbers)",28
39679685649,volume_cylinder,"import math
def volume_cylinder(r, h):
  volume = math.pi * (r**2) * h
  return volume",28
17502636454,max_Product,"def max_Product(arr):
    arr.sort()
    return max(arr[0]*arr[1], arr[-1]*arr[-2])",28
17740119666,sum_of_lists,"def sum_of_lists(nums):
    result = 0
    for sublist in nums:
        result += sum(sublist)
    return result",28
3958531083,count_significant_digits,"def count_significant_digits(number):
    number_str = str(number).replace('.', '').lstrip('0')
    return len(number_str)",28
564180611,max_element,"from functools import reduce

def max_element(nums):
    return reduce(lambda a, b: a if a > b else b, nums)",28
12329835718,sort_list_of_dicts,"def sort_list_of_dicts(list_of_dicts, key):
    return sorted(list_of_dicts, key=lambda x: x[key], reverse=True)",28
24352081012,remove_elements_in_range,"def remove_elements_in_range(lst, start, end):
    return [i for i in lst if i < start or i > end]",28
41560324012,count_words,"import re

def count_words(sentence):
    words = re.findall(r'\b\w+\b', sentence)
    return len(words)",28
44174565736,min_val,"def min_val(listval):
     min_val = min(i for i in listval if isinstance(i, int))
     return(min_val)",28
19077452163,fact,"def fact(n):
    if n == 0:
        return 1
    else:
        return n * fact(n-1)",28
7797637739,divisible_by_6,"def divisible_by_6(numbers):
    result = [num for num in numbers if num % 6 == 0]
    return result",28
4497625961,is_strictly_increasing,"def is_strictly_increasing(lst):
    return all(x < y for x, y in zip(lst, lst[1:]))",28
72056141686,remove_edges,"def remove_edges(text):
  if len(text) < 2:
    return ''
  else:
    return text[1:-1]",28
33273230256,is_strictly_increasing,"def is_strictly_increasing(sequence):
    return all(x < y for x, y in zip(sequence, sequence[1:]))",28
5285308124,nth_catalan,"import math

def nth_catalan(n):
    return math.comb(2*n, n) // (n + 1)",28
13242834086,reverse_sentence_words,"def reverse_sentence_words(sentence):
    words = sentence.split()
    reversed_words = ' '.join(reversed(words))
    return reversed_words",27
73922100328,sort_tuples,"def sort_tuples(tuples_list):
    return sorted(tuples_list, key=lambda x: (x[1], x[0]))",27
75099315401,k_combinations,"from itertools import combinations

def k_combinations(lst, k):
    return [list(comb) for comb in combinations(lst, k)]",27
18732932328,reverse_word_order,"def reverse_word_order(s):
    words = s.split()
    reversed_words = ' '.join(reversed(words))
    return reversed_words",27
21953511185,degree_of_polynomial,"def degree_of_polynomial(coefficients):
    if not coefficients:
        return -1
    return len(coefficients) - 1",27
24326679947,smaller_specificnum,"def smaller_specificnum(list,num):
    smaller_specificnum=max([x for x in list if x<num])
    return smaller_specificnum",27
33627553739,convert_to_lowercase,"def convert_to_lowercase(s):
    if len(s) > 5 and s.isalpha():
        return s.lower()
    return s",27
31942892110,remove_element_at_index,"def remove_element_at_index(lst, index):
    if 0 <= index < len(lst):
        del lst[index]
    return lst",27
7835037550,generate_ngrams,"def generate_ngrams(s, n):
    return [s[i:i+n] for i in range(len(s)-n+1)]",27
18616543029,intersection,"def intersection(list1, list2):
    result = [value for value in list1 if value in list2]
    return result",27
21298345731,longest_word_length,"def longest_word_length(words):
    if not words:
        return 0
    return max(len(word) for word in words)",27
41342708336,reverseWords,"def reverseWords(s: str) -> str:
    return ' '.join(word[::-1] for word in s.split(' '))",27
383431560,longest_string_length,"def longest_string_length(strings):
    if not strings:
        return 0
    return max(len(s) for s in strings)",27
22935160650,count_case_insensitive,"def count_case_insensitive(lst, s):
    return sum([1 for str in lst if str.lower() == s.lower()])",27
25204722639,split_string,"def split_string(s, n):
    return [s[i:i+n] for i in range(0, len(s), n)]",27
23277414497,reverse_words,"def reverse_words(sentence):
    words = sentence.split(' ')
    reversed_sentence = ' '.join(reversed(words))
    return reversed_sentence",27
43096645879,product_of_lists,"def product_of_lists(list1, list2):
    return [a*b for a, b in zip(list1, list2)]",27
24253856050,append_array,"def append_array(arr):
    n = len(arr)
    for i in range(n):
        arr.append(arr[i])
    return arr",27
44438303494,product_list,"def product_list(num_list):
    product = 1
    for num in num_list:
        product *= num
    return product",27
14032490830,count_distinct_words,"def count_distinct_words(s):
    words = s.split()
    distinct_words = set(words)
    return len(distinct_words)",27
3898108542,is_ascending,"def is_ascending(lst):
    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))",27
19744232361,square_odds,"def square_odds(lst):
    return [num**2 if num % 2 != 0 else num for num in lst]",27
7835048310,gcd,"def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a",27
5048131049,generate_combinations,"from itertools import combinations

def generate_combinations(lst, length):
    return [list(i) for i in combinations(lst, length)]",27
33288491832,calculate_average,"def calculate_average(lst):
    lst.sort()
    return sum(lst[1:-1]) / (len(lst) - 2)",27
16314130518,max_in_list,"def max_in_list(lst):
  if len(lst) == 0:
    return None
  else:
    return max(lst)",27
14114394736,reverse_word_order,"def reverse_word_order(s):
    words = s.split()
    reversed_words = ' '.join(reversed(words))
    return reversed_words",27
35849900569,reverse_sentence_order,"def reverse_sentence_order(sentence):
    words = sentence.split()
    reversed_words = ' '.join(reversed(words))
    return reversed_words",27
9656519781,longest_string_length,"def longest_string_length(strings):
    if not strings:
        return 0
    return max(len(s) for s in strings)",27
17471981684,reverse_sentence_order,"def reverse_sentence_order(sentence):
    words = sentence.split()
    reversed_words = ' '.join(reversed(words))
    return reversed_words",27
26488275650,reverse_if_palindrome,"def reverse_if_palindrome(s):
    if s == s[::-1]:
        return s[::-1]
    else:
        return s",27
34370614041,average,"from functools import reduce

def average(lst):
    return reduce(lambda a, b: a + b, lst) / len(lst)",27
23704628081,reverse_sentence,"def reverse_sentence(sentence):
    words = sentence.split("" "")
    reversed_sentence = "" "".join(words[::-1])
    return reversed_sentence",27
7594866430,gcd,"def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a",27
39761934043,sum_even_nums,"def sum_even_nums(nums):
  result = sum(num for num in nums if num % 2 == 0)
  return result",27
12234823220,count_ones_in_binary,"def count_ones_in_binary(n):
    binary = bin(n).replace(""0b"", """")
    return binary.count(""1"")",27
20179306555,sum_of_even,"def sum_of_even(numbers):
    result = sum(num for num in numbers if num % 2 == 0)
    return result",27
23457572487,reverse_string_words,"def reverse_string_words(s):
    words = s.split()
    reversed_words = ' '.join(reversed(words))
    return reversed_words",27
8519560652,biased_coin_flip,"import random

def biased_coin_flip(probability_heads):
    return 'H' if random.random() < probability_heads else 'T'",27
41049045086,has_palindrome,"def has_palindrome(words):
    for word in words:
        if word == word[::-1]:
            return True
    return False",27
74052312793,reverse_word_order,"def reverse_word_order(sentence):
    words = sentence.split()
    reversed_sentence = "" "".join(reversed(words))
    return reversed_sentence",27
42118829397,sum_ascii_values,"def sum_ascii_values(str):
    sum = 0
    for i in str:
        sum += ord(i)
    return sum",27
22670559977,num_unique_permutations,"from itertools import permutations

def num_unique_permutations(s):
    return len(set(''.join(p) for p in permutations(s)))",27
70592340280,longest_string_length,"def longest_string_length(strings):
    if not strings:
        return 0
    return max(len(s) for s in strings)",27
27843147282,double_characters,"def double_characters(input_string):
    result = """"
    for char in input_string:
        result += char*2
    return result",27
40648541417,product_of_lists,"def product_of_lists(list1, list2):
    return [a*b for a, b in zip(list1, list2)]",27
33496166696,gcd,"def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a",27
72126286841,gcd,"def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a",27
74658568476,unique_word_count,"def unique_word_count(sentence):
    words = sentence.lower().split()
    unique_words = set(words)
    return len(unique_words)",27
23706230004,contains_palindrome,"def contains_palindrome(words):
    for word in words:
        if word == word[::-1]:
            return True
    return False",27
41134327877,fahrenheit_to_celsius,"def fahrenheit_to_celsius(f):
    return round((f - 32) * 5/9, 2)",27
24330620455,generate_combinations,"from itertools import combinations

def generate_combinations(items, length):
  return [list(comb) for comb in combinations(items, length)]",27
4925877068,get_longest_string_length,"def get_longest_string_length(strings):
    if not strings:
        return 0
    return len(max(strings, key=len))",27
46368959508,gcd,"def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a",27
25807610842,gcd,"def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a",27
36551833517,ListLength,"def ListLength(inputList):
    output = []
    for sublist in inputList:
        output.append(len(sublist))
    return output",27
28541304318,sum_even_squares,"def sum_even_squares(numbers):
    return sum([i**2 for i in numbers if i % 2 == 0])",27
39650716001,reverse_sentence_order,"def reverse_sentence_order(sentence):
    words = sentence.split()
    reversed_sentence = ' '.join(reversed(words))
    return reversed_sentence",27
33757206650,reverse_words_in_sentence,"def reverse_words_in_sentence(sentence):
    result = ' '.join([word[::-1] for word in sentence.split()])
    return result",27
28138159339,volume_sphere,"import math
def volume_sphere(r):
  volume = (4/3) * math.pi * r**3
  return volume",27
17493319094,longest_string_length,"def longest_string_length(strings):
    if not strings:
        return 0
    return max(len(s) for s in strings)",27
41954333274,max_min_number,"def max_min_number(sequence):
    max_num = max(sequence)
    min_num = min(sequence)
    return max_num, min_num",27
15550867463,square_odd_cube_even,"def square_odd_cube_even(lst):
    return [num**3 if num % 2 else num**2 for num in lst]",27
5213755473,reverse_substrings,"def reverse_substrings(s):
    return [s[i:] for i in range(len(s)-1, -1, -1)]",27
17088731695,reverse_words,"def reverse_words(s):
    words = s.split("" "")
    reversed_words = "" "".join(reversed(words))
    return reversed_words",27
27611614909,first_greater_than,"def first_greater_than(nums, value):
    for num in nums:
        if num > value:
            return num
    return None",27
30470176577,filter_even_numbers,"def filter_even_numbers(nums):
    result = [num for num in nums if num % 2 == 0]
    return result",27
38160138888,reverse_sentence_order,"def reverse_sentence_order(sentence):
    words = sentence.split()
    reversed_sentence = ' '.join(reversed(words))
    return reversed_sentence",27
21777111418,power,"def power(x, n):
    result = 1
    for _ in range(n):
        result *= x
    return result",27
31134206538,str_len_dic,"def str_len_dic(l):
    res = {}
    for i in l:
        res[i] = len(i)
    return res",27
31339649433,smallest_multiple,"def smallest_multiple(number, threshold):
    multiple = number
    while multiple < threshold:
        multiple += number
    return multiple",26
19083128897,regex_match,"import re

def regex_match(string, pattern):
    match = re.fullmatch(pattern, string)
    return match is not None",26
12187667443,find_two_largest,"def find_two_largest(list_num):
    list_num.sort()
    return [list_num[-2], list_num[-1]]",26
21278635039,reverse_concat,"def reverse_concat(str1, str2):
    combined_str = str1 + str2
    return combined_str[::-1]",26
74449093944,find_gcd,"def find_gcd(x, y):
   while(y):
       x, y = y, x % y
   return x",26
41690022918,count_unique,"def count_unique(list_nums):
   unique_nums = set(list_nums)
   count_unique = len(unique_nums)
   return count_unique",26
37139613002,is_sorted,"def is_sorted(nums):
    return all(nums[i] <= nums[i+1] for i in range(len(nums)-1))",26
72903487966,string_conversion,"def string_conversion(str1):
    char_list = list(str1)
    char_list.reverse()
    return ''.join(char_list)",26
14472182333,list_to_string,"def list_to_string(char_list):
    result = ''
    for char in char_list:
        result += char
    return result",26
27108244680,repeat_string,"def repeat_string(s):
    result = """"
    for char in s:
        result += char * 2
    return result",26
13087150705,largest_Number,"def largest_Number(num):
    num = list(str(num))
    num.sort(reverse=True)
    return int(''.join(num))",26
73455187073,find_mcd,"def find_mcd(a, b):
    while b:
        a, b = b, a % b
    return a",26
22935652920,find_pattern,"import re

def find_pattern(text, pattern):
    return [match.start() for match in re.finditer(pattern, text)]",26
10536390111,reverse_sentence,"def reverse_sentence(sentence):
    words = sentence.split()
    reversed_sentence = ' '.join(reversed(words))
    return reversed_sentence",26
24867413394,repeat_string,"def repeat_string(s, n):
    if n > 0:
        return s * n
    else:
        return ''",26
753679536,reverse_sentence,"def reverse_sentence(sentence):
    words = sentence.split()
    reversed_sentence = ' '.join(reversed(words))
    return reversed_sentence",26
46053156151,replace_substring,"def replace_substring(string, old_substring, new_substring):
  return string.replace(old_substring, new_substring)",26
8777536207,gcd_calculator,"def gcd_calculator(a, b):
    while b:
        a, b = b, a % b
    return a",26
25328125935,maxSecondElement,"def maxSecondElement(lst):
    lst.sort(key=lambda x: x[1], reverse=True)
    return lst[0]",26
43356962837,find_gcd,"def find_gcd(x, y):
    while(y):
        x, y = y, x % y
    return x",26
3721550660,find_gcd,"def find_gcd(x, y):
   while(y):
       x, y = y, x % y
   return x",26
23703966273,matrix_search,"def matrix_search(matrix, target):
    for row in matrix:
        if target in row:
            return True
    return False",26
72857338619,reverse_order,"def reverse_order(sentence):
    words = sentence.split()
    reversed_sentence = ' '.join(reversed(words))
    return reversed_sentence",26
4124581340,find_permutations,"from itertools import permutations

def find_permutations(input_string):
    return [''.join(p) for p in permutations(input_string)]",26
37681037089,count_strings_with_substring,"def count_strings_with_substring(lst, substring):
    return sum(s.count(substring) > 0 for s in lst)",26
11535674927,find_gcd,"def find_gcd(a, b):
    while b:
        a, b = b, a % b
    return a",26
40384254839,reverseWords,"def reverseWords(s):
    words = s.split()
    reversed_words = ' '.join(reversed(words))
    return reversed_words",26
3138335391,find_most_frequent,"from collections import Counter

def find_most_frequent(lst):
    return Counter(lst).most_common(1)[0][0]",26
2341328795,cube_or_absolute,"def cube_or_absolute(lst):
    return [abs(x) if x < 0 else x**3 for x in lst]",26
35694399243,snake_to_camel,"def snake_to_camel(s):
    components = s.split('_')
    return ''.join(x.title() for x in components)",26
26836235993,ngrams,"def ngrams(string, n):
    return [string[i:i+n] for i in range(len(string)-n+1)]",26
27625719328,find_GCD,"def find_GCD(x, y):
   while(y):
       x, y = y, x % y
   return x",26
16284209191,can_form_string,"from collections import Counter

def can_form_string(str1, str2):
    return Counter(str1) == Counter(str2)",26
10108149329,rotate_list,"def rotate_list(nums, k):
    k = k % len(nums)
    return nums[-k:] + nums[:-k]",26
18586913844,find_gcd,"def find_gcd(x, y):
   while(y):
       x, y = y, x % y
   return x",26
19127913337,square_or_abs,"def square_or_abs(nums):
    return [num**2 if num > 0 else abs(num) for num in nums]",26
70709507313,find_gcd,"def find_gcd(x, y):
    while(y):
        x, y = y, x % y
    return x",26
11552160402,generate_combinations,"from itertools import product

def generate_combinations(lists):
    return [list(combination) for combination in product(*lists)]",26
32660848609,cylinder_volume,"import math

def cylinder_volume(r, h): 
    return round(math.pi * r**2 * h, 2)",26
29164044875,are_equal,"def are_equal(list1, list2):
    list1.sort()
    list2.sort()
    return list1 == list2",26
330327443,longest_string,"def longest_string(strings):
    if not strings:
        return 0
    return max(len(string) for string in strings)",26
72331202328,smallest_multiple,"def smallest_multiple(base, threshold):
    result = base
    while result < threshold:
        result += base
    return result",26
19116663421,find_gcd,"def find_gcd(a, b):
    while(b):
        a, b = b, a % b
    return a",26
39730399012,find_first_occurrence,"def find_first_occurrence(lst, element):
  try:
    return lst.index(element)
  except ValueError:
    return -1",26
73468197239,longest_string,"def longest_string(strings):
    if not strings:
        return 0
    return max(len(s) for s in strings)",26
26972570886,smallest_multiple,"def smallest_multiple(base, threshold):
    multiple = base
    while multiple < threshold:
        multiple += base
    return multiple",26
31914299357,smallest_k,"import heapq

def smallest_k(arr, k):
    heapq.heapify(arr)
    return heapq.nsmallest(k, arr)",26
71883375064,find_gcd,"def find_gcd(x, y):
    while(y):
        x, y = y, x % y
    return x",26
6923107628,string_permutation,"from itertools import permutations

def string_permutation(s):
    return len(set(''.join(p) for p in permutations(s)))",26
22693109166,longest_string,"def longest_string(lst):
    if not lst:
        return 0
    return max(len(s) for s in lst)",26
42384182373,calculate_exclusive_total,"def calculate_exclusive_total(nums):
    total_sum = sum(nums)
    return [total_sum - num for num in nums]",26
19189712346,unique_chars,"def unique_chars(str_list):
    result = []
    for s in str_list:
        result.append(set(s))
    return result",26
11252527300,find_GCD,"def find_GCD(x, y):
    while(y):
        x, y = y, x % y
    return x",26
25200758197,gcd,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return abs(a)",26
2280011146,longest_string,"def longest_string(lst):
    if not lst:
        return 0
    return max(len(s) for s in lst)",26
9372808781,cube_or_absolute,"def cube_or_absolute(numbers):
    return [num**3 if num > 0 else abs(num) for num in numbers]",26
25071210088,reverse_words,"def reverse_words(sentence):
    words = sentence.split()
    reversed_sentence = ' '.join(reversed(words))
    return reversed_sentence",26
20087102064,cylinder_surface_area,"import math

def cylinder_surface_area(radius, height):
    return 2 * math.pi * radius * (radius + height)",26
684251037,is_Perfect_Square,"import math

def is_Perfect_Square(n):
    sqrt = int(math.sqrt(n))
    return sqrt*sqrt == n",26
36752090854,find_gcd,"def find_gcd(x, y):
   while(y):
       x, y = y, x % y
   return x",26
31866596,longest_string,"def longest_string(strings):
    if not strings:
        return 0
    return max(len(string) for string in strings)",26
71859171516,check_pangram,"import string

def check_pangram(str):
    alphabet = set(string.ascii_lowercase)
    return set(str.lower()) >= alphabet",26
19875522829,reverse_sentence,"def reverse_sentence(sentence):
    words = sentence.split()
    reversed_sentence = ' '.join(reversed(words))
    return reversed_sentence",26
34075616195,generate_binary,"def generate_binary(n):
    return [bin(i)[2:].zfill(n) for i in range(2**n)]",26
29840083830,reverse_sentence,"def reverse_sentence(sentence):
    words = sentence.split()
    reversed_words = ' '.join(reversed(words))
    return reversed_words",26
2563455183,substrings,"def substrings(string, n):
    return [string[i:i+n] for i in range(len(string)-n+1)]",26
2492081790,check_palindrome_lowercase,"def check_palindrome_lowercase(s):
    if not s.islower():
        return False
    return s == s[::-1]",26
9813805843,difference_between_lists,"def difference_between_lists(list1, list2):
    return [x for x in list1 if x not in list2]",26
37734731208,find_single_number,"def find_single_number(nums):
    result = 0
    for num in nums:
        result ^= num
    return result",26
26617080265,product_of_list,"def product_of_list(lst):
    product = 1
    for num in lst:
        product *= num
    return product",26
36853334083,reverse_words,"def reverse_words(sentence):
    words = sentence.split()
    reversed_sentence = ' '.join(reversed(words))
    return reversed_sentence",26
16206534216,reverse_tuple,"def reverse_tuple(test_tuple):
  test_tuple = list(test_tuple)
  test_tuple.reverse()
  return tuple(test_tuple)",25
42386324379,sum_of_odds,"def sum_of_odds(numbers):
    return sum([num for num in numbers if num % 2 != 0])",25
39835481501,single_number,"def single_number(nums):
    result = 0
    for num in nums:
        result ^= num
    return result",25
785404438,Find_Min_Index,"def Find_Min_Index(lst, value):
    try:
        return lst.index(value)
    except ValueError:
        return -1",25
30789261498,product_nums,"from functools import reduce

def product_nums(nums):
    return reduce((lambda x, y: x * y), nums)",25
17867294571,single_number,"def single_number(nums):
    result = 0
    for num in nums:
        result ^= num
    return result",25
35589469047,find_single,"def find_single(nums):
    result = 0
    for num in nums:
        result ^= num
    return result",25
6321418044,product_list,"def product_list(nums):
    product = 1
    for num in nums:
        product *= num
    return product",25
3170632056,find_all_indices,"def find_all_indices(lst, target):
    return [i for i, x in enumerate(lst) if x == target]",25
71549012051,product_list,"def product_list(lst):
    product = 1
    for num in lst:
        product *= num
    return product",25
698167818,sum_of_evens,"def sum_of_evens(numbers):
    return sum([num for num in numbers if num % 2 == 0])",25
11015027850,count_substrings,"def count_substrings(s):
    n = len(s)
    return n * (n + 1) // 2",25
41278178955,find_element_index,"def find_element_index(lst, target):
    try:
        return lst.index(target)
    except ValueError:
        return -1",25
18308741834,find_ways,"from math import floor

def find_ways(n):
    return floor((n-1)*(n-2)/2)",25
70609171339,find_unique_elements,"def find_unique_elements(arr,start,end):
    unique_elements = set(arr[start:end+1])
    return len(unique_elements)",25
36877585518,remove_multiples_of_three,"def remove_multiples_of_three(lst):
    return [x for x in lst if x % 3 != 0]",25
2639992537,list_difference,"def list_difference(list1, list2):
    return [x for x in list1 if x not in list2]",25
40512647029,sum_list,"def sum_list(lst):
    total = 0
    for i in lst:
        total += i
    return total",25
509382011,is_perfect_square,"import math

def is_perfect_square(n):
    sqrt = int(math.sqrt(n))
    return sqrt*sqrt == n",25
74794875465,most_common_element,"from collections import Counter

def most_common_element(lst):
    return Counter(lst).most_common(1)[0][0]",25
15574920688,max_in_rows,"def max_in_rows(matrix):
    result = []
    for row in matrix:
        result.append(max(row))
    return result",25
43143302970,str_to_list,"def str_to_list(test_str):
    res = list(map(int, test_str.split(', ')))
    return (res)",25
24756880548,is_perfect_square,"import math

def is_perfect_square(n):
    sqrt = int(math.sqrt(n))
    return sqrt*sqrt == n",25
21455589316,create_square_dict,"def create_square_dict(n):
    return {i: i**2 for i in range(1, n+1)}",25
6069727873,singleNumber,"def singleNumber(nums):
    a = 0
    for i in nums:
        a ^= i
    return a",25
28609546333,intersect_lists,"def intersect_lists(lists):
    if not lists:
        return set()
    return set.intersection(*map(set, lists))",25
71344626697,list_factorial,"import math

def list_factorial(nums):
    factorial_list = list(map(math.factorial, nums))
    return factorial_list",25
17171434659,sum_of_squares,"def sum_of_squares(n):
    return sum([i**2 for i in range(1, n+1)])",25
28128809574,most_common_element,"from collections import Counter

def most_common_element(lst):
    return Counter(lst).most_common(1)[0][0]",25
12307873334,single_number,"def single_number(nums):
    a = 0
    for i in nums:
        a ^= i
    return a",25
74296912822,sphere_volume,"import math

def sphere_volume(radius):
    return (4/3) * math.pi * (radius ** 3)",25
20736680320,string_permutations,"from itertools import permutations

def string_permutations(s):
    return set(''.join(p) for p in permutations(s))",25
14694811765,sum_of_squares,"def sum_of_squares(n):
    return sum([i**2 for i in range(1, n+1)])",25
42323257513,string_to_list,"import re
def string_to_list(s):
    return [char for char in re.sub(r'\W+', '', s)]",25
41486465799,volume_cylinder,"import math

def volume_cylinder(r,h):
  volume = math.pi * r * r * h
  return volume",25
35754679296,findSingle,"def findSingle(nums):
    a = 0
    for i in nums:
        a ^= i
    return a",25
35849927469,concatenate_strings,"def concatenate_strings(string_list):
    result = ''
    for string in string_list:
        result += string
    return result",25
38279747573,list_difference,"def list_difference(list1, list2):
    return [i for i in list1 if i not in list2]",25
40603995067,count_unique_chars,"def count_unique_chars(s):
    s = s.lower()
    unique_chars = set(s)
    return len(unique_chars)",25
71969636927,number_and_parity,"def number_and_parity(numbers):
    return [(num, num % 2 == 0) for num in numbers]",25
70980423417,find_index,"def find_index(nums, find):
    for i, num in enumerate(nums):
        if num == find:
            return i",25
35082133531,find_single,"def find_single(nums):
    a = 0
    for i in nums:
        a ^= i
    return a",25
12250541267,str_to_dict,"def str_to_dict(str_list):
  res = {str: len(str) for str in str_list}
  return res",25
30307991144,singleNumber,"def singleNumber(nums):
    result = 0
    for num in nums:
        result ^= num
    return result",25
12364906042,find_single,"def find_single(nums):
  unique = 0
  for num in nums:
    unique ^= num
  return unique",25
73612171017,string_length_dict,"def string_length_dict(string_list):
    result = {x: len(x) for x in string_list}
    return result",25
15211459709,count_uppercase,"def count_uppercase(s: str) -> int:
    return sum(1 for c in s if c.isupper())",25
17000019025,square_even_numbers,"def square_even_numbers(numbers):
    return [num**2 for num in numbers if num % 2 == 0]",25
40674386956,find_common_elements,"def find_common_elements(list1, list2):
    return [element for element in list1 if element in list2]",25
42751521664,map_lists_to_dict,"def map_lists_to_dict(keys, values):
    return dict(zip(keys, values[:min(len(keys), len(values))]))",25
74669828859,find_unique,"def find_unique(nums):
    unique = 0
    for num in nums:
        unique ^= num
    return unique",25
45363577161,circle_circumference,"import math

def circle_circumference(radius):
    circumference = 2 * math.pi * radius
    return circumference",25
6781233511,find_unique_words,"def find_unique_words(sentence):
    words = sentence.split()
    unique_words = set(words)
    return len(unique_words)",25
33624726549,rotate_left,"def rotate_left(nums, k):
    k = k % len(nums)
    return nums[k:] + nums[:k]",25
32739404965,parse_curly_ints,"def parse_curly_ints(s):
    s = s.strip(""{}"")
    return sorted(map(int, s.split(',')))",25
20942812131,sum_list,"def sum_list(nums):
    total = 0
    for num in nums:
        total += num
    return total",25
643077763,single_number,"def single_number(nums):
    result = 0
    for num in nums:
        result ^= num
    return result",25
10168427241,count_unique_words,"def count_unique_words(sentence):
    words = sentence.split()
    unique_words = set(words)
    return len(unique_words)",25
26835456432,max_in_binary_tree,"def max_in_binary_tree(tree):
    if len(tree) == 0:
        return None
    return max(tree)",25
4099988138,sum_divisible_by_three,"def sum_divisible_by_three(lst):
    return sum(i for i in lst if i % 3 == 0)",25
5160218222,delete_char,"def delete_char(s):
    return [s[:i] + s[i+1:] for i in range(len(s))]",25
316691845,frequent_item,"def frequent_item(lst):
    if not lst:
        return None
    return max(set(lst), key=lst.count)",25
20644488482,matrix_row_sum,"def matrix_row_sum(matrix):
    if not matrix:
        return []
    return [sum(row) for row in matrix]",25
71662222821,length_of_last_word,"def length_of_last_word(s: str) -> int:
    x = s.split()
    return len(x[-1])",25
40226134705,can_construct,"from collections import Counter

def can_construct(str1, str2):
    return Counter(str1) == Counter(str2)",25
3634695897,single_number,"def single_number(nums):
    result = 0
    for i in nums:
        result ^= i
    return result",25
2469835238,sum_of_evens,"def sum_of_evens(numbers):
    return sum(number for number in numbers if number % 2 == 0)",24
22039969811,celsius_to_fahrenheit,"def celsius_to_fahrenheit(celsius):
    return (celsius * 9/5) + 32",24
13116007423,is_Perfect_Square,"import math
def is_Perfect_Square(n):
    sqrt = math.sqrt(n)
    return sqrt.is_integer()",24
74085544060,product,"def product(arr):
    prod = 1
    for i in arr:
        prod *= i
    return prod",24
19414196382,sum_even_numbers,"def sum_even_numbers(numbers):
    return sum([num for num in numbers if num % 2 == 0])",24
32160294903,sum_of_evens,"def sum_of_evens(nums):
    return sum(num for num in nums if num % 2 == 0)",24
70204302915,is_Perfect_Square,"import math
def is_Perfect_Square(n):
    sqrt = math.sqrt(n)
    return sqrt.is_integer()",24
41441599169,reverse_concat,"def reverse_concat(str1, str2):
    result = str1 + str2
    return result[::-1]",24
36877240605,sum_of_evens,"def sum_of_evens(L):
    return sum(x for x in L if x % 2 == 0)",24
6270568614,list_to_number,"def list_to_number(numbers):
    result = ''.join(str(number) for number in numbers)
    return int(result)",24
12638457569,string_permutations,"from itertools import permutations

def string_permutations(lst):
    return [''.join(p) for p in permutations(lst)]",24
24413852413,is_valid_float,"def is_valid_float(s):
    try:
        float(s)
        return True
    except ValueError:
        return False",24
74694520064,reverse_words_in_sentence,"def reverse_words_in_sentence(sentence):
  return ' '.join(word[::-1] for word in sentence.split(' '))",24
71512286288,unique_char_count,"def unique_char_count(s: str) -> int:
    unique_chars = set(s)
    return len(unique_chars)",24
7087774598,find_longest_string,"def find_longest_string(strings):
    if not strings:
        return None
    return max(strings, key=len)",24
21693064758,find_index,"def find_index(lst, element):
    try:
        return lst.index(element)
    except ValueError:
        return -1",24
12276773500,get_even_numbers,"def get_even_numbers(numbers):
    return sorted([num for num in numbers if num % 2 == 0])",24
71821993918,odd_numbers,"def odd_numbers(list1):
    return [num for num in list1 if num % 2 != 0]",24
71535700269,isPerfectSquare,"import math
def isPerfectSquare(n):
    sqrt = int(math.sqrt(n))
    return sqrt*sqrt == n",24
5963222475,sum_even_numbers,"def sum_even_numbers(numbers):
    return sum([num for num in numbers if num % 2 == 0])",24
18190315016,square_roots,"import math

def square_roots(n_list):
  return [round(math.sqrt(n)) for n in n_list]",24
71967266293,num_digits,"def num_digits(n):
    if n == 0:
        return 1
    return len(str(abs(n)))",24
15025011213,sum_of_even_numbers,"def sum_of_even_numbers(nums):
    return sum(num for num in nums if num % 2 == 0)",24
27935038680,is_repeated_substring,"def is_repeated_substring(s):
    return (s+s)[1:-1].find(s) != -1",24
73346033270,even_and_sort,"def even_and_sort(lst):
    return sorted([num for num in lst if num % 2 == 0])",24
12605452322,celsius_to_fahrenheit,"def celsius_to_fahrenheit(celsius):
    return (celsius * 9/5) + 32",24
38876970275,sum_of_evens,"def sum_of_evens(numbers):
    return sum(num for num in numbers if num % 2 == 0)",24
10989642861,is_valid_decimal,"def is_valid_decimal(s):
    try:
        float(s)
        return True
    except ValueError:
        return False",24
10575476921,find_permutations,"from itertools import permutations

def find_permutations(lst):
    return [list(perm) for perm in permutations(lst)]",24
33180178821,common_elements,"def common_elements(list1, list2):
    return [x for x in list1 if x in list2]",24
7322403129,generate_permutations,"from itertools import permutations

def generate_permutations(chars):
    return [''.join(p) for p in permutations(chars)]",24
39060511366,find_max,"def find_max(tuples_list):
    return max(tuples_list, key=lambda x: x[1])[1]",24
71230438326,combinations,"from itertools import permutations

def combinations(lst):
    return [list(p) for p in permutations(lst, len(lst))]",24
26862906111,sum_of_evens,"def sum_of_evens(numbers):
    return sum(number for number in numbers if number % 2 == 0)",24
3314659482,string_permutations,"from itertools import permutations

def string_permutations(s):
    return [''.join(p) for p in permutations(s)]",24
34101286156,intersect_lists,"def intersect_lists(list1, list2):
    return [value for value in list1 if value in list2]",24
43114757822,find_number,"def find_number(lst, num):
    try:
        return lst.index(num)
    except ValueError:
        return -1",24
71764439225,round_up,"import math

def round_up(nums):
    result = [math.ceil(num) for num in nums]
    return result",24
5623610151,sum_even_nums,"def sum_even_nums(lst):
    return sum([x for x in lst if x % 2 == 0])",24
34280414559,string_length,"def string_length(words):
  length_dict = {word: len(word) for word in words}
  return length_dict",24
38960741590,max_value,"def max_value(tuples_list):
    return max(tuples_list, key=lambda x: x[1])[0]",24
71700475066,common_elements,"def common_elements(list1, list2):
    return [element for element in list1 if element in list2]",24
16237895073,gcd,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a",24
7558832610,circle_area,"import math

def circle_area(radius: float) -> float:
    return math.pi * (radius ** 2)",24
72147332930,sum_of_even_numbers,"def sum_of_even_numbers(lst):
    return sum(i for i in lst if i % 2 == 0)",24
41379256407,list_permutations,"from itertools import permutations

def list_permutations(lst):
    return [list(perm) for perm in permutations(lst)]",24
75019085625,string_permutations,"from itertools import permutations
def string_permutations(s):
    return [''.join(p) for p in permutations(s)]",24
38418783432,is_valid_number,"def is_valid_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False",24
32196751094,string_permutation,"from itertools import permutations

def string_permutation(s):
    return [''.join(p) for p in permutations(s)]",24
29249563768,max_by_string_length,"def max_by_string_length(lst):
    return max(lst, key=lambda x: len(x[1]))[0]",24
14556865732,find_duplicates,"def find_duplicates(lst):
  return list(set([x for x in lst if lst.count(x) > 1]))",24
28744797827,check_palindrome,"def check_palindrome(s):
    return 'Palindrome' if s == s[::-1] else 'Not Palindrome'",24
73881332411,sum_of_evens,"def sum_of_evens(numbers):
    return sum(number for number in numbers if number % 2 == 0)",24
74557998930,sum_of_evens,"def sum_of_evens(lst):
    return sum(i for i in lst if i % 2 == 0)",24
13478340311,find_longest_string,"def find_longest_string(strings):
  if not strings:
    return None
  return max(strings, key=len)",24
4877724179,reverse_words_in_sentence,"def reverse_words_in_sentence(sentence):
    return ' '.join(word[::-1] for word in sentence.split(' '))",24
13752103050,sqrt_list,"import math

def sqrt_list(nums):
    return [round(math.sqrt(num), 2) for num in nums]",24
34565645397,common_elements,"def common_elements(list1, list2):
    return [value for value in list1 if value in list2]",24
10993076182,gcd,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a",24
40525824833,reverse_even,"def reverse_even(numbers):
    return [num for num in reversed(numbers) if num % 2 == 0]",24
26252668582,factorial_list,"from math import factorial

def factorial_list(test_list):
    return [factorial(i) for i in test_list]",24
4877681139,sum_of_evens,"def sum_of_evens(numbers):
    return sum(num for num in numbers if num % 2 == 0)",24
21481003444,find_palindromes,"def find_palindromes(strings):
    return [string for string in strings if string == string[::-1]]",23
72050540406,rearrange_list,"def rearrange_list(l):
    return sorted(l, key=lambda x: x < 0, reverse=True)",23
72524056529,list_permutations,"from itertools import permutations

def list_permutations(lst):
    return [list(p) for p in permutations(lst)]",23
73103127460,get_even_numbers,"def get_even_numbers(lst):
    return [num for num in lst if num % 2 == 0]",23
18394640826,even_numbers,"def even_numbers(lst):
    return sorted([num for num in lst if num % 2 == 0])",23
3650718575,largest_num,"def largest_num(xs):
  if len(xs) == 0:
    return None
  return max(xs)",23
74971320891,get_permutations,"from itertools import permutations

def get_permutations(numbers):
    return [list(i) for i in permutations(numbers)]",23
41457913379,sum_odd_numbers,"def sum_odd_numbers(numbers):
    return sum(number for number in numbers if number % 2 != 0)",23
10513735151,calculate_triangle_area,"def calculate_triangle_area(base, height):
  area = 0.5 * base * height
  return area",23
17272287676,find_palindromes,"def find_palindromes(words):
    return [word for word in words if word == word[::-1]]",23
27046826882,find_palindromes,"def find_palindromes(words):
    return [word for word in words if word == word[::-1]]",23
25827259636,sum_even_numbers,"def sum_even_numbers(numbers):
    return sum(num for num in numbers if num % 2 == 0)",23
11867225594,sum_odd_numbers,"def sum_odd_numbers(lst):
    return sum(num for num in lst if num % 2 != 0)",23
17346104775,sum_two_smallest_numbers,"def sum_two_smallest_numbers(numbers):
    numbers.sort()
    return numbers[0] + numbers[1]",23
18210061205,extract_even_numbers,"def extract_even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",23
13396458092,find_substring_ignore_case,"def find_substring_ignore_case(str1, sub_str):
   return str1.lower().count(sub_str.lower())",23
21290607417,sum_odd,"def sum_odd(nums):
    return sum([num for num in nums if num % 2 != 0])",23
12891477348,sum_even_numbers,"def sum_even_numbers(lst):
    return sum(x for x in lst if x % 2 == 0)",23
38839724847,sum_odd_numbers,"def sum_odd_numbers(numbers):
    return sum(num for num in numbers if num % 2 != 0)",23
73096162264,even_sorted,"def even_sorted(nums):
    return sorted([num for num in nums if num % 2 == 0])",23
6835350248,count_ones_in_binary,"def count_ones_in_binary(num):
    binary_representation = bin(num)
    return binary_representation.count('1')",23
33025854740,word_count,"from collections import Counter

def word_count(sentence):
    words = sentence.split()
    return dict(Counter(words))",23
41489313948,find_max_value,"def find_max_value(test_list):
    return max(test_list, key=lambda x: x[1])[1]",23
22934567257,get_even_numbers,"def get_even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",23
44369157038,even_odd,"def even_odd(lst):
    return [(num, num % 2 == 0) for num in lst]",23
24839140957,remove_even_numbers,"def remove_even_numbers(nums):
    return list(filter(lambda x: x % 2 != 0, nums))",23
72944710169,reverse_even,"def reverse_even(lst):
    return [i for i in lst if i%2==0][::-1]",23
43149223314,filter_even_numbers,"def filter_even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",23
17411970074,get_even_numbers,"def get_even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",23
35734857447,findKthLargest,"def findKthLargest(nums, k):
    nums.sort(reverse=True)
    return nums[k-1]",23
74062342708,odd_numbers,"def odd_numbers(numbers):
    return sorted([num for num in numbers if num % 2 != 0])",23
10317065623,even_sorted,"def even_sorted(nums):
    return sorted([num for num in nums if num % 2 == 0])",23
1183951432,smallest_multiple,"def smallest_multiple(divisor, threshold):
    return ((threshold + divisor - 1) // divisor) * divisor",23
12664019110,list_permutations,"from itertools import permutations

def list_permutations(elements):
    return [list(p) for p in permutations(elements)]",23
30196667487,tuple_to_string,"def tuple_to_string(tup):
    str1 = ''.join(map(str, tup)) 
    return str1",23
14997164729,sum_even_numbers,"def sum_even_numbers(lst):
    return sum(i for i in lst if i % 2 == 0)",23
15089574418,string_length_dict,"def string_length_dict(words):
    result = {word: len(word) for word in words}
    return result",23
14677255532,average_sublists,"def average_sublists(arr):
    return [sum(sublist) / len(sublist) for sublist in arr]",23
21585636759,extract_odd_numbers,"def extract_odd_numbers(nums):
    return [num for num in nums if num % 2 != 0]",23
1959675921,sum_even_numbers,"def sum_even_numbers(numbers):
    return sum(num for num in numbers if num % 2 == 0)",23
12284976008,sort_tuples,"def sort_tuples(tuples):
    return sorted(tuples, key=lambda x: x[1], reverse=True)",23
30388993085,permutations,"from itertools import permutations as perm

def permutations(items):
    return [list(i) for i in perm(items)]",23
39085883895,even_numbers,"def even_numbers(numbers):
    return sorted([num for num in numbers if num % 2 == 0])",23
24588892734,find_palindromes,"def find_palindromes(words):
    return [word for word in words if word == word[::-1]]",23
13540093775,get_even_numbers,"def get_even_numbers(nums):
    return [num for num in nums if num % 2 == 0]",23
21290744607,even_sort,"def even_sort(arr):
    return sorted([num for num in arr if num % 2 == 0])",23
1212906412,sort_dicts_by_key,"def sort_dicts_by_key(dict_list, key):
    return sorted(dict_list, key=lambda x: x[key])",23
33086344273,list_permutations,"import itertools

def list_permutations(lst):
    return [list(i) for i in itertools.permutations(lst)]",23
17132325124,tuple_sort,"def tuple_sort(tuples):
    return sorted(tuples, key=lambda x: x[1], reverse=True)",23
73661329588,get_even_numbers,"def get_even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",23
74960734905,area_of_triangle,"def area_of_triangle(base, height):
    area = 0.5 * base * height
    return area",23
25998972801,permute,"from itertools import permutations

def permute(s):
    return [''.join(p) for p in permutations(s)]",23
3986970885,all_permutations,"from itertools import permutations

def all_permutations(lst):
    return [list(p) for p in permutations(lst)]",23
73121106745,str_to_ascii,"def str_to_ascii(s):
    ascii_list = [ord(c) for c in s]
    return ascii_list",23
22637761004,filter_even_numbers,"def filter_even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",23
73346027830,get_even_numbers,"def get_even_numbers(lst):
    return [num for num in lst if num % 2 == 0]",23
6775989865,max_tuple_value,"def max_tuple_value(tuples):
    return max(tuples, key=lambda x: x[1])[1]",23
21761029140,check_pythagorean_triplet,"def check_pythagorean_triplet(a, b, c):
    return a*a + b*b == c*c",23
72651388836,remove_digit_strings,"def remove_digit_strings(lst):
    result = [i for i in lst if not i.isdigit()]
    return result",23
38281689642,filter_even_numbers,"def filter_even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",23
41200672235,extract_odd_numbers,"def extract_odd_numbers(numbers):
    return [num for num in numbers if num % 2 != 0]",23
71883901877,filter_even_numbers,"def filter_even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",23
70270930587,sum_odd_numbers,"def sum_odd_numbers(numbers):
    return sum(number for number in numbers if number % 2 != 0)",23
2129097604,find_longest_string,"def find_longest_string(string_list):
    longest_string = max(string_list, key=len)
    return longest_string",23
74687779197,filter_palindromes,"def filter_palindromes(lst):
    return [word for word in lst if word == word[::-1]]",23
4398477002,check_perfect_square,"import math

def check_perfect_square(n):
    sqrt = math.sqrt(n)
    return sqrt.is_integer()",23
26688823306,reverse_lexi_sort,"def reverse_lexi_sort(arr):
  arr.sort(key=lambda x: x.lower(), reverse=True)
  return arr",23
35861064031,findKthLargest,"def findKthLargest(nums, k):
    nums.sort(reverse=True)
    return nums[k-1]",23
43642174753,square_abs,"def square_abs(numbers):
    result = [abs(num) ** 2 for num in numbers]
    return result",23
25388343971,filter_even_numbers,"def filter_even_numbers(numbers):
    return [number for number in numbers if number % 2 == 0]",23
17354282978,max_num,"def max_num(a, b):
    if a > b:
        return a
    else:
        return b",23
70479763633,generate_permutations,"from itertools import permutations

def generate_permutations(elements):
    return [list(p) for p in permutations(elements)]",23
29128435169,sort_by_digit_length,"def sort_by_digit_length(nums):
    return sorted(nums, key=lambda x: (len(str(x)), x))",23
20371161023,find_permutations,"from itertools import permutations

def find_permutations(lst):
    return [list(p) for p in permutations(lst)]",23
26925563296,cube_list_elements,"def cube_list_elements(list1):
    result = [x**3 for x in list1]
    return result",23
26317446026,find_difference,"def find_difference(arr):
    if not arr:
        return None
    return max(arr) - min(arr)",23
27944646734,get_even_numbers,"def get_even_numbers(nums):
    return [num for num in nums if num % 2 == 0]",23
11550837545,count_number,"def count_number(numbers_list, number):
    count = numbers_list.count(number)
    return {number: count}",23
21671710042,even_sorted,"def even_sorted(numbers):
    return sorted([num for num in numbers if num % 2 == 0])",23
36142657643,even_numbers,"def even_numbers(numbers):
    return sorted([num for num in numbers if num % 2 == 0])",23
29545822021,filter_even_numbers,"def filter_even_numbers(nums):
    return [num for num in nums if num % 2 == 0]",23
23706480174,filter_even_numbers,"def filter_even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",23
70436961619,nth_largest,"import heapq

def nth_largest(nums, n):
    return heapq.nlargest(n, nums)[-1]",23
22851666726,list_permutations,"from itertools import permutations

def list_permutations(lst):
  return [list(p) for p in permutations(lst)]",23
32875371240,filter_even_numbers,"def filter_even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",23
15084772216,filter_even_numbers,"def filter_even_numbers(lst):
    return [num for num in lst if num % 2 == 0]",23
11321019616,string_to_hex,"def string_to_hex(s):
    return ''.join([hex(ord(c))[2:] for c in s])",22
319906230,heptagonal_number,"def heptagonal_number(n):
    return n * (5 * n - 3) // 2",22
30807115245,generate_combinations,"from itertools import combinations

def generate_combinations(lst, length):
    return list(combinations(lst, length))",22
11803660229,calculate_square_roots,"import math

def calculate_square_roots(numbers):
    return [math.sqrt(number) for number in numbers]",22
31583620781,find_pentagonal,"def find_pentagonal(n):
    return n * (3 * n - 1) // 2",22
21289951057,max_pairwise_product,"def max_pairwise_product(nums):
    nums.sort()
    return nums[-1] * nums[-2]",22
40249420755,kth_largest,"def kth_largest(nums, k):
    nums.sort(reverse=True)
    return nums[k-1]",22
72925816636,square_root_list,"import math

def square_root_list(lst):
    return [round(math.sqrt(x)) for x in lst]",22
44919102141,kth_largest,"def kth_largest(nums, k):
    nums.sort(reverse=True)
    return nums[k-1]",22
20254893427,concatenate_numbers,"def concatenate_numbers(numbers):
    concatenated_number = int(''.join(map(str, numbers)))
    return concatenated_number",22
4124347310,filter_even,"def filter_even(numbers):
  return [num for num in numbers if num % 2 == 0]",22
29545009641,celsius_to_fahrenheit,"def celsius_to_fahrenheit(celsius):
    return celsius * 9/5 + 32",22
34035517169,remove_char,"def remove_char(string, char):
    return ''.join([c for c in string if c != char])",22
37689359734,even_elements,"def even_elements(numbers):
    return [num for num in numbers if num % 2 == 0]",22
2881493964,triangle_area,"def triangle_area(base, height):
    area = 0.5 * base * height
    return area",22
3415736854,sort_tuples,"def sort_tuples(tuples_list):
    return sorted(tuples_list, key=lambda x: x[::-1])",22
70248614581,round_to_two_decimal_places,"def round_to_two_decimal_places(numbers):
    return [round(number, 2) for number in numbers]",22
13539237255,remove_even,"def remove_even(nums):
    return [num for num in nums if num % 2 != 0]",22
70451680885,string_to_list,"import string

def string_to_list(s):
    return [c for c in s if c.isalnum()]",22
11828483925,sort_strings_alphabetically,"def sort_strings_alphabetically(strings_list):
    return sorted(strings_list, key=lambda x: x.lower())",22
74337261650,kthSmallest,"def kthSmallest(arr, n, k):
    arr.sort()
    return arr[k-1]",22
8038334474,filter_even,"def filter_even(numbers):
    return [num for num in numbers if num % 2 == 0]",22
21278453134,centered_square_number,"def centered_square_number(n):
    return 2 * n * n - 2 * n + 1",22
32401760110,triangle_area,"def triangle_area(base, height):
    area = 0.5 * base * height
    return area",22
40931581282,even_numbers,"def even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",22
30342844987,sort_unique,"def sort_unique(nums):
    unique_nums = list(set(nums))
    unique_nums.sort()
    return unique_nums",22
18333905726,find_common_elements,"def find_common_elements(list1, list2):
    return list(set(list1) & set(list2))",22
26498968777,sum_even_numbers,"def sum_even_numbers(lst):
    return sum(i for i in lst if i%2 == 0)",22
14129687386,remove_even,"def remove_even(nums):
    return [num for num in nums if num % 2 != 0]",22
33859065965,circle_area,"import math

def circle_area(radius):
    area = math.pi * radius ** 2
    return area",22
7352290161,flatten_list,"def flatten_list(lst):
    result = [item for sublist in lst for item in sublist]
    return result",22
28077785402,sort_dict_list,"def sort_dict_list(dict_list, key):
    return sorted(dict_list, key=lambda k: k[key])",22
26394688574,unique_sorted_desc,"def unique_sorted_desc(nums):
    uniqueNum = set(nums)
    return sorted(uniqueNum, reverse=True)",22
4927961900,filter_long_strings,"def filter_long_strings(strings):
    return [string for string in strings if len(string) > 4]",22
23657064873,string_permutations,"from itertools import permutations

def string_permutations(s):
    return list(map("""".join, permutations(s)))",22
36274086826,difference,"def difference(numbers):
    if not numbers:
        return None
    return max(numbers) - min(numbers)",22
20734850507,permute,"from itertools import permutations

def permute(nums):
    return [list(p) for p in permutations(nums)]",22
14705576840,find_two_largest,"def find_two_largest(lst):
    lst.sort()
    return (lst[-1], lst[-2])",22
28039513541,even_numbers,"def even_numbers(lst):
    return [num for num in lst if num % 2 == 0]",22
14435679377,diagonal_square,"import math
def diagonal_square(side):
  diagonal = math.sqrt(2) * side
  return diagonal",22
29663932721,triangle_area,"def triangle_area(base, height):
  area = 0.5 * base * height
  return area",22
21820916919,find_intersections,"def find_intersections(list1, list2):
    return list(set(list1) & set(list2))",22
16312335401,even_numbers,"def even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",22
21009094669,kth_largest,"def kth_largest(nums, k):
    nums.sort(reverse=True)
    return nums[k-1]",22
34048521310,sum_two_largest,"def sum_two_largest(numbers):
    numbers.sort()
    return numbers[-1] + numbers[-2]",22
73942911886,reverse_list_to_string,"def reverse_list_to_string(list1):
    return ''.join(str(i) for i in reversed(list1))",22
8157724016,find_unique_elements,"def find_unique_elements(list1, list2):
    return len(set(list1) - set(list2))",22
15021348274,binary_to_int,"def binary_to_int(binary_str):
  result = int(binary_str, 2)
  return (result)",22
13268111202,unique_sorted,"def unique_sorted(nums):
    unique_nums = list(set(nums))
    unique_nums.sort()
    return unique_nums",22
6773805585,sum_two_largest,"def sum_two_largest(numbers):
    numbers.sort()
    return numbers[-1] + numbers[-2]",22
29048317555,reverse_if_palindrome,"def reverse_if_palindrome(s):
    return s[::-1] if s == s[::-1] else s",22
70807740824,circle_area,"import math

def circle_area(radius):
    area = math.pi * radius ** 2
    return area",22
33402163253,lcm,"from math import gcd

def lcm(a, b):
    return a * b // gcd(a, b)",22
44588660910,sum_even,"def sum_even(numbers):
    return sum(num for num in numbers if num % 2 == 0)",22
11589975970,reverse_tuple_in_list,"def reverse_tuple_in_list(tuples_list):
    return [tuple[::-1] for tuple in tuples_list]",22
72356665918,is_perfect_cube,"def is_perfect_cube(n):
    return round(n ** (1./3)) ** 3 == n",22
20153596131,sym_diff,"def sym_diff(set1, set2):
    result = set1.symmetric_difference(set2)
    return result",22
42110519932,days_in_month,"import calendar

def days_in_month(year, month):
    return calendar.monthrange(year, month)[1]",22
899642349,flatten_list,"def flatten_list(list_of_lists):
    return [item for sublist in list_of_lists for item in sublist]",22
6773590385,find_k_smallest,"import heapq

def find_k_smallest(lst, k):
    return heapq.nsmallest(k, lst)",22
7435556366,reverseWords,"def reverseWords(s):
    return ' '.join(word[::-1] for word in s.split(' '))",22
23523631161,sort_tuples,"def sort_tuples(tuples_list):
    return sorted(tuples_list, key=lambda x: x[1])",22
27482863890,sum_even,"def sum_even(numbers):
    return sum(num for num in numbers if num % 2 == 0)",22
15079577769,check_consecutive,"def check_consecutive(lst):
    return sorted(lst) == list(range(min(lst), max(lst)+1))",22
18637308111,sum_odd,"def sum_odd(lst):
    return sum(x for x in lst if x % 2 != 0)",22
11378158172,remove_even,"def remove_even(numbers):
    return tuple(number for number in numbers if number % 2 != 0)",22
42053122098,reverse_sqrt,"import math

def reverse_sqrt(numbers):
    return [round(math.sqrt(x)) for x in reversed(numbers)]",22
73903731828,sum_even,"def sum_even(lst):
    return sum(x for x in lst if x % 2 == 0)",22
31014010568,flatten_list,"def flatten_list(list_of_lists):
    return [item for sublist in list_of_lists for item in sublist]",22
2442679178,find_number_frequency,"def find_number_frequency(data, num):
    count = data.count(num)
    return [(num, count)]",22
32216077820,reverseWords,"def reverseWords(s):
    words = s.strip().split()
    return ' '.join(reversed(words))",22
38222436426,even_numbers,"def even_numbers(numbers):
    return [num for num in numbers if num % 2 == 0]",22
71036680343,filter_even,"def filter_even(numbers):
    return [num for num in numbers if num % 2 == 0]",22
71730931001,find_common_elements,"def find_common_elements(list1, list2):
    return list(set(list1) & set(list2))",22
40685026417,find_k_smallest,"import heapq

def find_k_smallest(lst, k):
    return heapq.nsmallest(k, lst)",22
7279366010,sort_dict_list,"def sort_dict_list(dict_list, key):
    return sorted(dict_list, key=lambda k: k[key])",22
38419135822,sum_of_natural_numbers,"def sum_of_natural_numbers(n):
    return (n * (n + 1)) // 2",22
8240530795,sort_dict_list,"def sort_dict_list(dict_list, key):
    return sorted(dict_list, key=lambda x: x[key])",22
70444783156,tuple_sum_sort,"def tuple_sum_sort(tup_list):
    return sorted(tup_list, key=lambda x: sum(x))",22
17035309301,permute,"from itertools import permutations
def permute(nums):
    return [list(p) for p in permutations(nums)]",22
3033863942,remove_even,"def remove_even(numbers):
    return [num for num in numbers if num % 2 != 0]",22
2365371621,sum_two_largest,"def sum_two_largest(numbers):
    numbers.sort()
    return numbers[-1] + numbers[-2]",22
40057681212,reverse_words,"def reverse_words(sentence):
    return ' '.join(word[::-1] for word in sentence.split(' '))",22
43149597224,sum_even,"def sum_even(lst):
    return sum(i for i in lst if i % 2 == 0)",22
6085051217,remove_even,"def remove_even(numbers):
    return [num for num in numbers if num % 2 != 0]",22
9770944475,permute,"import itertools

def permute(elements):
    return [list(p) for p in itertools.permutations(elements)]",22
17489794463,remove_odd,"def remove_odd(lst):
    return [i for i in lst if i % 2 == 0]",22
43523991249,is_heptagonal,"def is_heptagonal(n):
    return n * (5 * n - 3) // 2",22
20867681273,replace_substring,"def replace_substring(s, old_sub, new_sub):
    return s.replace(old_sub, new_sub)",22
74654299984,find_common_elements,"def find_common_elements(list1, list2):
    return list(set(list1) & set(list2))",22
35995217046,square_root_round,"import math
def square_root_round(nums):
    return [round(math.sqrt(num)) for num in nums]",22
16175255690,sort_strings_by_length,"def sort_strings_by_length(strings):
    return sorted(strings, key=lambda x: (len(x), x))",22
3650745475,filter_bad_strings,"def filter_bad_strings(strings):
  return [string for string in strings if 'bad' not in string]",22
15183643588,sum_of_squares,"def sum_of_squares(nums):
    result = sum(i**2 for i in nums)
    return result",22
1161338777,common_elements,"def common_elements(list1, list2):
    return list(set(list1) & set(list2))",21
39116452797,count_Unique_Characters,"def count_Unique_Characters(s):
    unique_chars = set(s)
    return len(unique_chars)",21
71715022006,check_anagrams,"def check_anagrams(str1, str2):
    return sorted(str1) == sorted(str2)",21
17450917759,check_anagrams,"def check_anagrams(str1, str2):
    return sorted(str1) == sorted(str2)",21
22835432796,volume_cylinder,"import math
def volume_cylinder(radius, height):
    return math.pi * radius * radius * height",21
25943456941,square_roots,"import math

def square_roots(numbers):
    return [math.sqrt(num) for num in numbers]",21
74822061466,repeat_strings,"def repeat_strings(lst, times):
    return [i for i in lst for _ in range(times)]",21
26890590629,find_longest_string,"def find_longest_string(strings):
    longest_string = max(strings, key=len)
    return longest_string",21
37029707776,list_to_dict,"def list_to_dict(lst):
    return {lst[i]: i for i in range(len(lst))}",21
71740149783,kthSmallestElement,"def kthSmallestElement(arr, k):
    arr.sort()
    return arr[k-1]",21
22618601166,sum_of_naturals,"def sum_of_naturals(n):
    return n * (n + 1) // 2",21
21844364942,listIntersection,"def listIntersection(list1, list2):
    return list(set(list1) & set(list2))",21
21258506151,intersect_lists,"def intersect_lists(list1, list2):
    return list(set(list1) & set(list2))",21
70208634557,remove_element,"def remove_element(nums, val):
    while val in nums:
        nums.remove(val)
    return nums",21
29193140971,intersect_lists,"def intersect_lists(list1, list2):
    return list(set(list1) & set(list2))",21
39809240301,multiply_by_index,"def multiply_by_index(lst):
    return [i * lst[i] for i in range(len(lst))]",21
11401612333,findKthSmallest,"def findKthSmallest(array, k):
    array.sort()
    return array[k-1]",21
25885860379,replace_char,"def replace_char(s, old_char, new_char):
    return s.replace(old_char, new_char)",21
71204862780,circle_area,"import math
def circle_area(radius):
  area = math.pi * radius**2
  return area",21
31206875683,round_sqrt,"import math
def round_sqrt(lst):
    return [round(math.sqrt(num)) for num in lst]",21
36781117874,sum_three_largest_nums,"def sum_three_largest_nums(lst):
	return sum(sorted([x for x in lst])[-3:])",21
7332084648,findKthSmallest,"def findKthSmallest(arr, k):
    arr.sort()
    return arr[k-1]",21
19453996839,word_length_dict,"def word_length_dict(word_list):
    return {word: len(word) for word in word_list}",21
8590373262,multiply_by_index,"def multiply_by_index(lst):
    return [i * lst[i] for i in range(len(lst))]",21
20394781608,normalize,"def normalize(numbers):
    total = sum(numbers)
    return [num / total for num in numbers]",21
26281187610,are_anagrams,"def are_anagrams(str1, str2):
    return sorted(str1) == sorted(str2)",21
16372571012,find_kth_smallest,"def find_kth_smallest(arr, k):
    arr.sort()
    return arr[k-1]",21
4042756151,intersect_lists,"def intersect_lists(list1, list2):
    return list(set(list1) & set(list2))",21
72618049985,find_largest_k,"def find_largest_k(arr, k):
    arr.sort(reverse=True)
    return arr[:k]",21
18180518701,list_intersection,"def list_intersection(list1, list2):
    return list(set(list1) & set(list2))",21
37992955964,count_unique_characters,"def count_unique_characters(string1):
    unique_chars = set(string1)
    return len(unique_chars)",21
27122829820,find_intersection,"def find_intersection(list1, list2):
    return list(set(list1) & set(list2))",21
3642048416,is_anagram,"def is_anagram(str1, str2):
    return sorted(str1) == sorted(str2)",21
25058535125,intersection_lists,"def intersection_lists(list1, list2):
    return list(set(list1) & set(list2))",21
19059953457,number_and_square,"def number_and_square(numbers):
    return [(num, num ** 2) for num in numbers]",21
32033026939,intersect_lists,"def intersect_lists(list1, list2):
    return list(set(list1) & set(list2))",21
31651332229,list_to_number,"def list_to_number(nums):
    result = int(''.join(map(str, nums)))
    return result",21
25794333151,merge_dictionaries,"def merge_dictionaries(dic1, dic2):
    return {**dic1, **dic2}",21
9072873237,str_length_dict,"def str_length_dict(list1):
    return {i: len(i) for i in list1}",21
34940462131,multiply_by_index,"def multiply_by_index(lst):
    return [i * lst[i] for i in range(len(lst))]",21
32660660309,str_to_dict,"def str_to_dict(str_list):
    return {i: len(i) for i in str_list}",21
37133530225,list_intersection,"def list_intersection(list1, list2):
    return list(set(list1) & set(list2))",21
70034028547,sort_tuples,"def sort_tuples(lst):
    return sorted(lst, key=lambda x: x[1], reverse=True)",21
74901124275,remove_element,"def remove_element(nums, val):
    while val in nums:
        nums.remove(val)
    return nums",21
13825997508,create_dict,"def create_dict(keys, values):
  dict1 = dict(zip(keys, values))
  return dict1",21
27742677308,intersection_lists,"def intersection_lists(list1, list2):
    return list(set(list1) & set(list2))",21
14662088747,max_element_repetition,"def max_element_repetition(lst):
    max_val = max(lst)
    return lst.count(max_val)",21
40179578466,area_circle,"import math

def area_circle(radius):
  area = math.pi * radius**2
  return area",21
17450158954,letter_frequency,"from collections import Counter

def letter_frequency(string):
  freq = Counter(string)
  return dict(freq)",21
38953376100,unique_characters_count,"def unique_characters_count(input_string):
    unique_chars = set(input_string)
    return len(unique_chars)",21
30472344051,extract_urls,"import re

def extract_urls(text):
  return re.findall(r'https?://\S+', text)",21
22450486176,capitalize_first_letter,"def capitalize_first_letter(s):
    return s[0].upper() + s[1:].lower()",21
41129539343,reverse_tuple,"def reverse_tuple(test_tup):
  res = test_tup[::-1]
  return (res)",21
30496105869,swap_values,"def swap_values(a, b):
    a, b = b, a
    return a, b",21
34425359278,find_intersection,"def find_intersection(list1, list2):
    return list(set(list1) & set(list2))",21
40604048867,findKthSmallest,"def findKthSmallest(arr, k):
    arr.sort()
    return arr[k-1]",21
70854659322,find_kth_smallest,"def find_kth_smallest(arr, k):
    arr.sort()
    return arr[k-1]",21
44070085401,is_anagram,"def is_anagram(str1, str2):
    return sorted(str1) == sorted(str2)",21
20054268270,rotate_matrix,"def rotate_matrix(matrix):
    return [list(x)[::-1] for x in zip(*matrix)]",21
24746407049,sum_between,"def sum_between(m, n):
    return sum(range(min(m,n), max(m,n)+1))",21
70766275865,list_intersection,"def list_intersection(list1, list2):
    return list(set(list1) & set(list2))",21
32726778243,sphere_volume,"import math

def sphere_volume(radius):
    return 4/3 * math.pi * radius**3",21
8691166989,count_Unique,"def count_Unique(str): 
    unique_chars = set(str) 
    return len(unique_chars)",21
15733862618,check_anagram,"def check_anagram(str1, str2):
    return sorted(str1) == sorted(str2)",21
35676355695,common_elements,"def common_elements(list1, list2):
    return list(set(list1) & set(list2))",21
73504031192,list_intersection,"def list_intersection(nums1, nums2):
    return list(set(nums1) & set(nums2))",21
73112078069,remove_occurrences,"def remove_occurrences(lst, value):
    return [x for x in lst if x != value]",21
74579980512,listIntersection,"def listIntersection(list1, list2):
    return list(set(list1) & set(list2))",21
9439138871,unique_chars,"from collections import Counter

def unique_chars(s):
    types = Counter(s)
    return len(types)",21
33186320429,intersection_lists,"def intersection_lists(list1, list2):
    return list(set(list1) & set(list2))",21
10248302988,string_length_counter,"def string_length_counter(str_list):
  return [(s, len(s)) for s in str_list]",21
33104443939,str_length_dict,"def str_length_dict(str_list):
    return {string: len(string) for string in str_list}",21
4076218706,positive_sum,"def positive_sum(list_nums):
    return sum(num for num in list_nums if num > 0)",21
29375443153,convert_to_dict,"def convert_to_dict(list1):
    return {i: len(i) for i in list1}",21
72912203410,find_common,"def find_common(list1, list2):
    return list(set(list1) & set(list2))",21
9164725159,check_list_elements,"def check_list_elements(test_list, element):
    return all(x == element for x in test_list)",21
44716574631,str_length_dict,"def str_length_dict(str_list):
    return {word: len(word) for word in str_list}",21
36403157693,reverse_sublists,"def reverse_sublists(list1):
    return [sublist[::-1] for sublist in list1]",21
71321200317,reverse_digits,"def reverse_digits(number):
    return [int(digit) for digit in str(number)][::-1]",21
33078329487,find_kth_smallest,"def find_kth_smallest(nums, k):
    nums.sort()
    return nums[k-1]",21
26440444385,sum_of_natural_numbers,"def sum_of_natural_numbers(n):
    return n * (n + 1) // 2",21
30143401268,remove_value,"def remove_value(lst, value):
    return [x for x in lst if x != value]",20
13405278899,sum_natural_numbers,"def sum_natural_numbers(n):
    return n * (n + 1) // 2",20
3366428608,remove_negatives,"def remove_negatives(nums):
    return [num for num in nums if num >= 0]",20
20643262509,remove_target,"def remove_target(nums,target):
    while target in nums:
        nums.remove(target)
    return nums",20
5384805455,remove_value,"def remove_value(lst, value):
    return [x for x in lst if x != value]",20
634546363,find_Longest_String,"def find_Longest_String(arr,n):
    longest = max(arr, key=len)
    return longest",20
13954558376,max_of_three,"def max_of_three(a, b, c):
    return max(a, max(b, c))",20
26214174140,reverse_array,"def reverse_array(arr):
    return [s[::-1] for s in arr][::-1]",20
17204067840,find_mode,"def find_mode(lst):
    mode = max(set(lst), key=lst.count)
    return mode",20
27173747137,max_of_three,"def max_of_three(a, b, c):
  return max(a, max(b, c))",20
2185986009,findKthLargest,"def findKthLargest(nums, k):
    nums.sort()
    return nums[-k]",20
43825528253,remove_element,"def remove_element(arr, val):
    return [x for x in arr if x != val]",20
671469157,tupleSort,"def tupleSort(tuples):
    return sorted(tuples, key=lambda x: x[1])",20
30658156628,remove_value,"def remove_value(lst, value):
    return [x for x in lst if x != value]",20
40384279049,is_palindrome_lowercase,"def is_palindrome_lowercase(s):
    return s == s[::-1] and s.islower()",20
36086730903,find_kth_largest,"def find_kth_largest(nums, k):
    nums.sort()
    return nums[-k]",20
73184949428,merge_and_sort_lists,"def merge_and_sort_lists(list1, list2):
    return sorted(list1 + list2)",20
39993251679,sort_strings,"def sort_strings(strings):
    return sorted(strings, key=lambda x: (-len(x), x))",20
25943263261,kth_smallest,"def kth_smallest(arr, k):
    arr.sort()
    return arr[k-1]",20
21545106983,kth_smallest,"def kth_smallest(arr, k):
    arr.sort()
    return arr[k-1]",20
10242637567,remove_value,"def remove_value(lst, value):
    return [x for x in lst if x != value]",20
7358712649,intersect,"def intersect(list1, list2):
    return list(set(list1) & set(list2))",20
36427259149,intersection,"def intersection(list1, list2):
    return list(set(list1) & set(list2))",20
70752392985,intersection,"def intersection(list1, list2):
    return list(set(list1) & set(list2))",20
15346851694,check_anagrams,"def check_anagrams(str1,str2):
    return sorted(str1) == sorted(str2)",20
26283466268,unique_characters,"def unique_characters(str1):
    unique_chars = set(str1)
    return len(unique_chars)",20
19633612144,sum_natural_numbers,"def sum_natural_numbers(n):
    return n * (n + 1) // 2",20
12185666007,intersection,"def intersection(list1, list2):
    return list(set(list1) & set(list2))",20
4066159952,list_to_string,"def list_to_string(list1):
  str1 = ''.join(list1)
  return str1",20
72441824752,multiply_by_two,"def multiply_by_two(input_list):
    return [element * 2 for element in input_list]",20
24062858427,find_max_of_three,"def find_max_of_three(a, b, c):
    return max(a, b, c)",20
16358267153,remove_elements,"def remove_elements(lst, element):
    return [x for x in lst if x != element]",20
3562771476,remove_value,"def remove_value(lst, value):
    return [x for x in lst if x != value]",20
16596200245,is_anagram,"def is_anagram(str1,str2):
    return sorted(str1) == sorted(str2)",20
41765828682,max_of_three,"def max_of_three(x, y, z): 
    return max(x, y, z)",20
74592492867,flatten_list,"def flatten_list(mylist):
    return [element for sublist in mylist for element in sublist]",20
8954138380,max_of_three,"def max_of_three(a, b, c):
    return max(a, max(b, c))",20
39091559891,check_perfect_square,"import math
def check_perfect_square(n):
    return math.isqrt(n)**2 == n",20
20205435777,find_max_of_three,"def find_max_of_three(a, b, c):
  return max(a, b, c)",20
12708843313,remove_nth_char,"def remove_nth_char(s, n):
    return s[:n] + s[n+1:]",20
12372313444,find_largest,"def find_largest(lst):
    if not lst:
        return None
    return max(lst)",20
29820465993,max_of_three,"def max_of_three(a, b, c):
    return max(a, max(b, c))",20
17461061759,is_mirror_image,"def is_mirror_image(lst1, lst2):
    return lst1 == lst2[::-1]",20
11994700308,intersect_elements,"def intersect_elements(list1, list2):
    return set(list1) & set(list2)",20
73699400087,max_of_three,"def max_of_three(a, b, c):
    return max(a, max(b, c))",20
6545672334,str_list_to_dict,"def str_list_to_dict(lst):
    return {s: len(s) for s in lst}",20
73083353756,sort_strings_lexicographically,"def sort_strings_lexicographically(strings):
    return sorted(strings, key=lambda s: s.lower())",20
21925326669,sum_even,"def sum_even(arr):
    return sum(i for i in arr if i%2==0)",20
34627400167,rotate_matrix,"def rotate_matrix(mat):
    return [list(x) for x in zip(*mat[::-1])]",20
35064414338,max_sum,"def max_sum(arr):
    arr.sort()
    return arr[-1] + arr[-2]",20
1151859556,tuple_list,"def tuple_list(numbers):
    return [(number, number ** 2) for number in numbers]",20
32420520751,find_max_index,"def find_max_index(nums):
  max_val = max(nums)
  return nums.index(max_val)",20
8494036973,sort_descending,"def sort_descending(list_of_integers):
    return sorted(list_of_integers, reverse=True)",20
43149435824,round_floats,"def round_floats(float_strings):
    return [round(float(num)) for num in float_strings]",20
20781465,sort_tuples,"def sort_tuples(tup):
    return sorted(tup, key=lambda x: x[1])",20
46511277642,remove_value,"def remove_value(lst, value):
    return [x for x in lst if x != value]",20
42604288264,circle_circumference,"import math

def circle_circumference(radius):
    return 2 * math.pi * radius",20
70550254738,min_element,"def min_element(test_list):
    return min(test_list, key=lambda x: x[1])",20
17343314063,nthMax,"def nthMax(lst, n):
    lst.sort(reverse=True)
    return lst[n-1]",20
74511631063,count_uppercase,"def count_uppercase(string):
    return sum(1 for c in string if c.isupper())",20
26499006437,kthSmallest,"def kthSmallest(arr, k):
    arr.sort()
    return arr[k-1]",20
39031213339,remove_element,"def remove_element(lst, element):
    return [i for i in lst if i != element]",20
23918401469,triangular_number,"def triangular_number(n):
    return int(n * (n + 1) / 2)",20
37421621183,sqrt_list,"import math

def sqrt_list(nums):
    return [math.sqrt(num) for num in nums]",20
28476702441,square_root,"import math
def square_root(lst):
    return [math.sqrt(i) for i in lst]",20
30089305024,multiply_by_index,"def multiply_by_index(lst):
    return [i * n for i, n in enumerate(lst)]",20
28829313366,find_max_of_three,"def find_max_of_three(a, b, c):
    return max(a, b, c)",20
40157731087,concatenate_numbers,"def concatenate_numbers(numbers):
    result = int("""".join(map(str, numbers)))
    return result",20
8152170181,count_unique_characters,"def count_unique_characters(s):
    unique_chars = set(s.lower())
    return len(unique_chars)",20
24957566092,compare_strings,"def compare_strings(a,b):
    if a+b>b+a:
        return a
    return b",20
43116581467,unique_characters,"def unique_characters(str1):
    unique_chars = set(str1)
    return len(unique_chars)",20
20374076307,count_unique_strings,"def count_unique_strings(lst):
    unique_strings = set(lst)
    return len(unique_strings)",19
40026071953,str_len_dict,"def str_len_dict(lst):
    return {x: len(x) for x in lst}",19
35714909285,nth_hexagonal,"def nth_hexagonal(n): 
    return n * (2 * n - 1)",19
25827410276,kth_largest,"def kth_largest(nums, k):
    nums.sort()
    return nums[-k]",19
41581699092,circle_area,"import math

def circle_area(radius):
    return math.pi * (radius ** 2)",19
11249681285,unique_char_count,"def unique_char_count(s):
    unique_chars = set(s)
    return len(unique_chars)",19
7804869116,string_length_dict,"def string_length_dict(lst):
    return {word: len(word) for word in lst}",19
22689749647,string_length_dict,"def string_length_dict(lst):
    return {i: len(i) for i in lst}",19
12321562645,square_tuples,"def square_tuples(nums):
    return [(num, num**2) for num in nums]",19
28402681409,sum_of_cubes,"def sum_of_cubes(n):
    return (n*(n+1)/2)**2",19
2398558984,unique_char_count,"def unique_char_count(string):
    unique_chars = set(string)
    return len(unique_chars)",19
28361837954,count_unique_characters,"def count_unique_characters(s):
    unique_chars = set(s)
    return len(unique_chars)",19
37334691789,sum_list_elements,"def sum_list_elements(li, start, end):
    return sum(li[start:end+1])",19
698237758,str_len_dict,"def str_len_dict(lst):
    return {word: len(word) for word in lst}",19
21289343117,square_dict,"def square_dict(lst): 
    return {x: x**2 for x in lst}",19
3139233851,string_length_dict,"def string_length_dict(lst):
    return {word: len(word) for word in lst}",19
70452262932,sum_of_squares,"def sum_of_squares(numbers):
    return sum(x ** 2 for x in numbers)",19
32240316877,char_to_ascii,"def char_to_ascii(string):
    return {char: ord(char) for char in string}",19
41957289431,largest_of_three,"def largest_of_three(a, b, c):
    return max(a, b, c)",19
70738912144,string_frequency,"def string_frequency(lst):
    return {i: lst.count(i) for i in lst}",19
11015176676,count_unique_characters,"def count_unique_characters(s):
    unique_chars = set(s)
    return len(unique_chars)",19
38962995556,string_length_dict,"def string_length_dict(lst):
    return {word: len(word) for word in lst}",19
365703485,count_unique_chars,"def count_unique_chars(str):
    unique_chars = set(str)
    return len(unique_chars)",19
41245626345,square_tuples,"def square_tuples(numbers):
    return [(num, num**2) for num in numbers]",19
25629016346,count_unique_characters,"def count_unique_characters(str):
  unique_chars = set(str)
  return len(unique_chars)",19
28740482231,sum_of_digits,"def sum_of_digits(number):
    return sum(int(digit) for digit in str(number))",19
35069078628,string_to_dict,"def string_to_dict(lst):
    return {s: len(s) for s in lst}",19
44155216466,multiply_by_3,"def multiply_by_3(nums):
    return [x * 3 for x in nums]",19
14440364276,square_and_sort,"def square_and_sort(arr):
    return sorted([i ** 2 for i in arr])",19
33697144790,strings_to_dict,"def strings_to_dict(strings):
    return {string: len(string) for string in strings}",19
4837201945,maximum_of_three,"def maximum_of_three(a, b, c):
    return max(a, b, c)",19
37064126029,sorted_squares,"def sorted_squares(nums):
    return sorted([i ** 2 for i in nums])",19
7337289917,str_len_dict,"def str_len_dict(lst):
    return {i: len(i) for i in lst}",19
74567460302,case_insensitive_sort,"def case_insensitive_sort(strings):
    return sorted(strings, key=lambda x: x.lower())",19
70452271572,unique_char_count,"def unique_char_count(s):
    unique_chars = set(s)
    return len(unique_chars)",19
23600450359,max_of_three,"def max_of_three(a, b, c):
    return max(a, b, c)",19
14091703410,string_length_dict,"def string_length_dict(strings):
    return {string: len(string) for string in strings}",19
21290529407,kth_largest,"def kth_largest(nums, k):
    nums.sort()
    return nums[-k]",19
36749631323,distinct_characters,"def distinct_characters(s):
    distinct_chars = set(s)
    return len(distinct_chars)",19
40264111839,count_unique_characters,"def count_unique_characters(s):
    unique_chars = set(s)
    return len(unique_chars)",19
24504940791,matrix_transpose,"def matrix_transpose(matrix):
    return [list(i) for i in zip(*matrix)]",19
34053824541,max_number,"def max_number(numbers):
    if not numbers:
        return None
    return max(numbers)",19
30001841935,max_unique_chars,"def max_unique_chars(lst):
    return max(lst, key=lambda x: len(set(x)))",19
39228121408,unique_char_count,"def unique_char_count(s):
    unique_chars = set(s)
    return len(unique_chars)",19
27843650192,string_length_dict,"def string_length_dict(lst):
    return {i: len(i) for i in lst}",19
42601864723,reverse_sublists,"def reverse_sublists(matrix):
    return [sublist[::-1] for sublist in matrix]",19
74666378980,str_len_dict,"def str_len_dict(lst):
    return {word: len(word) for word in lst}",19
32437669381,mergeTwoLists,"def mergeTwoLists(l1, l2):
    return sorted(l1 + l2)",19
31279792400,centered_hexagonal,"def centered_hexagonal(n):
    return 3*n*n - 3*n + 1",19
30783246802,convert_to_binary,"def convert_to_binary(nums):
    return [bin(num)[2:] for num in nums]",19
40641262330,count_unique_characters,"def count_unique_characters(str):
    unique_chars = set(str)
    return len(unique_chars)",19
25992247131,format_date,"import datetime

def format_date(date):
    return date.strftime('%d/%m/%Y')",19
4151771712,unique_character_count,"def unique_character_count(s):
    unique_chars = set(s)
    return len(unique_chars)",19
35479812753,string_length_dict,"def string_length_dict(lst):
    return {s: len(s) for s in lst}",19
17740410186,kth_largest,"def kth_largest(nums, k):
    nums.sort()
    return nums[-k]",19
36523652607,count_unique_chars,"def count_unique_chars(s):
    unique_chars = set(s)
    return len(unique_chars)",19
5932765169,remove_zeros,"def remove_zeros(nums):
    return [n for n in nums if n != 0]",19
72462192628,k_smallest,"def k_smallest(l, k):
    l.sort()
    return l[k-1]",19
25786175203,count_unique_chars,"def count_unique_chars(s):
    unique_chars = set(s)
    return len(unique_chars)",19
14257363563,count_unique_characters,"def count_unique_characters(s):
    unique_chars = set(s)
    return len(unique_chars)",19
42015323012,find_substring,"def find_substring(string, substring):
    index = string.find(substring)
    return index",19
6251601856,int_to_binary,"def int_to_binary(nums):
    return [bin(num)[2:] for num in nums]",19
33606670647,sum_of_elements,"def sum_of_elements(arr, l, r):
    return sum(arr[l:r+1])",19
12283413118,int_to_digit_list,"def int_to_digit_list(n):
    return [int(d) for d in str(n)]",19
17378689946,sort_dicts,"def sort_dicts(lst, key):
    return sorted(lst, key=lambda x: x[key])",19
893855581,kth_largest,"def kth_largest(nums, k):
    nums.sort()
    return nums[-k]",19
11233541042,count_unique_chars,"def count_unique_chars(s):
    unique_chars = set(s)
    return len(unique_chars)",19
42302651032,count_unique_chars,"def count_unique_chars(s):
    unique_chars = set(s)
    return len(unique_chars)",19
73589181145,indexify,"def indexify(arr):
    return {i: v for i, v in enumerate(arr)}",19
24877710684,count_unique_chars,"def count_unique_chars(s):
    unique_chars = set(s)
    return len(unique_chars)",19
26382388630,string_length_dict,"def string_length_dict(lst):
    return {word: len(word) for word in lst}",19
36842660018,unique_permutations,"from itertools import permutations

def unique_permutations(nums):
    return len(set(permutations(nums)))",19
2227972037,list_of_lengths,"def list_of_lengths(string_list):
    return [len(i) for i in string_list]",19
8760041327,word_length_dictionary,"def word_length_dictionary(words):
    return {word: len(word) for word in words}",19
38615458909,largest_word,"def largest_word(sentence):
    words = sentence.split()
    return max(words, key=len)",19
36844115308,sum_digits,"def sum_digits(number):
    return sum(int(digit) for digit in str(abs(number)))",19
6963584238,string_to_dict,"def string_to_dict(lst):
    return {s: len(s) for s in lst}",19
31460957889,unique_char_count,"def unique_char_count(s):
    unique_chars = set(s)
    return len(unique_chars)",19
38902257501,merge_lists,"def merge_lists(list1, list2):
    return list(zip(list1, list2))",19
9855304006,transpose_matrix,"def transpose_matrix(matrix):
    return [list(i) for i in zip(*matrix)]",18
41232654540,string_lengths,"def string_lengths(lst):
    return {word: len(word) for word in lst}",18
30156910330,list_to_string,"def list_to_string(lst):
    str1 = ''.join(lst)
    return str1",18
14750853773,sum_of_squares,"def sum_of_squares(numbers):
    return sum(x**2 for x in numbers)",18
23997547700,string_lengths,"def string_lengths(words):
    return {word: len(word) for word in words}",18
38006232155,unique_characters,"def unique_characters(s):
  unique_chars = set(s)
  return len(unique_chars)",18
37660563961,calculate_triangle_area,"def calculate_triangle_area(base, height):
    return (base * height) / 2",18
21526013280,symmetric_difference,"def symmetric_difference(set1, set2):
    return set1.symmetric_difference(set2)",18
23455750515,reverse_sentence_list,"def reverse_sentence_list(s):
    words = s.split()
    return words[::-1]",18
3142484254,string_lengths,"def string_lengths(strings):
    return {string: len(string) for string in strings}",18
11603573271,transpose_matrix,"def transpose_matrix(matrix):
    return [list(i) for i in zip(*matrix)]",18
71057593966,count_unique,"def count_unique(lst):
    unique_elements = set(lst)
    return len(unique_elements)",18
39730417842,string_lengths,"def string_lengths(lst):
    return {word: len(word) for word in lst}",18
21602722372,word_length,"def word_length(words):
    return {word: len(word) for word in words}",18
40361242583,digit_sum,"def digit_sum(n):
    return sum(int(digit) for digit in str(n))",18
10588012747,hexagonal_num,"def hexagonal_num(n):
    return n * (2 * n - 1)",18
72519209394,symmetric_difference,"def symmetric_difference(set1, set2):
    return set1.symmetric_difference(set2)",18
41052368822,str_list_to_float_list,"def str_list_to_float_list(str_list):
    return list(map(float, str_list))",18
11516326916,str_length,"def str_length(strings):
    return {string: len(string) for string in strings}",18
32087480830,string_length,"def string_length(lst):
    return {word: len(word) for word in lst}",18
32902757800,unique_characters,"def unique_characters(s):
    unique_chars = set(s)
    return len(unique_chars)",18
45144264578,repeat_chars,"def repeat_chars(s):
    return ''.join([c*2 for c in s])",18
15337668829,largest_number,"def largest_number(n):
    return int("""".join(sorted(str(n), reverse=True)))",18
18733010338,flatten_array,"def flatten_array(arr):
    return [item for sublist in arr for item in sublist]",18
41172717620,find_most_common_element,"def find_most_common_element(lst):
    return max(set(lst), key=lst.count)",18
36626726880,digit_sum,"def digit_sum(num):
    return sum(int(digit) for digit in str(num))",18
71749824979,transpose_matrix,"def transpose_matrix(matrix):
    return [list(i) for i in zip(*matrix)]",18
72257251946,digit_sum,"def digit_sum(n):
    return sum(int(digit) for digit in str(n))",18
12558241722,unique_sum,"def unique_sum(nums):
    unique_nums = set(nums)
    return sum(unique_nums)",18
37808545304,nth_largest,"def nth_largest(lst, n):
    lst.sort()
    return lst[-n]",18
17004658217,sum_digits,"def sum_digits(n):
    return sum(int(digit) for digit in str(n))",18
7834244000,sort_and_lowercase,"def sort_and_lowercase(words):
    return sorted([word.lower() for word in words])",18
71358968530,unique_characters,"def unique_characters(s):
    unique_chars = set(s)
    return len(unique_chars)",18
42868120642,string_lengths,"def string_lengths(lst):
    return {s: len(s) for s in lst}",18
10193702950,cartesian_product,"from itertools import product

def cartesian_product(sets):
    return list(product(*sets))",18
17502972704,string_length,"def string_length(lst):
    return {s: len(s) for s in lst}",18
29795796226,string_lengths,"def string_lengths(strings):
    return {string: len(string) for string in strings}",18
74864915731,word_length,"def word_length(words):
    return {word: len(word) for word in words}",18
17490103813,square_dict,"def square_dict(lst):
    return {i: i**2 for i in lst}",18
30075114539,average_list,"def average_list(nums):
  return sum([i for i in nums])/len(nums)",18
18692902614,triangular_number,"def triangular_number(n):
	return (n * (n + 1)) // 2",18
42061257022,word_length,"def word_length(words):
    return {word: len(word) for word in words}",18
9993783184,rotate_list_left,"def rotate_list_left(lst, n):
    return lst[n:] + lst[:n]",18
11072726473,num_to_square,"def num_to_square(nums):
    return {num: num*num for num in nums}",18
14921441692,length_dict,"def length_dict(lst):
    return {word: len(word) for word in lst}",18
8873151730,duplicate_characters,"def duplicate_characters(s):
    return ''.join([c*2 for c in s])",18
5287840997,hexagonal_number,"def hexagonal_number(n):
    return n * (2 * n - 1)",18
32698128754,flip_matrix,"def flip_matrix(matrix):
    return [list(x) for x in zip(*matrix)]",18
73087815105,remove_last_char,"def remove_last_char(lst):
    return [s[:-1] for s in lst]",18
10005843665,sort_strings_by_length,"def sort_strings_by_length(strings):
    return sorted(strings, key=len, reverse=True)",18
38321858135,calc_triangle_area,"def calc_triangle_area(base, height):
    return 0.5 * base * height",18
38268521952,to_binary,"def to_binary(nums):
    return [bin(num)[2:] for num in nums]",18
14171712508,transpose_matrix,"def transpose_matrix(matrix):
    return [list(i) for i in zip(*matrix)]",18
37844076552,k_smallest,"def k_smallest(numbers, k):
    numbers.sort()
    return numbers[:k]",18
14851624664,extract_elements,"def extract_elements(lst, indices):
    return [lst[i] for i in indices]",18
32269820899,hexagonal_number,"def hexagonal_number(n):
    return n * (2 * n - 1)",18
34069136022,square_elements,"def square_elements(input_list):
    return [x**2 for x in input_list]",18
40966078345,largest_number,"def largest_number(a, b, c):
    return max(a, b, c)",18
14328503141,count_unique,"def count_unique(lst):
    unique_elements = set(lst)
    return len(unique_elements)",18
13216348037,is_hexagonal,"def is_hexagonal(n):
    return n * (2 * n - 1)",18
42622012778,word_lengths,"def word_lengths(words):
    return {word: len(word) for word in words}",18
13626311785,largest_number,"def largest_number(n):
    return int("""".join(sorted(str(n), reverse=True)))",18
31837087716,multiply_by_three,"def multiply_by_three(numbers):
    return [number * 3 for number in numbers]",18
288521821,sum_digit,"def sum_digit(num):
  return sum(int(digit) for digit in str(num))",18
26719179405,digit_sum,"def digit_sum(num):
    return sum(int(digit) for digit in str(num))",18
36978779479,symmetric_difference,"def symmetric_difference(set1, set2):
    return set1.symmetric_difference(set2)",18
17367534990,find_hex_num,"def find_hex_num(n):
  return n * (2 * n - 1)",18
10294614717,string_lengths,"def string_lengths(strings):
    return {string: len(string) for string in strings}",18
8712162123,sort_tuples,"def sort_tuples(lst):
    return sorted(lst, key=lambda x: x[1])",18
33520201148,max_number,"def max_number(n):
    return int("""".join(sorted(str(n), reverse=True)))",18
30343046737,lowercase_filter,"def lowercase_filter(words):
    return [word for word in words if word.islower()]",18
37530539578,string_lengths,"def string_lengths(lst):
    return {word: len(word) for word in lst}",18
40697818669,square_root_ceiling,"import math
def square_root_ceiling(n):
    return math.ceil(math.sqrt(n))",18
4587260578,sum_of_squares,"def sum_of_squares(nums):
    return sum(x**2 for x in nums)",18
1959678611,largestNum,"def largestNum(n):
    return int("""".join(sorted(str(n), reverse=True)))",18
38720259336,count_unique,"def count_unique(lst):
    unique_elements = set(lst)
    return len(unique_elements)",18
23777195383,count_unique,"def count_unique(nums):
    unique_elements = set(nums)
    return len(unique_elements)",18
552839221,word_lengths,"def word_lengths(words):
    return {word: len(word) for word in words}",18
4674761142,sum_digits,"def sum_digits(number):
    return sum(int(digit) for digit in str(number))",18
70223444477,string_length,"def string_length(strings):
    return {string: len(string) for string in strings}",18
32721733889,string_length,"def string_length(lst):
    return {i: len(i) for i in lst}",18
29669703041,count_unique,"def count_unique(lst):
    unique_elements = set(lst)
    return len(unique_elements)",18
40352492055,convert_list_to_number,"def convert_list_to_number(lst):
    return int(''.join(map(str, lst)))",18
23661431874,string_length,"def string_length(strings):
    return {string: len(string) for string in strings}",18
19980498290,transpose_matrix,"def transpose_matrix(matrix):
    return [list(i) for i in zip(*matrix)]",18
6523646544,is_palindrome_sequence,"def is_palindrome_sequence(strings_list):
    return strings_list == strings_list[::-1]",18
28128790744,intersection_set,"def intersection_set(set1, set2):
    return set1.intersection(set2)",17
74541428,find_shortest_word,"def find_shortest_word(word_list):
    return min(word_list, key=len)",17
36308239969,square_elements,"def square_elements(numbers):
    return [num ** 2 for num in numbers]",17
1131982568,reverse_strings,"def reverse_strings(strings):
    return [string[::-1] for string in strings]",17
26719190165,multiply_list,"def multiply_list(lst):
    return [i * 2 for i in lst]",17
26224117287,most_frequent,"def most_frequent(lst):
    return max(set(lst), key=lst.count)",17
3579853496,abs_sorted,"def abs_sorted(lst):
    return sorted([abs(i) for i in lst])",17
1213011322,longest_word_length,"def longest_word_length(words):
    return max(len(word) for word in words)",17
30481302583,calculate_circle_area,"import math

def calculate_circle_area(radius):
    return math.pi * radius * radius",17
73589233305,num_to_bin,"def num_to_bin(num):
  return bin(num).replace(""0b"", """")",17
39376695818,find_most_common,"def find_most_common(lst):
    return max(set(lst), key=lst.count)",17
11441318703,reverse_strings,"def reverse_strings(strings):
    return [s[::-1] for s in strings]",17
20528000703,count_duplicates,"from collections import Counter

def count_duplicates(lst):
    return dict(Counter(lst))",17
20374458287,double_list,"def double_list(nums):
    return [num * 2 for num in nums]",17
3623318227,triangle_area,"def triangle_area(base, height):
    return 0.5 * base * height",17
39462762172,triangle_area,"def triangle_area(base, height):
  return 0.5 * base * height",17
29407885570,to_title_case,"def to_title_case(words):
    return [word.capitalize() for word in words]",17
20100877080,square_sum,"def square_sum(numbers):
    return sum(x ** 2 for x in numbers)",17
40942786809,transpose,"def transpose(matrix):
    return [list(i) for i in zip(*matrix)]",17
31268637366,square_list,"def square_list(nums):
    return [num ** 2 for num in nums]",17
21480691404,sum_of_numbers,"def sum_of_numbers(n):
    return sum(range(1, n+1))",17
17412007734,reverse_strings,"def reverse_strings(strings):
    return [s[::-1] for s in strings]",17
15304713075,square_list,"def square_list(nums):
    return [num ** 2 for num in nums]",17
23777653807,double_list,"def double_list(nums):
    return [num * 2 for num in nums]",17
37382175225,square_list,"def square_list(lst):
    return [i ** 2 for i in lst]",17
14704209231,join_characters_with_separator,"def join_characters_with_separator(char_list, separator):
  return separator.join(char_list)",17
1803410261,square_list,"def square_list(nums):
    return [num ** 2 for num in nums]",17
70245942249,sort_by_length,"def sort_by_length(strings):
    return sorted(strings, key=len, reverse=True)",17
42814352922,join_strings_with_separator,"def join_strings_with_separator(strings_list, separator):
    return separator.join(strings_list)",17
26427647696,triangle_perimeter,"def triangle_perimeter(a, b, c):
  return a + b + c",17
10711045707,square_array,"def square_array(nums):
    return [num ** 2 for num in nums]",17
41699231738,reverse_strings,"def reverse_strings(strings):
    return [s[::-1] for s in strings]",17
42629226127,square_list,"def square_list(numbers):
    return [number ** 2 for number in numbers]",17
27746613495,convertOne,"def convertOne(N):
    return str(N).replace('0', '1')",17
72955778034,cube_list,"def cube_list(numbers):
    return [num ** 3 for num in numbers]",17
11974479363,reverse_strings,"def reverse_strings(lst):
    return [s[::-1] for s in lst]",17
11551626886,is_in_range,"def is_in_range(num, low, high):
    return low <= num <= high",17
11604718143,sum_largest_smallest,"def sum_largest_smallest(lst):
    return max(lst) + min(lst)",17
42110875288,count_frequency,"from collections import Counter

def count_frequency(lst):
    return dict(Counter(lst))",17
16169396734,square_elements,"def square_elements(numbers):
    return [num ** 2 for num in numbers]",17
19476000789,calculate_circle_area,"import math

def calculate_circle_area(radius):
    return math.pi * radius * radius",17
23484396467,transpose,"def transpose(matrix):
    return [list(i) for i in zip(*matrix)]",17
73487638428,string_to_ascii,"def string_to_ascii(s):
    return [ord(c) for c in s]",17
5275387277,count_num_occurrence,"def count_num_occurrence(list_nums, num):
    return list_nums.count(num)",17
42123706287,square_list,"def square_list(nums):
    return [num ** 2 for num in nums]",17
39078045109,calculate_circle_area,"import math

def calculate_circle_area(radius):
    return math.pi * radius * radius",17
34091408229,dec_to_bin,"def dec_to_bin(n):
  return bin(n).replace(""0b"","""")",17
18626042532,count_frequency,"from collections import Counter

def count_frequency(lst):
    return dict(Counter(lst))",17
28541062244,replace_a_with_b,"def replace_a_with_b(s):
  return s.replace('a', 'b')",17
42602902790,square_list,"def square_list(nums):
    return [num ** 2 for num in nums]",17
2240031168,square_elements,"def square_elements(arr):
  return [i ** 2 for i in arr]",17
34527972626,replace_substring,"def replace_substring(s,old,new): 
    return s.replace(old,new)",17
13129059374,longest_word_length,"def longest_word_length(words):
    return max(len(word) for word in words)",17
7190489458,count_digit,"def count_digit(number, digit):
    return str(number).count(str(digit))",17
40351953758,reverse_strings,"def reverse_strings(lst):
    return [s[::-1] for s in lst]",17
5222607789,multiply_list,"def multiply_list(lst, num):
    return [i*num for i in lst]",17
18166693694,str_to_upper,"def str_to_upper(lst):
    return [i.upper() for i in lst]",17
22573588917,cube_elements,"def cube_elements(numbers):
    return [num ** 3 for num in numbers]",17
514157125,area_triangle,"def area_triangle(base, height):
    return 0.5 * base * height",17
1605981671,longest_word_length,"def longest_word_length(words):
    return max(len(word) for word in words)",17
29773415848,longest_word_length,"def longest_word_length(words):
    return max(len(word) for word in words)",17
26740125070,area_triangle,"def area_triangle(base, height):
    return 0.5 * base * height",17
38750654460,substring_count,"def substring_count(string, substring):
    return string.lower().count(substring.lower())",17
32279616255,check_sorted_unique,"def check_sorted_unique(test_list):
    return test_list == sorted(set(test_list))",17
73013550180,area_of_circle,"import math

def area_of_circle(radius):
    return math.pi * radius * radius",17
22634863311,reverse_strings,"def reverse_strings(lst):
    return [s[::-1] for s in lst]",17
35010450209,int_to_binary,"def int_to_binary(n):
    return bin(n).replace(""0b"","""")",17
25255135696,class_average,"def class_average(grades):
    return sum(grades) / len(grades)",17
5193484401,calculate_distance,"def calculate_distance(speed, time):
  distance = speed * time
  return distance",17
4239764849,count_words,"def count_words(sentence):
    words = sentence.split()
    return len(words)",16
73142230191,circle_area,"import math

def circle_area(radius):
    return math.pi * radius**2",16
74281140824,string_to_list,"def string_to_list(s):
    words = s.split(' ')
    return words",16
20611829589,find_k_smallest,"def find_k_smallest(lst, k):
    return sorted(lst)[:k]",16
38960937221,count_words,"def count_words(sentence):
    words = sentence.split()
    return len(words)",16
72980832665,round_list,"def round_list(numbers):
    return [round(num) for num in numbers]",16
6589336955,count_words,"def count_words(sentence):
    words = sentence.split()
    return len(words)",16
72817486997,set_intersection,"def set_intersection(set1,set2):
  return set1.intersection(set2)",16
24678675987,has_unique_chars,"def has_unique_chars(s):
    return len(s) == len(set(s))",16
36716433919,round_list,"def round_list(lst):
    return [round(i) for i in lst]",16
72394146687,count_words,"def count_words(sentence):
    words = sentence.split()
    return len(words)",16
71969624447,count_words,"def count_words(sentence):
    words = sentence.split()
    return len(words)",16
17675562000,symmetric_difference,"def symmetric_difference(set1, set2):
    return set1 ^ set2",16
17461050999,cube_list,"def cube_list(lst):
    return [i**3 for i in lst]",16
33813202215,frequent_element,"def frequent_element(lst):
    return max(set(lst), key = lst.count)",16
11468840958,is_Palindrome,"def is_Palindrome(s):  
    return s == s[::-1]",16
34602184401,merge_lists,"def merge_lists(list1, list2):
    return list1 + list2",16
15466141716,cube_list,"def cube_list(nums):
    return [num**3 for num in nums]",16
10792904611,reverseWords,"def reverseWords(s):
    return ' '.join(s.split()[::-1])",16
12455793049,cube_list,"def cube_list(nums):
    return [x**3 for x in nums]",16
32981701537,unique_chars,"def unique_chars(s):
    unique = set(s)
    return len(unique)",16
17479320162,square_list,"def square_list(lst):
    return [x**2 for x in lst]",16
18588224411,count_words,"def count_words(sentence):
    words = sentence.split()
    return len(words)",16
75157621331,circle_area,"import math

def circle_area(r):
  return math.pi * r * r",16
12305072257,string_lengths,"def string_lengths(lst):
    return [len(x) for x in lst]",16
26667307816,largest_fibonacci,"def largest_fibonacci(fib_list):
    return max(fib_list)",16
44151423566,word_length,"def word_length(words):
    return [len(word) for word in words]",16
8956374761,double_elements,"def double_elements(nums):
    return [x*2 for x in nums]",16
70716783222,circle_area,"import math

def circle_area(radius):
    return math.pi * radius * radius",16
32864763814,find_longest,"def find_longest(str_list):
  return max(str_list, key=len)",16
72071756745,round_list,"def round_list(lst):
    return [round(num) for num in lst]",16
19326407748,find_max_min,"def find_max_min(input): 
  return (max(input),min(input))",16
73782798611,square_list,"def square_list(lst):
    return [i**2 for i in lst]",16
13888872028,set_intersection,"def set_intersection(set1, set2):
    return set1 & set2",16
72788331023,find_tri_num,"def find_tri_num(n):
  return n*(n + 1)//2",16
14611141559,square_list,"def square_list(nums):
    return [num**2 for num in nums]",16
70678274527,word_length,"def word_length(words):
    return [len(word) for word in words]",16
32354683468,tower_of_hanoi,"def tower_of_hanoi(n):
    return 2**n - 1",16
21292579187,string_length,"def string_length(strings):
    return [len(string) for string in strings]",16
17086544725,round_list,"def round_list(numbers):
    return [round(num) for num in numbers]",16
33179866781,string_length,"def string_length(arr):
    return [len(word) for word in arr]",16
31158208679,bin_to_dec,"def bin_to_dec(bin_str):
  return int(bin_str, 2)",16
20536615076,count_words,"def count_words(sentence):
    words = sentence.split()
    return len(words)",16
20341911211,unique_chars,"def unique_chars(s):
    unique = set(s)
    return len(unique)",16
30948448222,reverse_tuple,"def reverse_tuple(test_tup):
  return tuple(reversed(test_tup))",16
39080154830,concatenate_lists,"def concatenate_lists(list1, list2):
  return list1 + list2",16
23661491054,is_list_palindrome,"def is_list_palindrome(lst):
    return lst == lst[::-1]",15
30974414694,is_unique,"def is_unique(s):
    return len(s) == len(set(s))",15
145260561,count_char_occurrences,"def count_char_occurrences(string, char):
    return string.count(char)",15
70473292249,find_max_min,"def find_max_min(lst):
    return (max(lst), min(lst))",15
8713287739,unique_chars,"def unique_chars(s):
    return len(s) == len(set(s))",15
23359002924,count_target,"def count_target(num_list, target):
    return num_list.count(target)",15
40124681200,reverse_list,"def reverse_list(input_list):
    input_list.reverse()
    return input_list",15
71268886827,longest_string,"def longest_string(string_list):
    return max(string_list, key=len)",15
95913175,find_extreme,"def find_extreme(lst):
    return (min(lst), max(lst))",15
38854024633,count_char_in_string,"def count_char_in_string(string, char):
    return string.count(char)",15
6321843064,is_list_palindrome,"def is_list_palindrome(nums):
    return nums == nums[::-1]",15
8452934848,diff_max_min,"def diff_max_min(arr):
    return max(arr) - min(arr)",15
22722132392,format_number,"def format_number(num):
    return str(num).zfill(5)",15
28204327368,is_string_palindrome,"def is_string_palindrome(s):
    return s == s[::-1]",15
24756681488,is_Palindrome,"def is_Palindrome(s):
    return s == s[::-1]",15
4120918493,is_palindrome_list,"def is_palindrome_list(lst):
    return lst == lst[::-1]",15
20000425499,shortest_word,"def shortest_word(words_list):
    return min(words_list, key=len)",15
15024857883,count_char_occurrences,"def count_char_occurrences(s, char):
    return s.count(char)",15
36934736771,check_duplicates,"def check_duplicates(lst):
    return len(lst) != len(set(lst))",15
37413600262,find_longest_string,"def find_longest_string(strings):
    return max(strings, key=len)",15
19739373488,count_value,"def count_value(list1, value):
    return list1.count(value)",15
29142202105,is_palindrome_list,"def is_palindrome_list(lst):
    return lst == lst[::-1]",15
3124118252,has_duplicates,"def has_duplicates(lst):
    return len(lst) != len(set(lst))",15
72974486749,has_duplicates,"def has_duplicates(lst):
    return len(lst) != len(set(lst))",15
72441842352,is_Palindrome,"def is_Palindrome(s):
    return s == s[::-1]",15
17035029541,replace_spaces,"def replace_spaces(string, character):
    return string.replace("" "", character)",15
12467347670,concatenate_strings_with_separator,"def concatenate_strings_with_separator(strings, separator):
    return separator.join(strings)",15
10490004787,is_list_palindrome,"def is_list_palindrome(lst):
    return lst == lst[::-1]",15
5681941161,last_Digit,"def last_Digit(n) :  
    return n % 10",15
12613214480,concatenate_strings,"def concatenate_strings(list_of_strings):
    return ''.join(list_of_strings)",15
25157855382,containsDuplicate,"def containsDuplicate(nums):
    return len(nums) != len(set(nums))",15
5245110626,is_palindrome_list,"def is_palindrome_list(lst):
    return lst == lst[::-1]",15
1670316179,is_list_palindrome,"def is_list_palindrome(lst):
    return lst == lst[::-1]",15
32015238436,is_unique,"def is_unique(s):
    return len(set(s)) == len(s)",15
22697476313,is_unique,"def is_unique(s):
    return len(set(s)) == len(s)",15
37170393871,hexagon_perimeter,"def hexagon_perimeter(side_length):
    return 6 * side_length",15
25943236361,replace_spaces,"def replace_spaces(s, char):
    return s.replace("" "", char)",15
73121085305,is_Palindrome,"def is_Palindrome(s):
    return s == s[::-1]",15
72925351036,is_Palindrome,"def is_Palindrome(s):
    return s == s[::-1]",15
6126020245,char_list_to_string,"def char_list_to_string(char_list):
    return ''.join(char_list)",15
28119599260,count_target_occurrences,"def count_target_occurrences(lst, target):
    return lst.count(target)",15
14475301523,count_char,"def count_char(str1, char):
    return str1.count(char)",15
40523271032,check_duplicates,"def check_duplicates(lst):
    return len(lst) != len(set(lst))",15
23266355493,find_min_max,"def find_min_max(numbers):
    return (min(numbers), max(numbers))",15
42634362633,find_degree,"def find_degree(coefficients):
    return len(coefficients) - 1",15
70304314904,count_occurrences,"def count_occurrences(tup, ele):
    return tup.count(ele)",15
6207181657,is_palindrome_list,"def is_palindrome_list(nums):
    return nums == nums[::-1]",15
13620387583,is_unique,"def is_unique(s):
    return len(s) == len(set(s))",15
26890458819,count_letter,"def count_letter(test_str, letter):
    return test_str.count(letter)",15
71759258035,is_unique,"def is_unique(s):
    return len(s) == len(set(s))",15
25388760921,unique_characters,"def unique_characters(string):
    return len(string) == len(set(string))",15
73871177170,student_grade_list,"def student_grade_list(student_grades):
    return dict(student_grades)",15
74485212238,check_Palindrome,"def check_Palindrome(s):
    return s == s[::-1]",15
16239515772,is_palindrome_list,"def is_palindrome_list(arr):
    return arr == arr[::-1]",15
74612463291,string_repeats,"def string_repeats(s, n):
    return n // len(s)",15
28275906176,squares,"def squares(lst):
    return [x**2 for x in lst]",15
8663133598,is_Palindrome,"def is_Palindrome(str):
    return str == str[::-1]",15
9793568933,sum_of_two_numbers,"def sum_of_two_numbers(a,b):   
    return a + b",14
22632855450,check_palindrome,"def check_palindrome(s):
    return s == s[::-1]",14
15104006689,is_palindrome,"def is_palindrome(s):
    return s == s[::-1]",14
30194517269,unique_chars_count,"def unique_chars_count(str1):
  return len(set(str1))",14
71719333860,sort_descending,"def sort_descending(lst):
    return sorted(lst, reverse=True)",14
11253907131,list_to_string,"def list_to_string(char_list):
    return ''.join(char_list)",14
19543189702,count_Character,"def count_Character(string, character): 
    return string.count(character)",14
31965279548,sort_descending,"def sort_descending(numbers):
    return sorted(numbers, reverse=True)",14
22028436840,sort_by_length,"def sort_by_length(lst):
    return sorted(lst, key=len)",14
15212498049,calculate_average,"def calculate_average(numbers):
    return sum(numbers) / len(numbers)",14
6559074944,remove_spaces,"def remove_spaces(my_string):
    return my_string.replace("" "", """")",14
74387241791,calculate_average,"def calculate_average(lst):
    return sum(lst) / len(lst)",14
38442874311,count_occurrences,"def count_occurrences(lst, target):
    return lst.count(target)",14
24661565295,calculate_average,"def calculate_average(numbers):
  return sum(numbers) / len(numbers)",14
4295907521,remove_char,"def remove_char(s, char):
    return s.replace(char, """")",14
16237835893,longest_word,"def longest_word(words):
    return len(max(words, key=len))",14
11443987675,max_min,"def max_min(arr):
    return (min(arr), max(arr))",14
38901174310,list_to_string,"def list_to_string(char_list):
  return ''.join(char_list)",14
19578850942,unique_Elem,"def unique_Elem(list_numbers):
    return list(set(list_numbers))",14
71963254513,find_smallest_index,"def find_smallest_index(arr):
  return arr.index(min(arr))",14
38487652193,convert_to_uppercase,"def convert_to_uppercase(input_string):
    return input_string.upper()",14
11134142179,remove_char,"def remove_char(string, char):
    return string.replace(char, """")",14
12306829075,palindrome,"def palindrome(s) : 
    return s == s[::-1]",14
8730960957,reverse_integer,"def reverse_integer(n):
    return int(str(n)[::-1])",14
38106761712,sort_strings,"def sort_strings(strings):
    return sorted(strings, key=str.lower)",14
24454246146,sort_by_length,"def sort_by_length(lst):
    return sorted(lst, key=len)",14
41131123430,count_distinct,"def count_distinct(list1):
    return len(set(list1))",14
6324102705,remove_character,"def remove_character(string, char):
  return string.replace(char, '')",14
4582606920,transpose,"def transpose(matrix):
    return list(map(list, zip(*matrix)))",14
36055206934,min_max,"def min_max(arr):
    return (min(arr), max(arr))",14
73311699278,is_key_in_dict,"def is_key_in_dict(dictionary, key):
    return key in dictionary",14
15324714962,unique_sorted_list,"def unique_sorted_list(input_list):
    return sorted(set(input_list))",14
13775042416,min_max,"def min_max(nums):
    return [min(nums), max(nums)]",14
44368862116,sort_descending,"def sort_descending(nums):
    return sorted(nums, reverse=True)",14
75054812314,max_min_diff,"def max_min_diff(lst):
	return max(lst) - min(lst)",14
785853668,find_difference,"def find_difference(lst):
    return max(lst) - min(lst)",14
23919620974,sort_descending,"def sort_descending(numbers):
    return sorted(numbers, reverse=True)",14
23689724641,find_difference,"def find_difference(nums):
    return max(nums) - min(nums)",14
8545847801,remove_char,"def remove_char(string, char):
    return string.replace(char, """")",14
20383115464,is_palindrome,"def is_palindrome(s):
    return s == s[::-1]",14
24060718611,count_occurrences,"def count_occurrences(lst, element):
    return lst.count(element)",14
26378660430,find_occurrences,"def find_occurrences(nums, target):
    return nums.count(target)",14
21860966878,sort_by_length,"def sort_by_length(strings):
    return sorted(strings, key=len)",14
13958249814,check_palindrome,"def check_palindrome(s):
    return s == s[::-1]",14
25369038617,is_palindrome,"def is_palindrome(word):
    return word == word[::-1]",14
70726596281,is_palindrome,"def is_palindrome(s):
    return s == s[::-1]",14
17303880201,reverse_tuple,"def reverse_tuple(test_tuple):
  return tuple(reversed(test_tuple))",14
27805518627,remove_char,"def remove_char(text, char):
    return text.replace(char, """")",14
197838604,find_smallest_index,"def find_smallest_index(lst):
  return lst.index(min(lst))",14
10734810978,sort_descending,"def sort_descending(list):
    return sorted(list, reverse=True)",14
70642926396,remove_char,"def remove_char(s, char):
    return s.replace(char, """")",14
20982612310,remove_char,"def remove_char(s, char):
    return s.replace(char, """")",14
4196993407,average_list,"def average_list(lst):
    return sum(lst) / len(lst)",14
14308102297,is_palindrome,"def is_palindrome(s):
    return s == s[::-1]",14
34300318039,sort_descending,"def sort_descending(lst):
    return sorted(lst, reverse=True)",14
36237288670,replace_spaces,"def replace_spaces(string,char):
    return string.replace(' ', char)",14
36322285429,remove_char,"def remove_char(str, char):
    return str.replace(char, """")",14
38826696262,sort_descending,"def sort_descending(numbers):
    return sorted(numbers, reverse=True)",14
29093666467,remove_character,"def remove_character(str, char):
    return str.replace(char, """")",14
24460490963,check_palindrome,"def check_palindrome(s):
    return s == s[::-1]",14
32465295299,is_sorted_ascending,"def is_sorted_ascending(lst):
    return lst == sorted(lst)",14
1041717325,sort_by_length,"def sort_by_length(strings):
    return sorted(strings, key=len)",14
17677882645,remove_char,"def remove_char(s, char):
    return s.replace(char, """")",14
15466052946,average,"def average(nums):
    return sum(nums) / len(nums)",13
74446367738,count_elements,"def count_elements(arr, x):
    return arr.count(x)",13
72403158873,count_target,"def count_target(lst, target):
    return lst.count(target)",13
3907035123,count_element,"def count_element(lst, element):
    return lst.count(element)",13
32397520577,isPalindrome,"def isPalindrome(s):
    return s == s[::-1]",13
30688585602,reverse_list,"def reverse_list(input_list):
    return input_list[::-1]",13
13282616864,average,"def average(lst):
    return sum(lst) / len(lst)",13
25065563191,countTarget,"def countTarget(nums, target):
    return nums.count(target)",13
37379280740,is_valid_word,"def is_valid_word(dictionary, word):
    return word in dictionary",13
42061442632,construct_string,"def construct_string(lst, separator):
    return separator.join(lst)",13
70262656778,sort_strings_lexicographically,"def sort_strings_lexicographically(strings):
    return sorted(strings)",13
39810017418,sort_desc,"def sort_desc(lst):
    return sorted(lst, reverse=True)",13
18643483699,descending_sort,"def descending_sort(lst):
    return sorted(lst, reverse=True)",13
29291951096,average,"def average(numbers):
    return sum(numbers) / len(numbers)",13
17739527866,count_chars,"def count_chars(string, char):
    return string.count(char)",13
23277371457,remove_duplicates,"def remove_duplicates(lst):
    return list(dict.fromkeys(lst))",13
72277556478,Roll_Dice,"def Roll_Dice(n, m):
    return m ** n",13
27210104383,list_to_string,"def list_to_string(lst):
    return "", "".join(lst)",13
27873608088,count_number,"def count_number(arr, number):
    return arr.count(number)",13
11253928651,longest_word,"def longest_word(words):
    return max(words, key=len)",13
8355241913,reverse_sort,"def reverse_sort(nums):
    return sorted(nums, reverse=True)",13
11252239402,extract_keys,"def extract_keys(dct):
    return list(dct.keys())",13
17853000954,reverse_string,"def reverse_string(input_string):
    return input_string[::-1]",13
21463928388,palindrome_list,"def palindrome_list(lst):
    return lst == lst[::-1]",13
73838732983,descending_sort,"def descending_sort(lst):
    return sorted(lst, reverse=True)",13
1184734174,average,"def average(nums):
  return sum(nums) / len(nums)",13
72915701009,find_frequency,"def find_frequency(lst, num):
    return lst.count(num)",13
21253720976,reverse_tuple,"def reverse_tuple(input_tuple):
    return input_tuple[::-1]",13
1095730072,find_smallest,"def find_smallest(list1):
   return min(list1)",13
32467275004,average,"def average(numbers):
    return sum(numbers) / len(numbers)",13
26540924409,join_strings,"def join_strings(lst, separator):
    return separator.join(lst)",13
17653121944,count_element,"def count_element(lst, element):
    return lst.count(element)",13
5761427612,reverse_list,"def reverse_list(input_list):
    return input_list[::-1]",13
26569605484,isPalindrome,"def isPalindrome(s):
    return s == s[::-1]",13
34602087561,isPalindrome,"def isPalindrome(s):
    return s == s[::-1]",13
23713610423,palindrome_check,"def palindrome_check(string):
    return string == string[::-1]",13
12784208387,round_list,"def round_list(nums):
    return list(map(round, nums))",13
37119845371,count_number,"def count_number(lst, num):
    return lst.count(num)",13
37591238981,longest_word,"def longest_word(words):
    return max(words, key=len)",13
28949626826,unique_words,"def unique_words(word_list):
    return len(set(word_list))",13
73504003032,isPalindrome,"def isPalindrome(s):
  return s == s[::-1]",13
71230379446,count_item,"def count_item(lst, item):
    return lst.count(item)",13
684409747,isPalindrome,"def isPalindrome(s):
    return s == s[::-1]",13
44155617276,count_number,"def count_number(lst, number):
    return lst.count(number)",13
26992880993,find_frequency,"def find_frequency(L, element):
  return L.count(element)",13
13272485474,average,"def average(lst):
    return sum(lst) / len(lst)",13
13353989540,count_target,"def count_target(nums, target):
    return nums.count(target)",13
2476114093,convert_to_words,"def convert_to_words(input_string):
    return input_string.split()",13
28020310972,reverse_upper,"def reverse_upper(s):
    return s[::-1].upper()",13
13954327036,isPalindrome,"def isPalindrome(s):
    return s == s[::-1]",13
12962535604,count_num,"def count_num(lst, num):
    return lst.count(num)",13
23792989425,smallest_number,"def smallest_number(list1):
    return min(list1)",12
39761944803,convert_to_uppercase,"def convert_to_uppercase(s):
    return s.upper()",12
785625018,count_distinct,"def count_distinct(s):
    return len(set(s))",12
786663358,max_triangle_area,"def max_triangle_area(r): 
    return r * r",12
33918164418,get_mirror_image,"def get_mirror_image(a):
    return a[::-1]",12
17870198400,smallest_number,"def smallest_number(num_list):
    return min(num_list)",12
6978845718,is_sorted,"def is_sorted(lst):
  return lst == sorted(lst)",12
16429740737,palindrome,"def palindrome(s):
    return s == s[::-1]",12
17567889081,join_strings,"def join_strings(lst):
    return "","".join(lst)",12
23260581097,string_to_array,"def string_to_array(s):
  return s.split("" "")",12
43653237806,repeat_string,"def repeat_string(str, n):
    return str * n",12
33029428690,unique_char_count,"def unique_char_count(s):
  return len(set(s))",12
71960416209,sum_of_odd_numbers,"def sum_of_odd_numbers(n):
  return n**2",12
39730407082,largest_element_in_stack,"def largest_element_in_stack(stack):
    return max(stack)",12
20380907651,largest_num,"def largest_num(list1):
    return max(list1)",12
3366259138,repeat_string,"def repeat_string(s, n):
    return s * n",12
20064068702,unique_sorted_list,"def unique_sorted_list(nums):
    return sorted(set(nums))",12
35775450798,remove_spaces,"def remove_spaces(s):
    return s.replace("" "", """")",12
6395470737,sum_of_odd_numbers,"def sum_of_odd_numbers(n):
    return n**2",12
8087291384,train_delay,"def train_delay(stops):
    return stops * 2",12
20352593867,is_present,"def is_present(nums,target):
    return target in nums",11
16171825855,find_smallest,"def find_smallest(nums):
    return min(nums)",11
12941608124,reverse_list,"def reverse_list(lst):
    return lst[::-1]",11
31580045926,reverse_list,"def reverse_list(lst):
    return lst[::-1]",11
27426666787,string_to_list,"def string_to_list(string):
    return list(string)",11
40731522409,unique_list,"def unique_list(l):
    return list(set(l))",11
12454776708,count_unique,"def count_unique(nums):
    return len(set(nums))",11
26894416785,find_ascii_value,"def find_ascii_value(char):
  return ord(char)",11
13397667436,sum_odd_numbers,"def sum_odd_numbers(n):
  return n * n",11
5630421814,case_convert,"def case_convert(s):
    return s.swapcase()",11
31580158906,reverse_string,"def reverse_string(s):
    return s[::-1]",11
71454061867,reverse_string,"def reverse_string(s):
    return s[::-1]",11
39125591616,reverse_string,"def reverse_string(s):
    return s[::-1]",11
32647863245,string_to_list,"def string_to_list(s):
    return list(s)",11
22023705431,convert_to_upper,"def convert_to_upper(str):
    return str.upper()",11
43660536904,count_digits,"def count_digits(number):
    return len(str(number))",11
386974390,reverse_array,"def reverse_array(array):
    return array[::-1]",11
38217888779,reverse_list,"def reverse_list(lst):
    return lst[::-1]",11
10734320175,reverse_string,"def reverse_string(s):
    return s[::-1]",11
25446310447,unique_list,"def unique_list(lst):
    return list(set(lst))",11
29412878930,reverse_list,"def reverse_list(lst):
    return lst[::-1]",11
33157040365,is_digit_string,"def is_digit_string(s):
    return s.isdigit()",11
10956525442,to_uppercase,"def to_uppercase(s):
    return s.upper()",11
13133350633,unique_sorted,"def unique_sorted(numbers):
    return sorted(set(numbers))",11
20019757571,reverse_strings,"def reverse_strings(strings):
    return strings[::-1]",11
15853947078,swap_case,"def swap_case(s):
    return s.swapcase()",11
71036640983,reverse_string,"def reverse_string(s):
    return s[::-1]",11
18738787548,split_string,"def split_string(text):
    return text.split(' ')",11
70304329624,reverse_list,"def reverse_list(nums):
    return nums[::-1]",11
27625493368,unique_sorted,"def unique_sorted(lst):
    return sorted(set(lst))",11
13873469459,unique_list,"def unique_list(l):
    return list(set(l))",11
35751666429,reverse_array,"def reverse_array(arr):
  return arr[::-1]",11
27464823968,find_smallest,"def find_smallest(nums):
    return min(nums)",11
24310845865,reverse_string,"def reverse_string(s):
    return s[::-1]",11
10143259163,unique_list,"def unique_list(l):
    return list(set(l))",11
37420919093,string_to_number,"def string_to_number(s):
    return int(s)",11
4319584368,reverse_array,"def reverse_array(arr):
    return arr[::-1]",11
27047042082,sum_of_elements,"def sum_of_elements(nums):
    return sum(nums)",11
15605302264,list_to_dict,"def list_to_dict(lst):
    return dict(lst)",11
17988332139,reverse_string,"def reverse_string(s):
    return s[::-1]",11
7943596260,find_smallest,"def find_smallest(nums):
    return min(nums)",11
6774397385,count_unique,"def count_unique(lst):
    return len(set(lst))",11
25282388468,smallest_element,"def smallest_element(lst):
    return min(lst)",10
38900786071,sum_elements,"def sum_elements(arr):
    return sum(arr)",10
29353783190,list_sum,"def list_sum(lst):
    return sum(lst)",10
74267603190,find_min,"def find_min(numbers):
    return min(numbers)",10
10317615907,evaluate_expression,"def evaluate_expression(expression):
    return eval(expression)",10
2802933019,smallest_number,"def smallest_number(lst):
    return min(lst)",10
26379940223,sort_list,"def sort_list(nums):
    return sorted(nums)",10
1516364756,smallest_number,"def smallest_number(arr):
    return min(arr)",10
31357937629,list_sum,"def list_sum(nums):
    return sum(nums)",10
24802847166,find_max,"def find_max(nums):
    return max(nums)",10
14699557128,smallest_number,"def smallest_number(numbers):
    return min(numbers)",10
41065408432,smallest_number,"def smallest_number(nums):
    return min(nums)",10
